<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面试官问我AQS中的PROPAGATE有什么用？</title>
    <url>/2020/12/02/AQS-shared-lock/</url>
    <content><![CDATA[<p>之前分析过<a href="https://generalthink.github.io/2020/11/20/sourcecode-of-AQS/">AQS的源码</a>，但只分析了独占锁的原理。</p>
<p>而刚好我们可以借助Semaphore来分析共享锁。</p>
<h3 id="如何使用Semaphore"><a href="#如何使用Semaphore" class="headerlink" title="如何使用Semaphore"></a>如何使用Semaphore</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请共享锁数量</span></span><br><span class="line">    Semaphore sp = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 获取共享锁</span></span><br><span class="line">          sp.acquire();</span><br><span class="line"></span><br><span class="line">          String threadName = Thread.currentThread().getName();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 访问API</span></span><br><span class="line">          System.out.println(threadName + <span class="string">&quot; 获取许可,访问API。剩余许可数 &quot;</span> + sp.availablePermits());</span><br><span class="line"></span><br><span class="line">          TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 释放共享锁</span></span><br><span class="line">          sp.release();</span><br><span class="line"></span><br><span class="line">          System.out.println(threadName + <span class="string">&quot; 释放许可,当前可用许可数为 &quot;</span> + sp.availablePermits());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;, <span class="string">&quot;thread-&quot;</span> + (i+<span class="number">1</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>Java SDK 里面提供了 Lock，为啥还要提供一个 Semaphore ？其实实现一个互斥锁，仅仅是 Semaphore 的部分功能，Semaphore 还有一个功能是 Lock 不容易实现的，那就是：<strong>Semaphore 可以允许多个线程访问一个临界区。</strong></p>
<p>比较常见的需求就是我们工作中遇到的连接池、对象池、线程池等等池化资源。其中，你可能最熟悉数据库连接池，在同一时刻，一定是允许多个线程同时使用连接池的，当然，每个连接在被释放前，是不允许其他线程使用的。</p>
<p>比如上面的代码就演示了同时最多只允许3个线程访问API。</p>
<h3 id="如何依托AQS实现Semaphore"><a href="#如何依托AQS实现Semaphore" class="headerlink" title="如何依托AQS实现Semaphore"></a>如何依托AQS实现Semaphore</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">  Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">    setState(permits);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取锁</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">int</span> available = getState();</span><br><span class="line">      <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">      <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">          compareAndSetState(available, remaining))</span><br><span class="line">          <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放锁</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Semaphore的<code>acquire/release</code>还是使用到了AQS，它把state的值作为共享资源的数量。获取锁的时候state的值减去1,释放锁的时候state的值加上1。</strong></p>
<h3 id="锁的获取"><a href="#锁的获取" class="headerlink" title="锁的获取"></a>锁的获取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">    doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Semaphore也有公平锁和非公平锁两种实现，不过都是借助于AQS的，这里默认实现是非公平锁，所以最终会调用<code>nonfairTryAcquireShared</code>方法。</p>
<h3 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">    doReleaseShared();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>锁的释放成功后，会调用<code>doReleaseShared()</code>，这个方法后面会分析。</p>
<h3 id="获取锁失败"><a href="#获取锁失败" class="headerlink" title="获取锁失败"></a>获取锁失败</h3><p>当获取锁失败后，新的线程就会被加入队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  <span class="comment">// 实际调用的是NonFairSync中的nonfairTryAcquireShared</span></span><br><span class="line">  <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当锁的数量小于0的时候，需要入队。</p>
<p>共享锁调用的方法<code>doAcquireSharedInterruptibly()</code>和独占锁调用的方法<code>acquireQueued()</code>只有一些细微的区别。</p>
<p><img data-src="/images/java/aqs-shared.png" alt="区别"></p>
<p>首先独占锁构造的节点是模式是<code>EXCLUSIVE</code>,而共享锁构造模式是<code>SHARED</code>，它们使用的是AQS中的nextWaiter变量来区分的。</p>
<p>其次在在准备入队的时候，如果尝试获取共享锁成功，那么会调用<code>setHeadAndPropagate()</code>方法，重新设置头节点并决定是否需要唤醒后继节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 旧的头节点</span></span><br><span class="line">  Node h = head;</span><br><span class="line">  <span class="comment">// 将当前获取到锁的节点设置为头节点</span></span><br><span class="line">  setHead(node);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果仍然有多的锁(propagate的值是nonfairTryAcquireShared()返回值)</span></span><br><span class="line">  <span class="comment">// 或者旧的头结点为空，或者头结点的 ws 小于0</span></span><br><span class="line">  <span class="comment">// 又或者新的头结点为空，或者新头结点的 ws 小于0，则唤醒后继节点</span></span><br><span class="line">  <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">      (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      Node s = node.next;</span><br><span class="line">      <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">          doReleaseShared();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  head = node;</span><br><span class="line">  node.thread = <span class="keyword">null</span>;</span><br><span class="line">  node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      Node h = head;</span><br><span class="line">      <span class="comment">// 保证同步队列中至少有两个节点</span></span><br><span class="line">      <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">          <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 需要唤醒后继节点</span></span><br><span class="line">          <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">              <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                  <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">              unparkSuccessor(h);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 将节点状态更新为PROPAGATE</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                   !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">              <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实看到这里就有一些逻辑我看不懂了，比如setHeadAndPropagate()方法中的这一段逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">      (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写成这样不好吗？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(propagate &gt; <span class="number">0</span>  &amp;&amp; h.waitStatus &lt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>为什么要那么复杂呢？而且看上去这样也可以嘛，我本来想要假装看懂的，可是我发现骗自己真的不容易呀。</p>
<p>这里应该是有什么特殊的原因，不然Doug Lea老爷子不会这么写。。。。。。</p>
<h3 id="PROPAGATE状态有什么用"><a href="#PROPAGATE状态有什么用" class="headerlink" title="PROPAGATE状态有什么用?"></a>PROPAGATE状态有什么用?</h3><p>我就去网上搜索了下，结果在Java的Bug列表中发现是因为有一个bug才这样修改的</p>
<blockquote>
<p><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6801020">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6801020</a></p>
</blockquote>
<p><img data-src="/images/java/JDK-6801020.png" alt="JDK Bug"></p>
<p>看到这个bug在2011年就在JDK6中被修复了，我想说那个时候我还不知道java是啥呢。。。。</p>
<p>这个修改可以在Doug Lead老爷子的主页中找到，通过JSR 166找到可对比的CSV，对比1.73和1.74两个版本</p>
<blockquote>
<p><a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/locks/AbstractQueuedSynchronizer.java?r1=1.73&amp;r2=1.74">http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/locks/AbstractQueuedSynchronizer.java?r1=1.73&amp;r2=1.74</a></p>
</blockquote>
<p>我们先看看setHeadAndPropagate中的修改对比</p>
<p><img data-src="/images/java/aqs-propagate-diff.png" alt="对比"></p>
<p>以前的版本中判断条件是这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (propagate &gt; <span class="number">0</span> &amp;&amp; node.waitStatus != <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>这样的判断很符合我的认知嘛。但是会造成怎样的问题呢？按照bug的描述，我们来纸上谈兵下没有PROPAGATE状态的时候会出什么问题。</p>
<p>首先 Semaphore初始化state值为0，然后4个线程分别运行4个任务。线程t1,t2同时获取锁，另外两个线程t3,t3同时释放锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里将信号量设置成了0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Semaphore sem = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 获取锁</span></span><br><span class="line">      sem.acquireUninterruptibly();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 释放锁</span></span><br><span class="line">      sem.release();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">      Thread t1 = <span class="keyword">new</span> Thread1();</span><br><span class="line">      Thread t2 = <span class="keyword">new</span> Thread1();</span><br><span class="line">      Thread t3 = <span class="keyword">new</span> Thread2();</span><br><span class="line">      Thread t4 = <span class="keyword">new</span> Thread2();</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">      t3.start();</span><br><span class="line">      t4.start();</span><br><span class="line">      t1.join();</span><br><span class="line">      t2.join();</span><br><span class="line">      t3.join();</span><br><span class="line">      t4.join();</span><br><span class="line">      System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据上面的代码,我们将信号量设置为0，所以t1,t2获取锁会失败。</p>
<p>假设某次循环中队列中的情况如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head --&gt; t1 --&gt; t2(tail)</span><br></pre></td></tr></table></figure>
<p>锁的释放由t3先释放，t4后释放</p>
<p><strong>时刻1:</strong> 线程t3调用releaseShared(),然后唤醒队列中节点(线程t1)，此时head的状态从-1变成0</p>
<p><strong>时刻2:</strong> 线程t1由于线程t3释放了锁，被t3唤醒，然后通过nonfairTryAcquireShared()取得propagate值为0</p>
<p><img data-src="/images/java/aqs-share-failed.png" alt="再次获取锁"></p>
<p><strong>时刻3:</strong> 线程t4调用releaseShared()，读到此时waitStatue为0(和时刻1中的head是同一个head),不满足条件，因此不唤醒后继节点</p>
<p><img data-src="/images/java/aqs-release-share-diff.png" alt="diff"></p>
<p><strong>时刻4:</strong>  线程t1获取锁成功，调用setHeadAndPropagate()，因为不满足propagate &gt; 0(时刻2中propagate == 0),从而不会唤醒后继节点</p>
<p><strong>如果没有PROPAGATE状态，上面的情况就会导致线程t2不会被唤醒。</strong></p>
<p>那在引入了propagate之后这个变量又会是怎样的情况呢？</p>
<p><strong>时刻1:</strong> 线程t3调用doReleaseShared,然后唤醒队列中结点(线程t1)，此时head的状态从-1变成0</p>
<p><strong>时刻2:</strong> 线程t1由于t3释放了信号量，被t3唤醒，然后通过nonfairTryAcquireShared()取得propagate值为0</p>
<p><strong>时刻3:</strong> 线程t4调用releaseShared()，读到此时waitStatue为0(和时刻1中的head是同一个head),将节点状态设置为PROPAGATE(-3)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">       !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">  <span class="keyword">continue</span>;     <span class="comment">// loop on failed CAS</span></span><br></pre></td></tr></table></figure>

<p><strong>时刻4:</strong> 线程t1获取锁成功，调用setHeadAndPropagate()，虽然不满足propagate &gt; 0(时刻2中propagate == 0),但是waitStatus&lt;0,所以会去唤醒后继节点</p>
<p>至此我们知道了PROPAGATE的作用，就是<strong>为了避免线程无法会唤醒的窘境。</strong>,因为共享锁会有很多线程获取到锁或者释放锁，所以有些方法是并发执行的，就会产生很多中间状态，而PROPAGATE就是为了让这些中间状态不影响程序的正常运行。</p>
<h3 id="doReleaseShared-小方法大智慧"><a href="#doReleaseShared-小方法大智慧" class="headerlink" title="doReleaseShared-小方法大智慧"></a>doReleaseShared-小方法大智慧</h3><p>无论是释放锁还是申请到锁都会调用<code>doReleaseShared()</code>方法，这个方法看似简单，其实里面的逻辑还是很精妙的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="comment">// 保证同步队列中至少有两个节点</span></span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">      <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 需要唤醒后继节点</span></span><br><span class="line">      <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">          <span class="comment">// 可能有其他线程调用doReleaseShared(),unpark操作只需要其中一个调用就行了</span></span><br><span class="line">          <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">              <span class="keyword">continue</span>;     <span class="comment">// loop to recheck cases</span></span><br><span class="line">          unparkSuccessor(h);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将节点状态设置为PROPAGATE(画重点了)</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">          <span class="keyword">continue</span>;    <span class="comment">// loop on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == head)        <span class="comment">// loop if head changed</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这其中有一个判断条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ws == <span class="number">0</span> &amp;&amp;!compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)</span><br></pre></td></tr></table></figure>

<p>这个if条件成立也巧妙</p>
<ol>
<li>首先队列中现在至少有两个节点，简化分析，我们认为它只有两个节点,head –&gt; node</li>
<li>执行到else if,说明跳过了前面的if条件，说明头结点是刚成为头结点的，它的waitStatus为0，尾节点是在这之后加入的，发生这种情况是shouldParkAfterFailedAcquire()中还没来得及将前一个节点的ws值修改为SIGNAL</li>
<li>CAS失败说明此时头结点的ws不为0了，也就表明shouldParkAfterFailedAcquire()已经将前驱节点的waitStatus值修改为了SIGNAL了</li>
</ol>
<p><img data-src="/images/java/aqs-update-before-node-status.png" alt="更新前一个节点状态"></p>
<p>而整个循环的退出条件是在h==head的时候，这个是为什么呢？</p>
<p>由于我们的head节点是一个虚拟节点(也可以叫做哨兵节点)，假设我们的同步队列中节点顺序如下:</p>
<p><code>head --&gt; A --&gt; B --&gt; C</code></p>
<p>现在假设A拿到了共享锁，那么它将成为新的dummy node(虚拟节点)，</p>
<p><code>head(A) --&gt; B --&gt; C</code></p>
<p>此时A线程会调用doReleaseShared方法唤醒后继节点B，它很快就获取到了锁，并成为了新的头节点</p>
<p><code>head(B) --&gt; C</code></p>
<p>此时B线程也会调用该方法，并唤醒其后继节点C,但是在B线程调用的时候，线程A可能还没有运行结束，也正在执行这个方法，<br>当它执行到<code>h==head</code>的时候发现head改变了，所以for循环就不会退出，又会继续执行for循环，唤醒后继节点。</p>
<p>至此我们共享锁分析完毕，其实只要弄明白了AQS的逻辑，依赖于AQS实现的Semaphore就很简单了。在看共享锁源码过程中尤其需要注意的是方法是会被多个线程并发执行的，所以其中很多判断是多线程竞争情况下才会出现的。同时需要注意的是对于共享锁并不能保证线程安全，仍然需要程序员自己保证对共享资源的操作是安全的。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>CountDownLatch和CyclicBarrier,我该怎么选?</title>
    <url>/2020/12/28/CountDownLatch-CyclicBarrier/</url>
    <content><![CDATA[<h3 id="CountDownLatch和CyclicBarrier区别"><a href="#CountDownLatch和CyclicBarrier区别" class="headerlink" title="CountDownLatch和CyclicBarrier区别"></a>CountDownLatch和CyclicBarrier区别</h3><p>CountDownLatch 和 CyclicBarrier 是 Java 并发包提供的两个非常易用的线程同步工具类，把它们放在一起介绍是因为它们之间有点像，又很不同。</p>
<p>CountDownLatch 主要用来解决一个线程等待多个线程的场景，可以类比旅游团团长要等待所有的游客到齐才能去下一个景点。</p>
<p>CyclicBarrier 是一组线程之间互相等待，只要有一个线程没有完成，其他线程都要等待,更像是你和你老婆不离不弃。</p>
<p>对于CountDownLatch来说，重点是那<strong>一个线程</strong>, 是它在等待，而另外那N个线程在把“某个事情”做完之后可以继续等待，可以终止。</p>
<p>而对于CyclicBarrier来说，重点是那**一组(N个)**线程，他们之间任何一个没有完成，所有的线程都必须等待。</p>
<p>除此之外 CountDownLatch 的计数器是不能循环利用的，也就是说一旦计数器减到 0，再有线程调用 await()，该线程会直接通过。<br>但CyclicBarrier 的计数器是可以循环利用的，而且具备自动重置的功能，一旦计数器减到 0 会自动重置到你设置的初始值。除此之外，CyclicBarrier 还可以设置回调函数，可以说是功能丰富。</p>
<a id="more"></a>

<h3 id="CountDownLatch使用"><a href="#CountDownLatch使用" class="headerlink" title="CountDownLatch使用"></a>CountDownLatch使用</h3><p>我们假设旅游团有3个游客，团长要等到游客都到齐了之后才能出发去下一个景点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">IntStream.rangeClosed(<span class="number">1</span>, <span class="number">3</span>).forEach(i -&gt; &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;游客&quot;</span> + i + <span class="string">&quot;到了集合地点&quot;</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">latch.await();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;所有人员都已经到齐了，出发去下个景点&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先创建了一个 CountDownLatch，计数器的初始值等于 3，之后每当一个团员到达就对计数器执行减 1操作(latch.countDown()实现)。在主线程中，我们通过调用 latch.await() 来实现对计数器等于 0 的等待。</p>
<h3 id="CountDownLatch源码分析"><a href="#CountDownLatch源码分析" class="headerlink" title="CountDownLatch源码分析"></a>CountDownLatch源码分析</h3><p>CountDownLatch是通过AQS来实现的，这里的计数器的值实际上是AQS中State的值,也就是我们的state的值会被初始化为我们传入的值。</p>
<p>当我们调用coutnDown的时候实际上是减去state的值(计数器减1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch中代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// countDown会调用这个方法</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 计数器的值减1</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS中的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当state等于0的时候，去唤醒阻塞的线程</span></span><br><span class="line">  <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">      doReleaseShared();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用await的时候，会判断当前state的值是否等于0，如果等于0,就代表其他线程已经执行完成了，可以接着往下执行。否则就阻塞当前线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch中代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// await会调用这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS中的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// 阻塞线程</span></span><br><span class="line">      doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此逻辑就很清晰了。 当我们调用countDown()方法的时候，会将AQS中的state的值减去1,当state值变为0的时候会唤醒CLH队列中阻塞的线程。当我们调用await()方法的时候，会判断state的值是否等于0，如果等于0则继续往下执行。如果不等于0则线程被阻塞，等待被唤醒(countDown()方法中会唤醒)。</p>
<h3 id="CyclicBarrier使用"><a href="#CyclicBarrier使用" class="headerlink" title="CyclicBarrier使用"></a>CyclicBarrier使用</h3><p>周末的时候，我和我老婆一起去吃烧烤，用CyclicBarrier来描述是这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 执行回调的线程池，很重要的点</span></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定计数器的值和回调函数</span></span><br><span class="line">CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, () -&gt; &#123;</span><br><span class="line">    executor.execute(() -&gt; System.out.println(<span class="string">&quot;到齐了，出发吃烧烤&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;半个小时后，think123媳妇儿准备好了&quot;</span>);</span><br><span class="line">    barrier.await();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;think123准备好了&quot;</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    barrier.await();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="CyclicBarrier源码分析"><a href="#CyclicBarrier源码分析" class="headerlink" title="CyclicBarrier源码分析"></a>CyclicBarrier源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面展示了CyclicBarrier的重要属性,它的属性名称还是挺有趣的。<br>为了实现一组线程相互等待，使用到了lock和condition，而parties则是表明一组线程的个数(计数器)，count表示当前有多少个线程还未执行完成。 barrierCommand表示当所有线程都就绪时，需要回调的函数。而generation是为了实现计数器循环利用，你可以理解为版本。</p>
<p>接下来我们看看await方法是如何实现的，下面的代码我只保留了核心代码逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加锁，独占锁</span></span><br><span class="line">  lock.lock();</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//省略部分代码</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 还有多少线程未执行完成</span></span><br><span class="line">  <span class="keyword">int</span> index = --count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有线程都执行完成</span></span><br><span class="line">  <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行barrierCommand回调函数</span></span><br><span class="line">    <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里调用的是Runnable的run方法，而不是thread.start()</span></span><br><span class="line">    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">        command.run();</span><br><span class="line"></span><br><span class="line">    ranAction = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 重置计数器，并唤醒所有正在等待的线程</span></span><br><span class="line">    nextGeneration();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只保留核心代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 阻塞线程</span></span><br><span class="line">      <span class="keyword">if</span> (!timed)</span><br><span class="line">          trip.await();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">          nanos = trip.awaitNanos(nanos);</span><br><span class="line">      <span class="keyword">if</span> (g != generation)</span><br><span class="line">          <span class="keyword">return</span> index;</span><br><span class="line">  &#125;</span><br><span class="line">  lock.unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 唤醒所有正在休假的线程</span></span><br><span class="line">  trip.signalAll();</span><br><span class="line">  <span class="comment">// set up next generation</span></span><br><span class="line">  count = parties;</span><br><span class="line">  generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>await的逻辑很简单，主要就是判断当前线程是否是最后一个执行完成的线程，如果是最后一个，则需要执行回调函数，然后唤醒其他所有被阻塞的线程并重置计数器。<br>如果不是最后一个执行完的，则阻塞当前线程。</p>
<p>尤其需要注意的CyclicBarrier的回调函数执行在一个回合里最后执行await()的线程上，而且是同步调用回调函数，调用完之后，才会开始第二回合。<br>所以回调函数如果不另开一线程异步执行，就起不到性能优化的作用了。</p>
<h3 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h3><p>你告诉我，要是你你怎么选？</p>
<p>如果觉得好看，记得三连哟。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedHashMap源码解析</title>
    <url>/2019/08/16/LinkedHashMap-analysis/</url>
    <content><![CDATA[<p>上一篇文章分析了HashMap的原理,有网友留言想看LinkedHashMap分析，今天它来了。</p>
<p>LinkedHashMap是HashMap的子类,在原有HashMap数据结构的基础上,它还维护着一个双向链表链接所有entry,这个链表定义了迭代顺序，通常是数据插入的顺序。</p>
<p><img data-src="/images/java/LinkedHashMap_structure.png" alt="LinkedHashMap结构"></p>
<a id="more"></a>

<p>上图我只画了链表，其实红黑树节点也是一样的，只是节点类型不一样而已</p>
<p>也就是说我们遍历LinkedHashMap的时候,是从head指针指向的节点开始遍历,一直到tail指向的节点。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表头节点</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表尾节点</span></span><br><span class="line">    <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定遍历LinkedHashMap的顺序,true表示按照访问顺序,false表示按照插入顺序，默认为false</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从LinkedHashMap的定义里面可以看到它单独维护了一个双向链表，用于记录元素插入的顺序。这也是为什么我们打印LinkedHashMap的时候可以按照插入顺序打印的支撑。而accessOrder属性则指明了进行遍历时是按照什么顺序进行访问,我们可以通过它的构造方法自己指定顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">  <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当accessOrder=true,访问顺序的输出是什么意思呢？来看下下面的一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedHashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">8</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">map.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">map.get(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(map);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;1&#x3D;1, 3&#x3D;3, 2&#x3D;2&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到get了的数据被放到了双向链表尾部，也就是按照了访问时间进行排序,这就是访问顺序的含义。</p>
<p>在插入的时候LinkedHashMap复写了HashMap的newNode以及newTreeNode方法,并且在方法内部更新了双向链表的指向关系。</p>
<p>同时插入的时候调用了afterNodeAccess()方法以及afterNodeInsertion()方法,在HashMap中这两个方法是空实现,而在LinkedHashMap中则有具体实现,这两个方法也是专门给LinkedHashMap进行回调处理的。</p>
<p>afterNodeAccess()方法中如果accessOrder=true时会移动节点到双向链表尾部。当我们在调用map.get()方法的时候如果accessOrder=true也会调用这个方法,这就是为什么访问顺序输出时访问到的元素移动到链表尾部的原因。</p>
<p>接下来来看看afterNodeInsertion()的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// evict如果为false，则表处于创建模式,当我们new HashMap(Map map)的时候就处于创建模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">  LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// removeEldestEntry 总是返回false,所以下面的代码不会执行。</span></span><br><span class="line">  <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">      K key = first.key;</span><br><span class="line">      removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里我有一个想法,可以通过LinkedHashMap来实现LRU(Least Recently Used,即近期最少使用),只要满足条件,就删除head节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LRUCache&lt;K,V&gt; extends LinkedHashMap&lt;K,V&gt; &#123;</span><br><span class="line">    </span><br><span class="line">  private int cacheSize;</span><br><span class="line">  </span><br><span class="line">  public LRUCache(int cacheSize) &#123;</span><br><span class="line">      super(16,0.75f,true);</span><br><span class="line">      this.cacheSize &#x3D; cacheSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 判断元素个数是否超过缓存容量</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @Override</span><br><span class="line">  protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;</span><br><span class="line">      return size() &gt; cacheSize;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>就这样一个简单的LRU Cache就实现了,以后面试官如果喊你给它实现一个LRU,你就这样写给他,如果他让你换一种方式,你就用链表使用同样的思维给他实现一个,然后你就可以收割offer了。</p>
<p>对于删除,LinkedHashMap也同样是在HashMap的删除逻辑完成后，调用了afterNodeRemoval这个回调方法来更正链表指向关系。</p>
<p>其实你只要看了上一篇文章再也不怕面试官问我JDK8 HashMap,再记得LinkedHashMap只是多维护了一个双向链表之后,再看LinkedHashMap中关于链表操作的代码就非常简单了。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>开放寻址的ThreadLocalMap分析</title>
    <url>/2019/07/25/ThreadLocalMap-sourcecode/</url>
    <content><![CDATA[<h3 id="什么是散列"><a href="#什么是散列" class="headerlink" title="什么是散列"></a>什么是散列</h3><p>散列表(hash table)我们平时也叫它哈希表或者Hash表，它用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，没有数组就没有散列表。</p>
<p>比如我们有100件商品,编号没有规律的4位数字,现在我们想要通过编号快速获取商品信息，如何做呢?我们可以将这100件商品信息放到数组里，通过 商品编号%100这样的方式得到一个值,值为1的商品放到数组中下标为1的位置，值为2的商品，我们放到数组中下标为2的位置。以此类推，编号为K的选手放到数组中下标为K的位置。因为商品编号通过散列函数(编号%100)跟数据下标一一对应，所以但我们需要查询编号为x的商品信息的时候,我们使用同样的方式，将编号转换为数组下标，就可以从对应的数组下标的位置取出数据。<br>这就是散列的典型思想。</p>
<a id="more"></a>

<p>我们通过上面的例子可以得出这样规律：散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。通过散列函数(商品编号%100)把元素的键值映<br>射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取<br>数据。</p>
<h3 id="开放寻址"><a href="#开放寻址" class="headerlink" title="开放寻址"></a>开放寻址</h3><p>一说到散列(或者叫做hash表),大家更熟悉的是HashMap或者LinkedHashMap,而今天的主角是ThreadLocalMap,它是ThreadLocal中的一个内部类。分析ThreadLocal源码的时候不可能绕过它。</p>
<p>由于哈希表使用了数组,无论hash函数如何设计都无可避免存在hash冲突。上面的例子如果两件商品的id分别是1001和1101,那么他们的数据就会就会被放到数组的同一个位置，出现了冲突</p>
<blockquote>
<p>鸽巢原理，又名狄利克雷抽屉原理、鸽笼原理。其中一种简单的表述法为：若有n个笼子和n+1只鸽子，所有的鸽子都被关在鸽笼里，那么至少有一个笼子有至少2只鸽子</p>
</blockquote>
<p>ThreadLocalMap作为hash表的一种实现方式,它是使用什么方式来解决冲突的呢?它使用了开放寻址法来解决这个问题。</p>
<h4 id="元素插入"><a href="#元素插入" class="headerlink" title="元素插入"></a>元素插入</h4><p>开放寻址法的核心是如果出现了散列冲突，就重新探测一个空闲位置，将其插入。当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p>
<p><img data-src="/images/java/hash-element-find.png" alt="元素查找过程"></p>
<p>从图中可以看出，散列表的大小为 10 ，在元素 x 插入散列表之前，已经 6 个元素插入到散列表中。 x 经过 Hash 算法之后，被散列到位置下标为 7 的位置,但是这个位置已经有数据了，所以就产生了冲突。于是我们就顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找，直到找到空闲位置 2 ，于是将其插入到这个位置。</p>
<h4 id="元素查找"><a href="#元素查找" class="headerlink" title="元素查找"></a>元素查找</h4><p>在散列表中查找元素的过程有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。</p>
<h4 id="元素删除"><a href="#元素删除" class="headerlink" title="元素删除"></a>元素删除</h4><p>ThreadLocalMap跟数组一样，不仅支持插入、查找操作，还支持删除操作。对于使用线性探测法解决冲突的散列表，删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空。</p>
<p>还记得我们刚讲的查找操作吗？在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？</p>
<p>我们可以在删除元素之后,将之后不为null的数据rehash，这样就不会影响查询的逻辑</p>
<blockquote>
<p>另一种方法是:可以将删除的元素，特殊标记为 deleted 。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测</p>
</blockquote>
<p><img data-src="/images/java/hash-rehash.png" alt="rehash过程"></p>
<p>这里解释下rehash的过程:当删除元素8的时候，先把下标为8的值设置为null,然后将其后面不为空的数组元素rehash。比如8后面的元素是9,其原本应该的位置(9%10=9)就在9所以不移动。下一个元素是19,应该在下标为9的位置,但是已经被占用了,所以就找下一个空闲的位置，下标为3的位置是空闲的，放入tab[3]。接着下一个元素1就在tab[1]不移动，<br>元素7的位置在tab[7]，因为已经被占用，放入下一个空闲位置tab[8]。下一个元素仍然是19,这里由于tab[9]已经被占用，所以放入下一个空闲位置tab[0]。接着最后一个元素4位置就在tab[4],所以不移动。元素4的下一个位置为空，整个rehash过程结束。</p>
<h3 id="装载因子"><a href="#装载因子" class="headerlink" title="装载因子"></a>装载因子</h3><p>你可能已经发现了，线性探测法其实存在很大问题。当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n) 。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。</p>
<p>不管采用哪种探测方法，hash函数设计得在合理,当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子(load factor)来表示空位的多少。</p>
<p>装载因子的计算公式是：<strong>散列表的装载因子=填入表中的元素个数/散列表的长度</strong> 装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="ThreadLocalMap定义"><a href="#ThreadLocalMap定义" class="headerlink" title="ThreadLocalMap定义"></a>ThreadLocalMap定义</h4><p>ThreadLocal的核心数据结构是ThreadLocalMap,它的数据结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 这里的entry继承WeakReference了</span><br><span class="line">  static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">      Object value;</span><br><span class="line">      Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">          super(k);</span><br><span class="line">          value &#x3D; v;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 初始化容量,必须是2的n次方</span><br><span class="line">  private static final int INITIAL_CAPACITY &#x3D; 16;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; entry数组,用于存储数据</span><br><span class="line">  private Entry[] table;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; map的容量</span><br><span class="line">  private int size &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 数据量达到多少进行扩容,默认是 table.length * 2 &#x2F; 3</span><br><span class="line">  private int threshold;</span><br></pre></td></tr></table></figure>

<p>从ThreadLocalMap的定义可以看出Entry的key就是ThreadLocal，而value就是值。同时，Entry也继承WeakReference，所以说Entry所对应key（ThreadLocal实例）的引用为一个弱引用。而且定义了装载因子为数组长度的三分之二。</p>
<h4 id="set-方法"><a href="#set-方法" class="headerlink" title="set()方法"></a>set()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Entry[] tab = table;</span><br><span class="line">  <span class="keyword">int</span> len = tab.length;</span><br><span class="line">  <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 采用线性探测,寻找合适的插入位置</span></span><br><span class="line">  <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">      ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">      <span class="comment">// key存在则直接覆盖</span></span><br><span class="line">      <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">          e.value = value;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// key不存在,说明之前的ThreadLocal对象被回收了</span></span><br><span class="line">      <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">          replaceStaleEntry(key, value, i);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不存在也没有旧元素,就创建一个</span></span><br><span class="line">  tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">  <span class="keyword">int</span> sz = ++size;</span><br><span class="line">  <span class="comment">// 清除旧的槽(entry不为空，但是ThreadLocal为空)，并且当数组中元素大于阈值就rehash</span></span><br><span class="line">  <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">      resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面源码的主要步骤如下:</p>
<ol>
<li>采用线性探测法,寻找合适的插入位置。首先判断key是否存在,存在则直接覆盖。如果key不存在证明被垃圾回收了此时需要用新的元素替换旧的元素</li>
<li>不存在对应的元素,需要创建一个新的元素</li>
<li>清除entry不为空，但是ThreadLocal(entry的key被回收了)的元素，防止内存泄露</li>
<li>如果满足条件:size &gt;= threshold - threshold / 4就将数组扩大为之前的两倍，同时会重新计算数组元素所处的位置并进行移动(rehash)。比如最开始数组初始大小为16,当size &gt;= (16*2/3=10) - (10/4) = 8的时候就会扩容,将数组大小扩容至32.</li>
</ol>
<p>无论是replaceStaleEntry()方法还是cleanSomeSlots()方法，最重要的方法调用是expungeStaleEntry(),你可以在ThreadLocalMap中的get,set,remove都能发现调用它的身影。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">  Entry[] tab = table;</span><br><span class="line">  <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除对应位置的entry</span></span><br><span class="line">  tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">  tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">  size--;</span><br><span class="line"></span><br><span class="line">  Entry e;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// rehash过程,直到entry为null</span></span><br><span class="line">  <span class="keyword">for</span> (i = nextIndex(staleSlot, len);(e = tab[i]) != <span class="keyword">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">    <span class="comment">// k为空,证明已经被垃圾回收了</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">        e.value = <span class="keyword">null</span>;</span><br><span class="line">        tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 判断当前元素是否处于&quot;真正&quot;应该待的位置</span></span><br><span class="line">        <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 线性探测</span></span><br><span class="line">            <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                h = nextIndex(h, len);</span><br><span class="line">            tab[h] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面rehash的代码结合文章开头的说明理解起来更是容易,当从ThreadLocalMap新增,获取,删除的时候都会根据条件进行rehash，条件如下</p>
<ol>
<li>ThreadLocal对象被回收,此时Entry中key为null,value不为null。这时会触发rehash</li>
<li>当阈值达到ThreadLocalMap容量的三分之二的时候</li>
</ol>
<h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">  Entry e = table[i];</span><br><span class="line">  <span class="comment">// 现在数据中进行查找</span></span><br><span class="line">  <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">      <span class="keyword">return</span> e;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用线性探测找到对应元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">  Entry[] tab = table;</span><br><span class="line">  <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">      <span class="comment">// 找到元素</span></span><br><span class="line">      <span class="keyword">if</span> (k == key)</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">      <span class="comment">// ThreadLocal为空,需要删除过期元素，同时进行rehash</span></span><br><span class="line">      <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">          expungeStaleEntry(i);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          i = nextIndex(i, len);</span><br><span class="line">      e = tab[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>线性探测法贯穿了get,set的所有流程，理解了原理在看代码就很简单了。</p>
<h4 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">   Entry[] tab = table;</span><br><span class="line">   <span class="keyword">int</span> len = tab.length;</span><br><span class="line">   <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">        e != <span class="keyword">null</span>;</span><br><span class="line">        e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">       <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">           e.clear();</span><br><span class="line">           expungeStaleEntry(i);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>remove的时候回删除旧的entry,然后进行rehash.</p>
<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; seqCount = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    seqCount.set(seqCount.get() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> seqCount.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Counter seqCount = <span class="keyword">new</span> Counter();</span><br><span class="line"></span><br><span class="line">    CountThread thread1 = <span class="keyword">new</span> CountThread(seqCount);</span><br><span class="line">    CountThread thread2 = <span class="keyword">new</span> CountThread(seqCount);</span><br><span class="line">    CountThread thread3 = <span class="keyword">new</span> CountThread(seqCount);</span><br><span class="line">    CountThread thread4 = <span class="keyword">new</span> CountThread(seqCount);</span><br><span class="line"></span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread3.start();</span><br><span class="line">    thread4.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Counter counter;</span><br><span class="line"></span><br><span class="line">    CountThread(Counter counter)&#123;</span><br><span class="line">        <span class="keyword">this</span>.counter = counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; seqCount :&quot;</span> + counter.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-3 seqCount :1</span><br><span class="line">Thread-0 seqCount :1</span><br><span class="line">Thread-3 seqCount :2</span><br><span class="line">Thread-0 seqCount :2</span><br><span class="line">Thread-0 seqCount :3</span><br><span class="line">Thread-2 seqCount :1</span><br><span class="line">Thread-2 seqCount :2</span><br><span class="line">Thread-1 seqCount :1</span><br><span class="line">Thread-3 seqCount :3</span><br><span class="line">Thread-1 seqCount :2</span><br><span class="line">Thread-1 seqCount :3</span><br><span class="line">Thread-2 seqCount :3</span><br></pre></td></tr></table></figure>
<p>ThreadLocal 其实是为每个线程都提供一份变量的副本, 从而实现同时访问而不受影响。从这里也看出来了它和synchronized之间的应用场景不同, synchronized是为了让每个线程对变量的修改都对其他线程可见, 而 ThreadLocal 是为了线程对象的数据不受其他线程影响, 它最适合的场景应该是在同一线程的不同开发层次中共享数据。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantLock的这几个问题，你都知道吗？</title>
    <url>/2020/11/23/about-ReentrantLock-problems/</url>
    <content><![CDATA[<h4 id="公平锁和非公平锁的区别？"><a href="#公平锁和非公平锁的区别？" class="headerlink" title="公平锁和非公平锁的区别？"></a>公平锁和非公平锁的区别？</h4><p>之前分析AQS的时候，了解到AQS依赖于内部的两个FIFO队列来完成同步状态的管理，当线程获取锁失败的时候，会将当前线程以及等待状态等信息构造成Node对象并将其加入同步队列中，同时会阻塞当前线程。当释放锁的时候，会将首节点的next节点唤醒(head节点是虚拟节点)，使其再次尝试获取锁。</p>
<p>同样的，如果线程因为某个条件不满足，而进行等待，则会将线程阻塞，同时将线程加入到等待队列中。当其他线程进行唤醒的时候，则会将等待队列中的线程出队加入到同步队列中使其再次获得执行权。</p>
<p>按照我们的分析，无论是同步队列还是等待队列都是FIFO,看起来就很公平呀？为什么ReentrankLock还分公平锁和不公平锁呢？</p>
<a id="more"></a>

<p>还是直接看源码吧，看看它是怎么做的？</p>
<p>首先看看锁的创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认是不公平锁 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true表示公平锁，false表示不公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">  sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>可以看到对应不同的锁，只是代表他们内部的Sync变量不同而已。</p>
<p>其中NonfairSync和FairSync两个类是Sync的子类，Sync又继承自AbstractQueuedSynchronizer</p>
<p><img data-src="/images/java/reentranklock-sync-structure.png" alt="公平锁和非公平锁继承关系"></p>
<p>当我们使用ReentrantLock加锁的时候实际上调用的是sync.lock()方法,也就是说，我们需要看看他们加锁的时候有什么不同之处？</p>
<p><img data-src="/images/java/lock-difference.png" alt="lock的区别"></p>
<p>可以看到在lock方法内部,非公平锁会先直接通过CAS修改state变量的值，如果修改成功则表示获取到了锁，而公平锁则是直接调用AQS的acquire方法来获取锁。</p>
<p>也就是说有可能当其他线程释放锁的时候，非公平锁能率先修改state的值成功，从而获取到锁。这样就比其他等待的线程率先获取到锁了，这就是不公平。</p>
<p>之前也有提到过，子类会根据自己的需求以实现tryAcquire方法，同样的非公平锁和公平锁的实现也实现了这个方法，我们可以来看看，两个的实现有什么不同</p>
<p><img data-src="/images/java/lock-fair-unfair-difference.png" alt="区别"></p>
<p>可以看到公平锁比非公平锁的实现多了一个判断条件(!hasQueuedPredecessors()),我们来看看这个方法的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node t = tail;</span><br><span class="line">  Node h = head;</span><br><span class="line">  Node s;</span><br><span class="line">  <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">      ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单，它的意思是如果当前线程之前有排队的线程，则返回true；如果当前线程位于队列的开头或队列为空，则返回false。</p>
<p>也就是锁公平锁在获取锁的时候会判断队列中是否已经有排队的线程，如果有则进行阻塞，如果没有则去通过CAS申请锁。</p>
<p>这就实现了公平锁，先来的先获取到锁，后来的后获取到锁。</p>
<p>所以我们可以总结下公平锁和非公平锁实现上的两点区别:</p>
<ol>
<li>非公平锁在调用lock()方法后，首先会通过CAS抢占锁，如果恰巧这个时候锁没有被占用，则获取锁成功</li>
<li>非公平锁在CAS失败后，和公平锁一样会调用tryAcquire()方法，在tryAcquire()方法中，如果发现锁被释放了(state=0),非公平锁会直接CAS进行抢占，而公平锁会判断同步队列中是否有线程处于等待状态，如果有则不去抢占，而是排队获取。</li>
</ol>
<p>这就是两者将细微的区别，如果这非公平锁两次CAS都失败了，那么会和公平锁一样，乖乖的在同步队列中排队。</p>
<p>相对而言，非公平锁的吞吐量更大，但是让获取锁的时间变得不确定，可能会导致同步队列中的线程长期处于饥饿状态。</p>
<h3 id="ReentrantLock靠什么保证可见性？"><a href="#ReentrantLock靠什么保证可见性？" class="headerlink" title="ReentrantLock靠什么保证可见性？"></a>ReentrantLock靠什么保证可见性？</h3><p>synchronized 之所以能够保证<a href="https://generalthink.github.io/2020/06/02/start-of-concurrent-programming/">可见性</a>,是因为有一条happens-before原则，那Java SDK 里面 ReentrantLock 靠什么保证可见性呢？</p>
<p>它是利用了 volatile 相关的 Happens-Before 规则。AQS内部有一个 volatile 的成员变量 state，当获取锁的时候，会读写state 的值；解锁的时候，也会读写 state 的值。</p>
<blockquote>
<p>对一个volatile变量的写操作happens-before 于后面对这个变量的读操作。这里的happens-before是时间上的先后顺序</p>
</blockquote>
<p>这样说起来挺抽象的，我们直接去看JVM中对volatile是否有特殊的处理，在<code>src/hotspot/share/interpreter/bytecodeinterpreter.cpp</code>中，我们找到getfield和getstatic字节码执行的位置</p>
<blockquote>
<p>现在这个执行器基本不再使用了，基本都会使用模板解释器，但是模板解释器的代码基本都是汇编，而我们只是想要快速了解其原理，所以可以看这个，对模板解释器感兴趣的可以去看templateTable_x86.cpp::getfield查看相关细节</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">CASE(_getfield):</span><br><span class="line">CASE(_getstatic):</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   ConstantPoolCacheEntry* cache;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span> (cache-&gt;is_volatile()) &#123;</span><br><span class="line">     <span class="keyword">if</span> (support_IRIW_for_not_multiple_copy_atomic_cpu) &#123;</span><br><span class="line">       OrderAccess::fence();</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在访问对象字段的时候，会判断它是不是volatile的，如果是，且当前CPU平台支持多核atomic操作(现在大多数CPU都支持)，就调用<code>OrderAccess::fence()</code>。</p>
<blockquote>
<p>JDK中的Unsafe也提供了内存屏障的方法，在JVM层面也是通过OrderAccess实现</p>
</blockquote>
<p>接下来来看下Linux x86下的实现是怎样的(src/hotspot/os_cpu/linux_x86/orderAccess_linux_x86.cpp)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">OrderAccess::fence</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// always use locked addl since mfence is sometimes expensive</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lock; addl $0,0(%%rsp)&quot;</span> : : : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lock; addl $0,0(%%esp)&quot;</span> : : : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  compiler_barrier();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指令中的”addl $0,0(%%esp)”(把ESP寄存器的值加0)是一个空操作，采用这个空操作而不是空操作指令nop是因为IA32手册规定lock前缀不允许配合nop指令使用，所以才采用加0这个空操作。</p>
<p>而lock有如下作用</p>
<ol>
<li>lock锁定的时候，如果操作某个数据，那么其他CPU核不能同时操作</li>
<li>lock 锁定的指令，不能上下文随意排序执行，必须按照程序上下顺序执行</li>
<li>在 lock 锁定操作完毕之后，如果某个数据被修改了，那么需要立即告诉其他 CPU 这个值被修改了，是它们的缓存数据立即失效，需要重新到内存获取</li>
</ol>
<p>关于lock的实现有两种，一种是锁总线，一种是锁缓存。锁缓存就涉及到CPU Cache,缓存行以及MESI了，所以这里就不展开了，有兴趣的童鞋咱们可以私下交流下。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>关于GC参数的一个问题</title>
    <url>/2016/11/30/about-gc-parameters/</url>
    <content><![CDATA[<h3 id="我遇到一个一个问题"><a href="#我遇到一个一个问题" class="headerlink" title="我遇到一个一个问题"></a>我遇到一个一个问题</h3><p>我遇到了一个问题,这个问题真的很难,我想说在国内去关注这个问题的人应该并不多，至少我问了很多人但是他们并没有去深究这个问题，不过既然让我发现了这个问题那么我肯定不能带着疑惑离开，我必须得留下点什么，所以我解决了这个问题，然后写下了这篇博客，我都不知道应该怎么赞美自己了,好了不吹牛逼了。。。</p>
<p>这个问题是这样的，我们都知道可以设置VM参数来设置堆的大小,通过-Xmx设置堆的最大值,-Xms设置堆的最小值。然后虚拟机在启动的时候会根据我们的参数进行动态调整。但是这其中还是有点小秘密的。</p>
<p>我们在本地运行这样的一段代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//VM Args：-Xms4m  -Xmx4m -XX:+PrintGCDetails</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapOutOfMomory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Byte[] b = <span class="keyword">new</span> Byte[<span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>查看打印出来的的GC信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC [PSYoungGen: 2344K-&gt;312K(2368K)] 2910K-&gt;1477K(5120K), 0.0083535 secs] [Times: user&#x3D;0.05 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2368K, used 1830K [0x00000000ffd60000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 74% used [0x00000000ffd60000,0x00000000ffedb9d8,0x00000000fff60000)</span><br><span class="line">  from space 320K, 97% used [0x00000000fffb0000,0x00000000ffffe010,0x0000000100000000)</span><br><span class="line">  to   space 320K, 0% used [0x00000000fff60000,0x00000000fff60000,0x00000000fffb0000)</span><br><span class="line"> ParOldGen       total 5504K, used 5261K [0x00000000ff800000, 0x00000000ffd60000, 0x00000000ffd60000)</span><br><span class="line">  object space 5504K, 95% used [0x00000000ff800000,0x00000000ffd23760,0x00000000ffd60000)</span><br><span class="line"> PSPermGen       total 21248K, used 5716K [0x00000000fa600000, 0x00000000fbac0000, 0x00000000ff800000)</span><br><span class="line">  object space 21248K, 26% used [0x00000000fa600000,0x00000000fab95308,0x00000000fbac0000)</span><br></pre></td></tr></table></figure>

<p>发现了吧！堆的大小是5504(ParOldGen)+320(from)+320(to)+2048(eden) = 8192(8M),虽然我们设置的是4M,但是实际上却是8M?那么这个为什么了?我们的参数没有起作用?</p>
<h3 id="和操作系统有关的VM"><a href="#和操作系统有关的VM" class="headerlink" title="和操作系统有关的VM"></a>和操作系统有关的VM</h3><p>我们先看一个图,如图所示64位的windows系统是Server模式,而其默认的收集器是parallel scavenge。<br><img data-src="/images/default_server.png" alt="不同系统下的server"></p>
<p>为什么这个收集器就这么神奇呢？经过我的探索发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The problem is os::page_size_for_region, in particular the check: </span><br><span class="line">if ((region_min_size &amp; mask) &#x3D;&#x3D; 0 &amp;&amp; (region_max_size &amp; mask) &#x3D;&#x3D; 0) </span><br><span class="line"></span><br><span class="line">If page_size_for_region is called with min_region_size and max_region_size that are a multiple of a page size larger than than max_page_size, then page_size_for_region will return that page. </span><br><span class="line"></span><br><span class="line">This problem manifests itself on Solaris using large pages. Solaris will use a page size of 2 MB. If -Xmx4m is used, then GenerationSizer::initialize_size_info will call page_size_for_region(4MB, 4MB, 8 &#x2F;* min_pages*&#x2F;). Since 4MB is a multiple 2MB, page_size_for_region will return 2MB. The bug is that we ask for at least 8 pages, which would limit the page size to 4MB&#x2F;8 &#x3D; 0.5MB (512 KB). Since parallel scavenge needs at least 4 pages, we get a heap size 4 * 2MB &#x3D; 8MB, even though the user specified -Xmx4m!</span><br></pre></td></tr></table></figure>

<p>事情当然不会到了这里就结束。我们知道-XX:SurvivorRatio表示Eden区与Survivor区的大小比值，默认是8，也就是说eden:from=8，但是很明显我们打印出来的信息并不是这样,2048:320=6,那么这个8哪里来的呢？顿时我又崩溃了,还好经过我不管的查找资料，翻看JDK源码,发现了原来是是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; The survivor ratio&#39;s are calculated &quot;raw&quot;, unlike the</span><br><span class="line">    &#x2F;&#x2F; default gc, which adds 2 to the ratio value. We need to</span><br><span class="line">    &#x2F;&#x2F; make sure the values are valid before using them.</span><br><span class="line">    if (MinSurvivorRatio &lt; 3) &#123;</span><br><span class="line">      MinSurvivorRatio &#x3D; 3;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里可以查看资料<a href="https://searchcode.com/codesearch/view/17980811/">parallelScavenge中GenerationSize</a></p>
<p>你以为到了这里问题就完了吗？我告诉你并没有。</p>
<h3 id="解决一个问题"><a href="#解决一个问题" class="headerlink" title="解决一个问题"></a>解决一个问题</h3><p>我遇到这个问题的时候我也是很崩溃的,我先是翻阅书籍，然后发现没有，然后为群友，去社区提问题，还是没有能够解决这个问题。</p>
<p>但是我是谁呀！我没有放弃，没有得过起过，我还和你耗上了。然后我去翻阅官方文档，然后让我发现了这个client和server端的区别，是的之前我没有发现这个。然后官方文档上没接着说这些细节，然后我就去找源码呀！我看人家源码怎么说的呀，这样一层一层找下来，最终问题解决了。</p>
<p>虽然现在看来我写出来这个问题真的很小，可是在找问题的过程中确实花费了很多事件，但是这也锻炼了我解决问题的思维。</p>
<p>我的方法如下：</p>
<ol>
<li>确定是自己配置不对还是自己理解有误</li>
<li>在1的基础上定位问题解决方向是寻找官方文档还是加深理解</li>
<li>找答案，做实验。</li>
</ol>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol>
<li><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/server-class.html">http://docs.oracle.com/javase/7/docs/technotes/guides/vm/server-class.html</a></li>
<li><a href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html">http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html</a></li>
<li><a href="http://www.oracle.com/technetwork/java/faq-140837.html">http://www.oracle.com/technetwork/java/faq-140837.html</a></li>
<li><a href="https://bugs.openjdk.java.net/browse/JDK-4484370">https://bugs.openjdk.java.net/browse/JDK-4484370</a></li>
<li><a href="https://bugs.openjdk.java.net/browse/JDK-8027915">https://bugs.openjdk.java.net/browse/JDK-8027915</a></li>
<li><a href="https://searchcode.com/codesearch/view/17980811/">https://searchcode.com/codesearch/view/17980811/</a></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>分析Java Object中的wait/notify</title>
    <url>/2019/10/10/analysis-java-object-wait-notify/</url>
    <content><![CDATA[<p>在Java的Object类中有2个我们不怎么常用(框架中用的更多)的方法：wait()与notify()或notfiyAll()，这两个方法主要用于多线程间的协同处理，即控制线程之间的等待、通知、切换及唤醒。</p>
<p>首先了解下线程有哪几种状态,Java的<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html">Thread.State</a>中定义了线程的6种状态,分别如下：</p>
<ol>
<li>NEW    未启动的,不会出现在dump文件中(可以通过jstack命令查看线程堆栈)</li>
<li>RUNNABLE    正在JVM中执行的</li>
<li>BLOCKED    被阻塞,等待获取监视器锁进入synchronized代码块或者在调用Object.wait之后重新进入synchronized代码块</li>
<li>WAITING    无限期等待另一个线程执行特定动作后唤醒它,也就是调用Object.wait后会等待拥有同一个监视器锁的线程调用notify/notifyAll来进行唤醒</li>
<li>TIMED_WAITING    有时限的等待另一个线程执行特定动作</li>
<li>TERMINATED    已经完成了执行</li>
</ol>
<a id="more"></a>

<blockquote>
<p>从操作系统层面上来讲，一个进程从创建到消亡期间，最常见的进程状态有以下几种<br>新建态 ： 从程序映像到进程映像的转变，还没有加入到就绪队列中<br>就绪态 : 进程运行已万事俱备，正等待调度执行<br>运行态 : 进程指令正在被执行<br>阻塞态 : 进程正在等待一个时间操作完成，例如I/O操作<br>完成态 : 进程运行结束，它的资源已经被释放，供其他活动进程使用</p>
</blockquote>
<p>接下来我们分析下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotify</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// thread1</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;thread1 is ready&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            lock.notify();</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1 is notify,but not exit synchronized&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1 is exit synchronized&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// thread2</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;thread2 is ready&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 is waiting&quot;</span>);</span><br><span class="line">                lock.wait();</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 is awake&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码运行结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread1 is ready</span><br><span class="line">thread2 is ready</span><br><span class="line">thread2 is waiting</span><br><span class="line">thread1 is notify,but not exit synchronized</span><br><span class="line">thread 1 is exit synchronized</span><br><span class="line">thread2 is awake</span><br></pre></td></tr></table></figure>

<p>看到这里你会发现平平无奇，好像也没什么特殊的事情,但是如果深入分析下，就会发现以下的问题</p>
<ol>
<li>为何调用wait或者notify一定要加synchronized，不加行不行？</li>
<li>thread2中调用了wait后，当前线程还未退出同步代码块，其他线程(thread1)能进入同步块吗？</li>
<li>为何调用wait()有可能抛出InterruptedException异常</li>
<li>调用notify/notifyAll后等待中的线程会立刻唤醒吗？</li>
<li>调用notify/notifyAll是随机从等待线程队列中取一个或者按某种规律取一个来执行？</li>
<li>wait的线程是否会影响系统性能？</li>
</ol>
<p>针对上面的问题，我们逐个分析下</p>
<h4 id="为何调用wait或者notify一定要加synchronized，不加行不行？"><a href="#为何调用wait或者notify一定要加synchronized，不加行不行？" class="headerlink" title="为何调用wait或者notify一定要加synchronized，不加行不行？"></a>为何调用wait或者notify一定要加synchronized，不加行不行？</h4><p>如果你不加，你会得到下面的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalMonitorStateException</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<a href="https://github.com/unofficial-openjdk/openjdk/blob/jdk8u%2Fjdk8u/hotspot/src/share/vm/runtime/objectMonitor.cpp#L1425">JVM源代码中</a>首先会检查当前线程是否持有锁,如果没有持有则抛出异常</p>
</blockquote>
<p>其次为什么要加,也有比较广泛的讨论，首先wait/notify是为了线程间通信的，为了这个通信过程不被打断，需要保证wait/notify这个整体代码块的原子性，所以需要通过synchronized来加锁。</p>
<h4 id="thread2中调用了wait后，当前线程还未退出同步代码块，其他线程-thread1-能进入同步块吗？"><a href="#thread2中调用了wait后，当前线程还未退出同步代码块，其他线程-thread1-能进入同步块吗？" class="headerlink" title="thread2中调用了wait后，当前线程还未退出同步代码块，其他线程(thread1)能进入同步块吗？"></a>thread2中调用了wait后，当前线程还未退出同步代码块，其他线程(thread1)能进入同步块吗？</h4><p>wait在处理过程中会临时释放同步锁(如果不释放其他线程没有机会抢)，不过需要注意的是当其他线程调用notify唤起这个线程的时候，在wait方法退出之前会重新获取这把锁，只有获取了这把锁才会继续执行,这也和我们的结果相符合,输出了<code>thread2 is awake</code>,<br>其实想想也容易理解,synchronized的代码实际上是被被monitorenter和monitorexit包围起来的。当我们调用wait的时候，会释放锁,调用monitorexit的时候也会释放锁,那么当thread2被唤醒的时候必然重新获取到了锁(objectMonitor::enter)。</p>
<p>其实从jdk源代码的<a href="https://github.com/unofficial-openjdk/openjdk/blob/jdk8u%2Fjdk8u/hotspot/src/share/vm/runtime/objectMonitor.cpp#L1463">ObjectMonitor::wait方法</a>可以一窥究竟，首先会放弃已经抢到的锁(exit(self)),而放弃锁的前提是获取到锁</p>
<p>而在notify方法中会选取一个线程获得cpu执行权，在去竞争锁，如果没有竞争到则会进入休眠。</p>
<p>如果调用的wait(200)这种代码,那么会在200ms后将线程从waiting set中移除并允许其重新竞争锁，需要注意的是notify方法并不会释放所持有的monitor</p>
<h4 id="为何调用wait-有可能抛出InterruptedException异常"><a href="#为何调用wait-有可能抛出InterruptedException异常" class="headerlink" title="为何调用wait()有可能抛出InterruptedException异常"></a>为何调用wait()有可能抛出InterruptedException异常</h4><p>当我们调用了某个线程的interrupt方法，对应的线程会抛出这个异常，wait方法也不希望去破坏这种规则，因此就算当前线程因为wait一直在阻塞。当某个线程希望它起来继续执行的时候，它还是得从阻塞态恢复过来，因此wait方法被唤醒起来的时候会去检测这个状态，当有线程interrupt了它的时候，它就会抛出这个异常从阻塞状态恢复过来。</p>
<p>这里有两点要注意：</p>
<ol>
<li>如果被interrupt的线程只是创建了，并没有start，那等他start之后进入wait态之后也是不能会恢复的</li>
<li>如果被interrupt的线程已经start了，在进入wait之前，如果有线程调用了其interrupt方法，那这个wait等于什么都没做，会直接跳出来，不会阻塞,下面的代码演示了这种情况</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;thread2 is ready&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2 is waiting&quot;</span>);</span><br><span class="line">            lock.wait();</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2 is awake&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// main</span></span><br><span class="line">  thread2.start();</span><br><span class="line"></span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  thread2.interrupt();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码输出结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread2 is ready</span><br><span class="line">thread2 is waiting</span><br><span class="line">java.lang.InterruptedException</span><br></pre></td></tr></table></figure>

<h4 id="调用notify-notifyAll后等待中的线程会立刻唤醒吗？"><a href="#调用notify-notifyAll后等待中的线程会立刻唤醒吗？" class="headerlink" title="调用notify/notifyAll后等待中的线程会立刻唤醒吗？"></a>调用notify/notifyAll后等待中的线程会立刻唤醒吗？</h4><p>hotspot真正的实现是退出同步代码块的时候才会去真正唤醒对应的线程，不过这个也是个默认策略，也可以改的，在notify之后立马唤醒相关线程。<br>这个也可从jdk源代码的objectMonitor类objectMonitor::notify方法中看到.在调用notify时的默认策略是Policy == 2（这个值是源码中的初值，可以通过-XX:SyncKnobs来设置）</p>
<p>其实对于Policy(1、2、3、4)都是将objectMonitor的ObjectWaiter集合中取出一个等待线程，放入到_EntryList（blocked线程集合，可以参与下次抢锁），只是放入_EntryList的策略不一样，体现为唤醒wait线程的规则不一样。</p>
<p>对于默认策略notify在将一个等待线程放入阻塞线程集合之后就退出，因为同步块还没有执行完monitorexit，锁其实还未释放，所以在打印出“thread1 is exit synchronized!”的时候，thread2线程还是blocked状态（因为thread1还没有退出同步块）。</p>
<p>这里可以发现，对于不在Policy中的情况，会直接将一个ObjectWaiter进行unpark唤醒操作，但是被唤醒的线程是否立即获取到了锁呢？答案是否定的。</p>
<h4 id="调用notify-notifyAll是随机从等待线程队列中取一个或者按某种规律取一个来执行？"><a href="#调用notify-notifyAll是随机从等待线程队列中取一个或者按某种规律取一个来执行？" class="headerlink" title="调用notify/notifyAll是随机从等待线程队列中取一个或者按某种规律取一个来执行？"></a>调用notify/notifyAll是随机从等待线程队列中取一个或者按某种规律取一个来执行？</h4><p>我们自己实现可能一个for循环就搞定了，不过在jvm里实现没这么简单，而是借助了monitor_exit，上面我提到了当某个线程从wait状态恢复出来的时候，要先获取锁，然后再退出同步块，所以notifyAll的实现是调用notify的线程在退出其同步块的时候唤醒起最后一个进入wait状态的线程，然后这个线程退出同步块的时候继续唤醒其倒数第二个进入wait状态的线程，依次类推，同样这是一个策略的问题，jvm里提供了挨个直接唤醒线程的参数,这里要分情况：</p>
<ol>
<li>如果是通过notify来唤起的线程，那先进入wait的线程会先被唤起来</li>
<li>如果是通过nootifyAll唤起的线程，默认情况是最后进入的会先被唤起来，即LIFO的策略</li>
</ol>
<h4 id="wait的线程是否会影响系统性能？"><a href="#wait的线程是否会影响系统性能？" class="headerlink" title="wait的线程是否会影响系统性能？"></a>wait的线程是否会影响系统性能？</h4><p>这个或许是大家比较关心的话题，因为关乎系统性能问题，wait/nofity是通过jvm里的park/unpark机制来实现的，在linux下这种机制又是通过pthread_cond_wait/pthread_cond_signal来玩的，因此当线程进入到wait状态的时候其实是会放弃cpu的，也就是说这类线程是不会占用cpu资源，也不会影响系统加载。</p>
<h4 id="什么是监视器-monitor"><a href="#什么是监视器-monitor" class="headerlink" title="什么是监视器(monitor)"></a>什么是监视器(monitor)</h4><p>Java中每一个对象都可以成为一个监视器（Monitor）, 该Monitor由一个锁（lock）, 一个等待队列（waiting queue ）, 一个入口队列( entry queue)组成.<br>对于一个对象的方法， 如果没有synchonized关键字， 该方法可以被任意数量的线程，在任意时刻调用。<br>对于添加了synchronized关键字的方法，任意时刻只能被唯一的一个获得了对象实例锁的线程调用。</p>
<p><img data-src="/images/java_monitor.bmp" alt="java监视器"></p>
<p><strong>进入区(Entry Set):</strong> 表示线程通过 synchronized要求获得对象锁，如果获取到了，则成为拥有者，如果没有获取到在在进入区等待，直到其他线程释放锁之后再去竞争(谁获取到则根据)</p>
<p><strong>拥有者(Owner):</strong> 表示线程获取到了对象锁，可以执行synchronized包围的代码了</p>
<p><strong>等待区(Wait Set):</strong> 表示线程调用了wait方法,此时释放了持有的对象锁，等待被唤醒(谁被唤醒取得监视器锁由jvm决定)</p>
<h4 id="关于sleep"><a href="#关于sleep" class="headerlink" title="关于sleep"></a>关于sleep</h4><p>它是一个静态方法，一般的调用方式是Thread.sleep(2000),表示让当前线程休眠2000ms,并不会让出监视器，这一点需要注意。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出String.intern()</title>
    <url>/2020/08/26/analysis-string-intern/</url>
    <content><![CDATA[<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>Java虚拟机管理的内存包含以下几个运行时数据区域</p>
<p><img data-src="/images/thread-java-running-data-area.png" alt="Java虚拟机运行时数据区"></p>
<p>方法区与java堆一样，是各个线程共享的内存区域，用于存储已经被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p><strong>JDK8之前很多人叫它永久代(这里可以联想下年前代，老年代)，是因为当时HotSpot虚拟机的设计团队选择将收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已。<br>这样使得HotSpot的垃圾收集器能像管理Java堆一样管理这部分内存。但是对于其他虚拟机实现是不存在这个概念的。</strong></p>
<p>运行时常量池(Runtime ConstantPool)是方法区的一部分。Class文件中除了有类的版本、字、方法、接口等描述信息外,还有一项信息是常量池表(ConstantPoolTable),用于存放编译期生<br>成的各种字面量与符号引用,这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<blockquote>
<p>String str = “think123” 其中的think123就直接保存在常量池中</p>
</blockquote>
<a id="more"></a>

<p>运行时常量池存了在编译器能产生之外，在运行期间也可以将新的常量放入池中,这种特性被利用最多的就是String类的intern()方法</p>
<p><code>String::intern()</code>是一个本地方法,它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串,则返回代表池中这个字符串的String对象的引用;否则,会将此String对象包含的字符串添加到常量池中,并且返回此String对象的引用。</p>
<p>伪代码类似如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">if(StringPool.contains(search_string)) &#123;</span><br><span class="line">  </span><br><span class="line">  return search_string_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">search_string_addr &#x3D; StringPool.add(search_string);</span><br><span class="line"></span><br><span class="line">return search_string_addr;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="神奇的代码"><a href="#神奇的代码" class="headerlink" title="神奇的代码"></a>神奇的代码</h3><p>下面的代码你猜猜会输出什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String s1 = <span class="keyword">new</span> StringBuilder().append(<span class="string">&quot;think&quot;</span>).append(<span class="string">&quot;123&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">    System.out.println(s1.intern() == s1);</span><br><span class="line"></span><br><span class="line">    String s2 = <span class="keyword">new</span> StringBuilder().append(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">    System.out.println(s2.intern() == s2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>JDK6 : false   false</p>
</li>
<li><p>JDK8 : true    false</p>
</li>
<li><p>JDK12: true    true</p>
</li>
</ol>
<p>神不神奇? 接下来就是见证奇迹的时刻了。</p>
<h3 id="为什么会有不同的结果"><a href="#为什么会有不同的结果" class="headerlink" title="为什么会有不同的结果"></a>为什么会有不同的结果</h3><p>从JDK6开始就就有放弃永久代，逐步改为采用本地内存来实现方法区的计划了。</p>
<p>到了JDK7的HotSpot，已经把原本放在永久代的字符串常量池、静态常量池等移出到堆中了</p>
<p>而到了JDK8,完全废弃了永久代的概念，改用在本地内存中实现的元空间(meta space)来代替了。把JDK7中永久代还剩下的内容(主要是类型信息)全部移到元空间中。</p>
<h4 id="JDK6为什么会这样？"><a href="#JDK6为什么会这样？" class="headerlink" title="JDK6为什么会这样？"></a>JDK6为什么会这样？</h4><p>在JDK6中，常量池还是存在于永久代中。</p>
<p>也就是说, <strong>常量池和堆是两块不同的内存区域。</strong></p>
<p>在JDK6中，intern()方法会把首次遇到的字符串实例复制到永久代的字符串常量池中，返回的也是永久代里面这个字符串实例的引用，而StringBuilder创建的字符串对象实例是在Java堆上，这必然不可能是同一个引用，所以返回false</p>
<h4 id="JDK7-为什么会有这样的结果"><a href="#JDK7-为什么会有这样的结果" class="headerlink" title="JDK7+为什么会有这样的结果"></a>JDK7+为什么会有这样的结果</h4><p>我本地没有JDK7环境,但是JDK7和JDK8输出是一样的结果。那么为什么JDK7会输出true false呢？</p>
<p>因为从JDK7开始，字符串常量池已经被移到了堆当中了。</p>
<p>对于变量s1,虽然常量池中不存在”think123”,但是堆中是存在的。 当调用s1.intern()的时候，实际是将堆中think123放入了常量池中。所以s1.intern()和s1都是指向java堆上的String对象</p>
<p>对于变量s2,常量池中一开始就存在”java”字符串，s2.intern()方法返回的是常量池中的字符串对象，而s2是new的字符串对象，虽然都在堆中，但是并不是一个对象。所以输出false</p>
<blockquote>
<p>这个一开始就存在常量池的java字符串在sun.misc.Version类中，具体可见R大分析 <a href="https://www.zhihu.com/question/51102308/answer/124441115">https://www.zhihu.com/question/51102308/answer/124441115</a><br>周志明老师在第三版《深入理解java虚拟机》已经把这个坑填上了</p>
</blockquote>
<h4 id="JDK12为什么会是这样的结果？"><a href="#JDK12为什么会是这样的结果？" class="headerlink" title="JDK12为什么会是这样的结果？"></a>JDK12为什么会是这样的结果？</h4><p>难道从JDK12开始常量池又不在堆里面了？ 当然不是这是因为sun.misc.Version这个类在JDK12(JDK11也不存在)中已经不存在了。这里我debug了源码，将部分JDK12中存在的字符串常量打印出来了(全部有1000多个)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;Cannot suppress a null exception.&quot;&#123;0x0000000787f00fb0&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;Self-suppression not permitted&quot;&#123;0x0000000787f01000&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;Caused by: &quot;&#123;0x0000000787f01048&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;Suppressed: &quot;&#123;0x0000000787f01080&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;&lt;init&gt;&quot;&#123;0x0000000787f02de8&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;sun.net.www.protocol&quot;&#123;0x0000000787f03a40&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;java.protocol.handler.pkgs&quot;&#123;0x0000000787f03a80&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;null&quot;&#123;0x0000000787f04828&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;-2147483648&quot;&#123;0x0000000787f04858&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;system&quot;&#123;0x0000000787f06730&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;*&quot;&#123;0x0000000787f073e0&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;classLoader&quot;&#123;0x0000000787f074a0&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;security&quot;&#123;0x0000000787f074f0&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;float&quot;&#123;0x0000000787f07a38&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;double&quot;&#123;0x0000000787f07aa0&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;segments&quot;&#123;0x0000000787f08210&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;segmentMask&quot;&#123;0x0000000787f08518&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;int&quot;&#123;0x0000000787f085a0&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;segmentShift&quot;&#123;0x0000000787f08778&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;sizeCtl&quot;&#123;0x0000000787f087c0&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;transferIndex&quot;&#123;0x0000000787f087f0&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;baseCount&quot;&#123;0x0000000787f08828&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;cellsBusy&quot;&#123;0x0000000787f08860&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;value&quot;&#123;0x0000000787f08910&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;jdk.internal.ref.Cleaner&quot;&#123;0x0000000787f08e50&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;Reference Handler&quot;&#123;0x0000000787f09228&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;Finalizer&quot;&#123;0x0000000787f097d8&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;java.home&quot;&#123;0x0000000787f0b1d0&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;Finalizer&quot;&#123;0x0000000787f097d8&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;java.home&quot;&#123;0x0000000787f0b1d0&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;user.home&quot;&#123;0x0000000787f0b208&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;user.dir&quot;&#123;0x0000000787f0b260&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;user.name&quot;&#123;0x0000000787f0b2b0&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;sun.jnu.encoding&quot;&#123;0x0000000787f0b308&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;file.encoding&quot;&#123;0x0000000787f0b360&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;os.name&quot;&#123;0x0000000787f0b3b8&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;os.arch&quot;&#123;0x0000000787f0b408&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;os.version&quot;&#123;0x0000000787f0b458&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;line.separator&quot;&#123;0x0000000787f0b4b0&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;file.separator&quot;&#123;0x0000000787f0b508&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;path.separator&quot;&#123;0x0000000787f0b560&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;java.io.tmpdir&quot;&#123;0x0000000787f0b5b8&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;http.proxyHost&quot;&#123;0x0000000787f0b610&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;http.proxyPort&quot;&#123;0x0000000787f0b648&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;https.proxyHost&quot;&#123;0x0000000787f0b680&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;https.proxyPort&quot;&#123;0x0000000787f0b6b8&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;ftp.proxyHost&quot;&#123;0x0000000787f0b6f0&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;ftp.proxyPort&quot;&#123;0x0000000787f0b728&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;id&quot;&#123;0x0000000787953030&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;language&quot;&#123;0x0000000787953218&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;country&quot;&#123;0x0000000787953270&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;variant&quot;&#123;0x00000007879532c8&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;hashcode&quot;&#123;0x0000000787953320&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;script&quot;&#123;0x0000000787953378&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;extensions&quot;&#123;0x00000007879533d0&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;Main&quot;&#123;0x0000000787957368&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;main&quot;&#123;0x0000000787957570&#125;&quot;</span><br><span class="line"></span><br><span class="line">... 省略 ....</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; think 123是程序代码中出现的常量,实际上并非原生</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;think&quot;&#123;0x0000000787957a90&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;123&quot;&#123;0x0000000787957ac0&#125;&quot;</span><br><span class="line">wh.resolve()-&gt;print_value_string() &#x3D; (char *) &quot;&quot;think123&quot;&#123;0x0000000787957af0&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>上面是我使用CLION 调试JVM源码输出的内容，其中的字符串就是常量表中的内容。在jdk12中如果你将java换成上面任意出现的一个字符串输出结果都会是false(JDK8中大部分都可以)</p>
<h3 id="intern源码分析"><a href="#intern源码分析" class="headerlink" title="intern源码分析"></a>intern源码分析</h3><p>以下代码是基于openJdk 12,和JDK8有细微区别，但是总体逻辑是一致的。</p>
<p>先搜索java_lang_string_intern字符串找到intern方法的实现入口String.c文件中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jobject JNICALL</span><br><span class="line">Java_java_lang_String_intern(JNIEnv *env, jobject <span class="keyword">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> JVM_InternString(env, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终会调用StringTable的intern方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">oop <span class="title">StringTable::intern</span><span class="params">(Handle string_or_null_h, <span class="keyword">const</span> jchar* name, <span class="keyword">int</span> len, TRAPS)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 首先计算hashcode</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = java_lang_String::hash_code(name, len);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过hashcode以及name(实际是将string转换成了unicode)在StringTable中的share_table寻找字符串</span></span><br><span class="line">  oop found_string = StringTable::the_table()-&gt;lookup_shared(name, len, hash);</span><br><span class="line">  <span class="keyword">if</span> (found_string != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> found_string;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (StringTable::_alt_hash) &#123;</span><br><span class="line">    hash = hash_string(name, len, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 未找到就加入StringTable</span></span><br><span class="line">  <span class="keyword">return</span> StringTable::the_table()-&gt;do_intern(string_or_null_h, name, len,</span><br><span class="line">                                             hash, CHECK_NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在找寻字符串的时候，lookup_shared()方法实际上就是在HashTable中去寻找这个字符串,通过hash确定StringTable中桶的位置，通过name作为key来确定value.</p>
<p>实际上无论字符串是否在常量池,shared_table的大小都是为0，也就是说这个fonund_string一直为NULL</p>
<p>如果字符串未找到,那么就会调用do_intern()方法将其加入StringTable中。(JDK8和JDK12有些许区别，但是原理是一样的)</p>
<p><img data-src="/images/java/stringtable-dointern.png" alt="do_intern"></p>
<p>这里的string_or_null_h是一个Handle对象，为什么访问对象的时候要使用它呢？是因为垃圾回收时对象可能被移动(对象地址发生改变)，通过handle访问对象可以对使用者屏蔽垃圾回收细节。</p>
<p>你需要注意的是红框中的while循环,如果我们的字符串在常量池中存在，那么会</p>
<p><img data-src="/images/java/insert_or_get_string.png" alt="insert_or_get"></p>
<p>需要注意的是这里的_local_table-&gt;get和上面的lookup_shared不同之处在于lookeup_shared中的map是一个强类型的map(里面的数据不会被垃圾回收),而_local_table中的则是是weak的，在内存不足的时候是会被回收的。</p>
<h3 id="常量池是如何被加入到常量池的？"><a href="#常量池是如何被加入到常量池的？" class="headerlink" title="常量池是如何被加入到常量池的？"></a>常量池是如何被加入到常量池的？</h3><p>在启动JVM的时候就会解析ldc这个指令(可以通过javap查看对应解析常量池的指令)，最终还是会通过intern()方法将其加入到常量池中,更具体的调用我就不做过多介绍了，这里我把调用堆栈贴上来</p>
<p><img data-src="/images/java/resolve_ldc.png" alt="解析ldc指令"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>实际开发中其实不需要去记住常量池中已经加载了哪些字符串常量，你只需要记住</p>
<ol>
<li><p>通过双引号声明的字符串，直接保存在常量池中</p>
</li>
<li><p>new的字符串在堆中,JDK6中常量池在永久代,JDK7+将常量池放到了堆中</p>
</li>
<li><p>常量池相当于一个缓存,intern()方法实际上就是动态将字符串常量加入到这个缓存中。类似HashMap::computeIfAbsent方法</p>
</li>
<li><p>一味的使用intern并不好，比较常量池的实现是hashtable,它也是有容量限制的，如果往里面放入大量的内容，会发生大量的hash冲突,导致运行速度过慢</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>备份hexo配置</title>
    <url>/2015/10/26/backup-hexo-config/</url>
    <content><![CDATA[<h2 id="备份hexo配置"><a href="#备份hexo配置" class="headerlink" title="备份hexo配置"></a>备份hexo配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: http://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: I am TKing</span><br><span class="line">subtitle:</span><br><span class="line">description: 相信自己做一个自信的人</span><br><span class="line">author: generalthink</span><br><span class="line">#主题支持的语言</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone:</span><br><span class="line">email: general_go@<span class="number">163.</span>com</span><br><span class="line">since: <span class="number">2014</span></span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="line">url: http:<span class="comment">//yoursite.com</span></span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: <span class="keyword">public</span></span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: <span class="number">0</span></span><br><span class="line">render_drafts: <span class="keyword">false</span></span><br><span class="line">post_asset_folder: <span class="keyword">false</span></span><br><span class="line">relative_link: <span class="keyword">false</span></span><br><span class="line">future: <span class="keyword">true</span></span><br><span class="line">highlight:</span><br><span class="line">  enable: <span class="keyword">true</span></span><br><span class="line">  line_number: <span class="keyword">true</span></span><br><span class="line">  auto_detect: <span class="keyword">true</span></span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: <span class="number">10</span></span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: http://hexo.io/plugins/</span><br><span class="line">## Themes: http://hexo.io/themes/</span><br><span class="line">theme: next</span><br><span class="line">avatar: /images/avatar.jpg</span><br><span class="line">social:</span><br><span class="line">    github: https:<span class="comment">//github.com/k</span></span><br><span class="line">    zhihu: http:<span class="comment">//www.zhihu.com/people/think123</span></span><br><span class="line"></span><br><span class="line">links_title: 友情链接</span><br><span class="line"># links</span><br><span class="line">links:</span><br><span class="line">  baidu: http:<span class="comment">//www.baidu.com</span></span><br><span class="line">  it2048: http:<span class="comment">//www.it2048.cn</span></span><br><span class="line"></span><br><span class="line">#多说评论</span><br><span class="line">duoshuo_shortname: generalthink</span><br><span class="line"># 多说分享服务</span><br><span class="line">duoshuo_share: <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">#hexo-generator-archive plugin</span><br><span class="line">archive_generator:</span><br><span class="line">  per_page: <span class="number">10</span></span><br><span class="line">  yearly: <span class="keyword">true</span></span><br><span class="line">  monthly: <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">#hexo-generator-category</span><br><span class="line">category_generator:</span><br><span class="line">  per_page: <span class="number">10</span></span><br><span class="line"></span><br><span class="line">#hexo-generator-index</span><br><span class="line">index_generator:</span><br><span class="line">  per_page: <span class="number">10</span></span><br><span class="line"></span><br><span class="line">toc:</span><br><span class="line">  maxDepth: <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: http://hexo.io/docs/deployment.html</span><br><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  repo: git<span class="meta">@github</span>.com:generalthink/generalthink.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式基本使用</title>
    <url>/2018/03/25/basic-use-of-regular-expressions/</url>
    <content><![CDATA[<p>正则表达式是一个很强大的模式语言，使用它我们能够解决很多很棘手的问题，有时候使用字符串查找来解决这类问题不是很方便，所以这个时候正则表达式就能帮我们很大的忙。</p>
<p>完整的正则表达式由两种字符构成。特殊字符(specialcharacters,比如*)<br>称为“元字符”(metacharacters),其他为“文字”(literal),或者是普通文本字符(normaltext characters).</p>
<h3 id="如何理解正则表达式"><a href="#如何理解正则表达式" class="headerlink" title="如何理解正则表达式"></a>如何理解正则表达式</h3><p>正则表达式是一门语言，同样有着它的语言模式,所以我们要以它的模式来理解它，比如^cat(^表示行开头)的意思是匹配以c字符作为第一行的第一个字符,紧接一个a，紧接一个t的文本.</p>
<h3 id="正则表达式的基本使用"><a href="#正则表达式的基本使用" class="headerlink" title="正则表达式的基本使用"></a>正则表达式的基本使用</h3><h4 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h4><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p>
<h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><table>
<thead>
<tr>
<th>元字符</th>
<th>名 称</th>
<th>匹配对象</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>点号</td>
<td>匹配除了换行符(\n)以外的任意一个字符</td>
</tr>
<tr>
<td>[…]</td>
<td>字符组</td>
<td>列出的任意字符</td>
</tr>
<tr>
<td>[^…]</td>
<td>排除型字符组</td>
<td>未列出的任意字符</td>
</tr>
<tr>
<td>^</td>
<td>脱字符</td>
<td>行的起始位置</td>
</tr>
<tr>
<td>$</td>
<td>美元符</td>
<td>行的结束位置</td>
</tr>
<tr>
<td>|</td>
<td>竖线</td>
<td>匹配分隔两边的任意一个表达式</td>
</tr>
<tr>
<td>(…)</td>
<td>括号</td>
<td>限制竖线的作用范围，其他功能下文讨论</td>
</tr>
<tr>
<td>?</td>
<td>问号</td>
<td>容许匹配一次,当并非必要</td>
</tr>
<tr>
<td>+</td>
<td>加号</td>
<td>表示之前紧邻的元素至少需要匹配一次,至多可能任意多次</td>
</tr>
<tr>
<td>*</td>
<td>星号</td>
<td>表示之前紧邻的元素尽可能匹配多次,也可能不匹配</td>
</tr>
<tr>
<td>\char</td>
<td>转义字符</td>
<td>若char是元字符，或转义序列无特殊含义时，匹配char对应的普通字符,如果是普通字符则反斜线被忽略</td>
</tr>
<tr>
<td>{n,m}</td>
<td>区间量词</td>
<td>表示至少匹配n次,最多匹配m次</td>
</tr>
<tr>
<td>\1,\2</td>
<td>反向引用</td>
<td>匹配之前的第一、第二组括号内的字表达式匹配的文本</td>
</tr>
</tbody></table>
<p>如果要匹配元字符，都需要加上反斜杠(‘&#39;)转义,在字符组内部无效</p>
<h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><p>忽略优先量词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*?, +?, ??, &#123;n&#125;?, &#123;n,&#125;?, &#123;n,m&#125;?   </span><br></pre></td></tr></table></figure>
<p>量词在正常情况下都是“匹配优先”的，匹配尽可能多的内容。相反，这些忽略优先的量词会匹配尽可能少的内容，只需要满足下限，匹配就能成功</p>
<p>匹配优先量词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*, +,  ?,  &#123;num,num&#125;</span><br></pre></td></tr></table></figure>

<p>占有优先量词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?+,  *+,  ++,  &#123;m,n&#125;+</span><br></pre></td></tr></table></figure>

<p>这些量词目前只有java.util.regex 和 PCRE (以及PHP)提供,占有优先量词类似普通的匹配优先量词，不过他们一旦匹配某些内容，就 不 会 “交还”。</p>
<h4 id="其他通用规则"><a href="#其他通用规则" class="headerlink" title="其他通用规则"></a>其他通用规则</h4><table>
<thead>
<tr>
<th>规则</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>\xXX</td>
<td>编号在 0 ~ 255 范围的字符，比如：空格可以使用 “\x20” 表示</td>
</tr>
<tr>
<td>\uXXXX</td>
<td>任何字符可以使用 “\u” 再加上其编号的4位十六进制数表示，比如：”\u4E2D”</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\s</td>
<td>任何 “空白”字 符(例如空格符、制表符、进纸符等)</td>
</tr>
<tr>
<td>\S</td>
<td>除\s 之外的任何字符</td>
</tr>
<tr>
<td>\w</td>
<td><a href="%5Cw+%E4%B8%AD%E5%BE%88%E6%9C%89%E7%94%A8%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D">a-zA-ZO-9</a></td>
</tr>
<tr>
<td>\W</td>
<td>除\w之外的任何字符，也就是[Aa-zA-ZO-9]</td>
</tr>
<tr>
<td>\d</td>
<td>[0-9],即数字</td>
</tr>
<tr>
<td>\D</td>
<td>除\d以外的任何字符，即[^a-zA-Z0-9]</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界，即左右两边都是 “\w” 范围或者左右两边都不是 “\w” 范围时的字符缝隙</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词边界</td>
</tr>
</tbody></table>
<h3 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h3><p>字符组的意思表示匹配若干个字符之一,比如gr[ae]y,表示匹配的结果是grey或者是gray。<br>请注意，在字符组以外，普通字符(例如gr[ae]y 中的g和r)都有“接下来是(and then)”的意思——“首先匹配g，接下来是r”。这与字符组内部的情况是完全相反的。<br>字符组的内容是在同一个位置能够匹配的若干字符，所以它的意思是“或”。</p>
<p>在字符组内部，字符组元字符‘-’表示范围的意思,比如[123456]表示1到6之间的任意一个数字，与[1-6]是一样的,同理[0-9A-Za-z]表示匹配9个数字与52个字母中的其中一个，顺序无所谓。<br>我们还可以随心所欲地把字符范围与普通文本结合起来:[0-9A-Z_!.?]能够匹配一个数字、大写字母、下画线、惊叹号、点号，或者是问号。</p>
<p>请注意，只有在字符组内部，连字符才是元字符一否则它就只能匹配普通的连字符号。其实，即使在字符组内部，它也不一定就是元字符。如果连字符出现在字符组的开头，它表<br>示的就只是一个普通字符，而不是一个范围。<br>同样的道理，问号和点号通常被当作元字符处理，但在字符组中则不是如此(说明白一点就是，[0-9A-Z_!] 里面，真正的特殊字符<br>就只有那两个连字符)。</p>
<p>字符组中的另外一个元字符是^,表示排除的意思，比如[^1-6],表示匹配除了1到6之外的任意字符。而且必须是紧接在字符组的第一个方括号之后才是排除的意思。<br>需要记住的是排除型字符组表示“匹配一个未列出的字符(match a character that’s not listed)”,而不是 “不要匹配列出的字符(don’t match what is listed)”</p>
<h3 id="分组和反向引用"><a href="#分组和反向引用" class="headerlink" title="分组和反向引用"></a>分组和反向引用</h3><p>小括号 () 可以达到对正则表达式进行分组的效果，分组后会在正则表达式中创建反向引用，反向引用会保存分组的字符片段，这使得我们可以使用这个字符片段。</p>
<p>对于这样一个正则表达式”((\w)\d(test)))”总共存在3组(每个括号是1组,从左到右开始数,整个表达式是第一组,因为它被括号包围了,\w是第二组,test是第三组内容),每个组在程序中都可以获取，正则表达式引擎在匹配的时候会保存整个组的内容，用于以后获取，如果将正则表达式修改为 “((?:\w)\d(test)))”,这样就不能获取\w所捕获的那一组的内容。</p>
<p>在以正则表达式替换字符串的语法中，是通过 <code>$</code> 来引用分组的反向引用，<code>$0</code> 是匹配完整模式的字符串(注意在 JavaScript 中是用 <code>$&amp;</code> 表示)；<br><code>$1</code> 是第一个分组的反向引用；<code>$2</code> 是第二个分组的反向引用，以此类推。</p>
<p>在匹配的过程中也是可以使用分组的结果的，表达式后边的部分，可以引用前面 “括号内的子匹配已经匹配到的字符串”。引用方法是 “&quot; 加上一个数字。”\1” 引用第1对括号内匹配到的字符串，”\2” 引用第2对括号内匹配到的字符串……以此类推，如果一对括号内包含另一对括号，则外层的括号先排序号。换句话说，哪一对的左括号 “(“ 在前，那这一对就先排序号。</p>
<h3 id="非捕获型括号"><a href="#非捕获型括号" class="headerlink" title="非捕获型括号"></a>非捕获型括号</h3><p>括号 <code>( )</code> 内的子表达式，如果希望匹配结果不进行记录供以后使用，可以使用 <code>(?:xxxxx)</code> 格式,此种方式可以提高效率。</p>
<p>举例1：表达式 <code>(?:(\w)\1)+</code> 匹配 <code>a bbccdd efg</code> 时，结果是 <code>bbccdd</code>。括号 <code>(?:)</code> 范围的匹配结果不进行记录，因此 <code>(\w)</code> 使用 <code>\1</code> 来引用。</p>
<h3 id="环视-或许也被叫做零宽断言"><a href="#环视-或许也被叫做零宽断言" class="headerlink" title="环视(或许也被叫做零宽断言)"></a>环视(或许也被叫做零宽断言)</h3><p>环视(Perl中叫这个名字)更多的表示的是一个位置,在java中适用,js中也适用,也叫做零宽表达式.</p>
<p>在说环视之前需要注意的一点是,在检查子表达式的过程中，它们本身不会”占用”任何文本，只匹配标记的位置</p>
<h4 id="肯定顺序环视"><a href="#肯定顺序环视" class="headerlink" title="肯定顺序环视"></a>肯定顺序环视</h4><p>(?=……) : 子表达式能够匹配右侧文本</p>
<p>原始串：abcdef</p>
<p>正则:abc(?=def)  能够匹配其中的abc,这里?=def匹配的是一个位置,即d的位置,然后这个位置前面有abc三个字符,所以匹配成功</p>
<h4 id="否定顺序序环视"><a href="#否定顺序序环视" class="headerlink" title="否定顺序序环视"></a>否定顺序序环视</h4><p>(?!……) : 子表达式不能匹配右侧文本</p>
<p>原始串：abcdef</p>
<p>正则:abc(?!def)  不能匹配其中的abc  但是可以匹配abcddef中的abc</p>
<h4 id="肯定逆序环视"><a href="#肯定逆序环视" class="headerlink" title="肯定逆序环视"></a>肯定逆序环视</h4><p>(?&lt;=……)    :    子表达式能够匹配左侧文本</p>
<p>原始串：abcdef</p>
<p>正则:(?&lt;=abc)def  能够匹配其中的def,</p>
<h4 id="否定逆序环视"><a href="#否定逆序环视" class="headerlink" title="否定逆序环视"></a>否定逆序环视</h4><p>(?&lt;!……)  :    子表达式不能匹配左侧文本</p>
<p>原始串：abcdef</p>
<p>正则:(?&lt;!abc)def  不能够匹配def  但是可以匹配 abdef中的def</p>
<p>顺序环视结构中可以使用任意正则表达式，但是逆序环视中的子表达式只能匹配长度有限的文本。也就是说 ?可以出现在逆序环视中，但 * 和 +则不行</p>
<h3 id="正则表达式中的匹配模式"><a href="#正则表达式中的匹配模式" class="headerlink" title="正则表达式中的匹配模式"></a>正则表达式中的匹配模式</h3><p>可以在正则的开头指定模式修饰符。</p>
<ol>
<li><p>(?i) 使正则忽略大小写。</p>
</li>
<li><p>(?s) 表示单行模式(“single line mode”)使正则的 . 匹配所有字符，包括换行符。</p>
</li>
<li><p>(?m) 表示多行模式(“multi-line mode”)，使正则的 ^ 和 $ 匹配字符串中每行的开始和结束。</p>
</li>
</ol>
<h3 id="在Java中使用正则表达式"><a href="#在Java中使用正则表达式" class="headerlink" title="在Java中使用正则表达式"></a>在Java中使用正则表达式</h3><p>我们需要先了解Java中的两个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.regex.Pattern</span><br><span class="line">java.util.regex.Matcher</span><br></pre></td></tr></table></figure>

<p>简称这两个为“ pattern ”和 “ matcher ”，许多时候我们只会用到这两个类。简单地说， Pattern对象就是编译好的正则表达式，可以应用于任意多个字符串，<br>Matcher对象则对应单独的实例，表示将正则表达式应用到某个具体的目标字符串上.</p>
<p>简单应用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String myTest = <span class="string">&quot;this is my 1st test string&quot;</span>;</span><br><span class="line">        String myRegex = <span class="string">&quot;\\d+\\w+&quot;</span>;</span><br><span class="line">        Pattern pattern = Pattern.compile(myRegex);</span><br><span class="line">        Matcher matcher = pattern.matcher(myTest);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(matcher.find()) &#123;</span><br><span class="line">            String matchText = matcher.group();</span><br><span class="line">            <span class="keyword">int</span> matchFrom = matcher.start();</span><br><span class="line">            <span class="keyword">int</span> matchEnd  =matcher.end();</span><br><span class="line">            System.out.println(<span class="string">&quot;matched [ &quot;</span> + matchText + <span class="string">&quot; ] from &quot;</span> + matchFrom + <span class="string">&quot; to &quot;</span> + matchEnd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;don&#x27;t match&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">matched [ <span class="number">1</span>st ] from <span class="number">11</span> to <span class="number">14</span></span><br></pre></td></tr></table></figure>
<h4 id="Matcher对象的常用API"><a href="#Matcher对象的常用API" class="headerlink" title="Matcher对象的常用API"></a>Matcher对象的常用API</h4><p>通过Matcher对象我们可以修改几个常用的对象：</p>
<ol>
<li>Pattern(usePattern方法)</li>
<li>目标字符串(reset(text)方法)</li>
<li>目标字符串的检索范围(region),默认是整个字符串,但是可以通过region方法修改为目标字符串的某一段,这样某些匹配操作就只能在某个区域进行了。</li>
<li>当前 pattern 的捕获型括号的数目可以通过groupCount查询</li>
</ol>
<p>当Matcher的正则表达式应用到文本的时候,下面这些方法会比较常用</p>
<ol>
<li><p>boolean find()</p>
<p> 此方法在目标字符串的当前检索范围中应用 Matcher 的正则表达式，返回的Boolean 值表示是否能找到匹配。如果多次调用，则每次都在上次的匹配位置之后尝试<br>新的匹配。没有给定参数的 find 只使用当前的检索 </p>
</li>
<li><p>boolean find (int  offset)</p>
<p> 如果指定了整 型参 数 ，匹配尝试会从距离目标字符串开头 offset个字符的位置 开始,这种形式的find不会受当前检索范围的影响,而会把它设置为整个“目标字符串”(它会在内部调用reset方法)</p>
</li>
<li><p>boolean matches()</p>
<p> 此方法返回的Boolean值表示matcher的正则表达式能否完全匹配目标字符串中当前检索范围的那段文本.也就是说,如果匹配成功,匹配的文本必须从检索范围的开头开<br>始 ，到检索范围的结尾结束(默认情况就是整个目标字符串)</p>
</li>
<li><p>boolean lookingAt()</p>
<p> 此方法返回的Boolean值表示Matches的正则表达式能否在当前目标字符串的当前检索范围中找到匹配.它类似于matches方法,但不要求检索范围中的整段文本都能匹配.</p>
</li>
<li><p>String group()</p>
<p> 返回前一次应用正则表达式的的匹配文本</p>
</li>
<li><p>Stirng group(int num) </p>
<p> 返回编号为num的捕获型括号匹配的内容，如果对应的捕获型括号没有参与匹配，则返回 null。如果num为0，表示返回整个匹配的内容，group(O)就等于group()</p>
</li>
</ol>
<h3 id="几个例子"><a href="#几个例子" class="headerlink" title="几个例子"></a>几个例子</h3><h4 id="获取返回的数据"><a href="#获取返回的数据" class="headerlink" title="获取返回的数据"></a>获取返回的数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String myTest = <span class="string">&quot;http://localhost:8080/spring/swagger-ui.html&quot;</span>;</span><br><span class="line">        <span class="comment">//指定捕获组名称为port</span></span><br><span class="line">        String myRegex = <span class="string">&quot;http://(\\w+)(?&lt;port&gt;:\\d+)&quot;</span>;</span><br><span class="line">        Pattern pattern = Pattern.compile(myRegex);</span><br><span class="line">        </span><br><span class="line">        Matcher matcher = pattern.matcher(myTest);</span><br><span class="line">        <span class="keyword">int</span> groupCount = matcher.groupCount();</span><br><span class="line">        System.out.println(<span class="string">&quot;groupCount = &quot;</span> + groupCount);</span><br><span class="line">        <span class="keyword">if</span>(matcher.find()) &#123;</span><br><span class="line">            <span class="comment">//返回正则表达式的匹配文本</span></span><br><span class="line">            System.out.println(matcher.group(<span class="number">0</span>));</span><br><span class="line">            System.out.println(matcher.group(<span class="number">1</span>));</span><br><span class="line">            <span class="comment">//group(2)</span></span><br><span class="line">            System.out.println(matcher.group(<span class="string">&quot;port&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">groupCount = <span class="number">2</span></span><br><span class="line">http:<span class="comment">//localhost:8080</span></span><br><span class="line">localhost</span><br><span class="line">:<span class="number">8080</span></span><br></pre></td></tr></table></figure>

<h4 id="非捕获组获取数据"><a href="#非捕获组获取数据" class="headerlink" title="非捕获组获取数据"></a>非捕获组获取数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String myTest = <span class="string">&quot;http://localhost:8080/spring/swagger-ui.html&quot;</span>;</span><br><span class="line">        <span class="comment">//注意这里的?:</span></span><br><span class="line">        String myRegex = <span class="string">&quot;http://(\\w+)(?::\\d+)&quot;</span>;</span><br><span class="line">        Pattern pattern = Pattern.compile(myRegex);</span><br><span class="line">        </span><br><span class="line">        Matcher matcher = pattern.matcher(myTest);</span><br><span class="line">        <span class="keyword">int</span> groupCount = matcher.groupCount();</span><br><span class="line">        System.out.println(<span class="string">&quot;groupCount = &quot;</span> + groupCount);</span><br><span class="line">        <span class="keyword">if</span>(matcher.find()) &#123;</span><br><span class="line">            System.out.println(matcher.group(<span class="number">0</span>));</span><br><span class="line">            System.out.println(matcher.group(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出如下：</span><br><span class="line">groupCount = <span class="number">1</span></span><br><span class="line">http:<span class="comment">//localhost:8080</span></span><br><span class="line">localhost</span><br></pre></td></tr></table></figure>

<h4 id="分组引用的使用"><a href="#分组引用的使用" class="headerlink" title="分组引用的使用"></a>分组引用的使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello world,hello java&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的$1是对分组的引用,如果改成(?:hello),下面的代码会报错</span></span><br><span class="line">System.out.println(str.replaceAll(<span class="string">&quot;(hello)&quot;</span>, <span class="string">&quot;$1 my&quot;</span>));</span><br><span class="line"></span><br><span class="line">输出: hello my world,hello my java</span><br></pre></td></tr></table></figure>

<h4 id="数据重置"><a href="#数据重置" class="headerlink" title="数据重置"></a>数据重置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String myTest = <span class="string">&quot;hello java&quot;</span>;</span><br><span class="line">        String myRegex = <span class="string">&quot;\\w+&quot;</span>;</span><br><span class="line">        Pattern pattern = Pattern.compile(myRegex);</span><br><span class="line">        </span><br><span class="line">        Matcher matcher = pattern.matcher(myTest);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//两行数据</span></span><br><span class="line">        matcher.reset(<span class="string">&quot;hello 1998\r\n hello 2018&quot;</span>);</span><br><span class="line">        matcher.usePattern(Pattern.compile(<span class="string">&quot;\\d+&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(matcher.find()) &#123;</span><br><span class="line">            System.out.println(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出如下:</span><br><span class="line"><span class="number">1998</span></span><br><span class="line"><span class="number">2018</span></span><br></pre></td></tr></table></figure>

<h4 id="匹配非中文数据"><a href="#匹配非中文数据" class="headerlink" title="匹配非中文数据"></a>匹配非中文数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String myTest = <span class="string">&quot;我是中国人 I&#x27;m chinese&quot;</span>;</span><br><span class="line">        <span class="comment">//去掉^匹配到的将是中文</span></span><br><span class="line">        String myRegex = <span class="string">&quot;[^\\u4e00-\\u9fa5]+&quot;</span>;</span><br><span class="line">        Pattern pattern = Pattern.compile(myRegex);</span><br><span class="line">        Matcher matcher = pattern.matcher(myTest);</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出如下:</span><br><span class="line">    I<span class="string">&#x27;m chinese</span></span><br></pre></td></tr></table></figure>

<h4 id="去除连字符"><a href="#去除连字符" class="headerlink" title="去除连字符"></a>去除连字符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String myTest = <span class="string">&quot;我要要学学学Jaaaaaava&quot;</span>;</span><br><span class="line">String myRegex = <span class="string">&quot;(.)\\1+&quot;</span>;</span><br><span class="line">System.out.println(myTest.replaceAll(myRegex, <span class="string">&quot;$1&quot;</span>));</span><br><span class="line"></span><br><span class="line">输出如下:</span><br><span class="line">    我要学Java</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>我在项目中这样使用状态机</title>
    <url>/2023/11/16/cola-state-machine-in-project/</url>
    <content><![CDATA[<p>最近一个新的项目中的一个业务,状态的流转比较复杂，涉及到二十几个状态的流转,而且吸取了其他业务教训,我们决定使用状态机来解决状态流转的问题。</p>
<p>要使用状态机除了自己写状态模式下还研究了当下两个开源项目，一个是spring的state machine,一个是cola-state-machine。</p>
<p>spring的状态机可以做状态持久化,和spring结合比较好，但是太重了。 cola就比较简单,它只是简单做了一个抽象,我们只需要实现具体的行为就行了。 使用cola最重要的就是要记得”因为某个事件，导致了状态A向状态B进行了迁移”,当然这里的状态可以是同一个。</p>
<p>因为项目中使用的是springboot,所以我这里结合起来做了一定的改造,下面给出我在项目中使用的例子,仅供大家参考</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cola<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cola-component-statemachine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>因为某个事件，导致了状态A向状态B进行了迁移。所以需要定义状态,事件,流程。</p>
<p><img data-src="/images/state-machine/state-process.png" alt="状态迁移"></p>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>根据我们的流程我定义了以下事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> StatusChangeEventEnum &#123;</span><br><span class="line">    <span class="comment">// save as draft</span></span><br><span class="line">    SAVE_AS_DRAFT_EVENT,</span><br><span class="line">    <span class="comment">// draft submit</span></span><br><span class="line">    DRAFT_SUBMIT_EVENT,</span><br><span class="line">    <span class="comment">// submit</span></span><br><span class="line">    SUBMIT_EVENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> StatusEnum &#123;</span><br><span class="line"></span><br><span class="line">    NONE(<span class="number">0</span>, <span class="string">&quot;None&quot;</span>),</span><br><span class="line">    DRAFT(<span class="number">1</span>, <span class="string">&quot;Draft&quot;</span>),</span><br><span class="line">    SUBMITTED(<span class="number">2</span>, <span class="string">&quot;Submitted&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>定义状态迁移和事件的关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> StatusChangeEnum implements StatusChange &#123;</span><br><span class="line"></span><br><span class="line">    SAVE_AS_DRAFT(NONE, DRAFT, SAVE_AS_DRAFT_EVENT),</span><br><span class="line">    SUBMIT(NONE, SUBMITTED, SUBMIT_EVENT),</span><br><span class="line">    DRAFT_SUBMIT(DRAFT, SUBMITTED, DRAFT_SUBMIT_EVENT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StatusEnum fromStatus;</span><br><span class="line">    <span class="keyword">private</span> StatusEnum toStatus;</span><br><span class="line">    <span class="keyword">private</span> StatusChangeEventEnum event;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StatusEnum <span class="title">from</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fromStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StatusEnum <span class="title">to</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StatusChangeEventEnum <span class="title">event</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象状态变更的接口，因为可能会存在多个不同的状态变更流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatusChange</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">StatusEnum <span class="title">from</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">StatusEnum <span class="title">to</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">StatusChangeEventEnum <span class="title">event</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用Spring管理状态机"><a href="#使用Spring管理状态机" class="headerlink" title="使用Spring管理状态机"></a>使用Spring管理状态机</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachineConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;StateMachineHandler&gt; handlerList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NEW_REQUEST_STATE_MACHINE = <span class="string">&quot;newRequestStateMachine&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(NEW_REQUEST_STATE_MACHINE)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;C&gt; <span class="function">StateMachine&lt;StatusEnum, StatusChangeEventEnum, C&gt; <span class="title">newRequestStateMachine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        StateMachineBuilder&lt;StatusEnum, StatusChangeEventEnum, C&gt; builder = StateMachineBuilderFactory.create();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (StatusChangeEnum changeEnum :StatusChangeEnum.values()) &#123;</span><br><span class="line">            build(builder, changeEnum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.build(NEW_REQUEST_STATE_MACHINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;C&gt; <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(StateMachineBuilder&lt;StatusEnum, StatusChangeEventEnum, C&gt; builder, StatusChange statusChange)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找到对应的handler来处理</span></span><br><span class="line">        StateMachineHandler&lt;StatusEnum, StatusChangeEventEnum, C&gt; handler = getHandler(statusChange);</span><br><span class="line"></span><br><span class="line">        StatusEnum fromStatus = statusChange.from();</span><br><span class="line">        StatusEnum toStatus = statusChange.to();</span><br><span class="line">        StatusChangeEventEnum changeEvent = statusChange.event();</span><br><span class="line">        <span class="comment">// 只产生了事件,但是状态未发生变化</span></span><br><span class="line">        <span class="keyword">if</span> (fromStatus == toStatus) &#123;</span><br><span class="line">            builder.internalTransition()</span><br><span class="line">                    .within(fromStatus)</span><br><span class="line">                    .on(changeEvent)</span><br><span class="line">                    .when(handler::isSatisfied)</span><br><span class="line">                    .perform((from, to, event, ctx) -&gt; handler.execute(from, to, event, ctx));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            builder.externalTransition()</span><br><span class="line">                    .from(fromStatus)</span><br><span class="line">                    .to(toStatus)</span><br><span class="line">                    .on(changeEvent)</span><br><span class="line">                    .when(handler::isSatisfied)</span><br><span class="line">                    .perform((from, to, event, ctx) -&gt; handler.execute(from, to, event, ctx));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接在handler中抛出更详细异常</span></span><br><span class="line">        <span class="comment">//builder.setFailCallback(new AlertFailCallback&lt;&gt;());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;C&gt; <span class="function">StateMachineHandler&lt;StatusEnum, StatusChangeEventEnum, C&gt; <span class="title">getHandler</span><span class="params">(StatusChange statusChange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handlerList.stream().filter(handler -&gt; handler.canHandle(statusChange))</span><br><span class="line">                .findFirst()</span><br><span class="line">                .orElse(<span class="keyword">new</span> DefaultStateMachineHandler&lt;C&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经过上面的定义后,后续有新的状态变更流程,我们只需要在 <code>StatusChangeEnum</code> 中添加就行了。</p>
<h3 id="实现对应的handler"><a href="#实现对应的handler" class="headerlink" title="实现对应的handler"></a>实现对应的handler</h3><p>这里我举一个例子,比如说首次提交数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoneToSubmittedStatusHandler</span>  <span class="keyword">implements</span> </span></span><br><span class="line"><span class="class">                        <span class="title">StateMachineHandler</span>&lt;<span class="title">StatusEnum</span>, <span class="title">StatusChangeEventEnum</span>, <span class="title">SubmitDTO</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canHandle</span><span class="params">(StatusChange statusChange)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// handler能处理的变更流程</span></span><br><span class="line">        StatusChangeEnum changeEnum = StatusChangeEnum.SUBMIT;</span><br><span class="line">        <span class="keyword">return</span> statusChange == changeEnum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(StatusEnum from, StatusEnum to, StatusChangeEventEnum event, SubmitDTO context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行具体的业务逻辑,比如插入数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfied</span><span class="params">(SubmitDTO context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否满足条件,比如是否是对应的用户等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样子我们的每一个handler的功能就比较专一了,只需要处理对应状态的就行了，你可能回想要是有些状态的变成要做的事情类似,这样的代码不可能写两遍吧? 其实我们可以有一个抽象类可以将这些公用的逻辑放到抽象类里面,这样子有相同逻辑的就可以使用了。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>万事具备,现在只差在项目中使用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> StateMachine&lt;StatusEnum, StatusChangeEventEnum, StatusChangeContext&gt; newRequestStateMachine;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">statusChange</span><span class="params">(StatusChange changeEnum, StatusChangeContext context)</span> </span>&#123;</span><br><span class="line">        newRequestStateMachine.fireEvent(changeEnum.from(), changeEnum.event(), context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatusChangeContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubmitDTO</span> <span class="keyword">extends</span> <span class="title">StatusChangeContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long String;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只要涉及到状态变更的,就都可以调用StateMachie了。 </p>
<h3 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h3><p>这种方式其实会导致类的数量变多，但是职责更加清晰,每个类的代码行数也并不多，而且以后想要找某个状态变更到某个状态做了什么时候很很好找。</p>
<p>这就是最近使用状态机的一些心得，希望能对你有所帮助。</p>
]]></content>
      <tags>
        <tag>cola</tag>
        <tag>statemachine</tag>
        <tag>状态机</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发容器那么多,应该怎么选？</title>
    <url>/2021/01/11/concurrent-container-introduce/</url>
    <content><![CDATA[<p>我们先来看看有哪些并发容器</p>
<p><img data-src="/images/java/concurrent-container.png" alt="并发容器"></p>
<p>这么多容器，我们该怎么选? 虽然不能全要，但是我们可以都了解一下，然后挑选适合自己的。</p>
<a id="more"></a>

<h3 id="并发下的Map"><a href="#并发下的Map" class="headerlink" title="并发下的Map"></a>并发下的Map</h3><p>我们都知道不能再并发场景下使用HashMap，因为在JDK7之前，在并发场景下使用 HashMap 会出现死循环，从而导致 CPU 使用率居高不下，而扩容是导致死循环的主要原因。虽然 Java 在 JDK8 中修复了 HashMap 扩容导致的死循环问题，但在高并发场景下，依然会有数据丢失以及不准确的情况出现。</p>
<p>HashMap扩容出现死循环的分析可以查看我之前的<a href="https://juejin.cn/post/6844903908465180685">文章</a></p>
<p>为了保证线程安全，安全的Map对象 <code>Hashtable</code>、<code>ConcurrentHashMap</code> 以及<code>ConcurrentSkipListMap</code> 三个容器</p>
<p>Hashtable和ConcurrentHashMap都是基于HashMap实现的，对小数据量的存取比较有优势，ConcurrentSkipListMap是基于跳表实现的,其特点是存取平均时间复杂度是 O(log(n))，适用于大数据量存取的场景。</p>
<h4 id="Hashtable-VS-ConcurrentHashMap"><a href="#Hashtable-VS-ConcurrentHashMap" class="headerlink" title="Hashtable VS ConcurrentHashMap"></a>Hashtable VS ConcurrentHashMap</h4><p>Hashtable在它所有的获取或者修改数据的方法上都添加了Synchronized，因此在高并发场景下，读写操作都会存在大量锁竞争，给系统带来性能开销。</p>
<p>ConcurrentHashMap 在保证线程安全的基础上兼具了更好的并发性能。在 JDK7 中，ConcurrentHashMap 就使用了分段锁 Segment 减小了锁粒度，最终优化了锁的并发操作。<br>到了 JDK8，ConcurrentHashMap 做了大量的改动，摒弃了 Segment 的概念。由于Synchronized 锁在 Java6 之后的性能已经得到了很大的提升，所以在 JDK1.8 中，Java<br>重新启用了 Synchronized 同步锁，通过 Synchronized 实现 HashEntry 作为锁粒度。这种改动将数据结构变得更加简单了，操作也更加清晰流畅。<br>与 JDK7 的 put 方法一样，JDK8 在添加元素时，在没有哈希冲突的情况下，会使用CAS 进行添加元素操作；如果有冲突，则通过 Synchronized 将链表锁定，再执行接下来的操作。</p>
<p><img data-src="/images/java/conc-map.png" alt="ConcurrentHashMap"></p>
<p>虽然 ConcurrentHashMap 的整体性能要优于 Hashtable，但在某些场景中，ConcurrentHashMap 依然不能代替 Hashtable。<br>例如，在强一致的场景中ConcurrentHashMap 就不适用，原因是 ConcurrentHashMap 中的 get、size 等方法没有用到锁，因此返回的数据就不准确,ConcurrentHashMap 是弱一致性的，因此有可能会导致某次读无法马上获取到写入的数据</p>
<h4 id="ConcurrentHashMap-VS-ConcurrentSkipListMap"><a href="#ConcurrentHashMap-VS-ConcurrentSkipListMap" class="headerlink" title="ConcurrentHashMap VS ConcurrentSkipListMap"></a>ConcurrentHashMap VS ConcurrentSkipListMap</h4><p>我们都知道 ConcurrentHashMap 数据量比较大的时候，链表会转换为红黑树。红黑树在并发情况下，删除和插入过程中有个平衡的过程，会牵涉到大量节点，因此竞争锁资源的代价相对比较高。</p>
<p>而ConcurrentSkipListMap由于是基于跳表实现的，它需要锁住的节点要少一些，在高并发场景下性能也要好一些。</p>
<p><img data-src="/images/java/SkipedList.png" alt="跳表"></p>
<p>跳跃表是基于链表扩展实现的一种特殊链表，类似于树的实现，跳跃表不仅实现了横向链表，还实现了垂直方向的分层索引。<br>一个跳跃表由若干层链表组成，每一层都实现了一个有序链表索引，只有最底层包含了所有数据，每一层由下往上依次通过一个指针指向上层相同值的元素，每层数据依次减少，等到<br>了最顶层就只会保留部分数据了。</p>
<p>跳跃表的这种结构，是利用了空间换时间的方法来提高了查询效率。程序总是从最顶层开始查询访问，通过判断元素值来缩小查询范围。</p>
<p>java的实现中，往跳表中插入数据的时候,会根据概率随机算出level值，然后重建索引层，这里的代码还是比较有趣的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 产生一个随机数</span></span><br><span class="line"><span class="keyword">int</span> rnd = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x80000001二进制为是‭10000000000000000000000000000001‬</span></span><br><span class="line"><span class="comment">// 只有随机数是正偶数才能决定是否要新增层级</span></span><br><span class="line"><span class="keyword">if</span> ((rnd &amp; <span class="number">0x80000001</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">1</span>, max;</span><br><span class="line">  <span class="comment">// 从随机数第二位开始,有几个连续的1，level值就加几</span></span><br><span class="line">  <span class="keyword">while</span> (((rnd &gt;&gt;&gt;= <span class="number">1</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">      ++level;</span><br><span class="line"></span><br><span class="line">  Index&lt;K,V&gt; idx = <span class="keyword">null</span>;</span><br><span class="line">  HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">  <span class="comment">// 层数小于等于当前跳表的最大层</span></span><br><span class="line">  <span class="keyword">if</span> (level &lt;= (max = h.level)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从第一层开始建立down的索引链表</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">          idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// 超出了现有跳表的层数，则只加一层，多了没有意义</span></span><br><span class="line">    level = max + <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略重建索引层代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当新增一个 key 值为 7 的节点时，首先新增一个节点到最底层的链表中，根据概率算出level 值，再根据 level 值新建索引层，最后链接索引层的新节点。新增节点和链接索引都是基于 CAS 操作实现</p>
<p><img data-src="/images/java/SkipedList-insertNode.png" alt="插入数据"></p>
<p>当删除某个key 时，首先找到待删除结点，将其 value 值通过cas设置为 null；之后再向待删除结点的 next 位置新增一个marker(标记)结点，以便减少并发冲突；然后让待删结点的前<br>驱节点直接越过本身指向的待删结点，直接指向后继结点，中间要被删除的结点最终将会被JVM 垃圾回收处理掉；最后判断此次删除后是否导致某一索引层没有其它节点了，如果这一层都没有节点了则跳表层数降级。</p>
<p>经过上面的分析，我们可以知道当我们不需要知道集合中准确数据的时候使用ConcurrentHashMap，当我们需要知道集合中准确数据个数时，则需要用到HashTable。如果数据量特别大，且存在大量增删改查操作，则可以考虑使用ConcurrentSkipListMap。</p>
<p>同时需要注意的是这三个线程安全的容器类key,value都不允许为null,而我们常使用的HashMap的key是可以为null,value不能为null的。</p>
<h3 id="并发下的List"><a href="#并发下的List" class="headerlink" title="并发下的List"></a>并发下的List</h3><p>我们都知道Vector也是在它所有暴露出来的public方法中都加上了synchronized 关键字来保证线程安全，所以在读远大于写的操作场景中，Vector 将会发生大量锁竞争，<br>从而给系统带来性能开销。</p>
<p>而CopyOnWriteList实现了读操作无锁，写操作则通过操作底层数组的新副本来实现，是一种读写分离的并发策略，我们来看下源码是如何实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到读操作平平无奇，就是从数组中读取元素。</p>
<p>再看看写操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  <span class="comment">// 独占锁加锁</span></span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取存储数据原始数组</span></span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的数据</span></span><br><span class="line">    <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">      <span class="keyword">int</span> len = elements.length;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将旧数据复制到一个新的数组</span></span><br><span class="line">      Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将数据插入到新的数组中，并将新的数组设置为存储数据的数组</span></span><br><span class="line">      newElements[index] = element;</span><br><span class="line">      setArray(newElements);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 重新设置数据，保证volatile写语义</span></span><br><span class="line">      setArray(elements);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从源码中我们知道了 CopyOnWriteList 就是当需要写入数据的时候，复制一个新的数组，将数据写入到新的数组中，再将新的数组赋值给旧数组。</p>
<p>所以 CopyOnWriteList 更适用于读远大于写的操作，同时业务场景对写入数据的实时获取并没有要求,只需要保证最终能获取到写入数组中的数据就可以了。</p>
<h3 id="并发下的Set"><a href="#并发下的Set" class="headerlink" title="并发下的Set"></a>并发下的Set</h3><p>CopyOnWriteArraySet是使用CopyOnWriteArrayList实现的，而 ConcurrentSkipListSet 又是使用 ConcurrentSkipListMap实现的，而这两者区别可以分别参考它们的实现。这里就不重复说明了。</p>
<h3 id="并发下的Queue"><a href="#并发下的Queue" class="headerlink" title="并发下的Queue"></a>并发下的Queue</h3><p>Java并发包中Queue这类并发容器时最复杂的，并不是说实现多复杂，而是它的类比较多，记起来复杂。不过它仍然可以从两个维度来分类。</p>
<p>一个维度是阻塞与非阻塞，所谓阻塞指的是当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞。</p>
<p>另一个维度是单端与双端，单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队。</p>
<p>Java 并发包里阻塞队列都用 Blocking 关键字标识，单端队列使用 Queue 标识，双端队列使用 Deque 标识。</p>
<p>两个维度可以双双组合，将 Queue 细分为4大类。</p>
<p><img data-src="/images/java/4-type-queue.png" alt="4大类队列"></p>
<h4 id="单端阻塞队列"><a href="#单端阻塞队列" class="headerlink" title="单端阻塞队列"></a>单端阻塞队列</h4><p>单端阻塞队列内部一般会持有一个队列，这个队列可能是数组(ArrayBlockingQueue)也可以是链表(LinkedBlockingQueue)。 甚至还可以不持有队列（其实现是 SynchronousQueue），此时生产者线程的入队操作必须等待消费者线程的出队操作。</p>
<p><strong>需要注意的是需要调用put/take方法队列才会阻塞，add,offer方法是不会阻塞的。</strong></p>
<p>ArrayBlockingQueue首先使用的是数组来实现队列，然后阻塞功能则是借助 ReentrantLock 和 Condition 来实现的。</p>
<p>LinkedBlockingQueue 则是借助的链表来实现队列, 阻塞功能也是借助 ReentrantLock 和 Condition 来实现的,和ArrayBlockingQueue还有一个不同之处在于 LinkedBlockingQueue 中put和take分别使用了不同的 ReentrantLock, 这样做的原因是 put的时候会将元素添加到队列尾，take的时候则是从队列头移除。</p>
<p>SynchronousQueue 也作为阻塞队列在线程池中出现过，它用于在两个线程之间直接移交元素，一个线程生产了数据，另一个线程才能消费数据。虽然它内部没有缓冲，但是如果同一个模式(生产或者消费)的线程过多，它们都会被存储起来，然后被阻塞，所以它更适合生产和消费速率相当的情况下使用。</p>
<p>PriorityBlockingQueue 支持按照优先级出队,其底层实现就是 PriorityQueue + ReentrantLock ,关于PriorityQueue可以参考我的这篇 <a href="https://juejin.cn/post/6844904031240847373">优先级队列源码解析</a></p>
<p>DelayQueue 是一个支持延时获取元素的阻塞队列，其使用 PriorityQueue(存储元素) + ReentrantLock 实现，<strong>同时元素必须实现 Delayed 接口</strong>；在创建元素时可以指定多久才可以从队列中获取当前元素，只有在延迟期满时才能从队列中提取元素。我们可以使用它实现定时调度和缓存系统。</p>
<p>LinkedTransferQueue 融合 LinkedBlockingQueue 和 SynchronousQueue 的功能，性能比 LinkedBlockingQueue 更好,它底层数据结构采用的是双队列(dual queue)，消费者线程取元素时，如果队列为空，那就生成一个节点(节点元素为null)入队，然后消费者线程park住，后面生产者线程入队时发现有一个元素为null的节点，生产者线程就不入队了，直接就将元素填充到该节点，唤醒该节点上park住线程，被唤醒的消费者线程就能获取到该节点上的数据了。如果是生产者插入元素时，如果队列为空，就生成一个数据节点入队，然后立即返回，并不会阻塞。</p>
<p><img data-src="/images/java/LinkedTransferQueue.png" alt="LinkedTransferQueue"></p>
<h4 id="双端阻塞队列"><a href="#双端阻塞队列" class="headerlink" title="双端阻塞队列"></a>双端阻塞队列</h4><p>双端阻塞队列的实现是 LinkedBlockingDeque, 它和LinkedBlockingQueue的实现类似，只是一个这个是双端。</p>
<h4 id="单端非阻塞队列"><a href="#单端非阻塞队列" class="headerlink" title="单端非阻塞队列"></a>单端非阻塞队列</h4><p>实现是 ConcurrentLinkedQueue, 从队尾插入数据，从队头取出数据。 均是通过CAS来更新head, tail的指向，所以不会阻塞线程，但是如果并发太激烈会导致CPU空转。</p>
<h4 id="双端非阻塞队列"><a href="#双端非阻塞队列" class="headerlink" title="双端非阻塞队列"></a>双端非阻塞队列</h4><p>实现是 ConcurrentLinkedDeque。和 ConcurrentLinkedQueue 实现类似，只是它是双端队列。</p>
<p>通过上面的分析还可以知道，阻塞就用到了锁，会阻塞线程。 非阻塞使用的是CAS的方式，不会阻塞线程，但是在并发很大的情况下，会使得CPU使用率过高。</p>
<p>使用队列时，需要格外注意队列是否支持有界(所谓有界指的是内部的队列是否有容量限制)。实际工作中，一般都不建议使用无界的队列，因为数据量大了之后很容易导致<br>OOM。上面我提到的这些 Queue 中，只有 ArrayBlockingQueue 和LinkedBlockingQueue 是支持有界的，所以在使用其他无界队列时，一定要充分考虑是否存在导致 OOM 的隐患。</p>
<h3 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h3><p>分析了这些容器的特点以及实现，我相信大家一定有自己的选择了。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>好家伙，这些问题还不是手拿把掐</title>
    <url>/2024/02/18/current-issues-in-my-system/</url>
    <content><![CDATA[<p>总结了下这段时间遇到的问题。</p>
<h3 id="快速生成字典表数据"><a href="#快速生成字典表数据" class="headerlink" title="快速生成字典表数据"></a>快速生成字典表数据</h3><p>在前期开发的时候，BA总是给我好几张excel,让我生成字典表,写代码又耗时，而且不同的excel字段也不一样，不可能每次都要去改代码吧，总之我不干，好在我能借助excel函数完成这样的需求。</p>
<p><img data-src="/images/excel.gif" alt="函数"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;CONCATENATE(&quot;insert into test_claims(&#96;id&#96;,&#96;code&#96;,&#96;name&#96;) values(&#39;&quot;, A1, &quot;&#39;,&#39;&quot;,B1, &quot;&#39;,&#39;&quot;,C1,&quot;&#39;);&quot;)</span><br><span class="line"></span><br><span class="line">这个函数的语法是 CONCATENATE(text1, [text2], ...)</span><br><span class="line">1. text1（必需）：要联接的第一个项目。项目可以是文本值、数字或单元格引用；</span><br><span class="line"></span><br><span class="line">2. Text2, ... （可选）：要联接的其他文本项目。最多可以有 255 个项目，总共最多支持 8,192 个字符</span><br></pre></td></tr></table></figure>

<h3 id="Kubernetes-Pod频繁重启"><a href="#Kubernetes-Pod频繁重启" class="headerlink" title="Kubernetes Pod频繁重启"></a>Kubernetes Pod频繁重启</h3><p>后台看到部署到kubernetes的pod一直在重启，但是看日志没有报错，但是一会儿它就自动重启了，最后通过describe命令看到是因为liveness接口的原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubelet  Liveness probe failed: Get &quot;http:&#x2F;&#x2F;10.24.8.84:9202&#x2F;actuator&#x2F;health&quot;</span><br></pre></td></tr></table></figure>

<p>因为使用了springboot actuator接口,它会检测服务中使用到的其他服务是否能正常使用,从而判定当前服务是否存活，所以必然是因为这个接口返回的信息导致pod重启。</p>
<p>重启的这个服务主要用到了邮件以及Redis,但是不知道到底是哪个服务健康检查失败了。此时我们也无法进入到pod中访问health接口了。</p>
<p>所以我们先移除掉pod template的livenessProbe配置，然后重新部署服务</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/actuator/health</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">9204</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">60</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">timeoutSeconds:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>这个时候使用exec命令进入pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">kubectl <span class="built_in">exec</span> -it &lt;pod name&gt; -n &lt;namespace&gt; -- /bin/bash</span><br></pre></td></tr></table></figure>

<p>访问  <code>curl -i http://localhost:9202/actuator/health</code>  可以看到response status code是503,并且还可以看到具体失败的组件是哪一个。 </p>
<p>最终确定是redis访问超时了，于是调整了下 livenessProbe的timeoutSeconds,然后在重启就不报错了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@noti-844567c558-2mvj8:&#x2F;home&#x2F;pro# curl -i http:&#x2F;&#x2F;localhost:9202&#x2F;actuator&#x2F;health</span><br><span class="line">HTTP&#x2F;1.1 200 </span><br><span class="line">X-XSS-Protection: 1; mode&#x3D;block</span><br><span class="line">Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;self&#39;; frame-ancestors &#39;self&#39;; object-src &#39;none&#39;</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br><span class="line">Content-Type: application&#x2F;vnd.spring-boot.actuator.v3+json;charset&#x3D;utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Sun, 18 Feb 2024 07:36:22 GMT</span><br><span class="line"></span><br><span class="line">&#123;&quot;status&quot;:&quot;UP&quot;,&quot;components&quot;:&#123;&quot;discoveryComposite&quot;:&#123;&quot;description&quot;:&quot;Discovery Client not initialized&quot;,&quot;status&quot;:&quot;UNKNOWN&quot;,&quot;components&quot;:&#123;&quot;discoveryClient&quot;:&#123;&quot;description&quot;:&quot;Discovery Client not initialized&quot;,&quot;status&quot;:&quot;UNKNOWN&quot;&#125;&#125;&#125;,&quot;diskSpace&quot;:&#123;&quot;status&quot;:&quot;UP&quot;,&quot;details&quot;:&#123;&quot;total&quot;:133003395072,&quot;free&quot;:94000709632,&quot;threshold&quot;:10485760,&quot;exists&quot;:true&#125;&#125;,&quot;livenessState&quot;:&#123;&quot;status&quot;:&quot;UP&quot;&#125;,&quot;mail&quot;:&#123;&quot;status&quot;:&quot;UP&quot;,&quot;details&quot;:&#123;&quot;location&quot;:&quot;xxmail:465&quot;&#125;&#125;,&quot;ping&quot;:&#123;&quot;status&quot;:&quot;UP&quot;&#125;,&quot;readinessState&quot;:&#123;&quot;status&quot;:&quot;UP&quot;&#125;,&quot;redis&quot;:&#123;&quot;status&quot;:&quot;UP&quot;,&quot;details&quot;:&#123;&quot;version&quot;:&quot;6.0.14&quot;&#125;&#125;,&quot;refreshScope&quot;:&#123;&quot;status&quot;:&quot;UP&quot;&#125;&#125;,&quot;groups&quot;:[&quot;liveness&quot;,&quot;readiness&quot;]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="minio数据迁移到Azure-blob"><a href="#minio数据迁移到Azure-blob" class="headerlink" title="minio数据迁移到Azure blob"></a>minio数据迁移到Azure blob</h3><p>项目中需要将minio中保存的文件迁移到azure的blob中,然后minio中保存文件的路径是这样的 <code>2023/11/07/20231107164256A579/Image3.jpg</code>  相当于文件夹中包含了时间戳等信息，虽然blob不支持目录，但是它的虚拟目录可以有相同的效果，这里我们使用azure提供的azcopy命令来进行数据迁移。</p>
<p>首先进入到minio所在的服务器,然后执行下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1.  sudo mkdir &#x2F;home&#x2F;azcopy </span><br><span class="line"></span><br><span class="line">2. cd &#x2F;home&#x2F;azcopy</span><br><span class="line"> </span><br><span class="line">3. sudo  wget -O azcopy_v10.tar.gz https:&#x2F;&#x2F;aka.ms&#x2F;downloadazcopy-v10-linux &amp;&amp;</span><br><span class="line"></span><br><span class="line">4. sudo tar -xf azcopy_v10.tar.gz --strip-components&#x3D;1</span><br><span class="line"></span><br><span class="line">5. sudo azcopy login  &#x2F;&#x2F; 登录azure</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6. 同步minio数据到blob,将sc-dev bucket的数据迁移到blob的container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里的sc-dev是minio的bucket, saoscdev是azure blob的account name, bvsc是container name</span><br><span class="line">    a. sudo &#x2F;home&#x2F;azcopy&#x2F;azcopy copy &#39;&#x2F;data&#x2F;minio&#x2F;data&#x2F;sc-dev&#x2F;*&#39; &#39;https:&#x2F;&#x2F;saoscdev.blob.core.windows.net&#x2F;bvsc&#39; --recursive</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将增量数据同步到blob中</span><br><span class="line">    b. sudo &#x2F;home&#x2F;azcopy&#x2F;azcopy sync &#39;&#x2F;data&#x2F;minio&#x2F;data&#x2F;sc-dev&#39; &#39;https:&#x2F;&#x2F;saoscdev.blob.core.windows.net&#x2F;bvsc&#39; --recursive</span><br></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是我最近遇到的问题，第一个字典表的那个当时第一反应是写代码，但是后来想到写代码的时候太长，成本太高还是需要借助工具，恰好提供给我的又是excel,于是就用excel顺带完成了这个功能，同时后面的其他字典数据如法炮制，也就变简单了。</p>
<p>第二个问题本来是定位重启的问题，但是看着看着就深入到了actuator的源码当中起了，这一点很不好，不过有失必有得，有顺带看了下actuator的源码,它其中的EntryPoint感觉很棒，后面针对这个写一篇。</p>
<p>第三个问题的话就是微软没有提供如何迁移的文档，不过好在它本生工具不少，多尝试也就成功了，这里我把迁移的步骤给出来，希望能帮助到同样有需求的人。</p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>Minio</tag>
        <tag>Azure</tag>
      </tags>
  </entry>
  <entry>
    <title>在MacOS系统上编译OpenJDK12并使用CLion调试</title>
    <url>/2020/07/22/debug-jvm-12-in-macox/</url>
    <content><![CDATA[<p>最近在看synchronized 锁优化方面的内容,有些地方看起来不是很方便,干脆就编译个源码来看看。</p>
<h3 id="在windows上编译"><a href="#在windows上编译" class="headerlink" title="在windows上编译"></a>在windows上编译</h3><p>由于自己常用的电脑操作系统是win10,所以最开始是想要在win10上编译的,但是一来网上文章太少,二来在windows上编译确实麻烦太多了(windows可以参考深入理解JVM虚拟机这本书),故放弃了。</p>
<a id="more"></a>

<h3 id="MAC环境"><a href="#MAC环境" class="headerlink" title="MAC环境"></a>MAC环境</h3><p><img data-src="/images/macos-jvm/macos.png" alt="mac信息"></p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><h4 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h4><p>OpenJDK源码使用Mercurial管理,如果通过版本库下载,则需要安装Mercurial,我们借助homebrew包管理器来安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install mercurial</span><br></pre></td></tr></table></figure>

<p>如果你的电脑没有安装homebrew,那么可以使用下面的命令来安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure>

<p>安装完成后使用以下命令clone源代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;jvm</span><br><span class="line">hg clone https:&#x2F;&#x2F;hg.openjdk.java.net&#x2F;jdk&#x2F;jdk12</span><br></pre></td></tr></table></figure>

<blockquote>
<p>命令运行之后,openjdk的源码并没有下载下来</p>
</blockquote>
<p>由于我并没有使用hg的方式,关于这部分可以参考闪电侠的文章<a href="https://www.jianshu.com/p/ee7e9176632c">https://www.jianshu.com/p/ee7e9176632c</a></p>
<p><strong>当然我非常不建议你使用Mercurial的方式下载,这种方式不久要等很久,而且还需要科学上网才稳妥。我墙裂推荐你直接通过页面下载<a href="https://hg.openjdk.java.net/jdk/jdk12">OpenJdk12源码压缩包</a>)</strong></p>
<p><img data-src="/images/macos-jvm/openjdk12-source-code.png" alt="下载OpenJDK12源码"></p>
<p>比如我下载的是gz格式的文件(选择什么格式并不重要)。</p>
<blockquote>
<p>如果你使用的Chrome,那么可以开启多线程下载,速度会有一个很明显的提升。</p>
</blockquote>
<h4 id="Bootstrap-JDK"><a href="#Bootstrap-JDK" class="headerlink" title="Bootstrap JDK"></a>Bootstrap JDK</h4><p>因为OpenJDK的各个组成部分有的是使用C++编写的,有的是使用Java编写的,因此编译这些Java代码需要使用到一个可用的JDK,官方称这个JDK为“Bootstrap JDK”,一般来说只需要比编译的JDK第一个版本,这里采用OpenJDK11,可以通过这个网址 <a href="https://jdk.java.net/archive/">https://jdk.java.net/archive/</a> 下载<br>记住一定要下载一个适合Mac平台的OpenJDK11。</p>
<p>我使用的Bootstrap JDK版本如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openjdk version &quot;11.0.2&quot; 2019-01-15</span><br><span class="line">OpenJDK Runtime Environment 18.9 (build 11.0.2+9)</span><br><span class="line">OpenJDK 64-Bit Server VM 18.9 (build 11.0.2+9, mixed mode)</span><br></pre></td></tr></table></figure>

<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 用于生成shell脚本的工具,可以使软件包在不同的系统下都可以编译</span><br><span class="line">brew install autoconf</span><br><span class="line"></span><br><span class="line"># 字体引擎</span><br><span class="line">brew install freetype</span><br></pre></td></tr></table></figure>

<h4 id="XCode-和-Command-Line-Tools-for-Xcode"><a href="#XCode-和-Command-Line-Tools-for-Xcode" class="headerlink" title="XCode 和 Command Line Tools for Xcode"></a>XCode 和 Command Line Tools for Xcode</h4><p>这两个SDK提供了OpenJDK所需的编译器以及Makefile中用到的外部命令。一般电脑上都自带安装了。</p>
<p>网上很多编译出错都是因为XCode版本问题,导致报错,我也遇到了这个坑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configure: error: No xcodebuild tool and no system framework headers found, use --with-sysroot or --with-sdk-name to provide a path to a valid SDK</span><br><span class="line"></span><br><span class="line">&#x2F;Users&#x2F;...&#x2F;...&#x2F;xxx.sh: line 82: 5: Bad file descriptor</span><br><span class="line"></span><br><span class="line">configure exiting with result code 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终我通过官网下载<a href="https://developer.apple.com/download/more/">https://developer.apple.com/download/more/</a>安装了9.4.1版本的XCode才搞定了。</p>
<blockquote>
<p>下载xcode需要登录,如果没有账号可以申请一个</p>
</blockquote>
<p>我选择的是手动下载xcode安装的方式,你可以先只下载Command Line Tools (macOS 10.13) for Xcode 9.4.1 安装看能不能解决你的问题,如果不能再下载Xcode(这个很大,大概4个多G)</p>
<p><img data-src="/images/macos-jvm/download-xcode.png" alt="xcode下载"></p>
<h3 id="编译jdk"><a href="#编译jdk" class="headerlink" title="编译jdk"></a>编译jdk</h3><p>源码下载好之后,我解压放到了这个<code>/Users/naver/jvm/jdk12-06222165c35f</code>目录下,下面的命令均是在这个目录下执行的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash configure  --with-boot-jdk&#x3D;&#39;&#x2F;usr&#x2F;local&#x2F;jdk-11.0.2.jdk&#x2F;Contents&#x2F;Home&#39; --with-debug-level&#x3D;slowdebug --with-target-bits&#x3D;64 --disable-warnings-as-errors --enable-dtrace --with-jvm-variants&#x3D;server</span><br></pre></td></tr></table></figure>

<p><code>--with-boot-jdk</code>：指定Bootstrap JDK路径<br><code>--with-debug-level</code>：编译级别,可选值为release、fastdebug、slowdebug和optimized,默认值为release,如果我们要调试的话,需要设定为fastdebug或者slowdebug,建议设置为slowdebug<br><code>--with-target-bits</code>：指定编译32位还是64位的虚拟机<br><code>--disable-warnings-as-errors</code>：避免因为警告而导致编译过程中断<br><code>--enable-dtrace</code>：开启一个性能工具<br><code>--with-jvm-variants</code>：编译特定模式下的虚拟机,一般这里编译server模式<br><code>--with-conf-name</code>：指定编译配置的名称,如果没有指定,则会生成默认的配置名称macosx-x86_64-server-slowdebug,我这里采用默认生成配置</p>
<p>在很多场景下编译OpenJDK都会使用<code>--enable-ccache</code>参数,来通过ccache加快编译速度,但我没有采用,因为目前编译速度其实不慢,再有就是如果增加了这个参数,后续导入到CLion的时候,会出现很多红字提示,看着好像不影响使用,但总归看着不太舒服</p>
<h4 id="生成Compilation-Database"><a href="#生成Compilation-Database" class="headerlink" title="生成Compilation Database"></a>生成Compilation Database</h4><p>在配置CLion的时候,直接import编译好之后的jdk源码,你会发现头文件都是红色的,无法找到提示,是因为CLion生产的CMakeLists.txt有问题,如果想要解决这个问题就需要修改这个文件,很明显我不会修。</p>
<p>最后通过JetBrains说的利用Compilation Database (<a href="https://blog.jetbrains.com/clion/2020/03/openjdk-with-clion/">https://blog.jetbrains.com/clion/2020/03/openjdk-with-clion/</a>) 在CLion中构建OpenJDK解决了这个问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make CONF&#x3D;macosx-x86_64-server-slowdebug compile-commands</span><br></pre></td></tr></table></figure>

<p>执行完该命令,就会在${source_root}/build/macosx-x86_64-server-slowdebug下生成compile_commands.json文件。</p>
<p><img data-src="/images/macos-jvm/compile_commands_json.png" alt="compile_commands.json"></p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>在导入CLion之前,要编译一下,因为某些模块使用了预编译头,如果不编译,CLion会在索引过程中提示找不到各种各样的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make CONF&#x3D;macosx-x86_64-server-slowdebug</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><img data-src="/images/macos-jvm/open-jdk-version.png" alt="open-jdk-version"></p>
<p>至此,证明我们已经编译完成了JDK12</p>
<h3 id="CLion调试"><a href="#CLion调试" class="headerlink" title="CLion调试"></a>CLion调试</h3><h4 id="导入project"><a href="#导入project" class="headerlink" title="导入project"></a>导入project</h4><p>在导入project之前先配置好Toolchains(Preferences进入)</p>
<p><img data-src="/images/macos-jvm/toolchains.png" alt="toolchains"></p>
<p>配置好Toolchains后,通过<code>File -&gt; Open</code>功能,选中<code>$&#123;source_root&#125;/build/macosx-x86_64-server-slowdebug/compile_commands.json</code>,<code>As a project</code>打开,这样就导入了Compilation Database文件,接下来CLion开始进行索引。</p>
<p>这时候,你会发现你是看不到源码的,所以下面需要修改项目的根目录,通过<code>Tools -&gt; Compilation Database -&gt; Change Project Root</code>功能,选中你的源码目录,也就是<code>$&#123;source_root&#125;</code>,这样设置就可以在CLion中看到源代码啦。</p>
<blockquote>
<p>${source_root}指的是 /Users/naver/jvm/jdk12-06222165c35f</p>
</blockquote>
<h4 id="debug之前配置"><a href="#debug之前配置" class="headerlink" title="debug之前配置"></a>debug之前配置</h4><p>需要在<code>Preferences --&gt; Build, Exceution, Deployment --&gt; Custom Build Targets</code>配置构建目标</p>
<p><img data-src="/images/macos-jvm/build.png" alt="build"></p>
<p><img data-src="/images/macos-jvm/clean.png" alt="clean"></p>
<p>由于我这里已经配置好了,所以这里显示的是编辑页面,第一次配置要点击+,进行新增即可。</p>
<p><strong>通过这两个配置每次构建之前都会重新编译我们的jdk,修改jvm代码之后可以直接进行重新调试。</strong></p>
<h4 id="debug-配置"><a href="#debug-配置" class="headerlink" title="debug 配置"></a>debug 配置</h4><p><img data-src="/images/macos-jvm/debug_config.png" alt="debug配置"></p>
<p>Executable：选择<code>$&#123;source_root&#125;/build/macosx-x86_64-server-slowdebug/jdk/bin/java</code>,或者其它你想调试的文件,比如javac；<br>Before luanch：这个下面新增的时候有一个bug,去掉就不会每次执行都去Build,节省时间,但其实OpenJDK增量编译的方式,每次Build都很快,所以就看个人选择了。</p>
<h4 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h4><p>在<code>$&#123;source_root&#125;/src/java.base/share/native/libjli/java.c</code>的401行打断点,点击Debug,然后F9放掉,不出意外你会遇到下面这个问题</p>
<p><img data-src="/images/macos-jvm/debug-sigsegv.png" alt="sigsegv信息"></p>
<p>由于我们使用的LLDB进行debug的,所以在进入第一个断点的时候在LLDB下执行以下命令可以避免此类问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pro hand -p true -s false SIGSEGV SIGBUS</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/macos-jvm/lldb-pro-hand.png" alt="解决sigsegv问题"></p>
<p>最终就可以看到java -version的输出效果如下</p>
<p><img data-src="/images/macos-jvm/java-version.png" alt="java-version"></p>
<p>不过每次debug的时候都要输入这么一句就很麻烦,所以我们可以在**~/.lldbinit**文件中,使用如下命令,实现每次Debug时自动打个断点,然后输入<code>pro hand -p true -s false SIGSEGV SIGBUS</code>,最后继续执行后续流程,文件内容如下(其中main.c文件的路径自行替换)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint set --file &#x2F;Users&#x2F;naver&#x2F;jvm&#x2F;jdk12-06222165c35f&#x2F;src&#x2F;java.base&#x2F;share&#x2F;native&#x2F;launcher&#x2F;main.c --line 98 -C &quot;pro hand -p true -s false SIGSEGV SIGBUS&quot; --auto-continue true</span><br></pre></td></tr></table></figure>

<h4 id="与Java程序联合debug"><a href="#与Java程序联合debug" class="headerlink" title="与Java程序联合debug"></a>与Java程序联合debug</h4><p>上面演示的实际是java -version如何debug,那么如何做到通过自己编写的java代码作为程序入口来调试呢？</p>
<p>首先java代码如下(我用idea编写的):</p>
<p><img data-src="/images/macos-jvm/java-code.png" alt="java-code"></p>
<p>CLion中配置如下</p>
<p><img data-src="/images/macos-jvm/debug-java-code.png" alt="debug-java-code"></p>
<p>运行结果如下:</p>
<p><img data-src="/images/macos-jvm/debug-java-code-result.png" alt="result"></p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>&lt;&lt;深入理解Java虚拟机：JVM高级特性与最佳实践&gt;&gt;<br><a href="https://www.jianshu.com/p/ee7e9176632c">mac下编译openjdk1.9及集成clion动态调试</a><br><a href="https://www.howieli.cn/posts/macos-clion-build-debug-openjdk12.html">在MacOS系统上使用CLion编译并调试OpenJDK</a></p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>这次上线我花了12个小时</title>
    <url>/2023/05/11/deployment-spend-a-day/</url>
    <content><![CDATA[<h3 id="迁移思路"><a href="#迁移思路" class="headerlink" title="迁移思路"></a>迁移思路</h3><p>这次上线比较复杂,线上有两个服务,A和B, A服务部署在生产环境(姑且叫做Prod-1), B服务部署到QA环境,当时客户催得急,被当做生产使用了。现在要做的就是将A,B两个服务迁移到C这个正式的生产环境(称作Prod-2)。</p>
<p>服务主要依赖两个外部组件,一个是minio,一个是mysql数据库(部署到Azure云平台上), 经过讨论  Prod-2环境要使用的minio仍然沿用Prod-1使用的,mysql数据库则使用新的。</p>
<p>意味着我们需要将QA环境的minio数据迁移到Prod-2的minio(和Prod-1使用的同一个), 需要将QA环境的mysql数据和Prod-1环境的mysql数据迁移到Prod-2,但是由于QA和Prod-1是不同的两个服务,所用的表均不一样,所以sql没有冲突。</p>
<a id="more"></a>


<h3 id="minio迁移"><a href="#minio迁移" class="headerlink" title="minio迁移"></a>minio迁移</h3><p>minio数据是以文件方式存储到服务器上的,所以我们只需要将文件迁移过来,然后保证路径不变就行了(bucket name变动没有问题),因此最开始就调研到了两种方案,一种是使用scp进行文件迁移,一种是使用rclone,但是QA环境minio和prod-1环境所在minio网络不能直接通,让运维给开通,他说有问题(这里我当时没多想下,多想下就不得有这样问题了),所以就只能采用scp方式。 先将QA minio数据拷贝到跳板机,然后从跳板机拷贝到生产环境。 </p>
<h4 id="SCP-amp-CP"><a href="#SCP-amp-CP" class="headerlink" title="SCP &amp; CP"></a>SCP &amp; CP</h4><p>使用的SCP命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1。 将文件从远程复制到本地</span><br><span class="line">// 将qa环境中的minio数据复制到当前目录(在跳板机运行的命令), sc-qa指的是bucket名字</span><br><span class="line"> sudo scp -r  scadmin@10。2。0。4:/data/minio/data/sc-qa 。</span><br><span class="line"></span><br><span class="line">// 将文件夹复制到prod环境所在目录(在跳板机运行命令),先放到一个目录中</span><br><span class="line">sudo scp -r sc-qa/ scadmin@10。2。0。5:/home/scadmin/sc-qa</span><br><span class="line"></span><br><span class="line">// 下面都在prod执行,先将现在的minio数据备份</span><br><span class="line">sudo cp -r  /data/minio/data/sc-prod /data/minio/data/sc-prod-bak-20230311-zy</span><br><span class="line"></span><br><span class="line">// 将sc-qa的数据递归开呗到sc-prod中,如果存在重复数据,会在文件名后添加一个 ~1~</span><br><span class="line">sudo cp -frap --backup=number /home/scadmin/sc-qa/* /data/minio/data/sc-prod/</span><br><span class="line"></span><br><span class="line">// 找出重复数据</span><br><span class="line">find /data/minio/data/sc-prod -<span class="built_in">type</span> f -regex <span class="string">&quot;。*\。~1~&quot;</span></span><br></pre></td></tr></table></figure>

<p>找到重复数据后,这个时候我们只能重命名文件名,然后修改对应数据库记录,不过好在,未发现重复记录。</p>
<p>最开始使用SCP方式文件大小和拷贝前一致,但是在界面就是打不开,说文件已被损坏,后来通过对比发现,虽然文件大小一样,但是不知道为什么拷贝过来的文件中但是有些字节发生了改变,导致文件无法打开了。</p>
<p>于是考虑使用winscp来移动数据,但是文件比较大,网络又有问题,总是中断,在重试了2个小时后作罢。</p>
<p>开始怀疑scp有什么问题,后来让运维帮我把目录导过来,还是一样的问题,这个方案只能就此作罢,但是我在dev环境下使用scp是可以的,不知道为什么,如果有知道的老哥麻烦给我讲下。</p>
<p>此时时间来到了下午。</p>
<h4 id="rclone"><a href="#rclone" class="headerlink" title="rclone"></a>rclone</h4><p>后面没办法只能采用rclone的方式,之前不是说两个网络不能通吗? 后来想想就让运维将qa环境开了一个外网,这样就可以了。于是开始使用rclone,首先需要安装好rclone, 我的rclone是安装在用户目录下的,所以编辑用户目录下的 <code>~/。config/rclone/rclone。conf</code>文件</p>
<p>配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[oldminio]</span><br><span class="line">type &#x3D; s3</span><br><span class="line">provider &#x3D; Minio</span><br><span class="line">env_auth &#x3D; false</span><br><span class="line">access_key_id &#x3D; bvfs</span><br><span class="line">secret_access_key &#x3D; BvFs2022</span><br><span class="line">region &#x3D; cn-east-1</span><br><span class="line"># qa环境的minio外网地址</span><br><span class="line">endpoint &#x3D; http:&#x2F;&#x2F;20。xx。xx。xx:9000</span><br><span class="line">location_constraint &#x3D;</span><br><span class="line">server_side_encryption &#x3D;</span><br><span class="line"></span><br><span class="line">[newminio]</span><br><span class="line">type &#x3D; s3</span><br><span class="line">provider &#x3D; Minio</span><br><span class="line">env_auth &#x3D; false</span><br><span class="line">access_key_id &#x3D; minioadmin</span><br><span class="line">secret_access_key &#x3D; minioadmin</span><br><span class="line">region &#x3D; cn-east-1</span><br><span class="line">&#x2F;&#x2F; 生产环境minio地址</span><br><span class="line">endpoint &#x3D; http:&#x2F;&#x2F;10。1。1。5:9000</span><br><span class="line">location_constraint &#x3D;</span><br><span class="line">server_side_encryption &#x3D;</span><br></pre></td></tr></table></figure>

<p>解释下access_key_id和secret_access_key这两个值是你项目中配置minio的accessKey和secretKey的值。</p>
<p>上面的配置文件是在prod minio服务器配置的。</p>
<p>然后使用 rclone copy命令进行文件复制,因为我们不能删除prod目录的文件。在运行这个命令之前,强烈建议使用 –dry-run 来测试下(它不会copy任何东西)</p>
<p>使用rclone后,minio文件同步成功,且能正确打开。</p>
<h3 id="Mysql同步"><a href="#Mysql同步" class="headerlink" title="Mysql同步"></a>Mysql同步</h3><p>以为mysql同步总要好点,结果还是很坑。 因为我们的mysql也是不同的环境,而且使用navicate无法连接上,于是我只能使用idea自带的database进行连接,先将qa数据库数据导出,然后在导入。 </p>
<p>但是导入的时候发现太慢了(一个文件一千多行sql),经常一个文件执行就半个小时,可是好多个文件,就算把idea的事务换成手动提交还是很慢,这里又折腾了许久,发现自己还是不行。</p>
<p>只能把sql给运维,让他到mysql所在服务器执行去了,通过source命令, 它几分钟就搞定了。</p>
<p>但是进行验证的时候,发现有些数据序号错乱了,因为数据库有些表字段是自增的,在idea中导出的时候不会导出自增字段,这就导致了在源数据库的自增值和新的不一致,因为源数据库的数据可能会删除掉,然后自增值就不是连续的了,导入到新的库,这个值就变成连续的,就知道两边不一致,这个坑也把我整到了,所以又只能重新导数据。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>下班的时候已经是晚上十点钟了,宵夜都吃过一次了,回首这次上线感觉被坑了许多,复盘这次上线,最重要的是记得要在dev环境充分预演下上线流程,一定要使用相同方案!</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s中如何进行DNS解析</title>
    <url>/2023/11/23/dns-analysis-in-k8s/</url>
    <content><![CDATA[<p>之前文章&lt;老大喊我7天从SpringCloud转到K8S&gt;中我提到过我们使用open-feign来访问内部服务,有很多童鞋留言问我访问内部服务的url应该怎么写，但是还是整个系统的整体url吗？</p>
<p>比如我整个系统的url是  <code>http://www.think123.com</code>, 现在有user服务和manage服务,那我现在想要访问user服务的ip就变成 <code>http://www.think123.com/user</code>吗? 当然不是因为这样的话你的访问就相当于还是访问外网，又要重新走gateway, 这样子不仅增加网络开销，而且我们做鉴权也不方便，因为服务间的访问鉴权往往是通过一个注解或者token来实现的。</p>
<p>&lt;!-more–&gt;</p>
<h3 id="服务的ip地址"><a href="#服务的ip地址" class="headerlink" title="服务的ip地址"></a>服务的ip地址</h3><p>我们都知道在k8s中我们一般会部署多个pod, 而我们又是通过K8S的Service来做LoadBalance的,Service会根据一定的策略来选择具体访问的pod, 如下图所示</p>
<p><img data-src="/images/k8s/website-to-k8s.png" alt="访问"></p>
<p>因此实际上我们只需要知道service的地址就行了,使用下面的命令查看service的地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get  svc -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/k8s/svc-ip.png" alt="service"></p>
<p>我们可以看到service的ip,因为我们服务是部署到同一个集群的，那是不是只需要知道服务的ip就行了，然后在open-feign中声明要访问的服务的ip加上端口就可以了呢？</p>
<p>原则是上可以的,但是实际上有问题,首先不同集群中ip地址不一样,如果你要部署不同集群，那么每次都要修改，其次就算只有一个集群，这个ip也是可能变动的，所以写ip不太靠谱。</p>
<h3 id="服务的域名"><a href="#服务的域名" class="headerlink" title="服务的域名"></a>服务的域名</h3><p>好在kubernetes给某个服务都添加了一个域名(这是通过kube-proxy和iptables实现的), 域名的规则是  <code>..svc.cluster.local</code>。 </p>
<p>比如对于我们的user服务,我们这个地址就是 <code>user.dev.svc.cluster.local(&lt;serviceName&gt;.&lt;namespace&gt;.svc.cluster.local)</code></p>
<p>当然后面的这么一堆你都可以省略，实际上我们在open-feign的url中只需要声明 <code>http://user:9201/(服务名:端口)</code> 就可以了,kubernetes在进行dns寻址的时候会先在本地dns找user这个域名对应的ip地址</p>
<h3 id="K8S的DNS解析机制"><a href="#K8S的DNS解析机制" class="headerlink" title="K8S的DNS解析机制"></a>K8S的DNS解析机制</h3><ol>
<li><p>集群域名和后缀：Kubernetes集群中的每个服务都会被分配一个域名，该域名由服务名称（Service Name）和命名空间（Namespace）组成。例如，一个服务名为my-service，位于命名空间my-namespace的服务的完整域名将是my-service.my-namespace.svc.cluster.local。svc.cluster.local是Kubernetes集群默认的后缀。</p>
</li>
<li><p>Kubernetes DNS服务器：Kubernetes集群内部有一个专用的DNS服务器负责处理服务的DNS解析请求。这个DNS服务器通常被命名为kube-dns或coredns。</p>
</li>
<li><p>解析流程：在进行DNS解析时，应用程序或服务可以使用服务名作为主机名（hostname），然后发送DNS查询请求到Kubernetes DNS服务器。</p>
</li>
<li><p>DNS查询：Kubernetes DNS服务器接收到DNS查询请求后，会根据请求中的域名信息进行解析。它首先进行域名拆分，将服务名、命名空间和集群后缀分离开。</p>
</li>
<li><p>域名解析：Kubernetes DNS服务器会依次解析域名的各个部分。它首先解析命名空间，然后根据服务名在该命名空间下查找对应的Service资源。</p>
</li>
<li><p>Service资源解析：Kubernetes DNS服务器在Service资源中查找与请求的服务名和命名空间匹配的条目。如果找到匹配项，将返回与之关联的Pod IP地址列表。</p>
</li>
<li><p>IP地址返回：Kubernetes DNS服务器将解析到的Pod IP地址返回给发起请求的应用程序或服务。</p>
</li>
<li><p>重试机制：如果在初始查询时没有找到匹配的Service资源，Kubernetes DNS服务器可能会进行一些重试机制，以确保服务名得到正确解析。这样做是因为在创建和删除Service资源的过程中，可能会存在一定的延迟。<br>通过这种方式，Kubernetes DNS解析机制使得服务能够通过服务名进行通信，无需关心具体的Pod IP地址。这种抽象层简化了服务之间的通信配置，并支持动态扩展和管理服务。</p>
</li>
</ol>
<h4 id="查看域名"><a href="#查看域名" class="headerlink" title="查看域名"></a>查看域名</h4><p>可以通过下面的命令查看域名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get svc my-service -n my-namespace -o jsonpath&#x3D;&#39;&#123;.metadata.name&#125;.&#123;.metadata.namespace&#125;.svc.cluster.local&#39;</span><br></pre></td></tr></table></figure>

<h4 id="查看coredns"><a href="#查看coredns" class="headerlink" title="查看coredns"></a>查看coredns</h4><p>通过下面的命令可以查看coredns pod</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl -n kube-system get pods -l k8s-app&#x3D;kube-dns</span><br></pre></td></tr></table></figure>

<p>当然我们可以通过下面的命令查看coredns的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl -n kube-system get cm -l k8s-app&#x3D;kube-dns</span><br><span class="line">kubectl describe cm coredns -n kube-system</span><br></pre></td></tr></table></figure>

<p>其核心配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.:53 &#123;</span><br><span class="line">    errors</span><br><span class="line">    ready</span><br><span class="line">    health</span><br><span class="line">    kubernetes cluster.local in-addr.arpa ip6.arpa &#123;</span><br><span class="line">      pods insecure</span><br><span class="line">      fallthrough in-addr.arpa ip6.arpa</span><br><span class="line">    &#125;</span><br><span class="line">    prometheus :9153</span><br><span class="line">    forward . &#x2F;etc&#x2F;resolv.conf</span><br><span class="line">    cache 30</span><br><span class="line">    loop</span><br><span class="line">    reload</span><br><span class="line">    loadbalance</span><br><span class="line">    import custom&#x2F;*.override</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>.:53</code> 表示监听的 DNS 端口号为 53，. 表示根域名（Root Zone）。</p>
</li>
<li><p><code>kubernetes cluster.local in-addr.arpa ip6.arpa</code> 定义了多个域和反向解析配置项。</p>
<ul>
<li><p><code>kubernetes</code> 是 Kubernetes 插件的名称，用于解析 Kubernetes 集群的服务和 Pod。</p>
</li>
<li><p><code>cluster.local</code> 是 Kubernetes 集群内部域名的默认后缀。</p>
</li>
<li><p><code>in-addr.arpa</code> 和 <code>ip6.arpa</code> 是用于反向 DNS 解析的 IPv4 和 IPv6 地址后缀。</p>
</li>
<li><p><code>pods insecure</code> 允许对 Pod 进行非安全（insecure）的 DNS 解析。</p>
</li>
<li><p>fallthrough in-addr.arpa ip6.arpa 表示如果查询未匹配到任何资源记录，则继续向下查询反向 DNS 解析。</p>
</li>
</ul>
</li>
<li><p><code>forward . /etc/resolv.conf</code> 将未能解析的 DNS 请求转发给 /etc/resolv.conf 文件中配置的其他 DNS 服务器。</p>
</li>
</ol>
<p>大家也可以去看pod中中/etc/host和/etc/resolv.conf然后也能发现一些迹象。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>至此,讲清楚了集群中内部服务之间是如何访问的，且k8s是如何进行寻址导致对应的pod的,希望对大家有所帮助。</p>
]]></content>
      <tags>
        <tag>Kubernetes</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>github集成drone CI的那些事儿</title>
    <url>/2019/12/10/drone-with-ci/</url>
    <content><![CDATA[<p>基于Drone来做CI/CD,个人感觉真的很棒,相对于业界老大哥jekins,我更喜欢drone,相比较而言，我觉得它主要有以下优势</p>
<ol>
<li>插件不需要额外管理</li>
<li>基于yaml文件，易编写,配置可以进行版本管理</li>
<li>可以根据不同的条件进行构建</li>
<li>更人性化的UI界面</li>
</ol>
<p>对于我们后端的java项目而言，我们CI要做什么呢?</p>
<p><img data-src="/images/drone/ci.png" alt="CI流程"></p>
<a id="more"></a>

<blockquote>
<p>一般提交代码流程如下</p>
<ol>
<li>Clone 项目到本地，创建一个分支来完成新功能的开发, git checkout -b feature/sync-status。在这个分支修改一些代码</li>
<li>git add .，书写符合规范的 Commit 并提交代码， git commit -m “sync article status”</li>
<li>将代码推送到代码库的对应分支， git push origin feature/sync-status</li>
<li>如果功能已经开发完毕，可以向 Develop(或者Master) 分支发起一个 Pull Request，并让项目的负责人 Code Review</li>
<li>Review 通过后，项目负责人将分支合并入主干分支</li>
</ol>
</blockquote>
<p>从上图中可以看到当我们提交代码时,会执行整个CI流程，需要注意的有以下2点</p>
<ol>
<li>执行build或者unit test的时候，如果失败，会发送消息到Slack,这个时候开发人员就能注意到这个问题，当然也可以使用发送邮件或者微信的方式</li>
<li>执行SonarQube check的时候,如果存在问题会将结果回写到github中,开发人员就会去看这个问题</li>
</ol>
<p>先看下SonarQube回写到github中的的检查结果是怎样的</p>
<p><img data-src="/images/drone/sonar-qube-check.png" alt="SonarQube Feed Back"></p>
<p>当sonar qube检测完成之后,会将检查结果通过oauth的方式发送给github,所以你需要在github中创建Personal access token(这个要记下来)</p>
<blockquote>
<p>当你激活你的代码仓库时，Drone会自动将Webhooks添加到版本控制系统中,例如GitHub,而无需手动配置</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">pipeline</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">default</span></span><br><span class="line"></span><br><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="comment"># build for push and pull_request</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">build-pr</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">maven:latest</span></span><br><span class="line">  <span class="attr">pull:</span> <span class="string">if-not-exists</span></span><br><span class="line">  <span class="attr">commands:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mvn</span> <span class="string">clean</span> <span class="string">org.jacoco:jacoco-maven-plugin:prepare-agent</span> <span class="string">install</span> <span class="string">-Dmaven.test.skip=true</span> <span class="string">-s</span> <span class="string">settings.xml</span></span><br><span class="line">  <span class="attr">when:</span></span><br><span class="line">    <span class="attr">branch:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">feature/*</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">issue/*</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">develop</span></span><br><span class="line">    <span class="attr">event:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">push</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pull_request</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">unittest</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">maven:latest</span></span><br><span class="line">  <span class="attr">pull:</span> <span class="string">if-not-exists</span></span><br><span class="line">  <span class="attr">commands:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mvn</span> <span class="string">test</span> <span class="string">-s</span> <span class="string">settings.xml</span></span><br><span class="line">  <span class="attr">when:</span></span><br><span class="line">    <span class="attr">branch:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">develop</span></span><br><span class="line">    <span class="attr">event:</span></span><br><span class="line">      <span class="attr">include:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pull_request</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">push</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我们使用命令来深度定制我们的扫描，而不是使用drone sonar plugin</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sonar-scan</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">newtmitch/sonar-scanner:4.0.0-alpine</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">SONAR_TOKEN:</span></span><br><span class="line">      <span class="attr">from_secret:</span> <span class="string">sonar_token</span></span><br><span class="line">    <span class="attr">GITHUB_ACCESS_TOKEN_FOR_SONARQUBE:</span></span><br><span class="line">      <span class="attr">from_secret:</span> <span class="string">github_access_token_for_sonarqube</span></span><br><span class="line">  <span class="attr">commands:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&gt;</span></span><br><span class="line">    <span class="string">sonar-scanner</span></span><br><span class="line">    <span class="string">-Dsonar.host.url=https://sonarqube.company-beta.com/</span></span><br><span class="line">    <span class="string">-Dsonar.login=$$SONAR_TOKEN</span></span><br><span class="line">    <span class="string">-Dsonar.projectKey=smcp-service-BE</span></span><br><span class="line">    <span class="string">-Dsonar.projectName=smcp-service-BE</span></span><br><span class="line">    <span class="string">-Dsonar.projectVersion=$&#123;DRONE_BUILD_NUMBER&#125;</span></span><br><span class="line">    <span class="string">-Dsonar.sources=src/main/java</span></span><br><span class="line">    <span class="string">-Dsonar.tests=src/test/java</span></span><br><span class="line">    <span class="string">-Dsonar.language=java</span></span><br><span class="line">    <span class="string">-Dsonar.java.coveragePlugin=jacoco</span></span><br><span class="line">    <span class="string">-Dsonar.modules=smcp-api,smcp-web</span></span><br><span class="line">    <span class="string">-Dsonar.java.binaries=target</span></span><br><span class="line">    <span class="string">-Dsonar.projectBaseDir=.</span></span><br><span class="line">    <span class="string">-Dsonar.analysis.mode=preview</span></span><br><span class="line">    <span class="string">-Dsonar.github.repository=Today_Group/SMCP-Service</span></span><br><span class="line">    <span class="string">-Dsonar.github.oauth=$$GITHUB_ACCESS_TOKEN_FOR_SONARQUBE</span></span><br><span class="line">    <span class="string">-Dsonar.github.pullRequest=$&#123;DRONE_PULL_REQUEST&#125;</span></span><br><span class="line">    <span class="string">-Dsonar.github.disableInlineComments=false</span></span><br><span class="line">  <span class="attr">when:</span></span><br><span class="line">    <span class="attr">event:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pull_request</span></span><br><span class="line">    <span class="attr">branch:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">develop</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># post sonarscan result back to git PR (not in preview mode)</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">sonar-scan-feedback</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">newtmitch/sonar-scanner:4.0.0-alpine</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">SONAR_TOKEN:</span></span><br><span class="line">      <span class="attr">from_secret:</span> <span class="string">sonar_token</span></span><br><span class="line">    <span class="attr">GITHUB_ACCESS_TOKEN_FOR_SONARQUBE:</span></span><br><span class="line">      <span class="attr">from_secret:</span> <span class="string">github_access_token_for_sonarqube</span></span><br><span class="line">  <span class="attr">commands:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&gt;</span></span><br><span class="line">      <span class="string">sonar-scanner</span></span><br><span class="line">      <span class="string">-Dsonar.host.url=https://sonarqube.company-beta.com/</span></span><br><span class="line">      <span class="string">-Dsonar.login=$$SONAR_TOKEN</span></span><br><span class="line">      <span class="string">-Dsonar.projectKey=smcp-service-BE</span></span><br><span class="line">      <span class="string">-Dsonar.projectName=smcp-service-BE</span></span><br><span class="line">      <span class="string">-Dsonar.projectVersion=$&#123;DRONE_BUILD_NUMBER&#125;</span></span><br><span class="line">      <span class="string">-Dsonar.sources=src/main/java</span></span><br><span class="line">      <span class="string">-Dsonar.tests=src/test/java</span></span><br><span class="line">      <span class="string">-Dsonar.language=java</span></span><br><span class="line">      <span class="string">-Dsonar.java.coveragePlugin=jacoco</span></span><br><span class="line">      <span class="string">-Dsonar.modules=smcp-api,smcp-web</span></span><br><span class="line">      <span class="string">-Dsonar.java.binaries=target</span></span><br><span class="line">      <span class="string">-Dsonar.projectBaseDir=.</span></span><br><span class="line">      <span class="string">-Dsonar.analysis.gitRepo=Today_Group/SMCP-Service</span></span><br><span class="line">      <span class="string">-Dsonar.analysis.pullRequest=$&#123;DRONE_PULL_REQUEST&#125;</span></span><br><span class="line">  <span class="attr">when:</span></span><br><span class="line">    <span class="attr">event:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pull_request</span></span><br><span class="line">    <span class="attr">branch:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">develop</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面drone的配置就是整个CI的基本流程了，需要注意的有以下几点</p>
<ol>
<li>只有当分支名称以feature/,issue/,develop开头的才会触发上面的执行步骤,对于unit test而言,只有develop分支才生效(可以根据需要自行定制)</li>
<li>sonar配置中的sonar.projectKey,sonar.projectName一定要和你在sonar服务器(sonar.host.url指定的地址)中创建project时的名称一样</li>
<li>sonar_token的值是在sonar服务器上创建的，然后将这个值设置在了drone的secrets中(drone中点击某一个仓库,进入Settings可以进行设置)</li>
<li>github token和sonar_token是同样的方式，都需要在drone中预设置(好处就是你不会暴露你的密码在文件中，这样更加安全)</li>
<li>由于所用Java项目是个多模块项目,所以可以在sonar.modules中指定多个模块名称</li>
<li>sonar scan feedback的内容到pr不要指定preview mode</li>
<li>build的时候使用了jacoco(分析单元测试覆盖率),所以需要在java项目中pom.xml引入这个plugin</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jacoco<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jacoco-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jacoco.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>prepare-agent<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">goal</span>&gt;</span>prepare-agent<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>default-report<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>test<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">goal</span>&gt;</span>report<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dataFile</span>&gt;</span>target/jacoco.exec<span class="tag">&lt;/<span class="name">dataFile</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>target/jacoco<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>其他可能遇到的问题：</strong></p>
<ol>
<li><p>ci执行完成之后，如何发送邮件或者消息到微信群</p>
<p>答: drone提供了关于<a href="http://plugins.drone.io/drillster/drone-email/">邮件</a>和<a href="http://plugins.drone.io/clem109/drone-wechat/">微信的插件</a></p>
</li>
<li><p>sonarqube能否集成阿里巴巴的p3c或者自定义checkstyle</p>
<p>答: 没有p3c的插件，但是可以通过PMD来进行集成</p>
<blockquote>
<p>集成p3c: <a href="https://www.jianshu.com/p/a3a58ac368be">https://www.jianshu.com/p/a3a58ac368be</a><br>自定义checkstyle: <a href="https://www.jianshu.com/p/a3a58ac368be">https://www.jianshu.com/p/a3a58ac368be</a></p>
</blockquote>
</li>
<li><p>我想根据build的信息(是否成功,时间等)自己做统计怎么办?</p>
<p>答: drone提供了webhooke的plugin,你只需要编写自己统计的程序就可以了,可以根据模板设置需要发送的信息</p>
</li>
<li><p>没有我想要的插件,怎么办?</p>
<p>答: 可以自己写一个插件,官网有bash/go的示例,用你熟悉的语言也是可以的</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>drone</tag>
        <tag>CI</tag>
      </tags>
  </entry>
  <entry>
    <title>fastjson中SerializerFeature解析</title>
    <url>/2015/11/15/fastjson-serializerFeature/</url>
    <content><![CDATA[<p>SerializerFeature在fastjson中扮演着一个极其重要的角色，通过它我们可以定制序列化，那么它本身是如何实现的呢？如此的设计有有何出彩之处呢？本篇文章将会重点围绕这些要素进行分析。<a id="more"></a></p>
<h3 id="1-认识SerializerFeature"><a href="#1-认识SerializerFeature" class="headerlink" title="1. 认识SerializerFeature"></a>1. 认识SerializerFeature</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SerializerFeature &#123;</span><br><span class="line">    QuoteFieldNames，</span><br><span class="line">    </span><br><span class="line">    UseSingleQuotes，</span><br><span class="line">   </span><br><span class="line">    WriteMapNullValue，</span><br><span class="line">    </span><br><span class="line">    WriteEnumUsingToString，</span><br><span class="line">    </span><br><span class="line">    UseISO8601DateFormat，</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WriteNullListAsEmpty，</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WriteNullStringAsEmpty，</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WriteNullNumberAsZero，</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WriteNullBooleanAsFalse，</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SkipTransientField，</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SortField，</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1.1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    WriteTabAsSpecial，</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PrettyFormat，</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WriteClassName，</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DisableCircularReferenceDetect，</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1.9</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WriteSlashAsSpecial，</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1.10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BrowserCompatible，</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1.14</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WriteDateUseDateFormat，</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1.15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NotWriteRootClassName，</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1.19</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DisableCheckSpecialChar，</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1.35</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BeanToArray，</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1.37</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WriteNonStringKeyAsString，</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.1.42</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NotWriteDefaultValue</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举的构造方法不能是public</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">SerializerFeature</span><span class="params">()</span></span>&#123;</span><br><span class="line">         mask = (<span class="number">1</span> &lt;&lt; ordinal());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mask;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">(<span class="keyword">int</span> features， SerializerFeature feature)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (features &amp; feature.getMask()) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">(<span class="keyword">int</span> features， <span class="keyword">int</span> fieaturesB， SerializerFeature feature)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mask = feature.getMask();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (features &amp; mask) != <span class="number">0</span> || (fieaturesB &amp; mask) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">config</span><span class="params">(<span class="keyword">int</span> features， SerializerFeature feature， <span class="keyword">boolean</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state) &#123;</span><br><span class="line">            features |= feature.getMask();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            features &amp;= ~feature.getMask();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> features;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>SerializerFeature是一个枚举类型(为什么不使用常量呢?这个会在接下来的文章当中提到)，其中定义了多个枚举(我们可以将其当成类来处理，只是这个类有点特殊而已)，比如我们常用的<strong>BrowserCompatible(游览器兼容，使用它会使得json串中的key加上双引号)**以及</strong>PrettyFormat(格式化)**，且提供了一个默认构造方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">SerializerFeature</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mask = (<span class="number">1</span> &lt;&lt; ordinal());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每实例化一个Enum的时候就会调用一次构造方法，其中的1&lt;&lt;ordinal()是此次讲解的重中之重。</p>
<h3 id="2-认识SerializerFeature的构造方法"><a href="#2-认识SerializerFeature的构造方法" class="headerlink" title="2. 认识SerializerFeature的构造方法"></a>2. 认识SerializerFeature的构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SerializerFeature</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mask = (<span class="number">1</span> &lt;&lt; ordinal());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ordinal()</code>方法根据枚举定义了的个数返回不同的数值，如果定义了五个枚举，那么该方法根据顺序依次返回0-4的五个数字。比如<strong>QuoteFieldNames，UseSingleQuotes，WriteMapNullValue依次返回的就是0，1，2这三个数字</strong>，所以根据这样定义枚举相对应的mask值就是1，2，4，8，16，32…(<strong>2的倍数，转换成2进制之后其特殊性就在于只有首位才为1</strong>)<br>比如4的二进制:100，4096的二进制:1000000000000</p>
<h3 id="3-注册或者移除SerializerFeature"><a href="#3-注册或者移除SerializerFeature" class="headerlink" title="3. 注册或者移除SerializerFeature"></a>3. 注册或者移除SerializerFeature</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">config</span><span class="params">(<span class="keyword">int</span> features， SerializerFeature feature， <span class="keyword">boolean</span> state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state) &#123;</span><br><span class="line">        features |= feature.getMask();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        features &amp;= ~feature.getMask();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> features;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第一个参数表示默认的SerializerFeature,fastjson在运行过程中加载了默认的SerializerFeature</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> features = <span class="number">0</span>;</span><br><span class="line">    features |= SerializerFeature.QuoteFieldNames.getMask();</span><br><span class="line">    features |= SerializerFeature.SkipTransientField.getMask();</span><br><span class="line">    features |= SerializerFeature.WriteEnumUsingToString.getMask();</span><br><span class="line">    features |= SerializerFeature.SortField.getMask();</span><br><span class="line">    <span class="comment">// features |=</span></span><br><span class="line">    <span class="comment">// com.alibaba.fastjson.serializer.SerializerFeature.WriteSlashAsSpecial.getMask();</span></span><br><span class="line">    DEFAULT_GENERATE_FEATURE = features;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第二个参数表示需要注册/移除的特性</strong></p>
<p><strong>第三个参数表示是注册还是移除特性的状态</strong></p>
<p><strong>注册过程:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">                 <span class="number">0000</span> <span class="number">0010</span></span><br><span class="line">            |(或)    <span class="number">0000</span> <span class="number">1000</span></span><br><span class="line">            |(或)    <span class="number">0010</span> <span class="number">0000</span>  </span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">                <span class="number">0010</span> <span class="number">1010</span>  (此时表示已经注册了三个特性,有几个<span class="number">1</span>就有几个特性)</span><br></pre></td></tr></table></figure>
<p><strong>移除过程:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">            </span><br><span class="line">            ~ <span class="number">0000</span> <span class="number">0010</span> = <span class="number">1111</span> <span class="number">1101</span></span><br><span class="line">                </span><br><span class="line">                <span class="number">0010</span> <span class="number">1010</span></span><br><span class="line">               &amp;(与)    <span class="number">1111</span> <span class="number">1101</span></span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">                <span class="number">0010</span> <span class="number">1000</span> (此时已经只具有了两个特性,已经被移除了一个)</span><br></pre></td></tr></table></figure>
<p>是不是觉得位运算很神奇呢？不得不让人感叹细微之处方见大智慧呀！</p>
<h3 id="4-验证是否存在该特性"><a href="#4-验证是否存在该特性" class="headerlink" title="4. 验证是否存在该特性"></a>4. 验证是否存在该特性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">(<span class="keyword">int</span> features， SerializerFeature feature)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (features &amp; feature.getMask()) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">(<span class="keyword">int</span> features， <span class="keyword">int</span> fieaturesB， SerializerFeature feature)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = feature.getMask();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (features &amp; mask) != <span class="number">0</span> || (fieaturesB &amp; mask) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>和config使用的方法一致,不在做过多累述。</p>
<h3 id="5-为什么使用枚举"><a href="#5-为什么使用枚举" class="headerlink" title="5. 为什么使用枚举"></a>5. 为什么使用枚举</h3><p>以前我们在代码中,定义使用过的常量,我们可能会这样定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OFF= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;现在的状态是:&quot;</span>+state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然都用了这么久了，有什么不好的呢？</p>
<ol>
<li>它不是类型安全的。你必须确保是int</li>
<li>你还要确保它的范围是0 和1</li>
<li>很多时候你打印出来的时候，你只看到1和0 </li>
</ol>
<p>导致阅读你代码的人并不知道你的意图。所以更多的时候我们应该使用枚举,而不是常量。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>json，java</tag>
      </tags>
  </entry>
  <entry>
    <title>fastjson定制序列化以及反序列化</title>
    <url>/2015/10/26/fastjson-use/</url>
    <content><![CDATA[<p><strong>先来看一段序列化的代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJsonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FastJsonTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;12&quot;</span>, <span class="string">&quot;zhangsan1&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;121&quot;</span>, <span class="string">&quot;zhangsan2&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;122&quot;</span>, <span class="string">&quot;zhangsan3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String gString = JSON.toJSONString(map, <span class="keyword">new</span> PropertyFilter() &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(Object object, String name, Object value)</span> </span>&#123;</span><br><span class="line">       System.out.println(object.toString()+<span class="string">&quot;...&quot;</span>+name+<span class="string">&quot;...&quot;</span>+value);</span><br><span class="line">       <span class="keyword">if</span>(name.equalsIgnoreCase(<span class="string">&quot;121&quot;</span>) || value.equals(<span class="string">&quot;zhangsan2&quot;</span>))</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, SerializerFeature.BrowserCompatible);<span class="comment">//SerializerFeature.WriteNonStringKeyAsString</span></span><br><span class="line"></span><br><span class="line">    System.out.println(gString);<span class="comment">//&#123;&quot;122&quot;:&quot;zhangsan3&quot;,&quot;12&quot;:&quot;zhangsan1&quot;&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>toJSONString 有很多重构的方法:<br><img data-src="/images/hexo-toJSONString.png" alt="toJSONString"></p>
<p>SerializerFeature: 在其中可以定义序列化成json串的时候的各种特性</p>
<ol>
<li>SerializerFeature.BrowserCompatible 标示兼容游览器</li>
<li>SerializerFeature.WriteNonStringKeyAsString 将非字符串类型的key当成字符串来处理</li>
</ol>
<p>使用上面两种中的任意一种都会为key加上双引号。</p>
<p>SerializeFilter:  定制序列化，它是一个接口,fastjson中预定义了部分常用的filter</p>
<ol>
<li>PropertyPreFilter 根据PropertyName判断是否序列化</li>
<li>PropertyFilter 根据PropertyName和PropertyValue来判断是否序列化</li>
<li>NameFilter 修改Key，如果需要修改Key,process返回值则可</li>
<li>ValueFilter 修改Value</li>
<li>BeforeFilter 序列化时在最前添加内容</li>
<li>AfterFilter 序列化时在最后添加内容</li>
</ol>
<p>更多序列化信息请参考:<a href="https://github.com/alibaba/fastjson/wiki/%E5%AE%9A%E5%88%B6%E5%BA%8F%E5%88%97%E5%8C%96">https://github.com/alibaba/fastjson/wiki/%E5%AE%9A%E5%88%B6%E5%BA%8F%E5%88%97%E5%8C%96</a></p>
<p>反序列化请参考:<a href="https://github.com/alibaba/fastjson/wiki/ParseProcess">https://github.com/alibaba/fastjson/wiki/ParseProcess</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>浮点数在计算机中的表示方法</title>
    <url>/2016/02/14/float-number-in-computer/</url>
    <content><![CDATA[<h3 id="java基本数据类型数据范围"><a href="#java基本数据类型数据范围" class="headerlink" title="java基本数据类型数据范围"></a>java基本数据类型数据范围</h3><p>java中基本数据类型所占字节数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Integer: &quot;</span> + Integer.SIZE/<span class="number">8</span>);           <span class="comment">// 4    </span></span><br><span class="line">System.out.println(<span class="string">&quot;Short: &quot;</span> + Short.SIZE/<span class="number">8</span>);               <span class="comment">// 2        </span></span><br><span class="line">System.out.println(<span class="string">&quot;Long: &quot;</span> + Long.SIZE/<span class="number">8</span>);                 <span class="comment">// 8    </span></span><br><span class="line">System.out.println(<span class="string">&quot;Byte: &quot;</span> + Byte.SIZE/<span class="number">8</span>);                 <span class="comment">// 1    </span></span><br><span class="line">System.out.println(<span class="string">&quot;Character: &quot;</span> + Character.SIZE/<span class="number">8</span>);       <span class="comment">// 2    </span></span><br><span class="line">System.out.println(<span class="string">&quot;Float: &quot;</span> + Float.SIZE/<span class="number">8</span>);               <span class="comment">// 4    </span></span><br><span class="line">System.out.println(<span class="string">&quot;Double: &quot;</span> + Double.SIZE/<span class="number">8</span>);             <span class="comment">// 8  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以其表示范围如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据类型        所占字节      表示范围  </span><br><span class="line">byte        1(8bit)       -128-127</span><br><span class="line">short       2(16bit)      -32768-32767</span><br><span class="line">int         4(32bit)      -2^31-2^31-1</span><br><span class="line">long        8(64bit)      -2^63-2^63-1</span><br><span class="line">float       4(32bit)      -3.4E+38-3.4E+38</span><br><span class="line">double      8(64bit)      -1.79E+308-1.79E+308</span><br></pre></td></tr></table></figure>

<h3 id="浮点数在计算机中如何表示"><a href="#浮点数在计算机中如何表示" class="headerlink" title="浮点数在计算机中如何表示"></a>浮点数在计算机中如何表示</h3><p>可以看出单精度float以及双精度的表示范围和其他基本数据类型的运算方式并不一致,那么这是为什么呢？这就涉及到了浮点数的表示方法,java语言在设计过程中，遵循了<a href="https://zh.wikipedia.org/wiki/IEEE_754">IEEE754标准</a>。</p>
<p>根据国际标准IEEE 754，任意一个二进制浮点数V可以表示成下面的形式：<br><img data-src="/images/hexo-float-style.png" alt="表现形式"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(-1)^s表示符号位，当s&#x3D;0，V为正数；当s&#x3D;1，V为负数。</span><br><span class="line">M表示有效数字，大于等于1，小于2。</span><br><span class="line">2^E表示指数位。</span><br></pre></td></tr></table></figure>
<p>举例来说，十进制的5.0，写成二进制是101.0，相当于1.01×2^2。那么，按照上面V的格式，可以得出s=0，M=1.01，E=2。<br>十进制的-5.0，写成二进制是-101.0，相当于-1.01×2^2。那么，s=1，M=1.01，E=2。<br>IEEE 754规定，对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。</p>
<p><img data-src="/images/hexo-32-float.png" alt="32位浮点数"></p>
<p>对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。<br><img data-src="/images/hexo-64-float-style.png" alt="64位浮点数"></p>
<p>IEEE 754对有效数字M和指数E，还有一些特别规定。<br>前面说过，1≤M&lt;2，也就是说，M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。</p>
<p>至于指数E，情况就比较复杂。首先，E为一个无符号整数(unsigned int)。这意味着，如果E为8位，它的取值范围为0<del>255；如果E为11位，它的取值范围为0</del>2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，E的真实值必须再减去一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。<br>比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。</p>
<p>然后，指数E还可以再分成三种情况：</p>
<p>(1) E不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127(或1023)，得到真实值，再将有效数字M前加上第一位的1。</p>
<p>(2) E全为0。这时，浮点数的指数E等于1-127(或者1-1023)，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。</p>
<p>(3) E全为1。这时，如果有效数字M全为0，表示±无穷大(正负取决于符号位s)；如果有效数字M不全为0，表示这个数不是一个数(NaN)。</p>
<h3 id="关于java中float说明"><a href="#关于java中float说明" class="headerlink" title="关于java中float说明"></a>关于java中float说明</h3><p>上面我们说过float的最小值是-3.4E+38,但是我们使用代码确发现:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">System.out.println(Float.MIN_VALUE);//1.4E-45</span><br></pre></td></tr></table></figure>
<p>这个1.4E-45是如何计算的？为什么仍然是一个正数呢?其实查看源代码可以发现这个值并不是float所表示的最小值,而是它所能表示的最接近0的数字(2^-149),这个如何得来的呢？可以查看<a href="https://zh.wikipedia.org/wiki/IEEE_754">IEEE754标准</a>。</p>
<p>上面说了32位浮点数的有效数字是23位,那么其表示的最大值为8388608(小于10^7),按照十进制表示法是8.388608*10^6,所以float表示的精度(十进制)是6位。</p>
<p><strong>参考博客</strong><br><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">浮点数的二进制表示-阮一峰</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>from-spring-cloud-to-springboot</title>
    <url>/2023/09/14/from-spring-cloud-to-springboot/</url>
    <content><![CDATA[<p>之前项目使用的是springcloud,主要使用到的组件有 spring gateway, nacos, minio, load balancer,open-feign等,然后我们的微服务通过docker部署到虚拟机里面的。</p>
<p>但是出于安全的考虑,需要将它迁移到azure的aks(kubernetes)中,所以需要将spring cloud改造成spring boot。这样就不用自己维护虚拟机的安全策略，也不需要去关注补丁了。</p>
<h3 id="梳理项目结构"><a href="#梳理项目结构" class="headerlink" title="梳理项目结构"></a>梳理项目结构</h3><p>项目是一个一个微服务组织起来的，大概业务类的服务有5个,公共服务有4个。 设计到的改造主要集中在gateway, auth中，公共包的一些改造比较少，主要是将open-feign的访问改为通过url进行调用，而不是之前通过服务名来。</p>
<p>而在kubernetes中，我们使用Traefik2来代替gateway的功能，不知道traefik2的，可以去翻翻之前的文章。</p>
<p>同时对于授权,需要提供一个授权接口，配合traefik2使用，这样每一个请求都会进行授权的验证。</p>
<h3 id="开始改造"><a href="#开始改造" class="headerlink" title="开始改造"></a>开始改造</h3><h4 id="确定分支"><a href="#确定分支" class="headerlink" title="确定分支"></a>确定分支</h4><p>最开始肯定是新拉一个分支进行这些改动，即便没改好也不影响其他人，所以我们先把分支名定好就叫做 feature/AKS-migrate。</p>
<h4 id="改造gateway"><a href="#改造gateway" class="headerlink" title="改造gateway"></a>改造gateway</h4><p>首先把pom文件中的不需要的依赖包注释掉,比如spring cloud gateay, nacos, sentinel等spring cloud相关组件。注释掉之后<br>去看代码中有哪些报错，就针对性的修改。</p>
<p>我们的项目中使用蛮多gateway的filter以及handler,最开始我看他们都是使用的webflux,我就想我单独引入这个包，代码是不是最小的改动就行了呢？</p>
<p>这样尝试过之后我发现不行,因为项目中使用最多还是@RestController,如果使用webflux的方式,那么很多filter不生效的。 </p>
<p>所以这种方式也不行，但是代码改得太多了，我只好回退到注释pom文件依赖的那一步。</p>
<p>没办法,只能读之前对应的代码逻辑,然后将其转换了。</p>
<p>读取gateway filter的代码,将其转换成spring filter,直接继承 <code>org.springframework.web.filter.OncePerRequestFilter</code> 即可，然后将之前的逻辑搬过来。 </p>
<p>需要注意的是如果是全局filter需要放到公共包里面。</p>
<p>handler也是一样的,将其转换成filter,需要注意执行顺序。</p>
<p>这样,核心代码改造完毕,可以开启调试了</p>
<h4 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h4><p>处理上面说的webflux的问题外,将springcloud变成springboot后,我们之前的配置文件名称是bootstrap.yml,bootstrap-dev.yml文件,但是改成了springboot后，配置文件名要改成application.yml,application-env.yml。</p>
<p>不然你会发现你启动不了,说找不到文件，这个坑也是自己把自己给坑了。</p>
<p>然后就是要将gateway的filter转换成spring filter的时候要注意一定要保证之前的逻辑完全移植过来了，我就遇到一个在改造前可以重复读取request的流,但是改造后这段代码报错了，就是因为没有将这段逻辑移植过去的问题。</p>
<h4 id="改造nacos"><a href="#改造nacos" class="headerlink" title="改造nacos"></a>改造nacos</h4><p>前面提到了nacos主要在open-feign的调用中以及变量注入中使用到了。feign那个好改,只需要指定url参数即可,这样就可以去掉nacos的依赖了。 然后变量注入同样的我们可以使用Kubernetes的ConfigMap以及Secret来代替。 </p>
<p>所以我们需要将以前配置到nacos中的变量放到配置文件中,这样变量可以直接通过Kubernetes进行注入了。</p>
<p>我们在各个环境中只需要有一份代码(一个镜像),部署的时候只需要注入的配置不一样就可以了，这样就可以保证各个环境代码一致。</p>
<p>比如之前的配置是这样的</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改造后配置文件的值为</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;env_redis_host&#125;</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">$&#123;env_redis_port&#125;</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">$&#123;env_redis_database&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;env_redis_password&#125;</span></span><br></pre></td></tr></table></figure>

<p>而这里的变量是通过ConfigMap进行配置的,到时候会注入到容器环境变量中，这样spring就可以从环境变量中获取到值了。</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>之前使用的jenkins方式部署，jenkins也是自己搭建的，现在全部迁移到了azure github上,所以这里直接使用azure的pipeline进行部署。 而我们管理k8s的资源则使用的是helm。</p>
<p>比如我项目中使用helm生成后结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:.                 </span><br><span class="line">│  .helmignore      </span><br><span class="line">│  Chart.yaml       </span><br><span class="line">│  values-prod.yaml </span><br><span class="line">│  values-qa.yaml   </span><br><span class="line">│  values-test.yaml </span><br><span class="line">│  values.yaml      </span><br><span class="line">│                   </span><br><span class="line">├─charts            </span><br><span class="line">├─config            </span><br><span class="line">│  ├─dev            </span><br><span class="line">│  │      config.yaml</span><br><span class="line">│  │      secret.yaml</span><br><span class="line">│  │                </span><br><span class="line">│  ├─prod           </span><br><span class="line">│  │      config.yaml</span><br><span class="line">│  │      secret.yaml</span><br><span class="line">│  │                </span><br><span class="line">│  ├─qa             </span><br><span class="line">│  │      config.yaml</span><br><span class="line">│  │      secret.yaml</span><br><span class="line">│  │                </span><br><span class="line">│  └─test           </span><br><span class="line">│          config.yaml</span><br><span class="line">│          secret.yaml</span><br><span class="line">│                   </span><br><span class="line">└─templates         </span><br><span class="line">        configmap.yaml</span><br><span class="line">        deployment.yaml</span><br><span class="line">        hpa.yaml    </span><br><span class="line">        secret.yaml </span><br><span class="line">        service.yaml</span><br><span class="line">        _helpers.tpl</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里只需要部署的时候指定不同的value 文件，就可以实现同一个镜像部署到不同的环境了。</p>
<p>dev目录下config.yaml，secret.yaml文件内容大致如下:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># config.yaml</span></span><br><span class="line"><span class="attr">env_redis_host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">env_redis_port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">env_redis_database:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#secret.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env_redis_password:</span> <span class="number">123456</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在template中configmap.yaml, secret.yaml中主要是如何将文件内容转换成对应的yaml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#values.yaml 指定有哪些文件</span></span><br><span class="line"><span class="attr">configOverrides:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">config/dev/config.yaml</span></span><br><span class="line"><span class="attr">secretOverrides:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">config/dev/secret.yaml</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> &#123;&#123; <span class="string">include</span> <span class="string">&quot;think-manifesto.fullname&quot;</span> <span class="string">.</span> &#125;&#125;<span class="string">-configmap</span></span><br><span class="line">  <span class="attr">namespace:</span> &#123;&#123; <span class="string">.Values.nameSpace</span> &#125;&#125;</span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">$files</span> <span class="string">:=</span> <span class="string">.Files</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">range</span>  <span class="string">.Values.configOverrides</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">range</span> <span class="string">$key</span>, <span class="string">$value</span> <span class="string">:=</span>  <span class="string">($files.Get</span> <span class="string">(printf</span> <span class="string">&quot;%s&quot;</span> <span class="string">.)</span> <span class="string">|</span> <span class="string">fromYaml)</span> &#125;&#125;</span><br><span class="line">&#123;&#123; <span class="string">$key</span> <span class="string">|</span> <span class="string">indent</span> <span class="number">2</span> &#125;&#125;<span class="string">:</span> &#123;&#123; <span class="string">$value</span> <span class="string">|</span> <span class="string">quote</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># secret.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> &#123;&#123; <span class="string">include</span> <span class="string">&quot;think-manifesto.fullname&quot;</span> <span class="string">.</span> &#125;&#125;<span class="string">-secret</span></span><br><span class="line">  <span class="attr">namespace:</span> &#123;&#123; <span class="string">.Values.nameSpace</span> &#125;&#125;</span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">$files</span> <span class="string">:=</span> <span class="string">.Files</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">range</span>  <span class="string">.Values.secretOverrides</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">range</span> <span class="string">$key</span>, <span class="string">$value</span> <span class="string">:=</span>  <span class="string">($files.Get</span> <span class="string">(printf</span> <span class="string">&quot;%s&quot;</span> <span class="string">.)</span> <span class="string">|</span> <span class="string">fromYaml)</span> &#125;&#125;</span><br><span class="line">&#123;&#123; <span class="string">$key</span> <span class="string">|</span> <span class="string">indent</span> <span class="number">2</span> &#125;&#125;<span class="string">:</span> &#123;&#123; <span class="string">$value</span> <span class="string">|</span> <span class="string">b64enc</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后给我deployment.yaml的例子,大家可以参考下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> &#123;&#123; <span class="string">include</span> <span class="string">&quot;think-manifesto.fullname&quot;</span> <span class="string">.</span> &#125;&#125;</span><br><span class="line">  <span class="attr">namespace:</span> &#123;&#123; <span class="string">.Values.nameSpace</span> &#125;&#125;</span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    &#123;&#123;<span class="bullet">-</span> <span class="string">include</span> <span class="string">&quot;think-manifesto.labels&quot;</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">4</span> &#125;&#125;</span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> &#123;&#123; <span class="string">.Values.replicaCount</span> &#125;&#125;</span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">include</span> <span class="string">&quot;think-manifesto.selectorLabels&quot;</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">6</span> &#125;&#125;</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">include</span> <span class="string">&quot;think-manifesto.selectorLabels&quot;</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">8</span> &#125;&#125;</span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">if</span> <span class="string">.Values.configOverrides</span>&#125;&#125;</span><br><span class="line">        <span class="attr">checksum/config:</span> &#123;&#123; <span class="string">include</span> <span class="string">(print</span> <span class="string">$.Template.BasePath</span> <span class="string">&quot;/configmap.yaml&quot;</span><span class="string">)</span> <span class="string">.</span> <span class="string">|</span> <span class="string">sha256sum</span> &#125;&#125;</span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">if</span> <span class="string">.Values.secretOverrides</span>&#125;&#125;</span><br><span class="line">        <span class="attr">checksum/secret:</span> &#123;&#123; <span class="string">include</span> <span class="string">(print</span> <span class="string">$.Template.BasePath</span> <span class="string">&quot;/secret.yaml&quot;</span><span class="string">)</span> <span class="string">.</span> <span class="string">|</span> <span class="string">sha256sum</span> &#125;&#125;</span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">with</span> <span class="string">.Values.imagePullSecrets</span> &#125;&#125;</span><br><span class="line">      <span class="attr">imagePullSecrets:</span></span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">8</span> &#125;&#125;</span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> &#123;&#123; <span class="string">.Chart.Name</span> &#125;&#125;</span><br><span class="line">          <span class="attr">image:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; .Values.image.repository &#125;&#125;</span>:<span class="template-variable">&#123;&#123; .Values.image.tag | default .Chart.AppVersion &#125;&#125;</span>&quot;</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> &#123;&#123; <span class="string">.Values.image.pullPolicy</span> &#125;&#125;</span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> &#123;&#123; <span class="string">.Values.service.portName</span> &#125;&#125;</span><br><span class="line">              <span class="attr">containerPort:</span> &#123;&#123; <span class="string">.Values.service.port</span> &#125;&#125;</span><br><span class="line">          <span class="attr">envFrom:</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">if</span> <span class="string">.Values.configOverrides</span> &#125;&#125;</span><br><span class="line">            <span class="bullet">-</span> <span class="attr">configMapRef:</span></span><br><span class="line">                <span class="attr">name:</span> &#123;&#123; <span class="string">include</span> <span class="string">&quot;think-manifesto.fullname&quot;</span> <span class="string">.</span> &#125;&#125;<span class="string">-configmap</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">if</span> <span class="string">.Values.secretOverrides</span> &#125;&#125;</span><br><span class="line">            <span class="bullet">-</span> <span class="attr">secretRef:</span></span><br><span class="line">                <span class="attr">name:</span> &#123;&#123; <span class="string">include</span> <span class="string">&quot;think-manifesto.fullname&quot;</span> <span class="string">.</span> &#125;&#125;<span class="string">-secret</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">          &#123;&#123;<span class="bullet">-</span> <span class="string">with</span> <span class="string">.Values.livenessProbe</span> &#125;&#125;</span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">12</span> &#125;&#125;</span><br><span class="line">          &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">          &#123;&#123;<span class="bullet">-</span> <span class="string">with</span> <span class="string">.Values.readinessProbe</span> &#125;&#125;</span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">12</span> &#125;&#125;</span><br><span class="line">          &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">toYaml</span> <span class="string">.Values.resources</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">12</span> &#125;&#125;</span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">with</span> <span class="string">.Values.nodeSelector</span> &#125;&#125;</span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">8</span> &#125;&#125;</span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">with</span> <span class="string">.Values.affinity</span> &#125;&#125;</span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">8</span> &#125;&#125;</span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">with</span> <span class="string">.Values.tolerations</span> &#125;&#125;</span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">8</span> &#125;&#125;</span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>至于values.yaml我就不给出来了，基本上是其他模板需要什么就写在上面就好了。</p>
<p>和Kustomize相比,helm安装第三方chart很方便，它有自己的仓库，这里附上我安装traefik2的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加traefiK仓库</span><br><span class="line">helm repo add traefik   https:&#x2F;&#x2F;traefik.github.io&#x2F;charts    </span><br><span class="line">#添加国内仓库       </span><br><span class="line">helm repo add stable http:&#x2F;&#x2F;mirror.azure.cn&#x2F;kubernetes&#x2F;charts       </span><br><span class="line">helm repo add aliyun https:&#x2F;&#x2F;kubernetes.oss-cn-hangzhou.aliyuncs.com&#x2F;charts       </span><br><span class="line">helm repo update       </span><br><span class="line">helm repo list</span><br><span class="line"></span><br><span class="line">helm install --set deployment.kind&#x3D;DaemonSet --set namespaceOverride&#x3D;traefik --set service.enabled&#x3D;false traefik traefik&#x2F;traefik</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="本地验证"><a href="#本地验证" class="headerlink" title="本地验证"></a>本地验证</h4><p>当你写好了上面的chart之后,如果你本地没有kubernetes环境(因为它可能在服务器才存在),而你又想要在本地进行验证你写得是否有问题，那么可以使用下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将下面的变量替换成你自己的。 chart-name表示chart的名字,chart-dir表示chart地址</span><br><span class="line">helm template --dry-run --debug --disable-openapi-validation $&#123;chart-name&#125; .\$&#123;chart-dir&#125;\</span><br></pre></td></tr></table></figure>

<p>然后如果你想要在k8s环境中安装的时候,而k8s环境又在远端服务器,那么你可以将chart打包，然后到服务器中进行安装，然后也可以在<br>将chart上传到服务器中，然后进行安装(服务器中要先安装helm)。</p>
<h3 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h3><p>自此,从springcloud迁移到k8s集群总算是完成了。因为是第一次使用helm(以前都用的kustomize),所以在helm这里耗费了一些功夫，主要是排查错误方面的,不过不得不说helm的文档写得不错，很清晰。</p>
<p>再然后就是代码改造以及一些配置问题,因为迁移azure,所以上面的关于它pipeline的一些配置不是很清楚，不过好在可以直接练习他们的运维,还是帮我们解决了一些问题的。</p>
]]></content>
      <tags>
        <tag>springcloud</tag>
        <tag>springboot</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的垃圾回收算法以及垃圾回收器</title>
    <url>/2018/11/04/garbage-collection/</url>
    <content><![CDATA[<p>最新出来的ZGC对JVM的垃圾回收有了一个很大的颠覆,那就是内存不在分区了，直接一个大堆搞定，而且还能保证回收速率，虽然现在还是实验版本但是可以遇见，以后升级JDK,ZGC就是一个巨大的诱惑。</p>
<p>我们都知道,JVM将内存在逻辑上划分为了以下几个区域,而新创建的对象都是在堆上分配内存，所以我们的垃圾收集也是在堆上面。</p>
<p><img data-src="/images/thread-java-running-data-area.png" alt="JVM内存区域"></p>
<p>现在大量的应用使用JDK6-JDK8仍然是主流,了解垃圾回收可以帮助我们调优JVM，遇到JVM方面的问题不至于束手无策.所以研究JVM的垃圾回收很有必要，我们先介绍下垃圾搜集算法.</p>
<h2 id="收集算法"><a href="#收集算法" class="headerlink" title="收集算法"></a>收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>这是最基本的收集算法，分为“标记”和”清除“两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象,标记是通过”可达性分析算法“，这里不做过多展开。<br>这个算法存在两个问题,一个是效率问题，标记和清除两个过程的效率都不高;另一个是标记清除之后会产生大量的内存碎片，经过几次的GC之后这些碎片可能已经小到不足以分配任何对象了。</p>
<p><img data-src="/images/garbage-collection-mark-sweep.jpg" alt="标记清除算法"></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题,复制算法出现了，它是将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存使用完了,就将还存活着的对象复制到另一块上面,然后在将使用过的内存空间清理掉。</p>
<p>这种算法不要考虑内存碎片等复杂情况,只需要按照顺序分配即可，实现简单，运行高效。但是代价就是将内存缩小为了原来的一半，代价太高了。</p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代,我们使用的HotSpot也是。IBM公司的专门研究发现，98%的对象基本上都是朝生夕死的,所以不需要按照1:1的比例来划分内存空间,而是将内存划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和一块Survivor,当回收的时候将Eden和Survivor中还存活着的对象一次性复制到另一块空间上,最后清理Eden和刚才Survivor用过的空间。HotSpot虚拟机默认Eden和两块Survivor的分配比例是8:1:1.当然我们没有办法保证每次回收都只有不多于10%的对象存活,当Survivor空间不够时，这个时候会进行担保分配,直接将对象放到老年代。</p>
<p><img data-src="/images/garbage-collection-copy.jpg" alt="复制算法"></p>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>标记整理算法于“标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p>
<p><img data-src="/images/garbage-collection-mark-tidy.jpg" alt="标记整理算法"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>现在商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法只是根据对象存活周期的不同将内存划分为几块，一般是把对内存分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中每次垃圾收集时都有大量对象死去，只有少量存活。那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。<br>而老年代因为对象存活率高，没有额外空间对他进行担保分配，则必须使用“标记-清除”或者“标记-整理”算法来进行回收。<br>而老年代因为对象存活率高，没有额外空间对他进行担保分配，则必须使用“标记-清除”或者“标记-整理”算法来进行回收。</p>
<h2 id="堆的分代"><a href="#堆的分代" class="headerlink" title="堆的分代"></a>堆的分代</h2><p><img data-src="/images/garbage-collection-heap-generation.jpg" alt="堆的分代"></p>
<p>Perm区被称为永久代,其实它只是方法区的一种实现，JVM规范中这一块被称为方法区，只是对于HotSpot虚拟机上开发者来说是这样的，实际上其他虚拟机(BEA JRockit,IBM J9)来说是不存在永久代概念的。</p>
<p>JDK8之后方法区被MetaSpace取代了,对应的JVM配置参数也修改了(-XX:MetaspaceSize,-XX:MaxMetaspaceSize).</p>
<p>Minor GC又被称为Young GC,只收集young gen的GC<br>Major GC(old gc)主要指对老年代的回收,只有CMS的concurrent collection是这个模式<br>Full GC 收集整个堆，包含young gen,old gen,perm gen(metaspace)等所有部分的模式。<br>Mixed GC: 收集真个young gen以及部分old gen 的GC，只有G1又这种模式</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img data-src="/images/garbage-collection-collector.jpg" alt="垃圾收集器"></p>
<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程；</li>
<li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。<h3 id="年轻代垃圾收集器"><a href="#年轻代垃圾收集器" class="headerlink" title="年轻代垃圾收集器"></a>年轻代垃圾收集器</h3></li>
</ul>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>单线程收集器,只会使用一个CPU或一条收集线程去完成垃圾收集工作,在进行垃圾收集时必须暂停其他工作线程。采用了复制算法来进行垃圾收集，它是虚拟机运行在Client模式下的默认新生代收集器</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>ParNew收集器是Serial收集器的多线程版本，除了使用 多条线程进行垃圾收集之外，其余行为(JVM参数、收集算法、对象分配规则、回收策略、Stop The World等)和Serial收集器完全一样。但是它是许多运行在Server模式下的虚拟机中首选的新生代收集器，因为只有它能与CMS收集器配合工作。默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>使用了复制算法，该收集器的关注点是在吞吐量上面,主要适合在后台运算而不需要太多交互的任务。因此也被常称为“吞吐量优先“收集器。它有一个参数-XX:UseAdaptiveSizePolicy参数值得关注,当这个参数打开后，就不需要手工指定新生代的大小(-Xmn)、Eden与Survivor区的比例(-XX:SurvivorRatio)、晋升老年代对象年龄(-XX:PretenureSizeThreshold)等细节参数了。系统会动态调整这些参数以提供最合适的停顿事件或者最大的吞吐量,这种调节方式被成为GC的自适应调节策略。</p>
<p>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间),垃圾收集时间越短,吞吐量就越高。</p>
<h3 id="老年代垃圾收集器"><a href="#老年代垃圾收集器" class="headerlink" title="老年代垃圾收集器"></a>老年代垃圾收集器</h3><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial Old是Serial收集器的老年代版本,它同样是一个单线程收集器使用”标记-整理“算法。主要也是在client模式下使用，除此之外还有两大用途。一种是在JDK1.5以及之前的版本中于Parallel Scavenge收集器搭配使用(现在很少JDK1.5之前的版本，所以这个作用就基本废弃了）,另外一种是作为CMS收集器的后备预案，在并发收集发成Concurrent Mode Failure时使用。</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p>Parallel Old是Parallel Scavenge收集器的老年代版本,使用多线程的”标记-整理“算法。该收集器是在JDK6及之后才出现的，也就是说如果之前年轻代选怎了Parallel Scavenge，那么老年代只能选择Serial Old.但是现在终于有了对应的应用组合了，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge + Parallel Old收集器。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。是基于”标记-清除“算法实现的。<br>CMS收集器分为四个步骤：</p>
<ol>
<li>初始标记(CMS initial mark):仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，会stop the world</li>
<li>并发标记(CMS concurrent mark):进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿</li>
<li>重新标记(CMS remark):为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,会stop the world</li>
<li>并发清除(CMS concurrent sweep):不需要停顿</li>
</ol>
<p>CMS中中的初始标记和重新标记都会产生stop the world的行外,但是并发标记和并发清除收集器线程都可以和用户线程一起运行，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>CMS默认启动的回收线程数是(CPU数量+3)/4,也就是当CPU在四个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个(譬如2个)时，对用户程序的影响就比较大了，此时回收线程数为1,本来CPU负载就比较大，还分出一半的运算能力去执行收集器线程，就可能导致用户的执行速度降低了50%,令人难以接受，所以如果CPU数量过少,就不太适合使用CMS收集器。</p>
<p>CMS收集器无法处理浮动垃圾，可能会出现“Concurrent Mode Failure（并发模式故障）”失败而导致Full GC产生。<br>浮动垃圾：由于CMS并发清理阶段用户线程还在运行着，伴随着程序运行自然就会有新的垃圾不断产生，这部分垃圾出现的标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC中再清理。这些垃圾就是“浮动垃圾”。</p>
<p>由于垃圾收集阶段用户线程还需要运行，就需要有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了在进行收集，需要预留一部分空间提供并发收集时的程序运作使用，所以CMS的运行时机就需要好好把握。JDK1.5中当老年代使用了68%的空间之后CMS收集器会被激活，而这个值在JDK6中是92%，当然可以通过参数参数-XX:CMSInitiatingOccupancyFraction的值来设置触发百分比。<br>要是CMS运行期间预留的内存无法满足程序需要，就会出现一次”Concurrent Mode Failure”失败，这时虚拟机将启动后预案：临时使用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就更长了。所以-XX:CMSInitiatingOccupancyFraction参数要是设置得太高很容易导致大量“Concurrent Mode Failure”失败，性能反而降低。</p>
<p>上面也提到了CMS采用得算法是”标记-清除“，那么也意味者收集结束时会有大量空间碎片产生，当空间碎片过多，将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数(默认开启)用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发执行的,空间碎片问题没有了，但是停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction,这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的(默认为0,表示每次进入Full GC时都进行碎片整理)，这也算是一个折中方案了。</p>
<p>CMS收集器由于并发收集、低停顿,在现在大量的应用中还是处理主流地位的。</p>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。<br>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。<br>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p>
<p><img data-src="/images/garbage-collection-g1.png" alt="G1收集器划分"></p>
<p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。<br>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。<br><img data-src="/images/garbase-collection-g1-safepoint.jpg" alt="g1-safepoint"></p>
<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：* 初始标记* 并发标记* 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。* 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。具备如下特点：* 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。* 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。<br>关于G1收集器的其他参考文章：<a href="https://tech.meituan.com/g1.html">G1收集器</a></p>
<h2 id="回收方式的选择"><a href="#回收方式的选择" class="headerlink" title="回收方式的选择"></a>回收方式的选择</h2><p>jvm有client和server两种模式，这两种模式的gc默认方式是不同的：</p>
<p>client模式下，新生代选择的是串行gc，旧生代选择的是串行gc</p>
<p>server模式下，新生代选择的是并行回收gc，旧生代选择的是并行gc</p>
<p>一般来说我们系统应用选择有两种方式：吞吐量优先和暂停时间优先，对于吞吐量优先的采用server默认的并行gc方式，对于暂停时间优先的选用并发gc（CMS）方式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记住各个收集器之间如何搭配有助于查看线上GC日志的时候帮助定位问题，也是对JVM的一次深入了解。了解各个收集器的特性以及使用场景更有助于优化JVM。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>写给新手的 github 设置指南</title>
    <url>/2019/08/30/github-setting-manual/</url>
    <content><![CDATA[<p>如果你的团队决定在github上管理项目代码,那么下面这些设置你一定要会。</p>
<p>首先进入到仓库的Settings页面,左边会有菜单选项</p>
<h3 id="设置谁能提交代码"><a href="#设置谁能提交代码" class="headerlink" title="设置谁能提交代码"></a>设置谁能提交代码</h3><p><img data-src="/images/github/github_setting_member.png" alt="设置成员"></p>
<p>添加你的team成员账号,这样他们才能向这个仓库提交代码</p>
<a id="more"></a>

<h3 id="设置默认分支"><a href="#设置默认分支" class="headerlink" title="设置默认分支"></a>设置默认分支</h3><p>开发过程中,我们并不直接向master提交分支,而是会新建一个开发分支develop/1.0,所有人都只能向这个分支提交代码</p>
<p><img data-src="/images/github/github_setting_default_branch.png" alt="设置默认分支"></p>
<h3 id="设置提交规则"><a href="#设置提交规则" class="headerlink" title="设置提交规则"></a>设置提交规则</h3><p>有了分支之后，我们可以针对不同的分支设置不同的提交规则(Settings–&gt;Branches–&gt;add rule)</p>
<p><img data-src="/images/github/github_setting_branch_rule.png" alt="设置分支规则"></p>
<p>设置状态检查我们一般会集成jekins，它是CI/CD的主要工具，当我们提交代码的时候会通过WebHooks和Jekins通信，然后在jekins上编译代码，运行其他任务等等。</p>
<h3 id="不允许merge代码-只能rebase或者squash"><a href="#不允许merge代码-只能rebase或者squash" class="headerlink" title="不允许merge代码,只能rebase或者squash"></a>不允许merge代码,只能rebase或者squash</h3><p><img data-src="/images/github/github_setting_forbidden_merge.png" alt="禁止merge"></p>
<p>一般在实践中，merge后的分支会使得git tree很难看，所以我们一般不做merge，直接squash或者rebase</p>
<p><img data-src="/images/github/github_no_merge.png" alt="不允许merge"></p>
<h3 id="设置pull-request模板"><a href="#设置pull-request模板" class="headerlink" title="设置pull request模板"></a>设置pull request模板</h3><p>在当前project下新建.github文件夹,然后再文件夹下放置pull_request_template.md文件,文件内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## Description: </span><br><span class="line">-</span><br><span class="line">## Changes:</span><br><span class="line">-</span><br><span class="line">## Test Scope:</span><br><span class="line">-</span><br><span class="line">## Screenshots (optional)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后将此次修改推送到远端并合并此次请求。这样当我们提交pr的时候就出现了下面的模板</p>
<p><img data-src="/images/github/github_setting_pr_template.png" alt="提交pr"></p>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>如果你知道观察者模式,那你也应该了解下EventBus</title>
    <url>/2020/09/10/google-event-bus/</url>
    <content><![CDATA[<p>观察者模式又叫发布-订阅模式，它定义了一种一对多的依赖关系，多个观察者对象可同时监听某一主题对象，当该主题对象状态发生变化时，相应的所有观察者对象都可收到通知。<br>比如求职者，他们订阅了一些工作发布网站，当有合适的工作机会时，他们会收到提醒。</p>
<p>又或者是当用户注册网站成功的时候，发送一封邮件或者发送一条短信。我们都可以使用观察者模式来解决类似的问题</p>
<a id="more"></a>

<p>关于观察者模式的基本模型代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unregisterObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Message message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Message message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">  String id;</span><br><span class="line">  String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的主题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRegisterSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Observer&gt; observerList = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">      observerList.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">      observerList.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Observer observer : observerList) &#123;</span><br><span class="line">        observer.update(message);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegNotificationObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;注册成功，已经发送邮件给&quot;</span> + message.getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegOtherObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;注册成功，发送优惠券给&quot;</span> + message.getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 实际使用的时候配合Spring使用</span></span><br><span class="line">    Subject subject = <span class="keyword">new</span> UserRegisterSubject();</span><br><span class="line">    subject.registerObserver(<span class="keyword">new</span> RegNotificationObserver());</span><br><span class="line">    subject.registerObserver(<span class="keyword">new</span> RegOtherObserver());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> registSuccess = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(registSuccess) &#123;</span><br><span class="line">      Message msg = <span class="keyword">new</span> Message();</span><br><span class="line">      msg.setId(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">      msg.setName(<span class="string">&quot;think123&quot;</span>);</span><br><span class="line">      subject.notifyObservers(msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果如下:<br>注册成功，已经发送邮件给think123<br>注册成功，发送优惠券给think123</p>
<p>从上面的代码可以看出，观察者模式中我们首先需要注册观察者,然后当某个事件发生的时候通知观察者。</p>
<p>而在google guava中对于观察者模式的框架实现叫做EventBus,实现方式更为优雅,我们来看看如何使用EventBus,然后再深入分析下它的源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBusDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      EventBus eventBus = <span class="keyword">new</span> EventBus(<span class="string">&quot;think123&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Offer offer = <span class="keyword">new</span> Offer();</span><br><span class="line">    offer.setCompany(<span class="string">&quot;蚂蚁金服&quot;</span>);</span><br><span class="line">    offer.setMoney(<span class="number">20000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    eventBus.register(<span class="keyword">new</span> EmailNotificationObserver());</span><br><span class="line"></span><br><span class="line">    eventBus.register(<span class="keyword">new</span> MessageNotificationObserver());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 触发MessageNotification</span></span><br><span class="line">    eventBus.post(offer.getCompany());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发EmailNotification</span></span><br><span class="line">    eventBus.post(offer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Offer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String company;</span><br><span class="line">    <span class="keyword">private</span> Integer money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送邮件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailNotificationObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailNotification</span><span class="params">(Offer offer)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;恭喜你被 &quot;</span> + offer.getCompany() + <span class="string">&quot; 录取,每月工资为&quot;</span> + offer.getMoney() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageNotificationObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageNotification</span><span class="params">(String company)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;恭喜你被&quot;</span> + company + <span class="string">&quot;录取了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出来,EventBus的使用更加简单,我们只需要编写自己的observer就可以了，然后在需要处理通知的方法上加上<code>@Subscribe</code>注解就行了。然后当post传入参数的时候，就会找到哪些观察者可以处理这样的参数，就调用观察者的这个方法。</p>
<p>可以理解为观察者订阅了某个事件,当事件发生的时候，观察者会执行指定的动作。<br>比如EmailNotificationObserver订阅了Offer事件(事件就可以认为是参数)，所以在收到通知后会发送邮件(这里使用打印来代替)</p>
<p>让我们看看EventBus的核心代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标识EventBus,可以理解为name</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String identifier;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 具体的线程池,实际上directExecutor,它实际上是单线程</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异常处理器，负责处理异常</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SubscriberExceptionHandler exceptionHandler;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅中心,存储有哪些订阅者。 这里将eventBus传递给了订阅中心</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SubscriberRegistry subscribers = <span class="keyword">new</span> SubscriberRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件转发器,负责转发event给订阅者</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">(String identifier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(</span><br><span class="line">        identifier,</span><br><span class="line">        MoreExecutors.directExecutor(),</span><br><span class="line">        Dispatcher.perThreadDispatchQueue(),</span><br><span class="line">        LoggingHandler.INSTANCE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册订阅者</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    subscribers.register(object);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除订阅者</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    subscribers.unregister(object);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 投送event给所有注册的订阅者</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Subscriber&gt; eventSubscribers = subscribers.getSubscribers(event);</span><br><span class="line">    <span class="keyword">if</span> (eventSubscribers.hasNext()) &#123;</span><br><span class="line">      dispatcher.dispatch(event, eventSubscribers);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(event <span class="keyword">instanceof</span> DeadEvent)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 没有找到订阅者,则封装成DeadEvent(默认是丢弃掉了)</span></span><br><span class="line">      post(<span class="keyword">new</span> DeadEvent(<span class="keyword">this</span>, event));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>EventBus中主要的方法就是注册/移除订阅者，然后分发事件。保留了主体流程的同时也让不同的类承担自己的职责，真的很赞。</p>
<p>在注册订阅者中，会调用<code>findAllSubscribers</code>方法从缓存中加载已有的订阅者，并且为了保证线程安全，会使用<code>CopyOnWriteArraySet</code>来保存对应的订阅者。</p>
<p>订阅者为什么会存在多个(用了set保存)呢？这是因为我们eventBus.post方法的参数是Object类型,而在订阅者中可能会存在多个方法可以处理这个类型的参数(有多个订阅者都订阅了该事件)，所以会是多个。</p>
<p>然后会根据订阅者的Class加载所有标明了<code>@Subscribe</code>注解的方法，并将其放到缓存中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(Object listener)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从缓存中获取所有的订阅者</span></span><br><span class="line">  Multimap&lt;Class&lt;?&gt;, Subscriber&gt; listenerMethods = findAllSubscribers(listener);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;Class&lt;?&gt;, Collection&lt;Subscriber&gt;&gt; entry : listenerMethods.asMap().entrySet()) &#123;</span><br><span class="line">    Class&lt;?&gt; eventType = entry.getKey();</span><br><span class="line">    Collection&lt;Subscriber&gt; eventMethodsInListener = entry.getValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据参数类型获取到所有的订阅者</span></span><br><span class="line">    CopyOnWriteArraySet&lt;Subscriber&gt; eventSubscribers = subscribers.get(eventType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用CopyOnWriteArraySet，保证线程安全</span></span><br><span class="line">    <span class="keyword">if</span> (eventSubscribers == <span class="keyword">null</span>) &#123;</span><br><span class="line">      CopyOnWriteArraySet&lt;Subscriber&gt; newSet = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">      eventSubscribers =</span><br><span class="line">          MoreObjects.firstNonNull(subscribers.putIfAbsent(eventType, newSet), newSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eventSubscribers.addAll(eventMethodsInListener);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> Multimap&lt;Class&lt;?&gt;, Subscriber&gt; findAllSubscribers(Object listener) &#123;</span><br><span class="line">    Multimap&lt;Class&lt;?&gt;, Subscriber&gt; methodsInListener = HashMultimap.create();</span><br><span class="line">    Class&lt;?&gt; clazz = listener.getClass();</span><br><span class="line">    <span class="keyword">for</span> (Method method : getAnnotatedMethods(clazz)) &#123;</span><br><span class="line">      Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">      Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// Subscriber中保存了要执行的对象以及方法</span></span><br><span class="line">      <span class="comment">// eventType就是参数类型，这里就形成了参数类型---》订阅者的映射</span></span><br><span class="line">      <span class="comment">// 而订阅者中保存了具体需要执行的类以及方法</span></span><br><span class="line">      methodsInListener.put(eventType, Subscriber.create(bus, listener, method));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> methodsInListener;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当缓存中没有的时候，会调用这个方法。所以最开始注册订阅者的时候都会调用这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ImmutableList&lt;Method&gt; <span class="title">getAnnotatedMethodsNotCached</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    Set&lt;? extends Class&lt;?&gt;&gt; supertypes = TypeToken.of(clazz).getTypes().rawTypes();</span><br><span class="line">    Map&lt;MethodIdentifier, Method&gt; identifiers = Maps.newHashMap();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; supertype : supertypes) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Method method : supertype.getDeclaredMethods()) &#123;</span><br><span class="line">        <span class="comment">// 只处理被Subscribe注解标明的方法并且method不能是合成的(isSynthetic)</span></span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(Subscribe.class) &amp;&amp; !method.isSynthetic()) &#123;</span><br><span class="line">          Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">          <span class="comment">// 参数个数只能为1</span></span><br><span class="line">          checkArgument(</span><br><span class="line">              parameterTypes.length == <span class="number">1</span>,</span><br><span class="line">              <span class="string">&quot;Method %s has @Subscribe annotation but has %s parameters.&quot;</span></span><br><span class="line">                  + <span class="string">&quot;Subscriber methods must have exactly 1 parameter.&quot;</span>,</span><br><span class="line">              method,</span><br><span class="line">              parameterTypes.length);</span><br><span class="line"></span><br><span class="line">          MethodIdentifier ident = <span class="keyword">new</span> MethodIdentifier(method);</span><br><span class="line">          <span class="keyword">if</span> (!identifiers.containsKey(ident)) &#123;</span><br><span class="line">            identifiers.put(ident, method);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ImmutableList.copyOf(identifiers.values());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到,EventBus的订阅者之所以不用实现特定的接口实际上是利用了反射将订阅者和要执行的方法对应起来了的。</p>
<p>经过register方法之后，我们就知道每个订阅者分别订阅了哪些事件(能处理什么参数),并且形成了这样的对应关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事件类型(参数) ---&gt; 订阅者(target object, method)</span><br><span class="line"></span><br><span class="line">Offer  --&gt; EmailNotificationObserver::mailNotification</span><br><span class="line"></span><br><span class="line">String --&gt; MessageNotificationObserver::messageNotification</span><br></pre></td></tr></table></figure>

<p>EventBus中，我们会通过post方法分发事件。在post方法中，首先会根据参数找到我们之前处理好的对应关系,然后通过反射调用对应的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Subscriber&gt; eventSubscribers = subscribers.getSubscribers(event);</span><br><span class="line">    <span class="keyword">if</span> (eventSubscribers.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 转发事件</span></span><br><span class="line">      dispatcher.dispatch(event, eventSubscribers);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(event <span class="keyword">instanceof</span> DeadEvent)) &#123;</span><br><span class="line">      <span class="comment">// 对于找不到订阅者的包装成DeadEvent处理,实际上就是丢弃掉</span></span><br><span class="line">      post(<span class="keyword">new</span> DeadEvent(<span class="keyword">this</span>, event));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PerThreadQueuedDispatcher实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Object event, Iterator&lt;Subscriber&gt; subscribers)</span> </span>&#123;</span><br><span class="line">  checkNotNull(event);</span><br><span class="line">  checkNotNull(subscribers);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每个线程都对应一个队列,如果多线程插入则先来的先处理</span></span><br><span class="line">  Queue&lt;Event&gt; queueForThread = queue.get();</span><br><span class="line">  queueForThread.offer(<span class="keyword">new</span> Event(event, subscribers));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dispatching.get()) &#123;</span><br><span class="line">    dispatching.set(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Event nextEvent;</span><br><span class="line">      <span class="comment">// 找到对应的订阅者进行处理</span></span><br><span class="line">      <span class="keyword">while</span> ((nextEvent = queueForThread.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nextEvent.subscribers.hasNext()) &#123;</span><br><span class="line">          nextEvent.subscribers.next().dispatchEvent(nextEvent.event);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      dispatching.remove();</span><br><span class="line">      queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Dispatcher是一个抽象类，这个类的作用是负责转发event给订阅者，提供不同的event顺序。这里这样的实现主要是考虑到了多线程。</p>
<p>我们的默认实现使用的是PerThreadQueuedDispatcher，看名字的意思就是每个线程一个队列，实行先来先处理的原则。</p>
<p>最终调用Subscriber的invokeSubscriberMethod()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(<span class="keyword">final</span> Object event)</span> </span>&#123;</span><br><span class="line">  executor.execute(</span><br><span class="line">    <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          invokeSubscriberMethod(event);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">          bus.handleSubscriberException(e.getCause(), context(event));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriberMethod</span><span class="params">(Object event)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 省略异常捕获代码</span></span><br><span class="line">  <span class="comment">// 反射调用方法执行 </span></span><br><span class="line">  method.invoke(target, checkNotNull(event));  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终这样就调用了我们使用<code>@Subscribe</code>注解标明的方法了。</p>
<p>而这里的executor实际上是创建EventBus的executor,它的execute方法实现如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GwtCompatible</span></span><br><span class="line"><span class="keyword">enum</span> DirectExecutor implements Executor &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    command.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以说EventBus实际上是同步阻塞执行，那么为什么还要写成线程池的方式呢？虽然EventBus默认是同步执行的，但是它还有一个异步执行的子类AsyncEventBus,异步的EventBus需要指定线程池，所以这里是为了兼容才这么写的。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase备份容灾常用命令</title>
    <url>/2018/12/17/hbase-backup-command/</url>
    <content><![CDATA[<p>灾难恢复是个令人神经紧张的话题,但必须面对.HBase虽然是一个分布式的数据库，但是有时候容灾以及数据备份仍然是需要考虑的，而掌握常用的命令正是写这篇文章的意义所在。<br>本文主要通过案例来讲解CopyTable,Import,Export,Snapshot,希望大家对它们的使用有一个直观的认识。</p>
<a id="more"></a>



<h3 id="CopyTable"><a href="#CopyTable" class="headerlink" title="CopyTable"></a>CopyTable</h3><pre><code>- 支持时间区间,row区间，改变表名称，改变列族名称，指定是否copy已经被删除的数据等功能
- CopyTable工具采用scan查询，写入新表时采用put和delete API,全是基于hbase的client api进行读写</code></pre>
<ol>
<li><p>首先需要新建好备份表，保证columnFamily一致<br><img data-src="/images/hbase-command/hbase-copytable-ready.png" alt="新建备份表"></p>
</li>
<li><p>在另外一个窗口中,进入hbase/bin目录下，执行以下命令(fileTableNew是备份的表,fileTable是原始表)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hbase org.apache.hadoop.hbase.mapreduce.CopyTable --new.name&#x3D;fileTableNew fileTable</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/hbase-command/hbase-copytable-result.png" alt="查看结果"></p>
</li>
</ol>
<h3 id="Export-Import"><a href="#Export-Import" class="headerlink" title="Export/Import"></a>Export/Import</h3><pre><code>1. Export可导出数据到目标集群,然后可在目标集群Import导入数据，Export支持指定开始时间和结束时间，因为可以做增量备份
2. Export导出工具与CopyTable一样是依赖hbase的scan读取数据</code></pre>
<h4 id="Export语法"><a href="#Export语法" class="headerlink" title="Export语法"></a>Export语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;hbase org.apache.hadoop.hbase.mapreduce.Export &lt;tablename&gt; hdfs:&#x2F;&#x2F;namenode:9000&#x2F;table_bak &lt;version&gt; &lt;startTime&gt; &lt;endTime&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Import语法"><a href="#Import语法" class="headerlink" title="Import语法"></a>Import语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;hbase -Dhbase.import.version&#x3D;0.94 org.apache.hadoop.hbase.mapreduce.Import &lt;tablename&gt; &lt;inputdir&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>查看hbase数据库，只存在fileTable表<br><img data-src="/images/hbase-command/hbase-export-ready.png" alt="数据准备"></p>
</li>
<li><p>执行导出语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#这里存储的路径是存储在hdfs上面的</span><br><span class="line">.&#x2F;hbase org.apache.hadoop.hbase.mapreduce.Export fileTable &#x2F;usr&#x2F;local&#x2F;hbase&#x2F;fileTable.db</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="/images/hbase-command/hbase-export-table.png" alt="查看导出的表"></p>
</li>
<li><p>新建需要导入的表，确保导入之前的表和导入后的表结构一致(相同的列簇)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create &#39;fileTableNew&#39;,&#39;fileInfo&#39;,&#39;saveInfo&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行导入语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;hbase org.apache.hadoop.hbase.mapreduce.Import fileTableNew &#x2F;usr&#x2F;local&#x2F;hbase&#x2F;fileTable.db</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img data-src="/images/hbase-command/hbase-import-table.png" alt="查看导入的数据"></p>
<h3 id="快照的处理"><a href="#快照的处理" class="headerlink" title="快照的处理"></a>快照的处理</h3><h4 id="创建快照"><a href="#创建快照" class="headerlink" title="创建快照"></a>创建快照</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">snapshot &#39;myTable&#39;,&#39;myTableSnapshot-181210&#39;</span><br></pre></td></tr></table></figure>

<h4 id="克隆快照"><a href="#克隆快照" class="headerlink" title="克隆快照"></a>克隆快照</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clone_snapshot &#39;myTableSnapshot-181210&#39;, &#39;myNewTestTable&#39;</span><br></pre></td></tr></table></figure>

<h4 id="列出快照"><a href="#列出快照" class="headerlink" title="列出快照"></a>列出快照</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list_snapshots</span><br></pre></td></tr></table></figure>

<h4 id="删除快照"><a href="#删除快照" class="headerlink" title="删除快照"></a>删除快照</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete_snapshot &#39;myTableSnapshot-181210&#39;</span><br></pre></td></tr></table></figure>

<h4 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">disable &#39;myTable&#39;</span><br><span class="line">restore_snapshot &#39;myTableSnapshot-181210&#39;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/hbase-command/hbase-snapshot-create.png" alt="创建快照"></p>
<p><img data-src="/images/hbase-command/hbase-snapshot-restore.png" alt="恢复快照"></p>
<h3 id="查看Hadoop集群信息"><a href="#查看Hadoop集群信息" class="headerlink" title="查看Hadoop集群信息"></a>查看Hadoop集群信息</h3><ol>
<li><code>http://ip:50070</code><br><a href="http://ip:50070/jmx%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0json%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%B6%88%E6%81%AF%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E7%BC%96%E7%A0%81%E8%8E%B7%E5%8F%96%E5%80%BC%EF%BC%8Chttp://ip:50070/jmx?qry=">http://ip:50070/jmx可以看到json格式的消息，也可以通过编码获取值，http://ip:50070/jmx?qry=</a>&lt;json中name的值&gt;，比如<a href="http://192.168.239.134:50070/jmx?qry=java.lang:type=MemoryPool,name=Survivor%20Space">http://192.168.239.134:50070/jmx?qry=java.lang:type=MemoryPool,name=Survivor%20Space</a></li>
</ol>
<h3 id="查看hbase集群信息"><a href="#查看hbase集群信息" class="headerlink" title="查看hbase集群信息"></a>查看hbase集群信息</h3><ol>
<li><code>http://ip:16010</code><br><a href="http://ip:16010/jmx%EF%BC%8C%E5%90%8C%E6%A0%B7%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87qry%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4">http://ip:16010/jmx，同样也可以通过qry进行过滤</a></li>
</ol>
]]></content>
      <categories>
        <category>HBase</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase的常用基础命令</title>
    <url>/2018/12/17/hbase-basic-command/</url>
    <content><![CDATA[<p><img data-src="/images/hbase-command/hbase-logo.png" alt="hbase"></p>
<a id="more"></a>

<ol>
<li>查看hbase状态<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">status</span><br></pre></td></tr></table></figure>
<img data-src="/images/hbase-command/hbase-status.png" alt="status"></li>
</ol>
<ol start="2">
<li><p>列出所有表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/hbase-command/hbase-list.png" alt="list"></p>
</li>
<li><p>新建表(需要指定列簇)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create &#39;tableName&#39;,&#39;columnFamilyName1&#39;,&#39;columnFamilyName2&#39;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/hbase-command/hbase-create.png" alt="create"></p>
</li>
<li><p>追加一个列簇</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter &#39;tableName&#39;,&#39;columnFamilyName3&#39;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/hbase-command/hbase-alter.png" alt="alter"></p>
</li>
<li><p>删除一个列簇</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter &#39;tableName&#39;,&#123;NAME&#x3D;&gt;&#39;columnFamilyName&#39;,METHOD&#x3D;&gt;&#39;delete&#39;&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/hbase-command/hbase-alter-delete.png" alt="alter-delete"></p>
</li>
</ol>
<ol start="6">
<li>查看一个表的描述信息(可以查看有哪些列簇)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc &#39;tableName&#39;</span><br></pre></td></tr></table></figure>
<img data-src="/images/hbase-command/hbase-desc.png" alt="desc"></li>
</ol>
<ol start="7">
<li><p>插入数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">put &#39;tableName&#39;,&#39;rowkey&#39;,&#39;columnFamilyName:columnName&#39;,&#39;columnValue&#39;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/hbase-command/hbase-put.png" alt="put"></p>
</li>
<li><p>获取数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get &#39;tableName&#39;, &#39;rowkey&#39;</span><br><span class="line"></span><br><span class="line">get &#39;tableName&#39;, &#39;rowkey&#39;, &#39;columnFamilyName:columnName&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="/images/hbase-command/hbase-get.png" alt="get"></p>
<p> get命令还可以指定版本等信息,可以通过 <code>help &#39;get&#39; </code>查看</p>
</li>
<li><p>scan的使用<br><img data-src="/images/hbase-command/hbase-scan.png" alt="scan"></p>
<p> scan命令的更多介绍将在下一篇文章介绍</p>
</li>
<li><p>删除某一列的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete &#39;tableName&#39;,&#39;rowKey&#39;,&#39;columnFamilyName:columnName&#39;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/hbase-command/hbase-delete.png" alt="delete"></p>
</li>
<li><p>删除某一行的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deleteall &#39;tableName&#39;,&#39;rowKey&#39;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/hbase-command/hbase-deleteall.png" alt="deleteall"></p>
</li>
</ol>
<ol start="12">
<li><p>删除一张表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">disable &#39;tableName&#39;</span><br><span class="line">drop &#39;tableName&#39;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/hbase-command/hbase-drop.png" alt="drop"></p>
</li>
<li><p>查看表是否存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exists &#39;tableName&#39;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/hbase-command/hbase-exists.png" alt="exists"></p>
</li>
<li><p>清空表数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truncate &#39;tableName&#39;</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/hbase-command/hbase-truncate.png" alt="truncate"></p>
</li>
<li><p>参考文档<br><a href="https://learnhbase.net/">https://learnhbase.net/</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>HBase</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase scan命令详解</title>
    <url>/2018/12/17/hbase-scan-command/</url>
    <content><![CDATA[<p>hbase中scan命令是我们经常使用到的，而filter的作用尤其强大。这里简要的介绍下scan下filter命令的使用.</p>
<h3 id="插入scan命令需要的数据"><a href="#插入scan命令需要的数据" class="headerlink" title="插入scan命令需要的数据"></a>插入scan命令需要的数据</h3><p>这里模拟了部分微博评论的数据,然后使用代码插入数据到hbase,代码就不列出来了比较简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Comment</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1--&gt;普通文章，2---&gt;热点文章</span></span><br><span class="line">    Integer articleType;</span><br><span class="line">    <span class="comment">//文章id</span></span><br><span class="line">    String articleId;</span><br><span class="line">    String userId;</span><br><span class="line">    <span class="keyword">long</span> timestamp;</span><br><span class="line">    <span class="comment">//comment content,暂时只考虑文本</span></span><br><span class="line">    String commentContent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>hbase的表名称为zy_comment,列簇info下有articleType以及commentInfo两个列。commentInfo的value为上面Comment类的json字符串,插入的数据如下所示<br><img data-src="/images/hbase-command/hbase-scan-readydata1.png" alt="插入数据"><br><img data-src="/images/hbase-command/hbase-scan-readydata2.png" alt="插入数据"></p>
<h3 id="HBase数据顺序"><a href="#HBase数据顺序" class="headerlink" title="HBase数据顺序"></a>HBase数据顺序</h3><p>HBase是三维有序存储的，是指rowkey（行键），column key（column family和qualifier）和TimeStamp（时间戳）这个三个维度是依照ASCII码表排序的。（比如A排在a前面）</p>
<ol>
<li>先rowkey升序排序，</li>
<li>rowkey相同则column key升序排序</li>
<li>rowkey、column key相同则timestamp降序排序</li>
</ol>
<h3 id="支持的Filter"><a href="#支持的Filter" class="headerlink" title="支持的Filter"></a>支持的Filter</h3><p>scan命令我们经常会大量使用Filter,hbase shell提供的filter都可以在hbase client包中找到对应的类，它们都是Filter的子类，很多命令都是通过filter来进行实现的。<br><img data-src="/images/hbase-command/hbase-scan-javafilter.png" alt="filter"></p>
<p>使用<code>show_filters</code>命令查看shell中定义了哪些filter常量,如果想要使用shell中未定义的常量,在使用的时候必须手动import filter的全路径。<br><img data-src="/images/hbase-command/hbase-show-filter.png" alt="filter"></p>
<h3 id="scan的用法"><a href="#scan的用法" class="headerlink" title="scan的用法"></a>scan的用法</h3><p>使用 <code>help &#39;scan&#39;</code> 命令可以查看scan的语法以及用法,关于scan命令中filter的使用规则如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scan &#39;tableName&#39;,&#123;FILTER&#x3D;&gt;&quot;FilterName(param1,param2,...,paramN)&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>{}中的语法是ruby的map的语法，FILTER必须大写,filter的参数是根据构造方法来的，也就是相当于java中的new Filter(‘param1’,’param2’)等，这里只是省略了new参数而已。<br>当然同样可以使用ruby中new对象的方式，只是那样就必须使用全限定名称。后面会举一个全限定名称的例子。</p>
<p>在使用Filter的过程中部分filter会用到比较器(CompareOperator.java)以及运算比较符(ByteArrayComparable.java)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CompareOperator &#123;</span><br><span class="line">    LESS,   <span class="comment">// &lt;</span></span><br><span class="line">    LESS_OR_EQUAL,    <span class="comment">// &lt;=</span></span><br><span class="line">    EQUAL,    <span class="comment">// =</span></span><br><span class="line">    NOT_EQUAL, <span class="comment">// &lt;&gt;</span></span><br><span class="line">    GREATER_OR_EQUAL, <span class="comment">// &gt;=</span></span><br><span class="line">    GREATER, <span class="comment">// &gt;</span></span><br><span class="line">    NO_OP; <span class="comment">// 没有任何操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CompareOperator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比较器主要有以下几种:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BinaryComparator 按字节索引顺序比较指定字节数组，采用Bytes.compareTo(byte[]),比如:binary:\x00\x00\x02</span><br><span class="line">BinaryPrefixComparator 跟前面相同，只是比较左端的数据是否相同,比如:binaryprefix:\x00\x00</span><br><span class="line">NullComparator 判断给定的是否为空,不常用</span><br><span class="line">BitComparator 按位比较 a BitwiseOp class 做异或，与，并操作，不常用</span><br><span class="line">RegexStringComparator 提供一个正则的比较器，仅支持 EQUAL 和非EQUAL,比如:regexstring:ab*add</span><br><span class="line">SubstringComparator 判断提供的子串是否出现在table的value中。比如：substring:great</span><br></pre></td></tr></table></figure>

<h3 id="scan例子"><a href="#scan例子" class="headerlink" title="scan例子"></a>scan例子</h3><p>查询方式通过rowKey来进行查询是最快的，所以rowkey的设计一定要合理，如果不合理会很影响查询速率。但是有时候确实没有办法完全通过rowkey来查询，所以就要借助scan.<br>scan命令支持的修饰词除了列（<code>COLUMNS</code>）修饰词外，HBase还支持<code>Limit</code>（限制查询结果行数），<code>STARTROW</code>（ROWKEY起始行。会先根据这个key定位到region，再向后扫描）、<code>STOPROW</code>(结束行)、<code>TIMERANGE</code>（限定时间戳范围）、<code>VERSIONS</code>（版本数）、和<code>FILTER</code>（按条件过滤行）等</p>
<ol>
<li>查询user是zhangsan的用户的评论数据,最多只返回10条<br><code>scan &#39;zy_comment&#39;,&#123;LIMIT=&gt;10,FILTER=&gt;&quot;PrefixFilter(&#39;zhangsan&#39;)&quot;&#125;</code><br> <img data-src="/images/hbase-command/hbase-scan-prefixfilter.png" alt="scan命令"></li>
</ol>
<ol start="2">
<li><p>通过startrow,stoprow来进行查询(这种也比较快,实际操作中如果不能通过rowkey)<br><code>scan &#39;zy_comment&#39;,&#123;STARTROW=&gt;&#39;b&#39;,STOPROW=&#39;e&#39;,LIMIT=&gt;10&#125;</code><br> <img data-src="/images/hbase-command/hbase-scan-startendrow.png" alt="scan命令"></p>
</li>
<li><p>查询评论内容为666的评论有哪些<br><code>scan &#39;zy_comment&#39;,&#123;LIMIT=&gt;10,FILTER=&gt;&quot;ValueFilter(=,&#39;substring:666&#39;)&quot;&#125;</code><br> <img data-src="/images/hbase-command/hbase-scan-valuefilter.png" alt="scan命令"></p>
</li>
<li><p>查询热点文章的数据有哪些</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scan &#39;zy_comment&#39;,&#123;LIMIT&#x3D;&gt;10,FILTER&#x3D;&quot;SingleColumnValueFilter(&#39;info&#39;,&#39;articleType&#39;,&#x3D;,&#39;binary: \x00\x00\x00\x00\x00\x00\x00\x02&#39;)&quot;&#125;</span><br></pre></td></tr></table></figure>
<p> <img data-src="/images/hbase-command/hbase-scan-singlecolumn.png" alt="scan命令"></p>
<p> 这里binary中的数据一定要是二进制字符串而不是具体的值</p>
</li>
</ol>
<ol start="5">
<li><p>查看评论包含great的热点文章评论有哪些</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scan &#39;zy_comment&#39;,&#123;LIMIT&#x3D;&gt;3,FILTER&#x3D;&gt;&quot;(SingleColumnValueFilter(&#39;info&#39;,&#39;articleType&#39;,&#x3D;,&#39;binary:\x00\x00\x00\x00\x00\x00\x00\x02&#39;)) AND (ColumnPrefixFilter(&#39;commentInfo&#39;) AND ValueFilter(&#x3D;,&#39;substring:great&#39;))&quot;&#125;</span><br></pre></td></tr></table></figure>
<p> <img data-src="/images/hbase-command/hbase-scan-multifilter.png" alt="scan命令"></p>
</li>
<li><p>查询评论的前两条<br><code>scan &#39;zy_comment&#39;,&#123;FILTER=&gt;&quot;PageFilter(2)&quot;&#125;</code>和LIMIT有异曲同工之妙<br> <img data-src="/images/hbase-command/hbase-scan-pagefilter.png" alt="scan命令"></p>
</li>
<li><p>查询rowkey中包含特定前缀的数据<br><code>scan &#39;zy_comment&#39;,&#123;FILTER=&gt;&quot;RowFilter(=,&#39;substring:zhangsan&#39;)&quot;&#125;</code></p>
<p> <img data-src="/images/hbase-command/hbase-scan-rowfilter1.png" alt="scan命令"></p>
<p> <img data-src="/images/hbase-command/hbase-scan-rowfilter2.png" alt="scan命令"></p>
</li>
<li><p>使用全限定名称查询articleId是123456的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.apache.hadoop.hbase.filter.SingleColumnValueFilter</span><br><span class="line">import org.apache.hadoop.hbase.filter.CompareFilter</span><br><span class="line">import org.apache.hadoop.hbase.filter.SubstringComparator</span><br><span class="line">scan &#39;zy_comment&#39;, &#123;COLUMNS&#x3D;&gt;[&#39;info:commentInfo&#39;], FILTER &#x3D;&gt; SingleColumnValueFilter.new(Bytes.toBytes(&#39;info&#39;), Bytes.toBytes(&#39;commentInfo&#39;), CompareFilter::CompareOp.valueOf(&#39;EQUAL&#39;), SubstringComparator.new(&#39;123456&#39;))&#125;</span><br></pre></td></tr></table></figure>

<p> <img data-src="/images/hbase-command/hbase-scan-filter-fullpath.png" alt="scan命令"></p>
</li>
</ol>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>如果scan中指定了COLUMNS，则FILTER中所使用的列需要包含在所指定的COLUMNS中，否则，filter不起作用。</li>
<li>HBase中主要的操作对象是一个个的cell，每个cell都可以有多个版本。如果使用过滤器ValueFilter，就会只有那些符合条件的cell被查出来。跟关系数据库的查询不同，关系数据库查出来的结果中各行都有相同的列。而HBase，查出来的结果中，不同的行会有不同的列。</li>
<li>filter不会降低服务方的IO，它会把符合条件的子集传给客户端。即，它是在对查出的结果进行过滤，而不是象原来sql中的where子句。所以，如果要查出的结果中不包含filter需要的列，则filter就不能发挥作用。</li>
</ul>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://acadgild.com/blog/different-types-of-filters-in-hbase-shell">https://acadgild.com/blog/different-types-of-filters-in-hbase-shell</a><br><a href="https://blog.csdn.net/u012185296/article/details/47338549">https://blog.csdn.net/u012185296/article/details/47338549</a></p>
]]></content>
      <categories>
        <category>HBase</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>helm常用命令</title>
    <url>/2023/11/07/helm-use/</url>
    <content><![CDATA[<h3 id="helm官方文档"><a href="#helm官方文档" class="headerlink" title="helm官方文档"></a>helm官方文档</h3><p>hi, bro, 最好的永远是官方文档: <a href="https://helm.sh/zh/docs/">https://helm.sh/zh/docs/</a></p>
<p>就是它上面的东西太多了，我知道你看得费力，所以我给你总结了下面的常用命令</p>
<h3 id="helm添加仓库"><a href="#helm添加仓库" class="headerlink" title="helm添加仓库"></a>helm添加仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm repo add  elastic  https:&#x2F;&#x2F;helm.elastic.co       </span><br><span class="line">helm repo add  gitlab   https:&#x2F;&#x2F;charts.gitlab.io       </span><br><span class="line">helm repo add  harbor   https:&#x2F;&#x2F;helm.goharbor.io</span><br><span class="line">helm repo add traefik   https:&#x2F;&#x2F;traefik.github.io&#x2F;charts    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加国内仓库       </span><br><span class="line">helm repo add stable http:&#x2F;&#x2F;mirror.azure.cn&#x2F;kubernetes&#x2F;charts       </span><br><span class="line">helm repo add aliyun https:&#x2F;&#x2F;kubernetes.oss-cn-hangzhou.aliyuncs.com&#x2F;charts       </span><br><span class="line">helm repo update       </span><br><span class="line">helm repo list</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<a id="more"></a>


<h3 id="搜索chart"><a href="#搜索chart" class="headerlink" title="搜索chart"></a>搜索chart</h3><ol>
<li><code>helm search repo traefik/traefik</code></li>
<li><code>helm search repo nginx</code></li>
</ol>
<h3 id="安装或者查看出错时"><a href="#安装或者查看出错时" class="headerlink" title="安装或者查看出错时"></a>安装或者查看出错时</h3><p>出现报错 Error: Kubernetes cluster unreachable: Get “<a href="http://localhost:8080/version&quot;">http://localhost:8080/version&quot;</a>: dial tcp 127.0.0.1:8080</p>
<p>需要指定kubernetes api server地址,可以通过</p>
<p><code>helm --kube-apiserver address</code></p>
<h3 id="安装chart"><a href="#安装chart" class="headerlink" title="安装chart"></a>安装chart</h3><ol>
<li><code>helm repo update</code></li>
<li><code>helm install bitnami/mysql --generate-name</code><blockquote>
<p>在 Helm 3 中，必须主动指定release名称，或者增加 –generate-name 的参数使Helm自动生成</p>
</blockquote>
</li>
</ol>
<h3 id="查看安装的chart"><a href="#查看安装的chart" class="headerlink" title="查看安装的chart"></a>查看安装的chart</h3><ol>
<li><code>helm list(helm ls)</code></li>
</ol>
<h3 id="卸载chart"><a href="#卸载chart" class="headerlink" title="卸载chart"></a>卸载chart</h3><ol>
<li><code>helm uninstall mysql-xxx</code></li>
</ol>
<h3 id="安装traefik"><a href="#安装traefik" class="headerlink" title="安装traefik"></a>安装traefik</h3><ol>
<li>安装traefik,并指定对应参数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm install --set deployment.kind&#x3D;DaemonSet --set namespaceOverride&#x3D;traefik --set service.enabled&#x3D;false traefik traefik&#x2F;traefik</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>端口转发，像访问本地服务一样访问traefik</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl port-forward $(kubectl get pods --selector &quot;app.kubernetes.io&#x2F;name&#x3D;traefik&quot; -n traefik --output&#x3D;name) 9000:9000 -n traefik</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>更新服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm upgrade --set deployment.kind&#x3D;DaemonSet --set namespaceOverride&#x3D;traefik --set service.enabled&#x3D;false traefik traefik&#x2F;traefik</span><br></pre></td></tr></table></figure>
</li>
<li><p>配合Azure使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm install --set deployment.kind&#x3D;DaemonSet --set namespaceOverride&#x3D;traefik --set service.annotations.&quot;service.beta.kubernetes.io&#x2F;azure-load-balancer-internal&quot;&#x3D;true  traefik traefik&#x2F;traefik</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="安装时报错内存不足"><a href="#安装时报错内存不足" class="headerlink" title="安装时报错内存不足"></a>安装时报错内存不足</h3><p>0/2 nodes are available: 2 Insufficient memory. preemption: 0/2 nodes are available: 2 No preemption victims found for incoming pod</p>
<p>这是因为我们的chart在安装的时候，k8s集群内存不足。</p>
<p>可以通过下面的命令查看node的内存状况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl describe node </span><br></pre></td></tr></table></figure>

<p>可以在安装的时候调整服务所需的内存,CPU等，也可以给集群加机器添加内存。</p>
<h3 id="查看chart信息"><a href="#查看chart信息" class="headerlink" title="查看chart信息"></a>查看chart信息</h3><p>+. 查看基本信息: <code>helm show chart traefik/traefik</code><br>+. 查看所有信息: <code>helm show all traefik/traefik</code></p>
<h3 id="查看chart的可配置选项"><a href="#查看chart的可配置选项" class="headerlink" title="查看chart的可配置选项"></a>查看chart的可配置选项</h3><ol>
<li><code>helm show values traefik/traefik</code></li>
</ol>
<p>然后，你可以使用 YAML 格式的文件覆盖上述任意配置项，并在安装过程中使用该文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. echo &#39;&#123;web.port: 8080&#125;&#39; &gt; values.yml</span><br><span class="line">3. helm install -f values.yml traefik&#x2F;traefik --generate-name</span><br></pre></td></tr></table></figure>

<p>还可以直接使用 –set web.port=8080 指定,优先级比-f(–values)高</p>
<h3 id="创建并安装自己的charts"><a href="#创建并安装自己的charts" class="headerlink" title="创建并安装自己的charts"></a>创建并安装自己的charts</h3><ol>
<li><code>helm create think-manifesto</code></li>
<li><code>heml package think-manifesto</code></li>
<li><code>helm install think-manifesto</code> 上一步打包好的tgz包</li>
</ol>
<h3 id="debug-chart而不安装"><a href="#debug-chart而不安装" class="headerlink" title="debug chart而不安装"></a>debug chart而不安装</h3><p><code>helm install --debug --dry-run goodly-guppy ./mychart</code></p>
<p>这样不会安装应用(chart)到你的kubenetes集群中，只会渲染模板内容到控制台</p>
<p>如果想看渲染出错的内容,可以加上另外参数</p>
<p><code>helm install --dry-run --disable-openapi-validation moldy-jaguar ./mychart</code></p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><ul>
<li><code>helm lin</code>t 是验证chart是否遵循最佳实践的首选工具。</li>
<li><code>helm template --debug</code> 在本地测试渲染chart模板。</li>
<li><code>helm install --dry-run --debug</code>：我们已经看到过这个技巧了，这是让服务器渲染模板的好方法，然后返回生成的清单文件。</li>
<li><code>helm get manifest</code>: 这是查看安装在服务器上的模板的好方法。</li>
</ul>
<p><code>helm template --dry-run --debug --disable-openapi-validation thinkpro-test .\think-manifesto\</code></p>
<h3 id="helm内置对象"><a href="#helm内置对象" class="headerlink" title="helm内置对象"></a>helm内置对象</h3><p><a href="https://helm.sh/zh/docs/chart_template_guide/builtin_objects/">https://helm.sh/zh/docs/chart_template_guide/builtin_objects/</a></p>
<h4 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h4><p>Release对象描述了版本发布本身。包含了以下对象：</p>
<ol>
<li>Release.Name： release名称</li>
<li>Release.Namespace： 版本中包含的命名空间(如果manifest没有覆盖的话)</li>
</ol>
<h4 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h4><p>Values对象是从values.yaml文件和用户提供的文件传进模板的。默认为空</p>
<h4 id="Chart"><a href="#Chart" class="headerlink" title="Chart"></a>Chart</h4><p>Chart.yaml文件内容。 Chart.yaml里的所有数据在这里都可以可访问的。比如 <code>&#123;&#123; .Chart.Name &#125;&#125;-&#123;&#123; .Chart.Version &#125;&#125;</code> 会打印出 mychart-0.1.0</p>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p>模板中频繁使用的一个函数是default： default DEFAULT_VALUE GIVEN_VALUE。 这个函数允许你在模板中指定一个默认值，以防这个值被忽略. 当然还可以使用管道符配合使用,比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drink: &#123;&#123; .Values.favorite.drink | default &quot;tea&quot; | quote &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除空白"><a href="#删除空白" class="headerlink" title="删除空白"></a>删除空白</h3><p><code>&#123;&#123;-` (包括添加的横杠和空格)表示向左删除空白， 而 `-&#125;&#125;</code>表示右边的空格应该被去掉。 一定注意空格就是换行</p>
<p>要确保-和其他命令之间有一个空格。 <code>&#123;&#123;- 3 &#125;&#125;</code> 表示“删除左边空格并打印3”，而<code>&#123;&#123;-3 &#125;&#125;</code>表示“打印-3”。</p>
<h3 id="模板的使用"><a href="#模板的使用" class="headerlink" title="模板的使用"></a>模板的使用</h3><p>我们一般会在_helpers.tpl中写我们的模板代码</p>
<h4 id="声明一个模板"><a href="#声明一个模板" class="headerlink" title="声明一个模板"></a>声明一个模板</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- define &quot;mychart.labels&quot; &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    generator: helm</span><br><span class="line">    date: &#123;&#123; now | htmlDate &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h4><p>我们可以使用 template  templateName 来引用我们的模板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-configmap</span><br><span class="line">  &#123;&#123;- template &quot;mychart.labels&quot; &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们在模板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;- define &quot;mychart.labels&quot; &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    generator: helm</span><br><span class="line">    date: &#123;&#123; now | htmlDate &#125;&#125;</span><br><span class="line">    chart: &#123;&#123; .Chart.Name &#125;&#125;</span><br><span class="line">    version: &#123;&#123; .Chart.Version &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>中使用 .Chart,会发现渲染出错(–disable-openapi-validation 可以查看渲染的内容),这是因为没有内容传入到模板中(可以认为默认范围是在模板),所以无法使用 . 访问任何内容. 需要传递一个范围给模板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- template &quot;mychart.labels&quot; . &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>注意这个在template调用末尾传入的.，我们可以简单传入.Values或.Values.favorite或其他需要的范围。但一定要是顶层范围。</p>
<p>由于template是一个行为，不是方法，无法将 template调用的输出传给其他方法，数据只是简单地按行插入。</p>
<p>为了处理这个问题，Helm提供了一个 include 的可选项，可以将模板内容导入当前管道，然后传递给管道中的其他方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-configmap</span><br><span class="line">  labels:</span><br><span class="line">&#123;&#123; include &quot;mychart.app&quot; . | indent 4 &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>相较于使用template，在helm中使用include被认为是更好的方式 只是为了更好地处理YAML文档的输出格式</p>
<h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><h4 id="配置更新后-Pod-自动重启"><a href="#配置更新后-Pod-自动重启" class="headerlink" title="配置更新后 Pod 自动重启"></a>配置更新后 Pod 自动重启</h4><p>利用 k8s 的 Deployment 更改后的自动更新，我们可以用来更新应用配置，简单说就是更新 Secrets 或 ConfigMaps 后，计算它的最新 hash 值，然后将这个 hash 值 patch 到相应的 Deployment 中。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">checksum/config:</span> &#123;&#123; <span class="string">include</span> <span class="string">(print</span> <span class="string">$.Template.BasePath</span> <span class="string">&quot;/configmap.yaml&quot;</span><span class="string">)</span> <span class="string">.</span> <span class="string">|</span> <span class="string">sha256sum</span> &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这样，假如这个配置有问题，比如造成应用崩溃了，k8s 也会认为新的 ReplicaSet 失败了，不会将流量导过去，从而不继续滚动更新，避免了了由配置更新导致的应用崩溃问题。</p>
<h4 id="Image-pull-credentials"><a href="#Image-pull-credentials" class="headerlink" title="Image pull credentials"></a>Image pull credentials</h4><p>有些时候，Docker 镜像可能需要用户名与密码去 registry 拉取，那么，你就需要专门为此创建一个模板了。<br>比如 value 是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imageCredentials:</span><br><span class="line">  registry: quay.io</span><br><span class="line">  username: someone</span><br><span class="line">  password: sillyness</span><br></pre></td></tr></table></figure>

<p>而模板就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;- define &quot;imagePullSecret&quot; &#125;&#125;</span><br><span class="line">&#123;&#123;- printf &quot;&#123;&quot;auths&quot;: &#123;&quot;%s&quot;: &#123;&quot;auth&quot;: &quot;%s&quot;&#125;&#125;&#125;&quot; .Values.imageCredentials.registry (printf &quot;%s:%s&quot; .Values.imageCredentials.username .Values.imageCredentials.password | b64enc) | b64enc &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>当然，需要注意多个 Deployment 共享一个 Chart 的情况，这时候可能会出现 secrets 冲突的情况，可考虑单为此单独创建一个 Config Chart，然后作为 App Chart 的依赖。</p>
]]></content>
      <tags>
        <tag>Helm</tag>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo搭建github博客</title>
    <url>/2015/09/20/hexo-for-github-blog/</url>
    <content><![CDATA[<ol>
<li><p>使用工具版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git版本:git version 2.5.2.windows.2</span><br><span class="line">npm版本:2.14.2</span><br><span class="line">hexo: 3.1.1</span><br></pre></td></tr></table></figure></li>
<li><p>github账号,同时新建一个仓库,仓库名称是固定的,格式为: <strong>your_username.github.io</strong></p>
</li>
<li><p>环境准备<br><a href="http://git-scm.com/">git</a><br><a href="https://nodejs.org/en/">node.js</a></p>
</li>
</ol>
<p><strong>安装注意:</strong><br>    <img data-src="/images/hexo-nodejs-add-to-path.png" alt="记住添加到path"></p>
<ol start="4">
<li><p>打开刚刚安装好的git客户端,然后和github建立SSH连接</p>
<ul>
<li><a href="https://help.github.com/articles/generating-ssh-keys/">建立连接</a></li>
</ul>
</li>
<li><p>hexo安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br><span class="line">$ <span class="built_in">cd</span> f:  <span class="comment">#可以是任何路径</span></span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br><span class="line"><span class="comment">#3.0版本和2.0版本的区别,3.0已经将发布的程序独立出来了，所以需要安装</span></span><br><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布</p>
<ul>
<li>修改blog根目录下的_config.yml文件,将deploy节点修改为如下内容(将<strong>generalthink</strong>替换成自己github的名称):<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy: </span><br><span class="line">type: git  </span><br><span class="line">repo: git@github.com:generalthink&#x2F;generalthink.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></li>
<li>hexo deploy</li>
</ul>
</li>
<li><p>访问自己的博客,博客地址为:<a href="http://your_username.github.io/">http://your_username.github.io</a></p>
</li>
<li><p>_config.yml文件的配置均为key: value形式,值得一提的是value前面必须要有一个空格</p>
</li>
<li><p>常见错误参考</p>
<ul>
<li><img data-src="/images/hexo-deploy-error.png" alt="deploy错误"></li>
<li>解决方案,这个是由于时间久了SSH连接过期导致的,此时重新建立连接即可,使用   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">eval</span> $(ssh-agent -s)</span><br><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>
  或者参考<a href="https://help.github.com/articles/generating-ssh-keys/">https://help.github.com/articles/generating-ssh-keys/</a></li>
</ul>
</li>
<li><p>建议参考文档:</p>
<ol>
<li><a href="https://hexo.io/docs/">https://hexo.io/docs/</a> </li>
<li><a href="http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/">http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/</a></li>
<li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/">http://ibruce.info/2013/11/22/hexo-your-blog/</a></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB中如何管理用户权限?</title>
    <url>/2020/03/26/how-to-authorization-in-mongodb/</url>
    <content><![CDATA[<p>你还在用root账户来访问你程序的所有数据吗？午夜梦回,你是否有过担心,要是手误操作,一不小心就删库了，应该怎么办? </p>
<p>如果你真有这样的担忧,那么现在开始就让你的用户权限小一点。</p>
<p>mongodb有下面四种认证方式</p>
<ol>
<li>用户名+密码 : 默认认证方式,用户信息存储于MongoDB本地数据库</li>
<li>证书方式 : 采用X.509标准,服务端需要提供证书文件启动，客户端需要证书文件连接服务端,证书由内部或外部CA颁发</li>
<li>LDAP外部认证 : 企业版功能。连接到外部LDAP服务器认证</li>
<li>Kerberos外部认证 : 企业版功能, 连接到外部Kerberos服务器认证</li>
</ol>
<p>而今天我们探究的是最简单的也是最常用的一种：用户名+密码。</p>
<a id="more"></a>

<p>我们一般说到权限控制,都绕不过RBAC:基于角色的访问控制(Role-Based Access Control)，MongoDB中也不外如是。</p>
<blockquote>
<p>RBAC实际很简单,就是一个用户有哪些角色,而这些角色都有哪些资源。 这样就可以使得拥有对应角色的用户拥有对应的权限。</p>
</blockquote>
<p>MongoDB中也存在这么三个概念,User,Role以及Action。</p>
<p>User,Role好理解,就是用户和角色，那么Action是啥玩意呢？Action实际上是用户能对数据库做什么操作，比如增删改查等</p>
<blockquote>
<p>更多Action可以查看：<a href="https://docs.mongodb.com/manual/reference/privilege-actions/">https://docs.mongodb.com/manual/reference/privilege-actions/</a></p>
</blockquote>
<h3 id="启用认证"><a href="#启用认证" class="headerlink" title="启用认证"></a>启用认证</h3><p>默认情况下,mongodb安装完成后是不启用认证机制的,这个时候你没有用户名,密码也可以登录进去，并且你拥有操作数据库的任何权限(这个时候你的权限最大，也最危险)。</p>
<p>虽然启用认证后,不指定用户名，密码,也可以登录，但是此时只能创建用户，而不能做其他的操作。</p>
<p>启用认证有两种方式，</p>
<ol>
<li>在mongod.cfg中指定</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">authorization:</span> <span class="string">enabled</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://docs.mongodb.com/manual/reference/configuration-options/#security-options">https://docs.mongodb.com/manual/reference/configuration-options/#security-options</a></p>
</blockquote>
<ol start="2">
<li>通过命令行参数指定</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongod --auth --port 27017 --dbpath &#x2F;data&#x2F;db</span><br></pre></td></tr></table></figure>

<p>此时如果你试图做其他操作，比如查询数据就会遇到下面的错误:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.demo.find();</span><br><span class="line">Error: error: &#123;</span><br><span class="line">  &quot;ok&quot; : 0,</span><br><span class="line">  &quot;errmsg&quot; : &quot;not authorized on test to execute command &#123; find: \&quot;demo\&quot;, filter: &#123;&#125;, $db: \&quot;test\&quot; &#125;&quot;,</span><br><span class="line">  &quot;code&quot; : 13,</span><br><span class="line">  &quot;codeName&quot; : &quot;Unauthorized&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时我们可以选择创建用户，比如我们创建一个root用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use admin;</span><br><span class="line"></span><br><span class="line">db.createUser(&#123;</span><br><span class="line">  user: &quot;root&quot;, </span><br><span class="line">  pwd: &quot;123456&quot;, </span><br><span class="line">  roles: [</span><br><span class="line">   &#123;</span><br><span class="line">    role: &quot;root&quot;, </span><br><span class="line">    db:&quot;admin&quot;</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line"> &#125; </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>上面的命令创建了一个root账户,role是root(对所有数据库都拥有最高权限，下面会讲到mongodb内置有哪些角色)。</p>
<p>此时使用下面的命令来登录mongodb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo -u root -p 123456 --authenticationDatabase admin</span><br></pre></td></tr></table></figure>
<p>设置以auth方式登陆之后，client端通过mongo登陆mongodb，是必须加上“–authenticationDatabase”选项的，“authenticationDatabase”指定了校验用户账户名和密码的数据库,我们一般存储在admin库中。</p>
<p>然后使用下面的命令可以查看对应的授权机制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.runCommand(&#123;getParameter: 1, authenticationMechanisms: 1&#125;)</span><br><span class="line">&#123;</span><br><span class="line">  &quot;authenticationMechanisms&quot; : [</span><br><span class="line">          &quot;MONGODB-X509&quot;,</span><br><span class="line">          &quot;SCRAM-SHA-1&quot;,</span><br><span class="line">          &quot;SCRAM-SHA-256&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用Robo 3T工具连接的时候，对应用户的授权机制一定要是上面的其中一种。</p>
<h3 id="MongoDB内置角色以及权限继承关系"><a href="#MongoDB内置角色以及权限继承关系" class="headerlink" title="MongoDB内置角色以及权限继承关系"></a>MongoDB内置角色以及权限继承关系</h3><p><img data-src="/images/mongodb/mongodb-role-extends.png" alt="内置角色"></p>
<p>可以看到root角色是处于顶层位置的。</p>
<p>当你想知道某个角色有哪些权限的时候可以使用getRole的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.getRole(&#39;read&#39;, &#123;showPrivileges: true&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>getRole命令会给出角色对应的权限,继承下来的权限以及对应的Action</p>
<p>同样的，mongodb也是支持我们自建角色的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建 sampleRole角色</span><br><span class="line">&#x2F;&#x2F; 作用在sampledb中的sample Collection,只能拥有read,update操作</span><br><span class="line">db.createRole(</span><br><span class="line">&#123;</span><br><span class="line">  &quot;role&quot;: &quot;sampleRole&quot;,</span><br><span class="line">  &quot;privileges&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;resource&quot;: &#123;</span><br><span class="line">        &quot;db&quot;: &quot;sampledb&quot;,</span><br><span class="line">        &quot;collection&quot;: &quot;sample&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;actions&quot;: [</span><br><span class="line">        &quot;update&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;roles&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;role&quot;: &quot;read&quot;,</span><br><span class="line">      &quot;db&quot;: &quot;sampledb&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建用户绑定角色</span><br><span class="line">db.createUser(</span><br><span class="line">&#123;</span><br><span class="line">  &quot;user&quot;: &quot;sampleUser&quot;,</span><br><span class="line">  &quot;pwd&quot;: &quot;password&quot;,</span><br><span class="line">  &quot;roles&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;role&quot;: &quot;sampleRole&quot;,</span><br><span class="line">      &quot;db&quot;: &quot;admin&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当我们使用sampleUser登录的时候，就不能再向sample Collection中插入数据了。</p>
<h3 id="创建应用用户"><a href="#创建应用用户" class="headerlink" title="创建应用用户"></a>创建应用用户</h3><p>我们在实际使用的使用，可以根据不同的使用场景创建不同的用户分配不同的角色，这样可以使得权限控制更小，更加安全。</p>
<h4 id="创建只读用户"><a href="#创建只读用户" class="headerlink" title="创建只读用户"></a>创建只读用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.createUser(&#123;user: &quot;reader&quot;, pwd: &quot;abc123&quot;, roles: [&#123; role:&quot;read&quot;, db: &quot;mydb&quot; &#125;]&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="创建读写用户"><a href="#创建读写用户" class="headerlink" title="创建读写用户"></a>创建读写用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.createUser(&#123;user: &quot;writer&quot;, pwd: &quot;abc123&quot;, roles: [&#123; role:&quot;readWrite&quot;, db: &quot;mydb&quot; &#125;]&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>工作8年,你就是这样记日志的？</title>
    <url>/2024/09/19/how-to-record-log/</url>
    <content><![CDATA[<p>平常在写代码的过程中,我们经常需要记录日志,具体的日志实现我们可以使用logback, log4j, log4j2等。 但是一般我们会通过日志门面来记录日志，比如通过SLF4J或者apache commons logging。 无论使用哪种方式记录日志都不在我们这篇文章的讨论范围内。</p>
<p>如果你对它们如何找到真正的日志实现感兴趣，可以看看我<a href="https://juejin.cn/post/6844903936780926989">之前的文章</a>。</p>
<h3 id="日志怎么记录"><a href="#日志怎么记录" class="headerlink" title="日志怎么记录"></a>日志怎么记录</h3><p>日志分为6种，每种级别实际上有不同的应对场景，但是说实话我在项目中看到最多的永远是INFO, ERROR级别。</p>
<p>几乎没有怎么见到业务系统中有其他级别。 DEBUG的日志在集成的各个框架中是比较多见的。</p>
<p>日志应该是帮助我们定位问题的，所以日志怎么记录其实很关键。</p>
<a id="more"></a>


<h3 id="DEBUG日志"><a href="#DEBUG日志" class="headerlink" title="DEBUG日志"></a>DEBUG日志</h3><h4 id="开源框架如何使用"><a href="#开源框架如何使用" class="headerlink" title="开源框架如何使用"></a>开源框架如何使用</h4><p>哪里应该记录debug日志呢？ 我们先看看开源框架中哪里地方会打印DEBUG日志，我们学习下。</p>
<p>项目中使用了Nacos,在加载nacos配置的变量的时候，会把加载到的Nacos的数据打印出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.cloud.nacos.client.NacosPropertySourceBuilder#loadNacosData#92</span></span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(String.format(</span><br><span class="line">            <span class="string">&quot;Loading nacos data, dataId: &#x27;%s&#x27;, group: &#x27;%s&#x27;, data: %s&quot;</span>, dataId,</span><br><span class="line">            group, data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到这里使用的是debug日志。  一般而言我们的配置基本上都是配置到nacos中的，比如数据库连接信息，openfeign配置信息，还有其他一些变量，所以这里的数据打印出来应该是比较多的。 像这种日志打印出来也更多只是为了验证下我们的配置是否正确或者帮助我们调试。</p>
<p>所以这里我们使用debug级别日志来打印信息。</p>
<p>再来看看Spring中哪些地方用到了debug日志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition#1014</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                    <span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                    <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当我们注册BeanDefinition的时候，如果有相同的,这时候会把旧的替换掉，所以这里会打上一个debug日志。 当想要排查之前的Bean是怎样被替换的，这时候只需要开启日志级别是DEBUG，我们就能清晰的知道Bean是被那个Defeinition替换掉的了。</p>
<p>这里为什么不记录INFO日志呢？ 我个人理解是因为注册BeanDefinition这个行为如果产生了replace行为,那么一定是使用者控制的，框架不会产生重复的BeanDefinition, 那么既然是使用者自己行为,所以这里替换掉原有的就很合理，但是又为了让用户知道框架的具体行为(是替换还是忽略),所以这里加了一个debug日志。</p>
<h4 id="业务系统如何记录"><a href="#业务系统如何记录" class="headerlink" title="业务系统如何记录"></a>业务系统如何记录</h4><p>在业务开发中我们主要是和参数打各种交道,比如我们接收到前端一个大参数的时候,我们需要对这个参数进行各种转换和计算之后保存到数据库。这个时候我建议记录下DEBUG日志。 </p>
<p>有时候业务逻辑依赖这个参数进行运算，但是有时候得到的结果又和我们需要的不一致，所以这时候就需要排查下前端是否处理的不准确，或者计算逻辑是否不正确。 这个时候把参数打印出来我们就可以复现这个问题。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">log.debug(<span class="string">&quot;save param is &#123;&#125;&quot;</span>, JSON.toJSONString(param));</span><br></pre></td></tr></table></figure>
<p>这里打印的时候我建议打印出json字符串,因为我们拿到这个字符串后可以在本地进行调试。当然由于这个字符串很大,这也是我们设置成debug级别的原因之一,至少不要让日志成为制约系统响应速度的罪魁祸首。</p>
<h3 id="INFO日志"><a href="#INFO日志" class="headerlink" title="INFO日志"></a>INFO日志</h3><h4 id="开源框架如何使用-1"><a href="#开源框架如何使用-1" class="headerlink" title="开源框架如何使用"></a>开源框架如何使用</h4><p>同样是nacos,在进行服务注册的时候如果注册成功，会输出一条注册完成的日志。从这个日志我们可以知道哪个服务注册成功了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.cloud.nacos.registry.NacosServiceRegistry:register#75</span></span><br><span class="line">log.info(<span class="string">&quot;nacos registry, &#123;&#125; &#123;&#125; &#123;&#125;:&#123;&#125; register finished&quot;</span>, group, serviceId,</span><br><span class="line">                    instance.getIp(), instance.getPort());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从这里可以看到使用INFO日志,是记录一个比较重要的时刻,我们打印出必要的消息，证明已经跑过了一个重要的节点。</p>
<p>同样的在Spring初始化ServletContext的时候也打印了INFO日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#prepareWebApplicationContext#288</span></span><br><span class="line">setServletContext(servletContext);</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - getStartupDate();</span><br><span class="line">                logger.info(<span class="string">&quot;Root WebApplicationContext: initialization completed in &quot;</span> + elapsedTime + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从这里我们可以看出来测试Spring框架运行到了一个重要的节点,又打印出了一些必要的信息：初始化的时间。</p>
<h4 id="业务系统如何记录-1"><a href="#业务系统如何记录-1" class="headerlink" title="业务系统如何记录"></a>业务系统如何记录</h4><p>我们一般会在一些重要的节点进行日志记录,比如在邮件模板系统中,当我们找到需要处理的模板的时候,我记录了这样的一条日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">log.info(<span class="string">&quot;find templates by rule,templateNames=&#123;&#125;, serviceLineId=&#123;&#125;, companyId=&#123;&#125;, triggerEventId=&#123;&#125;&quot;</span>,</span><br><span class="line">                emailTemplateList.stream().map(EmailTemplate::getTemplateName).collect(Collectors.joining(<span class="string">&quot;;&quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>)),</span><br><span class="line">                dto.getServiceLineId(), dto.getCompanyId(), dto.getTriggerEventId()</span><br><span class="line">        );</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这条日志记录了我根据参数找到了哪些需要被处理的模板。后面当我看日志的时候我就知道根据下游系统的参数定位到了哪些模板来处理</p>
<h3 id="WARN日志"><a href="#WARN日志" class="headerlink" title="WARN日志"></a>WARN日志</h3><h4 id="开源框架如何使用-2"><a href="#开源框架如何使用-2" class="headerlink" title="开源框架如何使用"></a>开源框架如何使用</h4><p>同样的，在Nacos中如果未加载到nacos的配置信息的时候，这里使用了warn日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.cloud.nacos.client.NacosPropertySourceBuilder#loadNacosData#86</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(data)) &#123;</span><br><span class="line">    log.warn(</span><br><span class="line">            <span class="string">&quot;Ignore the empty nacos configuration and get it based on dataId[&#123;&#125;] &amp; group[&#123;&#125;]&quot;</span>,</span><br><span class="line">            dataId, group);</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为什么不使用ERROR其他类型的日志呢？ 其实是因为加载不到配置信息不影响系统的运行,但是你用了nacos又加载不到，就很奇怪。</p>
<p>所以这里使用了warn级别日志，而不是ERROR或者其他级别日志。 </p>
<h4 id="业务系统如何记录-2"><a href="#业务系统如何记录-2" class="headerlink" title="业务系统如何记录"></a>业务系统如何记录</h4><p>warn是一个警告，证明了这个信息不影响业务继续运行,但是会对业务使用有一定影响。比如我们列表查询需要展示业务单独的操作人,根据单据存储的userId获取userName进行展示, 需要去用户服务中取,但是由于下游系统挂了或者这个用户被删除了， 我们取不到这个用户了。</p>
<p>那整个列表就不展示了吗？ 当然不行,顶多是某行数据的user name不展示就行了。 这种情况下,我们需要记录下warn日志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略业务代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;user not exists, userId=&#123;&#125;&quot;</span>, id);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ERROR日志"><a href="#ERROR日志" class="headerlink" title="ERROR日志"></a>ERROR日志</h3><h4 id="开源框架如何使用-3"><a href="#开源框架如何使用-3" class="headerlink" title="开源框架如何使用"></a>开源框架如何使用</h4><p>同样还是nacos加载数据失败的场景，这里就打印了通过哪个dataId加载数据的时候失败，并打印了异常。<br>但是因为nacos加载数据失败并不会影响程序的继续运行，所以这里这是打印了日志，并没有抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;PropertySource&lt;?&gt;&gt; loadNacosData(String dataId, String group,</span><br><span class="line">        String fileExtension) &#123;</span><br><span class="line">    <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;get data from Nacos error,dataId:&#123;&#125; &quot;</span>, dataId, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;parse data from Nacos error,dataId:&#123;&#125;,data:&#123;&#125;&quot;</span>, dataId, data, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而在Spring初始化ServletContext的时候如果失败了是会打印error日志，并抛出异常的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">        setServletContext(servletContext);</span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line">        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里不仅仅记录了错误日志，而且还抛出了异常，而这个异常会直接让我们的应用程序崩溃，这很合理，因为servlet初始化失败，就代表我们的容器启动失败，所以这里就需要住址程序继续往下运行。</p>
<h4 id="业务系统如何记录-3"><a href="#业务系统如何记录-3" class="headerlink" title="业务系统如何记录"></a>业务系统如何记录</h4><p>业务系统中如果我们捕获了某些异常，然后需要记录错误日志，比如我们发送测试邮件失败。但是又因为发送邮件不是一个必须行为，所以我们并不抛出异常，而是可以继续执行后续逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       remoteNotiService.sendContent(email);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       log.error(LogUtil.format(<span class="string">&quot;send email failure, toList=&#123;&#125;, subject=&#123;&#125;&quot;</span>, toList, subject), e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然如果你在系统中捕获的非业务异常,那么一般都是记录日志，然后抛出异常的。</p>
<h3 id="添加traceId"><a href="#添加traceId" class="headerlink" title="添加traceId"></a>添加traceId</h3><p>最后无论现在你们是否有完整的日志体系，我都建议你把traceId加入到你的日志中,因为你可以通过traceId拉到某一次请求所有的日志，能很好的帮助你过滤掉无关日志。 关于traceId的添加可以参考我<a href="https://juejin.cn/post/6949073119852101663">之前的文章</a></p>
<p>虽然有了traceId,但是我还是建议你记录日志的文本要是唯一的,这样你根据日志搜索的时候可以直接定位到是哪一段代码。</p>
<p>当然我这里还推荐给你了另外一种方式,如果你使用了spring cloud, 那你可以使用sleuth来添加traceId。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时你只需要在你spring cloud的gateway中添加一个filter即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceIdFilter</span>  <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">        HttpHeaders httpHeaders = response.getHeaders();</span><br><span class="line">        httpHeaders.add(<span class="string">&quot;X-Trace-Id&quot;</span>, MDC.get(<span class="string">&quot;traceId&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange.mutate().response(response).build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里是从MDC(slf4j)中获取的，因为sleuth会将这个值放到MDC中，我们直接从里面获取就行了。</p>
<p>当然你可以直接注入<code>org.springframework.cloud.sleuth.Tracer</code>,然后这样获取traceId也可以使用的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tracer.currentSpan().context().traceId();</span><br></pre></td></tr></table></figure>

<p>然后在logback的配置文件的log pattern中加上traceId,这里我给出我的log pattern</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;log.pattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%d&#123;HH:mm:ss.SSS&#125;-[%thread]-[traceId=%X&#123;traceId&#125;,spanId=%X&#123;spanId&#125;]-%-5level-%logger&#123;20&#125;-[%method,%line]-%msg%n&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样子打印出来的日志就会有traceId了，然后返回给前端的header里面也带有traceId了。而且因为引入了sleuth,所以它只天然支持openfeign的，你就不用再去写Inteceptor了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我上面特意忽略了trace和fatal这两个级别，这两个实在不常用,不过你可以根据你的实际情况来使用，这里我也把各个级别的使用场景总结了下。</p>
<h4 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h4><ul>
<li>用于记录程序执行的细节信息,提供最详细的日志信息。</li>
<li>通常用于调试和问题分析,在正常运行时可以被禁用以减少日志输出。</li>
</ul>
<h4 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h4><ul>
<li>用于记录程序执行的详细信息,有助于开发和调试。</li>
<li>通常在开发和测试环境中使用,在生产环境中可以被禁用以减少日志输出。</li>
</ul>
<h4 id="INFO"><a href="#INFO" class="headerlink" title="INFO"></a>INFO</h4><ul>
<li>用于记录程序执行的重要信息,如关键事件、状态变更等。</li>
<li>通常在生产环境中使用,提供程序运行的概况信息。</li>
</ul>
<h4 id="WARN"><a href="#WARN" class="headerlink" title="WARN"></a>WARN</h4><ul>
<li>用于记录程序执行中出现的潜在问题,但不会导致程序崩溃。</li>
<li>通常用于记录一些可能会影响程序正常运行的情况,如资源耗尽、配置错误等。</li>
</ul>
<h4 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h4><ul>
<li>用于记录程序执行中出现的错误信息,可能会导致程序崩溃或无法正常运行。</li>
<li>通常用于记录严重的问题,如异常、错误代码、系统故障等。</li>
</ul>
<h4 id="FATAL"><a href="#FATAL" class="headerlink" title="FATAL"></a>FATAL</h4><ul>
<li>用于记录程序执行中出现的严重错误,导致程序无法继续运行。</li>
<li>通常用于记录程序无法恢复的致命错误,如系统崩溃、资源耗尽等。</li>
</ul>
]]></content>
      <tags>
        <tag>log</tag>
        <tag>traceId</tag>
        <tag>logback</tag>
        <tag>slf4j</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么start方法才能启动线程,而run不行？</title>
    <url>/2020/08/03/how-to-start-thread/</url>
    <content><![CDATA[<p>我们都知道，一个线程直接对应了一个Thread对象,在刚开始学习线程的时候我们也知道启动线程是通过start()方法,而并非run()方法。</p>
<p>那这是为什么呢？</p>
<p>如果你熟悉Thread的代码的话,你应该知道在这个类加载的时候会注册一些native方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Make sure registerNatives is the first thing &lt;clinit&gt; does. */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      registerNatives();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>一看到native我就想起了JNI,registerNatives()实际上就是java方法和C/C++的函数对应。在首次加载的时候就会注册这些native方法。Thread中有很多native方法，大家有兴趣的可以去看看。</p>
<blockquote>
<p>关于JNI方法的命名,我们可以这样测试，我们用java声明一个native方法，然后先使用javac编译源文件(比如javac main.java),然后在使用javah即可生成头文件(javah main),打开这个头文件你就知道方法命名是如何的了 </p>
</blockquote>
<p>我们在JVM源码中搜索Java_java_lang_Thread_registerNatives可以看到registerNatives方法的具体实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;start0&quot;</span>,           <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;stop0&quot;</span>,            <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)V&quot;</span>, (<span class="keyword">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;isAlive&quot;</span>,          <span class="string">&quot;()Z&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;suspend0&quot;</span>,         <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;resume0&quot;</span>,          <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;setPriority0&quot;</span>,     <span class="string">&quot;(I)V&quot;</span>,       (<span class="keyword">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;yield&quot;</span>,            <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;sleep&quot;</span>,            <span class="string">&quot;(J)V&quot;</span>,       (<span class="keyword">void</span> *)&amp;JVM_Sleep&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;currentThread&quot;</span>,    <span class="string">&quot;()&quot;</span> THD,     (<span class="keyword">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;countStackFrames&quot;</span>, <span class="string">&quot;()I&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_CountStackFrames&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;interrupt0&quot;</span>,       <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;isInterrupted&quot;</span>,    <span class="string">&quot;(Z)Z&quot;</span>,       (<span class="keyword">void</span> *)&amp;JVM_IsInterrupted&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;holdsLock&quot;</span>,        <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)Z&quot;</span>, (<span class="keyword">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;getThreads&quot;</span>,        <span class="string">&quot;()[&quot;</span> THD,   (<span class="keyword">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;dumpThreads&quot;</span>,      <span class="string">&quot;([&quot;</span> THD <span class="string">&quot;)[[&quot;</span> STE, (<span class="keyword">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;setNativeName&quot;</span>,    <span class="string">&quot;(&quot;</span> STR <span class="string">&quot;)V&quot;</span>, (<span class="keyword">void</span> *)&amp;JVM_SetNativeThreadName&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_java_lang_Thread_registerNatives(JNIEnv *env, jclass cls)</span><br><span class="line">&#123;</span><br><span class="line">    (*env)-&gt;RegisterNatives(env, cls, methods, ARRAY_LENGTH(methods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在registerNatives函数中，注册了很多的native方法比如这里的start0()方法。</p>
<p>所有对JNI函数的调用都使用了env指针,该指针是对每一个本地方法的第一个参数。env指针是函数指针表的指针。我们可以在<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html">https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html</a>中找到JNI API</p>
<p>在Thread.start()方法中，实际就是通过调用start0()方法来启动线程的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">  <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 主要调用了start0()这个native方法来启动线程</span></span><br><span class="line">      start0();</span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">              group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">          <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">            it will be passed up the call stack */</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而JNINativeMethod这个数据结构定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">char</span> *signature;</span><br><span class="line">  <span class="keyword">void</span> *fnPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此start0()这个方法对应的本地函数是JVM_StartThread</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;start0&quot;</span>, <span class="string">&quot;()V&quot;</span>, (<span class="keyword">void</span> *)&amp;JVM_StartThread&#125;</span><br></pre></td></tr></table></figure>

<p>我们接下来看JVM_StartThread的方法实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_StartThread(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">&quot;JVM_StartThread&quot;</span>);</span><br><span class="line">  JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> throw_illegal_thread_state = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Ensure that the C++ Thread and OSThread structures aren&#x27;t freed before</span></span><br><span class="line">    <span class="comment">// we operate.</span></span><br><span class="line">    <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从JDK5开始，使用java.lang.Thread threadStatus来防止重新启动一个已经启动的线程</span></span><br><span class="line">    <span class="keyword">if</span> (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      throw_illegal_thread_state = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line">      jlong size =</span><br><span class="line">             java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">      </span><br><span class="line">      NOT_LP64(<span class="keyword">if</span> (size &gt; SIZE_MAX) size = SIZE_MAX;)</span><br><span class="line">      <span class="keyword">size_t</span> sz = size &gt; <span class="number">0</span> ? (<span class="keyword">size_t</span>) size : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建Java线程</span></span><br><span class="line">      native_thread = <span class="keyword">new</span> JavaThread(&amp;thread_entry, sz);</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">      <span class="keyword">if</span> (native_thread-&gt;osthread() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        native_thread-&gt;prepare(jthread);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (throw_illegal_thread_state) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_IllegalThreadStateException());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略了部分代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将线程状态设置为Runnable,表示可以被运行</span></span><br><span class="line">  Thread::start(native_thread);</span><br><span class="line"></span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>

<p>上面代码主要做了三件事情</p>
<ol>
<li><p>判断当前线程状态是否合法，不合法抛出IllegalThreadStateException</p>
</li>
<li><p>创建一个Java线程(我们需要重点关注的)</p>
</li>
<li><p>将线程状态设置为Runnable</p>
</li>
</ol>
<p>如果面试官以后再问你两次调用start()方法会怎样,你就大胆而坚定的回复说抛出IllegalThreadStateException。</p>
<p>在JavaThread构造函数中实际调用的是os::create_thread方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">os::create_thread</span><span class="params">(Thread* thread, ThreadType thr_type,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">size_t</span> req_stack_size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  OSThread* osthread = <span class="keyword">new</span> OSThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (osthread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  osthread-&gt;set_thread_type(thr_type);</span><br><span class="line">  osthread-&gt;set_state(ALLOCATED);</span><br><span class="line"></span><br><span class="line">  thread-&gt;set_osthread(osthread);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// init thread attributes</span></span><br><span class="line">  <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">  pthread_attr_init(&amp;attr);</span><br><span class="line">  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">size_t</span> stack_size = os::Posix::get_initial_stack_size(thr_type, req_stack_size);</span><br><span class="line">  <span class="keyword">int</span> status = pthread_attr_setstacksize(&amp;attr, stack_size);</span><br><span class="line"></span><br><span class="line">  ThreadState state;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, &amp;attr, (<span class="keyword">void</span>* (*)(<span class="keyword">void</span>*)) thread_native_entry, thread);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他代码...</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>pthread_create函数作用是创建一个线程,它的第三个参数是线程运行函数的起始地址,第四个参数是运行函数参数。</p>
<blockquote>
<p>IEEE标准1003.1c中定义了线程的标准,它定义的线程包叫做Pthread,大部分UNIX系统都支持这个标准。</p>
</blockquote>
<p>而pthread_create实际上是调用了clone()完成系统调用创建线程的,所以目前 Java 在 Linux 操作系统下采用的是用户线程加<br>轻量级线程，一个用户线程映射到一个内核线程.</p>
<p>我们的thread_native_entry实际传入的是JavaThread这个对象,所以最终会调用JavaThread::run()(thread.cpp中)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JavaThread::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  thread_main_inner();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JavaThread::thread_main_inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">this</span>-&gt;entry_point()(<span class="keyword">this</span>,<span class="keyword">this</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>thread_main_inner函数中entry_point的返回值实际上是我们在创建JavaThread的时候传入的第一个参数thread_entry。而thread_entry指针指向的函数如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="function">HandleMark <span class="title">hm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, thread-&gt;threadObj())</span></span>;</span><br><span class="line">  <span class="function">JavaValue <span class="title">result</span><span class="params">(T_VOID)</span></span>;</span><br><span class="line">  JavaCalls::call_virtual(&amp;result,</span><br><span class="line">    obj,</span><br><span class="line">    SystemDictionary::Thread_klass(),</span><br><span class="line">    <span class="comment">// run方法名称run</span></span><br><span class="line">    vmSymbols::run_method_name(),</span><br><span class="line">    <span class="comment">// 方法签名()V</span></span><br><span class="line">    vmSymbols::void_method_signature(),</span><br><span class="line">    THREAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样我们就最终通过JavaCalls调用了run方法。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>new Thread</code>只是创建了一个普通的Java对象,只有在调用了start()方法之后才会创建一个真正的线程,在JVM内部会在创建线程之后调用run()方法,执行相应的业务逻辑。</p>
<p>由于Java中线程最终还是和操作系统线程挂钩了的,所以线程资源是一个很重要的资源,为了复用我们一般是通过线程池的方式来使用线程。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>fastjson使用</title>
    <url>/2015/10/02/how-to-use-fastjson/</url>
    <content><![CDATA[<h4 id="1-fastjson的主要API"><a href="#1-fastjson的主要API" class="headerlink" title="1. fastjson的主要API"></a>1. fastjson的主要API</h4><p>  <strong>fastjson入口类是com.alibaba.fastjson.JSON,主要的API是JSON.toJSONString,和parseObject</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JSON</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">toJSONString</span><span class="params">(Object object)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">T <span class="title">parseObject</span><span class="params">(String text, Class&lt;T&gt; clazz, Feature... features)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>  <strong>序列化:</strong><br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String jsonString = JSON.toJSONString(obj);</span><br></pre></td></tr></table></figure></p>
<p>  <strong>反序列化:</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">VO vo = JSON.parseObject(<span class="string">&quot;...&quot;</span>, VO.class);</span><br></pre></td></tr></table></figure>

<p>  <strong>泛型反序列化:</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.TypeReference;</span><br><span class="line"></span><br><span class="line">List&lt;VO&gt; list = JSON.parseObject(<span class="string">&quot;...&quot;</span>, <span class="keyword">new</span> TypeReference&lt;List&lt;VO&gt;&gt;() &#123;&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="2-JSON、JSONObject、JSONArray三者之间的关系"><a href="#2-JSON、JSONObject、JSONArray三者之间的关系" class="headerlink" title="2. JSON、JSONObject、JSONArray三者之间的关系"></a>2. JSON、JSONObject、JSONArray三者之间的关系</h4>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSONObject</span> <span class="keyword">extends</span> <span class="title">JSON</span> <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSONArray</span> <span class="keyword">extends</span> <span class="title">JSON</span> <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">Object</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  也就是说,JSONObject实际上就是一个Map,其处理方式和Map类似,而JSONArray实质上是一个List,其处理方式和List类似。</p>
<h4 id="3-实例讲解"><a href="#3-实例讲解" class="headerlink" title="3. 实例讲解"></a>3. 实例讲解</h4><p>  <strong>涉及到的实体Bean:</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> id,</span><br><span class="line">     <span class="keyword">int</span> name;</span><br><span class="line">     Date birthday;</span><br><span class="line">     List&lt;Phone&gt; phones;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">       <span class="comment">//省略get,set方法</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> phoneNum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//省略get,set方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  <strong>测试:</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  User user = <span class="keyword">new</span> User();</span><br><span class="line">  user.setId(<span class="number">1</span>);</span><br><span class="line">  user.setName(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">  user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">  List&lt;Phone&gt; phones = <span class="keyword">new</span> ArrayList&lt;Phone&gt;();</span><br><span class="line">  Phone p1 = <span class="keyword">new</span> Phone();</span><br><span class="line">  p1.setPhoneNum(<span class="number">12123123</span>);</span><br><span class="line">        </span><br><span class="line">  Phone p2 = <span class="keyword">new</span> Phone();</span><br><span class="line">  p2.setPhoneNum(<span class="number">23423423</span>);</span><br><span class="line">  phones.add(p1);</span><br><span class="line">  phones.add(p2);</span><br><span class="line">        </span><br><span class="line">  user.setPhones(phones);</span><br><span class="line">        </span><br><span class="line">  JSON.DEFFAULT_DATE_FORMAT = <span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>;</span><br><span class="line">  System.out.println(<span class="string">&quot;JSON:&quot;</span>+JSON.toJSONString(user,SerializerFeature.WriteDateUseDateFormat));</span><br><span class="line">  <span class="comment">//该注释的代码和上面两行的代码效果一致</span></span><br><span class="line">  <span class="comment">//System.out.println(JSON.toJSONStringWithDateFormat(user, &quot;yyyy-MM-dd hh:mm:ss&quot;));</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">  JSONObject jobj = <span class="keyword">new</span> JSONObject();</span><br><span class="line">  jobj.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">  System.out.println(<span class="string">&quot;JSONObject:&quot;</span>+jobj.toJSONString());</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">  JSONArray jArray = <span class="keyword">new</span> JSONArray();</span><br><span class="line">  jArray.add(user);</span><br><span class="line">  System.out.println(<span class="string">&quot;JSONArray:&quot;</span>+jArray.toJSONString());        </span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>输出:</strong></p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;birthday&quot;</span>:<span class="string">&quot;2015-09-30 03:06:36&quot;</span>,</span><br><span class="line">    <span class="string">&quot;id&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;abc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;phones&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;phoneNum&quot;</span>:<span class="number">12123123</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;phoneNum&quot;</span>:<span class="number">23423423</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSONObject:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;user&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;birthday&quot;</span>: <span class="number">1443597247350</span>,</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;phones&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;phoneNum&quot;</span>: <span class="number">12123123</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;phoneNum&quot;</span>: <span class="number">23423423</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JSONArray:</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;birthday&quot;</span>: <span class="number">1443597247350</span>,</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;phones&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;phoneNum&quot;</span>: <span class="number">12123123</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;phoneNum&quot;</span>: <span class="number">23423423</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>  <strong>测试:</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">      User u1 = <span class="keyword">new</span> User();</span><br><span class="line">      u1.setId(<span class="number">2</span>);</span><br><span class="line">      u1.setName(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">      u1.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">      User u2 = <span class="keyword">new</span> User();</span><br><span class="line">      u2.setId(<span class="number">3</span>);</span><br><span class="line">      u2.setName(<span class="string">&quot;cde&quot;</span>);</span><br><span class="line">      list.add(u1);list.add(u2);</span><br><span class="line">        </span><br><span class="line">      String result = JSON.toJSONStringWithDateFormat(list, <span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">      System.out.println(result);</span><br><span class="line">      <span class="comment">//[&#123;&quot;birthday&quot;:&quot;2015-09-30 03:34:38&quot;,&quot;id&quot;:2,&quot;name&quot;:&quot;abc&quot;&#125;,&#123;&quot;id&quot;:3,&quot;name&quot;:&quot;cde&quot;&#125;]</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment">//List&lt;User&gt; refList = JSON.parseObject(result, new ArrayList&lt;User&gt;().getClass());和下面的代码效果一致</span></span><br><span class="line">      List&lt;User&gt; refList2 = JSON.parseObject(result, <span class="keyword">new</span> TypeReference&lt;List&lt;User&gt;&gt;()&#123;&#125;);</span><br><span class="line">      System.out.println(refList2.size());</span><br><span class="line">      <span class="comment">//输出:2</span></span><br><span class="line">      List&lt;User&gt; users = JSON.parseArray(result, User.class);</span><br><span class="line">      System.out.println(users.size());</span><br><span class="line">      <span class="comment">//输出:2</span></span><br><span class="line">        </span><br><span class="line">      JSONObject obj = <span class="keyword">new</span> JSONObject();</span><br><span class="line">      obj.put(<span class="string">&quot;abc&quot;</span>, <span class="number">123</span>);</span><br><span class="line">      Boolean b = obj.getBoolean(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">      System.out.println(b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-控制哪些值序列化"><a href="#4-控制哪些值序列化" class="headerlink" title="4. 控制哪些值序列化"></a>4. 控制哪些值序列化</h4><p>  <strong>可以通过扩展实现根据object或者属性名称或者属性值进行判断是否需要序列化。例如:</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PropertyFilter filter = <span class="keyword">new</span> PropertyFilter() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(Object source, String name, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;id&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = ((Integer) value).intValue();</span><br><span class="line">            <span class="keyword">return</span> id &gt;= <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">JSON.toJSONString(obj, filter); <span class="comment">// 序列化的时候传入filter</span></span><br></pre></td></tr></table></figure>

<p>  <strong>同样可以通过SimplePropertyPreFilter来决定哪些值可以序列化:</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User vo = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">vo.setId(<span class="number">123</span>);</span><br><span class="line">vo.setName(<span class="string">&quot;flym&quot;</span>);</span><br><span class="line"></span><br><span class="line">SimplePropertyPreFilter filter = <span class="keyword">new</span> SimplePropertyPreFilter(VO.class, &quot;name&quot;);</span><br><span class="line">Assert.assertEquals(<span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;flym\&quot;&#125;&quot;</span>, JSON.toJSONString(vo, filter));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  <strong>同样可以通过注解的方式来判断哪些只需要序列化,详细请查看fastjson的官方文档</strong></p>
<h4 id="5-参考文档"><a href="#5-参考文档" class="headerlink" title="5. 参考文档"></a>5. 参考文档</h4><p>  <a href="https://github.com/alibaba/fastjson">fastjson下载以及文档参考</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>Graphql在项目中的使用</title>
    <url>/2018/09/27/how-to-use-graphql/</url>
    <content><![CDATA[<h3 id="什么是GraphQL"><a href="#什么是GraphQL" class="headerlink" title="什么是GraphQL"></a>什么是GraphQL</h3><p>GraphQL 是一种用于 API 的查询语言。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。GraphQL 查询不仅能够获得资源的属性，还能沿着资源间引用进一步查询。典型的 REST API 请求多个资源时得载入多个 URL，而 GraphQL 可以通过一次请求就获取你应用所需的所有数据。GraphQL API 基于类型和字段的方式进行组织，而非入口端点。你可以通过一个单一入口端点得到你所有的数据能力。</p>
<p>Facebook 的移动应用从 2012 年就开始使用 GraphQL。GraphQL 规范于 2015 年开源，现已经在多种环境下可用，并被各种体量的团队所使用。</p>
<h3 id="最好的入门文档"><a href="#最好的入门文档" class="headerlink" title="最好的入门文档"></a>最好的入门文档</h3><p>最好的文档当然是<a href="https://www.howtographql.com/graphql-java/1-getting-started/">官方文档</a></p>
<h3 id="SpringMVC集成GraphQL"><a href="#SpringMVC集成GraphQL" class="headerlink" title="SpringMVC集成GraphQL"></a>SpringMVC集成GraphQL</h3><h4 id="引入Java包"><a href="#引入Java包" class="headerlink" title="引入Java包"></a>引入Java包</h4><p>这里为了尽量的展示整个集成流程，所以会使用SpringBoot来进行整体框架搭建。但是会将更多的流程聚焦在GraphQL中。所以第一步是引入GraphQL的jar包，关于SpringBoot的搭建,可以借助<a href="http://start.spring.io/">http://start.spring.io/</a>来快速搭建。这里不做过多叙述。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--集成GraphQL--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphql-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphql-java-tools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphql-java-servlet<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="开始开发"><a href="#开始开发" class="headerlink" title="开始开发"></a>开始开发</h3><p>这里可以考虑实现一个具体的场景,就以二手书网站卖书举例好了。在GraphQL中查询和修改(增加,删除,更新)都是分别对应Query和Mutation.GraphQL支持的数据类型只有Int(Java中的Integer),Float,String,Enum以及Type(相当于Java中的Class),所以对于其他不支持的类型需要使用scalars自定义。</p>
<h4 id="定义接口描述-schema-graphqls"><a href="#定义接口描述-schema-graphqls" class="headerlink" title="定义接口描述(schema.graphqls)"></a>定义接口描述(schema.graphqls)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">type Book &#123;</span><br><span class="line">    id: Long</span><br><span class="line">    name: String</span><br><span class="line">    url: String</span><br><span class="line">    person: Person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 注意这里得关键字是 input</span><br><span class="line">input PersonParam &#123;</span><br><span class="line">    name: String</span><br><span class="line">    age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Person &#123;</span><br><span class="line">    name: String</span><br><span class="line">    age: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">   books(name: String, size: Int): [Book]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Mutation &#123;</span><br><span class="line">    newBook(name: String, url: String, person: PersonParam): Long</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">schema &#123;</span><br><span class="line">    query: Query</span><br><span class="line">    mutation: Mutation</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">scalar Long</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在GraphQL中如果参数是一个对象而不是标量值(Float,Int,String,Enum)的话，那么数据类型需要申明为input.上面可以看到PersonParam和Person的字段都是一样的，那么两个可以使用为同一个吗？<br>我告诉你不行，因为PersonParam是输入参数,而Person是输出参数，两者在GraphQL中不能混为一谈,如果你这样做了，程序会报错。</p>
<h4 id="定义接口实现"><a href="#定义接口实现" class="headerlink" title="定义接口实现"></a>定义接口实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span> <span class="keyword">implements</span> <span class="title">GraphQLQueryResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookRespository bookRespository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法名称,参数以及返回类型要和schema.graphqls文件中的定义保持一致.DataFetchingEnvironment是GraphQL提供的上下文,其中可以获取到request,response</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">books</span><span class="params">(String name,Integer size,DataFetchingEnvironment env)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//AuthContext context = env.getContext()   用于权限过滤</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bookRespository.getBooks(name,size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mutation</span> <span class="keyword">implements</span> <span class="title">GraphQLMutationResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookRespository bookRespository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接口需要和schema.graphqls中保持一致</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">newBook</span><span class="params">(String name, String url, PersonParam personParam)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(personParam.getName(),personParam.getAge());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bookRespository.saveBook(name,url,person);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的接口实际上也是请求的最终落地点，可以想成SpringMVC中的Controller，最终的执行逻辑就会从这里开始。</p>
<h4 id="集成MongoDB"><a href="#集成MongoDB" class="headerlink" title="集成MongoDB"></a>集成MongoDB</h4><h5 id="application-properties中设置mongodb参数"><a href="#application-properties中设置mongodb参数" class="headerlink" title="application.properties中设置mongodb参数"></a>application.properties中设置mongodb参数</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.data.mongodb.uri&#x3D;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;gln-local-test</span><br></pre></td></tr></table></figure>

<h5 id="添加对MongoDB的访问"><a href="#添加对MongoDB的访问" class="headerlink" title="添加对MongoDB的访问"></a>添加对MongoDB的访问</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookRespository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(String name, Integer size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == size) &#123;</span><br><span class="line">            size = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Query query = <span class="keyword">new</span> Query();</span><br><span class="line">        query.addCriteria(Criteria.where(<span class="string">&quot;name&quot;</span>).alike(Example.of(name))).limit(size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mongoTemplate.findAll(Book.class, &quot;book&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Long <span class="title">saveBook</span><span class="params">(String name, String url, Person person)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> id = <span class="keyword">new</span> Random().nextLong();</span><br><span class="line"></span><br><span class="line">        Book book = Book.builder().id(id).name(name).url(url).person(person).build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mongoTemplate.save(book,<span class="string">&quot;book&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="添加Scalar"><a href="#添加Scalar" class="headerlink" title="添加Scalar"></a>添加Scalar</h4><p>刚才提到了GraphQL,它只提供了Int,Float,String,Enum以及自定义Type(class)类型,对于其他的需要自定义,实际上也就是定义如何序列化以及反序列化,这种自定义类型被称为scalar.刚才接口中定义了Long,所以我们需要写一个Long的scalar.实际上就是自定义序列化以及反序列化的规则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Scalars</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> GraphQLScalarType JAVA_LONG = <span class="keyword">new</span> GraphQLScalarType(<span class="string">&quot;Long&quot;</span>, <span class="string">&quot;Java Long scalar&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> Coercing() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Long <span class="title">serialize</span><span class="params">(Object dataFetcherResult)</span> <span class="keyword">throws</span> CoercingSerializeException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> Long.parseLong(dataFetcherResult.toString());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">parseValue</span><span class="params">(Object input)</span> <span class="keyword">throws</span> CoercingParseValueException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> serialize(input);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Long <span class="title">parseLiteral</span><span class="params">(Object input)</span> <span class="keyword">throws</span> CoercingParseLiteralException </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(input <span class="keyword">instanceof</span> StringValue) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Long.parseLong(((StringValue) input).getValue());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(input <span class="keyword">instanceof</span> IntValue) &#123;</span><br><span class="line">                        <span class="keyword">return</span> ((IntValue) input).getValue().longValue();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="添加SpringMVC支持"><a href="#添加SpringMVC支持" class="headerlink" title="添加SpringMVC支持"></a>添加SpringMVC支持</h4><p>之前的配置只是对接口定义的诠释，但是要谈到和SpringMVC对接其实还没有，那么接下来的配置就是和SpringMVC进行对接了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphqlEndpoint</span> <span class="keyword">extends</span> <span class="title">SimpleGraphQLServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GraphqlEndpoint</span><span class="params">(Query query, Mutation mutation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(SchemaParser.newParser()</span><br><span class="line">                .file(<span class="string">&quot;schema.graphqls&quot;</span>)</span><br><span class="line">                .resolvers(query,mutation)      <span class="comment">//引如resovler</span></span><br><span class="line">                .scalars(Scalars.JAVA_LONG)  <span class="comment">//引入刚才定义的scalar</span></span><br><span class="line">                .build()</span><br><span class="line">                .makeExecutableSchema());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//统一的入口,graphQL通过这个统一入口将请求进行分发给各个resolver</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphqlController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GraphQLServlet graphQLServlet;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/graphql&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">graphql</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        graphQLServlet.service(request,response);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="添加对应的实体类"><a href="#添加对应的实体类" class="headerlink" title="添加对应的实体类"></a>添加对应的实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonParam</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="开始真正的表演了"><a href="#开始真正的表演了" class="headerlink" title="开始真正的表演了"></a>开始真正的表演了</h4><p>接下来就要开始发起请求了,那么我们可以使用GraphQL Playground(或者google graphiql插件)或者post man来进行测试,这里我两个都使用</p>
<p><img data-src="/images/graphql-postman-get.png" alt="postman get测试"></p>
<p><img data-src="/images/graphql-test-background.png" alt="graphql background测试"></p>
<p>query后面那一串其实是<br>query {<br>  books(name:”MongoDB”,size:10) {<br>    name<br>    url<br>    person {<br>      name<br>      age<br>    }<br>  }<br>}<br>的url转义。所以如果使用get方法发起请求，将查询参数放到url后面，需要将参数转义之后发起请求。如果使用post方法则值需要将请求体放到body中即可</p>
<h4 id="关于权限的验证"><a href="#关于权限的验证" class="headerlink" title="关于权限的验证"></a>关于权限的验证</h4><p>这里给出一个自定义的实现,在GraphqlEndpoint复写下面的方法,然后在Query或者Mutation中就可以通过DataFetchingEnvironment获取到自定义的context,通过其中的request来进行权限验证了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> GraphQLContext <span class="title">createContext</span><span class="params">(Optional&lt;HttpServletRequest&gt; request, Optional&lt;HttpServletResponse&gt; response)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//从request获取到cookie token等能证明用于身份的数据,解析出user</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> AuthContext(user,request,response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthContext</span> <span class="keyword">extends</span> <span class="title">GraphQLContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthUser authUser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthContext</span><span class="params">(AuthUser user, Optional&lt;HttpServletRequest&gt; request, Optional&lt;HttpServletResponse&gt; response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request, response);</span><br><span class="line">        <span class="keyword">this</span>.authUser = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthUser <span class="title">getAuthUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> authUser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://graphql.github.io/learn/schema/">http://graphql.github.io/learn/schema/</a></p>
<p><a href="https://www.howtographql.com/graphql-java/1-getting-started/">https://www.howtographql.com/graphql-java/1-getting-started/</a></p>
]]></content>
      <categories>
        <category>Graphql</category>
      </categories>
      <tags>
        <tag>Graphql</tag>
      </tags>
  </entry>
  <entry>
    <title>Graphql在项目中的使用(二)</title>
    <url>/2018/10/30/how-to-use-graphql2/</url>
    <content><![CDATA[<p>在上一篇文章中我们介绍了Graphql集成SpringMVC，今天就来介绍下GraphQLResolver的使用。<br>假设我们想要Book这个API返回desc这个字段,desc可能并不在数据库中,或者是你想个性化定制你的返回数据,这个时候就轮到GraphQLResolver了。</p>
<h3 id="GraphQLResolver的使用"><a href="#GraphQLResolver的使用" class="headerlink" title="GraphQLResolver的使用"></a>GraphQLResolver的使用</h3><ol>
<li>首先将schema.graphqls中关于book的声明变更如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Book &#123;</span><br><span class="line">id: Long</span><br><span class="line">name: String</span><br><span class="line">url: String</span><br><span class="line">person: Person</span><br><span class="line">desc: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是Book类的声明仍然没有任何变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> Long id;    </span><br><span class="line">    <span class="keyword">private</span> String name;    </span><br><span class="line">    <span class="keyword">private</span> String url;   </span><br><span class="line">    <span class="keyword">private</span> Person person;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 但是我们的声明中是添加了desc这个字段的,那么我们怎么处理这个字段呢？</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.coxautodev.graphql.tools.GraphQLResolver;</span><br><span class="line"><span class="keyword">import</span> com.generalthink.graphql.com.generalthink.graphql.bean.Book;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookResolver</span> <span class="keyword">implements</span> <span class="title">GraphQLResolver</span>&lt;<span class="title">Book</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//获取desc字段的处理方式，getUpperFieldName</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Java&quot;</span>.equals(book.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;great book&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;unrecommened book&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在GraphqlEndopoint中声明需要处理的resolver:</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphqlEndpoint</span> <span class="keyword">extends</span> <span class="title">SimpleGraphQLServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GraphqlEndpoint</span><span class="params">(Query query, Mutation mutation, BookResolver bookResolver)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(SchemaParser.newParser()</span><br><span class="line">.file(<span class="string">&quot;schema.graphqls&quot;</span>)</span><br><span class="line">.resolvers(query,mutation,bookResolver)</span><br><span class="line">.scalars(Scalars.JAVA_LONG)</span><br><span class="line">.build()</span><br><span class="line">.makeExecutableSchema());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时使用grapqhql playgound发起请求：<br><img data-src="/images/graphql2-playground-post.png" alt="grapqhl palyground"></p>
<h3 id="Graphql-Playground的使用"><a href="#Graphql-Playground的使用" class="headerlink" title="Graphql Playground的使用"></a>Graphql Playground的使用</h3><p>playground工具还有一个chome插件版,可以在应用商店搜索graphiql安装,同样可以提供一样的功能，上面看了知道如何发起请求，但是在我们前端中如何发起请求呢？</p>
<p>首先打开chrome调试工具<br><img data-src="/images/graphql2-playground-open-console.png" alt="打开dev Tool"></p>
<p>发起graphql请求，可以在dev tools中看到具体的请求，此时可以将请求复制为cURL或者查看具体的发起的请求体<br><img data-src="/images/graphql2-devtool-copy2curl.png" alt="请求拷贝为cURL"></p>
<p>这里我们把具体请求导出为cURL，然后导入到postman中<br><img data-src="/images/graphql2-curl-postman.png" alt="导入请求到postman"></p>
<p>查看请求结果<br><img data-src="/images/graphql2-get-request-in-postman.png" alt="在postman中发起请求"></p>
<p>会发现在web请求中，是将请求参数全部放到body体中发送到后端的。在这次使用过程中，发现graphql所有返回的参数都是可以由前端自己定制的,而且使用graphql playground的过程可以让我们知道请求需要哪些参数，返回可以由哪些值，使用还是极为方便的。</p>
]]></content>
      <categories>
        <category>Graphql</category>
      </categories>
      <tags>
        <tag>Graphql</tag>
      </tags>
  </entry>
  <entry>
    <title>关于wait,notify,join,sleep的用法说明</title>
    <url>/2018/07/16/how-to-use-methods-about-thread/</url>
    <content><![CDATA[<p>提到多线程总是绕不开wait,notify,notifyAll这些操作,在往下看之前,问问自己真的知道它们怎么使用吗?</p>
<h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，我举个例子来帮助理解。<br>唐僧对悟空说:”悟空,你要好好保护我，取经路上艰辛呀,但是为师现在有点饿了，你去给我化点斋饭吧?”,悟空心想，我又要保护你，又要给你化缘，我很可咋办呀？(同一时间一个CPU只能处理一个任务，这里的悟空就是一个进程),突然悟空灵光一闪，我用我的猴毛变一个我，然后去给师傅老人家化缘不就行了，这样我也可以保护师傅(分出去的猴毛就是一个线程)。<br>所以，线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>Java的<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html">Thread.State</a>中定义了线程的6种状态,分别如下：</p>
<ol>
<li>NEW    未启动的,不会出现在dump文件中(可以通过jstack命令查看线程堆栈)</li>
<li>RUNNABLE    正在JVM中执行的</li>
<li>BLOCKED    被阻塞,等待获取监视器锁进入synchronized代码块或者在调用Object.wait之后重新进入synchronized代码块</li>
<li>WAITING    无限期等待另一个线程执行特定动作后唤醒它,也就是调用Object.wait后会等待拥有同一个监视器锁的线程调用notify/notifyAll来进行唤醒</li>
<li>TIMED_WAITING    有时限的等待另一个线程执行特定动作</li>
<li>TERMINATED    已经完成了执行</li>
</ol>
<h3 id="和多线程相关的方法以及关键字"><a href="#和多线程相关的方法以及关键字" class="headerlink" title="和多线程相关的方法以及关键字"></a>和多线程相关的方法以及关键字</h3><p>wait,notify,notifyAll,sleep,join以及synchronized</p>
<h3 id="错误的使用wait"><a href="#错误的使用wait" class="headerlink" title="错误的使用wait"></a>错误的使用wait</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ThreadTest tt = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tt.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们运行的时候会看到如下的错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalMonitorStateException</span><br></pre></td></tr></table></figure>

<p>这是为什么呢？官方API说的很清楚了，在调用这个方法的时候当前线程必须拥有这个对象的 <strong>监视器</strong>。调用了wait方法之后这个线程会释放监视器锁直到调用notify/notifyAll方法。</p>
<h3 id="如何获取监视器？"><a href="#如何获取监视器？" class="headerlink" title="如何获取监视器？"></a>如何获取监视器？</h3><p>通常我们使用synchronized关键字来获取监视器，我们可能会经常看到这样的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;synchronized method test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">execute2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (ThreadTest.class) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized code block test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       execute1();</span><br><span class="line">       System.out.println(execute2());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这就是synchronized的用法,一般使用它用来修饰语句或者修饰方法,对于synchronized语句当Java源代码被javac编译成bytecode的时候，会在同步块的入口位置和退出位置分别插入monitorenter和monitorexit字节码指令.而synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、return指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象这里就不对synchronized原理做深入说明了。</p>
<p><img data-src="/images/synchro_compile_code.png" alt="反编译代码"></p>
<h3 id="为什么使用synchronized"><a href="#为什么使用synchronized" class="headerlink" title="为什么使用synchronized"></a>为什么使用synchronized</h3><p>synchonized用于实现多线程的同步操作，一般多线程协作过程中,都会操作共享资源,可能是某个类,比如HashMap也可能是硬盘文件,数据库资源等等，不正当的操作方式会导致结果难以预料。线程安全需要保证几个基本特征：</p>
<ol>
<li><p>原子性，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现</p>
</li>
<li><p>可见性，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态同步到主内存上，volatile就可以保证可见性</p>
</li>
<li><p>有序性，是保证线程内串行语义，避免<a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html">指令重排</a></p>
</li>
</ol>
<p>而synchronized能保证这些特性，所以它也是保证线程安全的一种手段，但是不要滥用，容易导致死锁，关于线程安全你可以看看我的这篇<a href="http://generalthink.github.io/2016/09/21/talk-thread-safe/">文章</a>,当然今天的重点不是这个，毕竟我们聊的是wait。</p>
<h3 id="什么是监视器-monitor"><a href="#什么是监视器-monitor" class="headerlink" title="什么是监视器(monitor)"></a>什么是监视器(monitor)</h3><p>Java中每一个对象都可以成为一个监视器（Monitor）, 该Monitor由一个锁（lock）, 一个等待队列（waiting queue ）, 一个入口队列( entry queue).<br>对于一个对象的方法， 如果没有synchonized关键字， 该方法可以被任意数量的线程，在任意时刻调用。<br>对于添加了synchronized关键字的方法，任意时刻只能被唯一的一个获得了对象实例锁的线程调用。</p>
<p><img data-src="/images/java_monitor.bmp" alt="java监视器"></p>
<p><strong>进入区(Entry Set):</strong> 表示线程通过 synchronized要求获得对象锁，如果获取到了，则成为拥有者，如果没有获取到在在进入区等待，直到其他线程释放锁之后再去竞争(谁获取到则根据)</p>
<p><strong>拥有者(Owner):</strong> 表示线程获取到了对象锁，可以执行synchronized包围的代码了</p>
<p><strong>等待区(Wait Set):</strong> 表示线程调用了wait方法,此时释放了持有的对象锁，等待被唤醒(谁被唤醒取得监视器锁由jvm决定)</p>
<h3 id="正确的使用wait-notify"><a href="#正确的使用wait-notify" class="headerlink" title="正确的使用wait/notify"></a>正确的使用wait/notify</h3><p>之前也说了wait/notify是为了处理线程之间协作的问题的，那么既然是协作必然涉及到了对公共资源的操作。所以我们举一个生产者消费者的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Thread producer = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(queue,<span class="number">20</span>));</span><br><span class="line">    Thread consumer = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(queue,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    producer.start();</span><br><span class="line">    consumer.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    Integer maxSize = <span class="number">10</span>;</span><br><span class="line">    Integer maxTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Queue&lt;Integer&gt; queue, Integer maxTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        <span class="keyword">this</span>.maxTime = maxTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= maxTime) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                <span class="keyword">while</span> (queue.size() &gt;= maxSize) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;waiting producer&quot;</span>);</span><br><span class="line">                        queue.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 产生一个数据</span></span><br><span class="line">                <span class="keyword">int</span> d = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">                queue.add(d);</span><br><span class="line">                System.out.println(<span class="string">&quot;producer queue size is &quot;</span> + queue.size() + <span class="string">&quot;,produce data &quot;</span> + d);</span><br><span class="line"></span><br><span class="line">                queue.notify();</span><br><span class="line"></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    Integer maxTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Queue queue,Integer maxTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        <span class="keyword">this</span>.maxTime = maxTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= maxTime) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                <span class="keyword">while</span>(queue.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;consume data &quot;</span> + queue.poll());</span><br><span class="line">                <span class="comment">//去唤醒生产者</span></span><br><span class="line">                queue.notify();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">producer queue size is 1,produce data  99</span><br><span class="line">producer queue size is 2,produce data  55</span><br><span class="line">producer queue size is 3,produce data  59</span><br><span class="line">producer queue size is 4,produce data  78</span><br><span class="line">producer queue size is 5,produce data  99</span><br><span class="line">producer queue size is 6,produce data  30</span><br><span class="line">producer queue size is 7,produce data  40</span><br><span class="line">producer queue size is 8,produce data  28</span><br><span class="line">producer queue size is 9,produce data  52</span><br><span class="line">producer queue size is 10,produce data  57</span><br><span class="line">queue is full,waiting produce</span><br><span class="line">consume data 99</span><br><span class="line">consume data 55</span><br><span class="line">consume data 59</span><br><span class="line">consume data 78</span><br><span class="line">consume data 99</span><br><span class="line">consume data 30</span><br><span class="line">consume data 40</span><br><span class="line">consume data 28</span><br><span class="line">consume data 52</span><br><span class="line">consume data 57</span><br><span class="line">producer queue size is 1,produce data  29</span><br><span class="line">producer queue size is 2,produce data  72</span><br><span class="line">producer queue size is 3,produce data  8</span><br><span class="line">producer queue size is 4,produce data  66</span><br><span class="line">producer queue size is 5,produce data  27</span><br><span class="line">producer queue size is 6,produce data  37</span><br><span class="line">producer queue size is 7,produce data  27</span><br><span class="line">producer queue size is 8,produce data  27</span><br><span class="line">producer queue size is 9,produce data  4</span><br><span class="line">producer queue size is 10,produce data  87</span><br><span class="line">queue is full,waiting produce</span><br><span class="line">consume data 29</span><br><span class="line">consume data 72</span><br><span class="line">consume data 8</span><br><span class="line">consume data 66</span><br><span class="line">consume data 27</span><br><span class="line">consume data 37</span><br><span class="line">consume data 27</span><br><span class="line">consume data 27</span><br><span class="line">consume data 4</span><br><span class="line">consume data 87</span><br><span class="line">producer queue size is 1,produce data  79</span><br><span class="line">consume data 79</span><br></pre></td></tr></table></figure>

<p>上面的wait的用法基本可以简化成为这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(queue) &#123;<span class="comment">//使当前线程获取到queue对象的监视器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//让拥有queue对象监视器的线程进行等待(让出monitor使用权)直到被唤醒(notify/notifyAll)</span></span><br><span class="line">    queue.wait();</span><br><span class="line"></span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，wait和notify/notifyAll基本上是成对出现的,<br>wait(0)=wait()后的线程必须要由notify/notifyAll唤醒才能继续去竞争锁，从而运行wait之后的代码.如果调用的wait(200)这种代码,那么会在200ms后将线程从waiting set中移除并允许其重新竞争锁，需要注意的是notify方法并不会释放所持有的monitor.</p>
<h3 id="join的使用"><a href="#join的使用" class="headerlink" title="join的使用"></a>join的使用</h3><p>先来看看join的源码，咋在接着分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们写了这样的一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread th = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadTest());</span><br><span class="line">        th.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            th.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread execute over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sleep 3s&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;wake up&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么输出结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sleep <span class="number">3</span>s</span><br><span class="line">wake up</span><br><span class="line">main thread execute over</span><br></pre></td></tr></table></figure>

<p>如果将th.join修改为th.join(2000)那么main thread会在sleep 3s之后打印。<br>上面我们贴出来了join的源码，其实我觉得th.join()可以修改成为这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(th) &#123;</span><br><span class="line"><span class="keyword">while</span>(th.isAlive()) &#123;</span><br><span class="line">    th.wait();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>synchronized关键字是加在方法上面的，这个方法并不是一个static方法，所以此时获取到的是线程实例的监视器，在上面这段代码中获取到的就是th这实例的监视器。由于是main线程运行的th.join()这段代码所以会导致main线程进行等待(等待时间可以通过添加调用不同的方法来决定，比如wait(2000),join(2000)),上面我们发现join方法其实内部也是使用的wait，但是是哪里notify的呢？官方api说明，在线程结束后会隐含的调用notifyAll方法，所以才会有输出，如果把锁加在其他对象(比如new Object)上，会发现一直等待，应用程序无法退出。</p>
<h3 id="关于sleep"><a href="#关于sleep" class="headerlink" title="关于sleep"></a>关于sleep</h3><p>它是一个静态方法，一般的调用方式是Thread.sleep(2000),表示让当前线程休眠2000ms,并不会让出监视器，这一点需要注意。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>wait/notify基本上是成对出现，有时候在代码中使用不当会导致程序出现异常效果</li>
<li>关于monitor的概念需要了解清楚，wait/join方法会让出monitor,notify不会</li>
</ol>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>在Docker中使用HBase</title>
    <url>/2018/11/24/how-to-use-hbase-in-docker/</url>
    <content><![CDATA[<p>由于hbase依赖于hadoop,所以想要使用hbase必须先要安装hadoop(主要是我懒),我们可以通过docker使用别人安装好的hbase.</p>
<h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>docker的安装很简单,请参考<a href="http://www.runoob.com/docker/centos-docker-install.html">http://www.runoob.com/docker/centos-docker-install.html</a></p>
<h3 id="查看hbase镜像"><a href="#查看hbase镜像" class="headerlink" title="查看hbase镜像"></a>查看hbase镜像</h3><p>首先查看关于hbase的镜像有哪些,运行 <code>docker search hbase</code></p>
<p><img data-src="/images/hbase-docker-search-image.png" alt="查看镜像"></p>
<p>我们就使用第一个好了,毕竟star最多。</p>
<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>使用命令 <code>docker pull harisekhon/hbase</code> 就会将镜像拉取到本地。然后查看当前本地存在哪些镜像</p>
<p><img data-src="/images/hbase-docker-list-images.png" alt="列出本地镜像"></p>
<h3 id="运行hbase容器并进入容器内部"><a href="#运行hbase容器并进入容器内部" class="headerlink" title="运行hbase容器并进入容器内部"></a>运行hbase容器并进入容器内部</h3><ol>
<li><p><code>docker run -dit harisekhon/hbase</code></p>
<p>启动容器,默认的版本是latest,如果运行的版本不是需要加上版本,比如<code>docker run -dit harisekhon/hbase:1.0</code><br><img data-src="/images/hbase-docker-run-image.png" alt="启动HBase容器"></p>
</li>
<li><p><code>docker exec -it dc0716 bash</code>(进入容器内部,这里的dc0716是容器id前几位)</p>
</li>
</ol>
<p><img data-src="/images/hbase-docker-exec-bash.png" alt="进入容器内部"></p>
<p>可以看到此时容器内的hbase目录</p>
<h3 id="运行hbase命令"><a href="#运行hbase命令" class="headerlink" title="运行hbase命令"></a>运行hbase命令</h3><p><img data-src="/images/hbase-docker-hbase-shell.png" alt="运行hbase shell"></p>
<p>运行了<code>./hbase shell</code>命令后就进入了hbase shell命令行，此时可以用命令的方式查看hbase状态,新建表等<br>由于我们安装的hbase镜像是一个伪分布式的，只有一个服务器，所以查看状态显示只有一个server</p>
<p><img data-src="/images/hbase-docker-hbase-status.png" alt="Hbase status"></p>
<p>更多的hbase命令将在下一篇文章中讲解</p>
<h3 id="连接服务器的hbase"><a href="#连接服务器的hbase" class="headerlink" title="连接服务器的hbase"></a>连接服务器的hbase</h3><p>hbase默认使用的配置文件是hbase-site.xml位于hbase安装路径下的conf目录，有时候我们可能没有权限连接远程服务器,但是又想要看hbase的数据怎么办呢？这个时候可以修改hbase-site.xml中的配置连接上远程服务器。将项目中的hbase-site.xml替换默认的hbase-site.xml然后重新进入hbase shell即可。但是需要注意的是由于我们使用的docker，所以每次虚拟机关闭之后对hbase容器的修改都会还原，所以如果想要修改之后一直生效可以将修改保存成另一个镜像。</p>
<pre><code>1. 替换自带的hbase-site.xml
2. docker commit containerId  saveImageName:version
    比如： docker commit 430d centor-tar:1.0</code></pre>
<p>之前也提到了hbase需要依赖于hadoop以及zookeeper,hbase自带了一个zookeeper,可以不使用它，而使用已有的zookeeper。所以能连接远程hbase服务器主要是因为我们在hbase-site.xml中配置了hadoop以及zookeeper的地址,这两个配置项的属性如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9020/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的localhost:9020需要替换成对应服务器上Hadoop的地址以及端口,通过它们的配置我们就可以去hbase shell上愉快的操作hbase了。</p>
]]></content>
      <categories>
        <category>HBase</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile的使用以及实践</title>
    <url>/2020/02/14/how-to-write-dockerfile/</url>
    <content><![CDATA[<p>Dockerfile是Docker用来构建镜像的文本文件,包括自定义的指令和格式。可以通过docker build命令从Dockerfile中构建镜像。用户可以通过统一的语法命令来根据需求进行配置，通过这份统一的配置文件，在不同的文件上进行分发，需要使用时就可以根据配置文件进行自动化构建，这解决了开发人员构建镜像的复杂过程。</p>
<a id="more"></a>
<h3 id="Dockerfile的使用"><a href="#Dockerfile的使用" class="headerlink" title="Dockerfile的使用"></a>Dockerfile的使用</h3><p>Dockerfile描述了组装对象的步骤，其中每条指令都是单独运行的。除了FROM指令，其他每条命令都会在上一条指令所生成镜像的基础上执行，执行完后会生成一个新的镜像层，新的镜像层覆盖在原来的镜像之上从而形成了新的镜像。Dockerfile所生成的最终镜像就是在基础镜像上面叠加一层层的镜像层组建的。</p>
<h3 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h3><p>Dockerfile的基本格式如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Comment</span><br><span class="line">INSTRUCTION arguments</span><br></pre></td></tr></table></figure>

<p>在Dockerfile中,指令(INSTRUCTION)不区分大小写，但是为了与参数区分，推荐大写。<br>Docker会顺序执行Dockerfile中的指令，第一条指令必须是FROM指令，它用于指定构建镜像的基础镜像。在Dockerfile中以#开头的行是注释，而在其他位置出现的#会被当成参数。</p>
<p>Dockerfile中的指令有FROM、MAINTAINER、RUN、CMD、EXPOSE、ENV、ADD、COPY、ENTRYPOING、VOLUME、USER、WORKDIR、ONBUILD,错误的指令会被忽略。下面将详细讲解一些重要的Docker指令。</p>
<h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p>格式: <code>FROM &lt;image&gt; 或者 FROM &lt;image&gt;:&lt;tag&gt;</code></p>
<p>FROM指令的功能是为后面的指令提供基础镜像,因此Dockerfile必须以FROM指令作为第一条非注释指令。从公共镜像库中拉取镜像很容易,基础镜像可以选择任何有效的镜像。<br>在一个Dockerfile中FROM指令可以出现多次,这样会构建多个镜像。tag的默认值是latest,如果参数image或者tag指定的镜像不存在，则返回错误。</p>
<h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>格式: <code>ENV &lt;key&gt; &lt;value&gt; 或者 ENV &lt;key&gt;=&lt;value&gt; ...</code></p>
<p>ENV指令可以为镜像创建出来的容器声明环境变量。并且在Dockerfile中，ENV指令声明的环境变量会被后面的特定指令(即ENV、ADD、COPY、WORKDIR、EXPOSE、VOLUME、USER)解释使用。</p>
<p>其他指令使用环境变量时，使用格式为<code>$variable_name</code>或者<code>$&#123;variable_name&#125;</code>。如果在变量面前添加斜杠\可以转义。如<code>\$foo</code>或者<code>\$&#123;foo&#125;</code>将会被转换为<code>$foo</code>和<code>$&#123;foo&#125;</code>,而不是环境变量所保存的值。另外，ONBUILD指令不支持环境替换。</p>
<h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>格式: <code>COPY &lt;src&gt; &lt;dest&gt;</code></p>
<p>COPY指令复制<src>所指向的文件或目录,将它添加到新镜像中,复制的文件或目录在镜像中的路径是<code>&lt;dest&gt;</code>。<code>&lt;src&gt;</code>所指定的源可以有多个,但必须是上下文根目录中的相对路径。<br>不能只用形如 <code> COPY ../something /something</code>这样的指令。此外,<code>&lt;src&gt;</code>可以使用通配符指向所有匹配通配符的文件或目录，例如，COPY home* /mydir/ 表示添加所有以”hom”开头的文件到目录/mydir/中。</p>
<p><code>&lt;dest&gt;</code>可以是文件或目录，但必须是目标镜像中的绝对路径或者相对于WORKDIR的相对路径(WORKDIR即Dockerfile中WORKDIR指令指定的路径,用来为其他指令设置工作目录)。<br>若<code>&lt;dest&gt;</code>以反斜杠/结尾则其指向的是目录；否则指向文件。<code>&lt;src&gt;</code>同理。若<code>&lt;dest&gt;</code>是一个文件，则<code>&lt;src&gt;</code>的内容会被写到<code>&lt;dest&gt;</code>中；否则<code>&lt;src&gt;</code>指向的文件或目录中的内容会被复制添加到<code>&lt;dest&gt;</code>目录中。<br>当<code>&lt;src&gt;</code>指定多个源时，<code>&lt;dest&gt;</code>必须是目录。如果<code>&lt;dest&gt;</code>不存在，则路径中不存在的目录会被创建。</p>
<h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>格式：<code>ADD &lt;src&gt; &lt;dest&gt;</code></p>
<p>ADD与COPY指令在功能上很相似，都支持复制本地文件到镜像的功能，但ADD指令还支持其他功能。<code>&lt;src&gt;</code>可以是指向网络文件的URL,此时若<code>&lt;dest&gt;</code>指向一个目录，则URL必须是完全路径，这样可以获得网络文件的文件名filename，该文件会被复制添加到<code>&lt;dest&gt;/&lt;filename&gt;</code>。<br>比如 ADD <a href="http://example.com/config.property">http://example.com/config.property</a> / 会创建文件/config.property。</p>
<p><code>&lt;src&gt;</code>还可以指向一个本地压缩归档文件，该文件会在复制到容器时会被解压提取，如ADD sxample.tar.xz /。但是若URL中的文件为归档文件则不会被解压提取。</p>
<p>ADD 和 COPY指令虽然功能相似，但一般推荐使用COPY,因为COPY只支持本地文件，相比ADD而言，它更加透明。</p>
<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p>格式: <code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</code></p>
<p>EXPOSE指令通知Docker该容器在运行时侦听指定的网络端口。可以指定端口是侦听TCP还是UDP，如果未指定协议，则默认值为TCP。<br>这个指令仅仅是声明容器打算使用什么端口而已，并不会自动在宿主机进行端口映射,可以在运行的时候通过docker -p指定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPOSE 80&#x2F;tcp</span><br><span class="line">EXPOSE 80&#x2F;udp</span><br></pre></td></tr></table></figure>

<h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>格式: <code>USER &lt;user&gt;[:&lt;group] 或者 USER &lt;UID&gt;[:&lt;GID&gt;]</code></p>
<p>USER指令设置了user name和user group(可选)。在它之后的RUN,CMD以及ENTRYPOINT指令都会以设置的user来执行。</p>
<h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>格式: <code>WORKDIR /path/to/workdir</code></p>
<p>WORKDIR指令设置工作目录，它之后的RUN、CMD、ENTRYPOINT、COPY以及ADD指令都会在这个工作目录下运行。如果这个工作目录不存在，则会自动创建一个。<br>WORKDIR指令可在Dockerfile中多次使用。如果提供了相对路径，则它将相对于上一个WORKDIR指令的路径。例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WORKDIR &#x2F;a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure>
<p>输出结果是 /a/b/c</p>
<h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>格式1： <code>RUN &lt;command&gt;</code> (shell格式)<br>格式2： <code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> (exec格式，推荐使用)</p>
<p>RUN指令会在前一条命令创建出的镜像的基础上创建一个容器，并在容器中运行命令，在命令结束运行后提交容器为新镜像，新镜像被Dockerfile中的下一条指令使用。</p>
<p>RUN指令的两种格式表示命令在容器中的两种运行方式。当使用shell格式时，命令通过/bin/sh -c运行。<br>当使用exec格式时，命令是直接运行的，容器不调用shell程序，即容器中没有shell程序。<br>exec格式中的参数会被当成JSON数组被Docker解析，故必须使用双引号而不能使用单引号。因为exec格式不会在shell中执行，所以环境变量的参数不会被替换。</p>
<p>比如执行<code>RUN [&quot;echo&quot;, &quot;$HOME&quot;]</code>指令时，$HOME不会做变量替换。如果希望运行shell程序，指令可以写成 <code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo&quot;, &quot;$HOME&quot;]</code>。</p>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>CMD指令有3种格式。</p>
<p>格式1：<code>CMD &lt;command&gt;</code> (shell格式)<br>格式2：<code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> (exec格式，推荐使用)<br>格式3：<code>CMD [&quot;param1&quot;, &quot;param2&quot;]</code> (为ENTRYPOINT指令提供参数)</p>
<p>CMD指令提供容器运行时的默认值，这些默认值可以是一条指令，也可以是一些参数。一个Dockerfile中可以有多条CMD指令，但只有最后一条CMD指令有效。<br>CMD [“param1”, “param2”]格式是在CMD指令和ENTRYPOINT指令配合时使用的，CMD指令中的参数会添加到ENTRYPOING指令中.使用shell和exec格式时，命令在容器中的运行方式与RUN指令相同。</p>
<p>不同之处在于，RUN指令在构建镜像时执行命令，并生成新的镜像；CMD指令在构建镜像时并不执行任何命令，而是在容器启动时默认将CMD指令作为第一条执行的命令。如果用户在命令行界面运行docker run命令时指定了命令参数，则会覆盖CMD指令中的命令。</p>
<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>ENTRYPOINT指令有两种格式。</p>
<p>格式1：<code>ENTRYPOINT &lt;command&gt;</code> (shell格式)<br>格式2：<code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> (exec格式，推荐格式)</p>
<p>ENTRYPOINT指令和CMD指令类似，都可以让容器在每次启动时执行相同的命令，但它们之间又有不同。一个Dockerfile中可以有多条ENTRYPOINT指令，但只有最后一条ENTRYPOINT指令有效。</p>
<p>当使用Shell格式时，ENTRYPOINT指令会忽略任何CMD指令和docker run命令的参数，并且会运行在bin/sh -c中。这意味着ENTRYPOINT指令进程为bin/sh -c的子进程,进程在容器中的PID将不是1，且不能接受Unix信号。即当使用<code>docker stop &lt;container&gt;</code>命令时，命令进程接收不到SIGTERM信号。</p>
<p>推荐使用exec格式，使用此格式时，docker run传入的命令参数会覆盖CMD指令的内容并且附加到ENTRYPOINT指令的参数中。从ENTRYPOINT的使用中可以看出，CMD可以是参数，也可以是指令，而ENTRYPOINT只能是命令；另外，docker run命令提供的运行命令参数可以覆盖CMD,但不能覆盖ENTRYPOINT。</p>
<h3 id="Dockerfile实践心得"><a href="#Dockerfile实践心得" class="headerlink" title="Dockerfile实践心得"></a>Dockerfile实践心得</h3><h4 id="使用标签"><a href="#使用标签" class="headerlink" title="使用标签"></a>使用标签</h4><p>给镜像打上标签，有利于帮助了解进镜像功能</p>
<h4 id="谨慎选择基础镜像"><a href="#谨慎选择基础镜像" class="headerlink" title="谨慎选择基础镜像"></a>谨慎选择基础镜像</h4><p>选择基础镜像时，尽量选择当前官方镜像库的肩宽，不同镜像的大小不同，目前Linux镜像大小由如下关系:</p>
<p><code>busybox &lt; debian &lt; centos &lt; ubuntu</code></p>
<p>同时在构建自己的Docker镜像时,只安装和更新必须使用的包。此外相比Ubuntu镜像，更推荐使用Debian镜像，因为它非常轻量级(目前其大小是在100MB以下),并且仍然是一个完整的发布版本。</p>
<h4 id="充分利用缓存"><a href="#充分利用缓存" class="headerlink" title="充分利用缓存"></a>充分利用缓存</h4><p>Docker daemon会顺序执行Dockerfile中的指令，而且一旦缓存失效，后续命令将不能使用缓存。为了有效地利用缓存，需要保证指令的连续性，尽量将所有Dockerfile文件相同的部分都放在前面，而将不同的部分放到后面。</p>
<h4 id="正确使用ADD与COPY命令"><a href="#正确使用ADD与COPY命令" class="headerlink" title="正确使用ADD与COPY命令"></a>正确使用ADD与COPY命令</h4><p>当在Dockerfile中的不同部分需要用到不同的文件时，不要一次性地将这些文件都添加到镜像中去，而是在需要时添加，这样也有利于重复利用docker缓存。<br>另外考虑到镜像大小问题，使用ADD指令去获取远程URL中的压缩包不是推荐的做法。应该使用RUN wget或RUN curl代替。这样可以删除解压后不在需要的文件，并且不需要在镜像中在添加一层。</p>
<p>错误做法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD http:&#x2F;&#x2F;example.com&#x2F;big.tar.xz &#x2F;usr&#x2F;src&#x2F;things&#x2F;</span><br><span class="line">RUN tar -xJf &#x2F;usr&#x2F;src&#x2F;things&#x2F;big.tar.xz -C &#x2F;usr&#x2F;src&#x2F;things</span><br><span class="line">RUN make -C &#x2F;usr&#x2F;src&#x2F;things all</span><br></pre></td></tr></table></figure>

<p>正确的做法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN mkdir -p &#x2F;usr&#x2F;src&#x2F;things \</span><br><span class="line">    &amp;&amp; curl -SL http:&#x2F;&#x2F;example.com&#x2F;big.tar.xz \</span><br><span class="line">    | tar -xJC &#x2F;usr&#x2F;src&#x2F;things \</span><br><span class="line">    &amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;things all</span><br></pre></td></tr></table></figure>

<h4 id="RUN指令"><a href="#RUN指令" class="headerlink" title="RUN指令"></a>RUN指令</h4><p>在使用较长的RUN指令时可以使用反斜杠\分隔多行。大部分使用RUN指令的常见是运行apt-wget命令，在该场景下请注意以下几点。</p>
<ol>
<li><p>不要在一行中单独使用指令RUN apt-get update。当软件源更新后，这样做会引起缓存问题，导致RUN apt-get install指令运行失败。所以,RUN apt-get update和RUN apt-get install应该写在同一行。比如 RUN apt-get update &amp;&amp; apt-get install -y package-1 package-2 package-3</p>
</li>
<li><p>避免使用指令RUN apt-get upgrade 和 RUN apt-get dist-upgrade。因为在一个无特权的容器中，一些必要的包会更新失败。如果需要更新一个包(如package-1)，直接使用命令RUN apt-get install -y package-1。</p>
</li>
</ol>
<h4 id="CMD和ENTRYPOINT命令"><a href="#CMD和ENTRYPOINT命令" class="headerlink" title="CMD和ENTRYPOINT命令"></a>CMD和ENTRYPOINT命令</h4><p>CMD和ENTRYPOINT命令指定是了容器运行的默认命令，推荐二者结合使用。使用exec格式的ENTRYPOINT指令设置固定的默认命令和参数，然后使用CMD指令设置可变的参数。</p>
<p>比如下面这个例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">WORKDIR &#x2F;app</span><br><span class="line">COPY run.sh &#x2F;app</span><br><span class="line">RUN chmod +x run.sh</span><br><span class="line">ENTRYPOINT [&quot;&#x2F;app&#x2F;run.sh&quot;]</span><br><span class="line">CMD [&quot;param1&quot;]</span><br></pre></td></tr></table></figure>

<p>run.sh内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">echo &quot;$@&quot;</span><br></pre></td></tr></table></figure>

<p>运行后输出结果为param1, Dockerfile中CMD和ENTRYPOINT的顺序不重要(CMD写在ENTRYPOINT前后都可以)。</p>
<p>当在windows系统下build dockerfile你可能会遇到这个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">standard_init_linux.go:207: exec user process caused &quot;no such file or directory&quot;</span><br></pre></td></tr></table></figure>
<p>这是因为sh文件的fileformat是dos,这里需要修改为unix,不需要下载额外的工具，一般我们机器上安装了git会自带git bash,进入git bash,使用vi 编辑，在命令行模式下修改(:set ff=unix)。</p>
<h4 id="不要再Dockerfile中做端口映射"><a href="#不要再Dockerfile中做端口映射" class="headerlink" title="不要再Dockerfile中做端口映射"></a>不要再Dockerfile中做端口映射</h4><p>使用Dockerfile的EXPOSE指令，虽然可以将容器端口映射在主机端口上，但会破坏Docker的可移植性，且这样的镜像在一台主机上只能启动一个容器。所以端口映射应在docker run命令中用-p 参数指定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 不要再Dockerfile中做如下映射</span><br><span class="line">EXPOSE 80:8080</span><br><span class="line"></span><br><span class="line"># 仅暴露80端口,需要另做映射</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实践Dockerfile的写法"><a href="#实践Dockerfile的写法" class="headerlink" title="实践Dockerfile的写法"></a>实践Dockerfile的写法</h3><h4 id="Java-服务的DockerFile"><a href="#Java-服务的DockerFile" class="headerlink" title="Java 服务的DockerFile"></a>Java 服务的DockerFile</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8-jre-alpine</span><br><span class="line">ENV spring_profiles_active=dev</span><br><span class="line">ENV env_java_debug_enabled=<span class="literal">false</span></span><br><span class="line">EXPOSE 8080</span><br><span class="line">WORKDIR /app</span><br><span class="line">ADD target/smcp-web.jar /app/target/smcp-web.jar</span><br><span class="line">ADD run.sh /app</span><br><span class="line">ENTRYPOINT ./run.sh</span><br></pre></td></tr></table></figure>
<p>可以看到基础镜像是openjdk,然后设置了两个环境变量,服务访问端口是9090(意味着springboot应用中指定了server.port=8080),设置了工作目录是/app。通过ENTRYPOINT设定了启动镜像时要启动的命令(./run.sh)。这个脚本中的内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"># Set debug options if required</span><br><span class="line">if [ x&quot;$&#123;env_java_debug_enabled&#125;&quot; !&#x3D; x ] &amp;&amp; [ &quot;$&#123;env_java_debug_enabled&#125;&quot; !&#x3D; &quot;false&quot; ]; then</span><br><span class="line">    java_debug_args&#x3D;&quot;-agentlib:jdwp&#x3D;transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;n,address&#x3D;5005&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># ex: env_jvm_flags&#x3D;&quot;-Xmx1200m -XX:MaxRAM&#x3D;1500m&quot; for production</span><br><span class="line">java $java_debug_args $env_jvm_flags -XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap -jar target&#x2F;smcp-web.jar</span><br></pre></td></tr></table></figure>
<p>如果我们要指定jvm的一些参数,可以通过在环境变量中设置env_jvm_flags来指定。</p>
<h4 id="Maven-Dockerfile"><a href="#Maven-Dockerfile" class="headerlink" title="Maven Dockerfile"></a>Maven Dockerfile</h4><p>maven的Dockerfile也写的很好，这里我发上来也给大家参考下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8-jdk</span><br><span class="line"></span><br><span class="line">ARG MAVEN_VERSION&#x3D;3.6.3</span><br><span class="line">ARG USER_HOME_DIR&#x3D;&quot;&#x2F;root&quot;</span><br><span class="line">ARG SHA&#x3D;c35a1803a6e70a126e80b2b3ae33eed961f83ed74d18fcd16909b2d44d7dada3203f1ffe726c17ef8dcca2dcaa9fca676987befeadc9b9f759967a8cb77181c0</span><br><span class="line">ARG BASE_URL&#x3D;https:&#x2F;&#x2F;apache.osuosl.org&#x2F;maven&#x2F;maven-3&#x2F;$&#123;MAVEN_VERSION&#125;&#x2F;binaries</span><br><span class="line"></span><br><span class="line">RUN mkdir -p &#x2F;usr&#x2F;share&#x2F;maven &#x2F;usr&#x2F;share&#x2F;maven&#x2F;ref \</span><br><span class="line">  &amp;&amp; curl -fsSL -o &#x2F;tmp&#x2F;apache-maven.tar.gz $&#123;BASE_URL&#125;&#x2F;apache-maven-$&#123;MAVEN_VERSION&#125;-bin.tar.gz \</span><br><span class="line">  &amp;&amp; echo &quot;$&#123;SHA&#125;  &#x2F;tmp&#x2F;apache-maven.tar.gz&quot; | sha512sum -c - \</span><br><span class="line">  &amp;&amp; tar -xzf &#x2F;tmp&#x2F;apache-maven.tar.gz -C &#x2F;usr&#x2F;share&#x2F;maven --strip-components&#x3D;1 \</span><br><span class="line">  &amp;&amp; rm -f &#x2F;tmp&#x2F;apache-maven.tar.gz \</span><br><span class="line">  &amp;&amp; ln -s &#x2F;usr&#x2F;share&#x2F;maven&#x2F;bin&#x2F;mvn &#x2F;usr&#x2F;bin&#x2F;mvn</span><br><span class="line"></span><br><span class="line">ENV MAVEN_HOME &#x2F;usr&#x2F;share&#x2F;maven</span><br><span class="line">ENV MAVEN_CONFIG &quot;$USER_HOME_DIR&#x2F;.m2&quot;</span><br><span class="line"></span><br><span class="line">COPY mvn-entrypoint.sh &#x2F;usr&#x2F;local&#x2F;bin&#x2F;mvn-entrypoint.sh</span><br><span class="line">COPY settings-docker.xml &#x2F;usr&#x2F;share&#x2F;maven&#x2F;ref&#x2F;</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;mvn-entrypoint.sh&quot;]</span><br><span class="line">CMD [&quot;mvn&quot;]</span><br></pre></td></tr></table></figure>
<p>可以看到它是基于openjdk这个基础镜像来创建的，先去下载maven的包，然后进行了安装。 然后又设置了MAVEN_HOME和MAVEN_CONFIG这两个环境变量，最后通过mvn-entrypoing.sh来进行了启动。</p>
<h4 id="前端服务的两阶段构建"><a href="#前端服务的两阶段构建" class="headerlink" title="前端服务的两阶段构建"></a>前端服务的两阶段构建</h4><p>我有一个前端服务，目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls frontend&#x2F;</span><br><span class="line">myaccount&#x2F;  resources&#x2F;  third_party&#x2F;</span><br></pre></td></tr></table></figure>

<p>myaccount目录下是放置的js,vue等，resources放置的是css,images等。third_party放的是第三方应用。</p>
<p>这里采用了两阶段构建，即采用上一阶段的构建结果作为下一阶段的构建数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM node:alpine as builder</span><br><span class="line">WORKDIR &#39;&#x2F;build&#39;</span><br><span class="line">COPY myaccount .&#x2F;myaccount</span><br><span class="line">COPY resources .&#x2F;resources</span><br><span class="line">COPY third_party .&#x2F;third_party</span><br><span class="line"></span><br><span class="line">WORKDIR &#39;&#x2F;build&#x2F;myaccount&#39;</span><br><span class="line"></span><br><span class="line">RUN npm install</span><br><span class="line">RUN npm rebuild node-sass</span><br><span class="line">RUN npm run build</span><br><span class="line"></span><br><span class="line">RUN ls &#x2F;build&#x2F;myaccount&#x2F;dist</span><br><span class="line"></span><br><span class="line">FROM nginx</span><br><span class="line">EXPOSE 80</span><br><span class="line">COPY --from&#x3D;builder &#x2F;build&#x2F;myaccount&#x2F;dist &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br></pre></td></tr></table></figure>

<p>需要注意结尾的 <code>--from=builder</code>这里和开头是遥相呼应的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我相信看完dockerfile指令,你看任何一个dockerfile应该都没有太大问题,不记得的命令回来翻一下就行了。如果你觉得还可以，关注下哟。 公众号: think123</p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>万万没想到,我还是找到了适合我理解的全排列实现方式</title>
    <url>/2020/04/09/how-to-write-permutation/</url>
    <content><![CDATA[<p>以前刚入行当CRUD boy的时候，我常去刷leetcode,每次遇到排列问题以及它的变种我就抓瞎了，然后搜索别人的实现方式我发现我都无法理解，甚至我还背过这类题的解法，可惜没啥用，过几天又忘记了，想不到时隔多年，我还是找到了一种适合我理解的实现方式。</p>
<p>我们初高中的时候，都学过排列，它的概念是这么说的：从 n 个不同的元素中取出m（1≤m≤n）个不同的元素，按照一定的顺序排成一列，这个过程就叫排列。当 m=n 这种特殊情况出现的时候，就是全排列（All Permutation）。如果选择出的这 m 个元素可以有重复的，这样的排列就是为重复排列（否则就是不重复排列。</p>
<p>如果有这样一道题：求 1,2,3,4,5五个数字的全排列，那么该如何实现呢？我们都知道答案是有120种(5<em>4</em>3<em>2</em>1=120)。</p>
<p>很明显这这里我们会想到用递归来做,以下是我的心路历程：</p>
<a id="more"></a>

<p><img data-src="/images/java/permutation.png" alt="全排列"></p>
<p>我这里只列举了3个数字的，不过也差不多一样的意思。代码应该很容易写出来，递归而已! 先回顾下递归三要素</p>
<ol>
<li>一个问题的解可以分解为几个子问题的解</li>
</ol>
<ol start="2">
<li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li>
</ol>
<ol start="3">
<li>存在递归终止条件<br>5个数字都参与了全排列则递归终止</li>
</ol>
<p>所以代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> numbers 函数执行前,当前还未参与全排列的数字</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> result 函数执行前,已经参与过全排列的数字以及顺序</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allPermutation</span><span class="params">(ArrayList&lt;Integer&gt; numbers, ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有数字都参与过了，则排列结束</span></span><br><span class="line">    <span class="keyword">if</span> (numbers.isEmpty()) &#123;</span><br><span class="line">      System.out.println(result);</span><br><span class="line">      count++;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从剩下的未排列的数字中选择一个加入结果</span></span><br><span class="line">      ArrayList&lt;Integer&gt; newResult = (ArrayList&lt;Integer&gt;) result.clone();</span><br><span class="line">      newResult.add(numbers.get(i));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将以选择的数字从未排列的列表中移出</span></span><br><span class="line">      ArrayList&lt;Integer&gt; newNumbers = (ArrayList&lt;Integer&gt;) numbers.clone();</span><br><span class="line">      newNumbers.remove(i);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 递归调用，对于剩余的数字继续生成排列</span></span><br><span class="line">      allPermutation(newNumbers, newResult);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    numbers.add(<span class="number">1</span>);</span><br><span class="line">    numbers.add(<span class="number">2</span>);</span><br><span class="line">    numbers.add(<span class="number">3</span>);</span><br><span class="line">    numbers.add(<span class="number">4</span>);</span><br><span class="line">    numbers.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    allPermutation(numbers, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span> count == <span class="number">120</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我认为这里<strong>最重要的思想是将数字分为了两堆,分别是未参与排列的数字(numbers)以及已经参与过全排列的数字以及顺序(result)。</strong></p>
<p>万万没想到，CRUD boy也找到了属于自己解题的方式。</p>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>从Eclipse到Idea,常用的快捷键</title>
    <url>/2018/07/11/idea-shortcut-key-md/</url>
    <content><![CDATA[<h3 id="从Eclipse转到Idea"><a href="#从Eclipse转到Idea" class="headerlink" title="从Eclipse转到Idea"></a>从Eclipse转到Idea</h3><p>我用了七年的Eclipse，熟悉了Eclipse的快捷键，今年转战到Idea,还有有点不喜欢，虽然可以切换到Eclipse的快捷键，但是其他人的不会切换，以后你在别人电脑上调试或者别人帮你看问题的时候就会不喜欢，干脆就不换了，但是有些快捷键确实记不住，而且也很多，就记录下自己常用的快捷键。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1. 根据模糊的类名或者方法名查找Java文件： Ctrl+Shift+Alt+N</span><br><span class="line"></span><br><span class="line">2. 查找文件或目录: Ctrl+Shift+N后，使用&#x2F;然后输入目录名称即可</span><br><span class="line"></span><br><span class="line">3. 查看所有快捷键: Ctrl+Shift+A(很常用)</span><br><span class="line"></span><br><span class="line">4. 在当前窗口弹出某个类的定义: Ctrl+Shift+i</span><br><span class="line"></span><br><span class="line">5. 实现接口方法： Ctrl+I</span><br><span class="line"></span><br><span class="line">6. 复写或者实现父类的方法: Ctrl+O</span><br><span class="line"></span><br><span class="line">7. 快速返回上次查看代码的位置: Ctrl+Alt+方向键</span><br><span class="line"></span><br><span class="line">8. 一键格式化代碼: Ctrl+Alt+L</span><br><span class="line"></span><br><span class="line">9. 去掉无效的import: Ctrl+Alt+O</span><br><span class="line"></span><br><span class="line">9. 删除一行: Ctrl+X  或者Ctrl+Y</span><br><span class="line"></span><br><span class="line">10. 查看类或接口的继承关系：Ctrl+H</span><br><span class="line"></span><br><span class="line">11. 查找接口的实现类： ctrl + alt +B</span><br><span class="line"></span><br><span class="line">12. 复制行: Ctrl+D</span><br><span class="line"></span><br><span class="line">13. 快速打开类: Ctrl+N</span><br><span class="line"></span><br><span class="line">14. 查看当前类的所有方法: Alt+7  或者Ctrl+F12(这个放方便)</span><br><span class="line"></span><br><span class="line">15. 查看下一个方法: ctrl+下方向键</span><br><span class="line"></span><br><span class="line">16. 查看上一个方法: ctrl+上方向键</span><br><span class="line"></span><br><span class="line">15. 关闭Tab页 : Ctrl+F4</span><br><span class="line"></span><br><span class="line">16. 查看方法被都被谁调用了： Ctrl+Alt+H  会显示出哪些类调用了它以及次数</span><br><span class="line"></span><br><span class="line">17. 精确查看被谁调用了： Alt+F7</span><br><span class="line"></span><br><span class="line">18. 寻找Controller中URL路径： Ctrl+Alt+Shift+H 或者 double shift(search everything)</span><br><span class="line"></span><br><span class="line">19. 添加bookmark方法：</span><br><span class="line">    1. 使用Ctrl+F12列出该类的所有方法，定位到你想要加入的方法</span><br><span class="line">    2. 按下F11，将方法加入到bookmark</span><br><span class="line">    3. 按下shift+F11,将bookmark列表弹出来</span><br><span class="line">    4. 在上面可以进行对应的修改</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">20. 添加代码折叠块</span><br><span class="line">    1. 将光标定位在左边大括号里面，然后使用Ctrl+Shift+.即可</span><br><span class="line">    2. 按下Ctrl加上一个+即可让折叠快修改</span><br><span class="line"></span><br><span class="line">21. 大括号匹配： Ctrl+] 或者 Ctrl+[来回定位即可</span><br><span class="line"></span><br><span class="line">22. 高亮某个变量： Ctrl+Shift+F7  不会随着鼠标的移动而高亮消失</span><br><span class="line"></span><br><span class="line">23. 跳转到父类接口： Ctrl+U</span><br><span class="line"></span><br><span class="line">24. 回滚代码： Ctrl+Z  回滚回去： Ctrl+Shift+Z</span><br><span class="line"></span><br><span class="line">25. 调试</span><br><span class="line">    1. F9            resume programe 恢复程序</span><br><span class="line">    2. Alt+F10       show execution point 显示执行断点</span><br><span class="line">    3. F8            Step Over 相当于eclipse的f6      跳到下一步</span><br><span class="line">    4. F7            Step Into 相当于eclipse的f5就是  进入到代码</span><br><span class="line">    5. Alt+shift+F7  Force Step Into 这个是强制进入代码</span><br><span class="line">    6. Shift+F8      Step Out  相当于eclipse的f8跳到下一个断点，也相当于eclipse的f7跳出函数</span><br><span class="line">    7. Atl+F9        Run To Cursor 运行到光标处</span><br><span class="line"></span><br><span class="line">26. 常用插件</span><br><span class="line"></span><br><span class="line">    1. CheckStyle-IDEA   代码风格检测插件</span><br><span class="line">    2. FindBugs-IDEA      寻找代码的bug插件</span><br><span class="line">    3. Lombok plugin      支持lombok的插件</span><br><span class="line">    4. 阿里巴巴规约插件</span><br><span class="line">    5. Maven Helper     查看maven依赖关系插件</span><br><span class="line">    6. CodeGlance   类似于SublimeText的Mini Map插件</span><br><span class="line">    7. Grep Console     给工作台输出上色，根据不同的日志等级设置不同的前景色或者背景色，以及查找等功能</span><br><span class="line">    8. JRebel for IntelliJ  热部署插件修改了代码无需重启</span><br><span class="line">    9. lombok Plugin    使用lombok的都知道</span><br><span class="line">    10.  rainbow brackets    彩虹括号,代码中括号层级太多的时候你就知道它的用处了</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Idea</tag>
      </tags>
  </entry>
  <entry>
    <title>对于Http Status Code,我有话说</title>
    <url>/2020/01/08/http-status-code/</url>
    <content><![CDATA[<p>现在很多项目都是web项目，前后端分离，唯一的交互就是通过restful接口,而当我们请求返回的时候,status code如何返回呢?</p>
<p>首先介绍下常用的http status code有哪些。</p>
<h3 id="2XX-Success-成功状态码"><a href="#2XX-Success-成功状态码" class="headerlink" title="2XX(Success 成功状态码)"></a>2XX(Success 成功状态码)</h3><h4 id="200-OK"><a href="#200-OK" class="headerlink" title="200 - OK"></a>200 - OK</h4><p>请求成功</p>
<h4 id="201-Created"><a href="#201-Created" class="headerlink" title="201 - Created"></a>201 - Created</h4><p>文档创建成功,<strong>比如新增一个user成功</strong></p>
<h4 id="202-Accepted"><a href="#202-Accepted" class="headerlink" title="202 - Accepted"></a>202 - Accepted</h4><p>请求已被接受，但相应的操作可能尚未完成。这用于后台操作，<strong>例如数据库压缩等异步操作</strong></p>
<h3 id="4XX-Client-Error-客户端错误状态码"><a href="#4XX-Client-Error-客户端错误状态码" class="headerlink" title="4XX(Client Error 客户端错误状态码)"></a>4XX(Client Error 客户端错误状态码)</h3><h4 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 - Bad Request"></a>400 - Bad Request</h4><p>请求参数有误(<strong>比如应该传一个Number类型的参数，你却传了一个字符串</strong>),请求无法被服务器理解,修改后可以重新提交这个请求</p>
<a id="more"></a>

<h4 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 - Unauthorized"></a>401 - Unauthorized</h4><p>当前请求用户未被授权,<strong>比如未登陆</strong></p>
<h4 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 - Forbidden"></a>403 - Forbidden</h4><p>当前请求被拒绝。<strong>比如文件系统访问权限有问题，或者进行了越权操作(比如普通用户试图获取admin用户列表)</strong></p>
<h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 - Not Found"></a>404 - Not Found</h4><p>无法找到请求资源,<strong>一般是url错误</strong></p>
<h4 id="405-Method-Not-Allowed"><a href="#405-Method-Not-Allowed" class="headerlink" title="405 - Method Not Allowed"></a>405 - Method Not Allowed</h4><p>使用无效的HTTP请求类型对请求的URL进行了请求。<strong>比如某个api只支持post,而client却使用了get</strong></p>
<h4 id="406-Not-Acceptable"><a href="#406-Not-Acceptable" class="headerlink" title="406 - Not Acceptable"></a>406 - Not Acceptable</h4><p>服务器不支持请求的content type</p>
<h4 id="413-Request-Entity-Too-Large"><a href="#413-Request-Entity-Too-Large" class="headerlink" title="413 - Request Entity Too Large"></a>413 - Request Entity Too Large</h4><p>请求体太大不支持，<strong>一般是上传的文件超出了限定导致的。</strong></p>
<h3 id="5XX-Server-Error-服务器错误状态码"><a href="#5XX-Server-Error-服务器错误状态码" class="headerlink" title="5XX(Server Error 服务器错误状态码)"></a>5XX(Server Error 服务器错误状态码)</h3><h4 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 - Internal Server Error"></a>500 - Internal Server Error</h4><p>表示服务端在执行请求时发生了错误。 <strong>可能是服务器或者应用存在bug</strong></p>
<h4 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 - Service Unavailable"></a>503 - Service Unavailable</h4><p>服务不可用，现在无法处理请求。</p>
<h3 id="返回什么样的错误码"><a href="#返回什么样的错误码" class="headerlink" title="返回什么样的错误码"></a>返回什么样的错误码</h3><p>一般在restful API里，我们对于状态码的认定是这样的：</p>
<p><strong>1. 2xx: server 收到 client 端请求，可以执行</strong><br><strong>2. 4xx: client 送來资料有错，server 端无法执行 (client 修正错误后，可再送一次请求)</strong><br><strong>3. 5xx: client 送來的资料没错，但 server 端出错无法执行(client 端无法 take 任何 action)</strong></p>
<p>但是<strong>我也见过status code返回200,然后在response中通过自定义code告诉用户请求是否成功</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;code&quot;</span>: <span class="number">10020</span>,</span><br><span class="line">  <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;name不能为空&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>虽然萝卜青菜各有所爱,我个人仍然认为对于REST接口，就应该用HTTP层面的status来表达操作是否成功。</strong>,因为网络通讯不仅仅是一个客户端一个服务器的事情,中间会有很多层节点，如果其中某一层对status 200的请求理解非常正统,做了cache或者什么处理,那你可能就坐蜡了。而且既然是写接口，就最好标准一点,别给自己埋坑。</p>
<p>所以对于成功的请求就应该返回2XX,对于4XX接口,你可以做对应的封装</p>
<p><img data-src="/images/java/response.png" alt="返回数据"></p>
<p>状态码一定要返回4XX,但是你可以在reponse data中返回异常错误码(这个错误码是业务错误的错误码),这个时候可以和前端约定好这个业务错误码代表什么意思,就可以给用户相应的提示了。</p>
<h3 id="返回的数据格式"><a href="#返回的数据格式" class="headerlink" title="返回的数据格式"></a>返回的数据格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseResponse</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务异常码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明信息</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要封装返回的数据</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如对于<code>GET /api/users/1</code>,这样的请求返回的数据就放在data这个字段当中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;code&quot;</span>:<span class="number">200</span>,</span><br><span class="line">  <span class="string">&quot;msg&quot;</span>:<span class="string">&quot;SUCCESS&quot;</span>,</span><br><span class="line">  <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>:<span class="number">1095</span>,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而对于请求失败的错误(http status code是4XX),则是会返回下面的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;code&quot;</span>: <span class="number">10030</span>,</span><br><span class="line">  <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;id不存在&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring对Http-Status-Code的支持"><a href="#Spring对Http-Status-Code的支持" class="headerlink" title="Spring对Http Status Code的支持"></a>Spring对Http Status Code的支持</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@ResponseStatus(HttpStatus.CREATED)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BaseResponse <span class="title">addUser</span><span class="params">(UserParam userParam)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> service.addUser(userParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以直接通过<code>ResponseStatus</code>注解来指定返回的错误码是多少。当然上面说的是正常情况,那些参数失败校验失败或者是其他业务异常导致的情况如何处理呢？</p>
<p>有两种办法，第一种是通过Spring的 ResponseEntity 这个类来完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;BaseResponse&gt; <span class="title">addUser</span><span class="params">(UserParam userParam)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(validate(userParam)) &#123;</span><br><span class="line">      <span class="keyword">return</span> service.addUser(userParam);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>  <span class="keyword">new</span> ResponseEntity&lt;&gt;(ResponseUtil.fail(STATUS_INVALID_PARAM), HttpStatus.NOT_FOUND);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二种方式是借助全局异常处理,如果在service中发现客户端传递过来的参数存在问题，可以通过抛出异常,然后在全局异常拦截器中进行统一处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebExceptionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ExceptionHandler(InvalidParamException.class)</span></span><br><span class="line">  <span class="meta">@ResponseStatus(HttpStatus.BAD_REQUEST)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BaseResponse <span class="title">handleInvalidParamException</span><span class="params">(InvalidParamException e)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ResponseUtil.fail(STATUS_INVALID_PARAM, e.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>不同的情况返回不同的status code,对于失败的请求,请返回4XX,并可以通过返回数据指定业务异常code</li>
<li>内部一定要统一</li>
<li>不要让返回的status code影响你的业务逻辑</li>
</ol>
<h3 id="点关注，不迷路"><a href="#点关注，不迷路" class="headerlink" title="点关注，不迷路"></a>点关注，不迷路</h3><p>如果觉得我写的还行的话，请给我个点赞、关注、分享呀，对我是很大的激励呀。</p>
<blockquote>
<p>公众号 think123,可以第一时间阅读哟。</p>
</blockquote>
]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S集群中安装Nginx Ingress Controller</title>
    <url>/2019/11/08/install-nginx-ingress-controller/</url>
    <content><![CDATA[<p>Kubernetes Ingress是为了代理不同后端Service而设置的负载均衡服务,我们自己的每个服务可以根据自己的需求定制自己的ingress rule.</p>
<p>实际的使用中我们要选择一个具体的ingress controller，部署在k8s集群中，然后Ingress Controller会根据我们定义的Ingress对象,提供对应的代理能力。</p>
<p>比如我在们开发一个cms系统,是前后端分离的，也是分开部署的，我希望它们有这样的规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.mycms.com&#x2F;api   ---&gt; 后端</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;www.mycms.com&#x2F;   ---&gt;  前端</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>ingress很简单，下面这样就可以</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cms-ingress</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">today-partner-beta</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nginx.ingress.kubernetes.io/proxy-body-size:</span> <span class="string">&quot;20M&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mycms.com</span></span><br><span class="line">    <span class="attr">secretName:</span> <span class="string">cms-secret</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">host:</span> <span class="string">mycms.com</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/api</span></span><br><span class="line">    <span class="attr">backend:</span></span><br><span class="line">      <span class="attr">serviceName:</span> <span class="string">cms-service</span></span><br><span class="line">      <span class="attr">servicePort:</span> <span class="number">9000</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">backend:</span></span><br><span class="line">      <span class="attr">serviceName:</span> <span class="string">cms-html</span></span><br><span class="line">      <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>当我们创建了ingress之后，可以使用下面的命令查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl get ingress cms-ingress -n today-partner-beta</span><br><span class="line">NAME           HOSTS       ADDRESS          PORTS     AGE</span><br><span class="line">cms-ingress   mycms.com   172.19.88.130   80, 443     4d</span><br></pre></td></tr></table></figure>

<p>上面ingress rule这样就会形成下面的映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mycms.com -&gt; 172.19.88.130 -&gt; &#x2F;api  cms-service:9000</span><br><span class="line">                              &#x2F;     cms-html:80</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>当然在这个ingress生效之前，我们首先要在集群中安装ingress controller,它会收集所有的ingress rule,然后在遇到请求的时候进行转发</p>
<p>这里我们选择的是<a href="https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md">nginx ingress controller</a>,安装步骤如下</p>
<ol>
<li>执行下面的命令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;ingress-nginx&#x2F;master&#x2F;deploy&#x2F;static&#x2F;mandatory.yaml</span><br></pre></td></tr></table></figure>
<p>如果你使用的是1.14之前的Kubernetes版本，则需要在mandatory.yaml的第217行将kubernetes.io/os更改为beta.kubernetes.io/os，</p>
<ol start="2">
<li>使用nodeport的方式暴露nginx-controller</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;ingress-nginx&#x2F;master&#x2F;deploy&#x2F;static&#x2F;provider&#x2F;baremetal&#x2F;service-nodeport.yaml</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>验证安装是否成功</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pods --all-namespaces -l app.kubernetes.io&#x2F;name&#x3D;ingress-nginx --watch</span><br></pre></td></tr></table></figure>
<p>如果你看到ingress controller的状态是running，就代表安装成功，现在你可以安装自己的ingress了。</p>
<ol start="4">
<li>查看nginx ingress controller暴露的端口</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl get svc -n ingress-nginx</span><br><span class="line">NAME            TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">ingress-nginx   NodePort   172.19.88.130   &lt;none&gt;        80:32257&#x2F;TCP,443:30839&#x2F;TCP   6d</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到这里对外暴露出来的端口是32257和30839两个。</p>
<blockquote>
<p>这两个端口是在你配置LoadBalance的时候要用的,80–&gt;32257,443–&gt;30839</p>
</blockquote>
<p>我们的nginx-ingress-controller部署好之后，它会去拉取集群中的所有ingress-rule,当请求通过worker node转发到ingress controller之后，它会根据具体的规则将请求转发到对应的Service.</p>
<p><strong>尤其需要注意的是我们k8s集群的网络是私有的，如果你想要访问集群内的服务，只能通过worker node ip才能访问对应的服务。</strong></p>
<p>比如我的k8s集群中有3个worker node,它们的ip分别是下面这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.231.123.142</span><br><span class="line">10.231.123.143</span><br><span class="line">10.231.123.147</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一般我们会添加一个LoadBalancer,映射这三个workerer node,这个时候会分配给你一个VIP,然后在DNS中设置域名到VIP的映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mycms.com   10.128.161.21</span><br></pre></td></tr></table></figure>

<blockquote>
<p>DNS也是可以实现负载均衡的，只是DNS的实现和专业的LoadBanlance相比还是有很大区别的</p>
</blockquote>
<p><img data-src="/images/k8s/lb-http.png" alt="Load Balancer"><br><img data-src="/images/k8s/lb-https.png" alt="Load Balancer"></p>
<p>这样当我们访问<a href="https://mycms.com/api%E7%9A%84%E6%97%B6%E5%80%99,%E8%AF%B7%E6%B1%82%E9%80%9A%E8%BF%87LB%E8%BD%AC%E5%8F%91%E5%88%B0worker">https://mycms.com/api的时候,请求通过LB转发到worker</a> node,然后通过ingress controller转发到具体的service了。</p>
<p>如果你是在windows上，你可以配置hosts文件，mycms.com指向worknode ip即可。</p>
<p>** 413 Request Entity Too Large**</p>
<p>当文件上传的时候你遇到这个错误，就证明你需要适当调整你的ingress配置了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io&#x2F;proxy-body-size : &quot;20M&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>nginx-ingress</tag>
        <tag>ingress</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>在kubernetes中安装traefik2</title>
    <url>/2020/05/22/install-traefik2-in-kubernetes/</url>
    <content><![CDATA[<h3 id="traefik2-DaemonSet"><a href="#traefik2-DaemonSet" class="headerlink" title="traefik2 DaemonSet"></a>traefik2 DaemonSet</h3><p>云原生微服务中我们使用了traefik2来作为我们的网关，当然我们也是通过DaemonSet(也可以使用deployment)的方式来部署到Kubernetes集群中。<br>DaemonSet部署之后的pod有如下特征</p>
<blockquote>
<p>Kubernetes集群中的每个work node上都有这个pod(traefik2实例)<br>每个work node上只有一个这样的pod实例<br> 当有新的work node加入Kubernetes集群后，该pod会自动在新加入的work node上被创建出来，而当旧的work node被删除后,它上面的pod也会被相应的删除掉。</p>
</blockquote>
<a id="more"></a>

<p>比如我们的traefik2的DaemonSet像下面这样</p>
<p><img data-src="/images/k8s/traefik-ds.png" alt="DaemonSet"></p>
<p>需要注意的是args从configMap中引入了4个变量，其值分别如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 访问http端口</span><br><span class="line">web_port&#x3D;80</span><br><span class="line"></span><br><span class="line"># 访问https端口</span><br><span class="line">websecure_port&#x3D;443</span><br><span class="line"></span><br><span class="line"># traefik dashborad端口(默认)</span><br><span class="line">traefik_port&#x3D;8080</span><br><span class="line"></span><br><span class="line"># 监控哪个namespace资源,如果有多个,则以逗号连接。默认是所有namespace</span><br><span class="line">watch_namespace&#x3D;exmpale-beta</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你使用DaemonSet的方式安装两个相同的traefik,那么上面提及到的4个变量都要进行对应的修改<br>一个traefik提供对内服务的访问，一个traefik提供对外服务的访问</p>
</blockquote>
<p>使用了kubernetes,流量路由就如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> internet</span><br><span class="line">     |</span><br><span class="line">[ Ingress ]</span><br><span class="line">--|-----|--</span><br><span class="line">[ Services ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里定义的80/443端口就是外部的请求要通过这两个端口才能转发到Service(kubernetes)中。</p>
<h4 id="指定关注的的namespace"><a href="#指定关注的的namespace" class="headerlink" title="指定关注的的namespace"></a>指定关注的的namespace</h4><p>如果我们不指定traefik2监控的是哪个namespace的资源(默认是所有的),那么当我们访问的时候就可能访问到其他namespace的资源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -H &#39;Host: www.example-beta.com&#39; www.example-rc.com</span><br></pre></td></tr></table></figure>

<p>example-beta.com部署在example-beta这个namespace,而example-rc.com部署在example-rc这个namespace，但是通过上面的访问方式就能访问到example-beta的资源,很明显这并不安全。</p>
<p><img data-src="/images/k8s/traefik-ingressroute-1.png" alt="ingressRoute"></p>
<p>traefik ingress解析规则是根据Host头来解析的，如果我们偷天换日就会导致访问了另外一个namespace的资源。</p>
<blockquote>
<p>关于traefik ingress route我在下面还会提及</p>
</blockquote>
<h3 id="使用traefik2-IngressRoute代替Kubernetes-Ingress"><a href="#使用traefik2-IngressRoute代替Kubernetes-Ingress" class="headerlink" title="使用traefik2 IngressRoute代替Kubernetes Ingress"></a>使用traefik2 IngressRoute代替Kubernetes Ingress</h3><p>traefik2不仅可以作为网关，它还可以作为ingress controller(另一个比较出名的的nginx),有了它我们需要使用ingress route来配置我们的匹配规则而不再使用kubernetes的ingress。</p>
<p>之前kubernetes 的ingress规则是这样的</p>
<p><img data-src="/images/k8s/ingress.png" alt="Ingress"></p>
<p>而使用了ingress route之后则是这样的</p>
<p><img data-src="/images/k8s/traefik-ingressroute-2.png" alt="ingressRoute"></p>
<h3 id="为什么需要CRD"><a href="#为什么需要CRD" class="headerlink" title="为什么需要CRD?"></a>为什么需要CRD?</h3><p>IngressRoute这个Kind是traefik提供的,kubernetes并不认识它呀，不过还好kubernetes支持CRD(Custom Resource Definitions)。我们只需要加上CRD即可。</p>
<blockquote>
<p>所有关于kubernetes的CRD配置请参考官方文档: <a href="https://docs.traefik.io/reference/dynamic-configuration/kubernetes-crd/">https://docs.traefik.io/reference/dynamic-configuration/kubernetes-crd/</a></p>
</blockquote>
<h3 id="访问集群资源-RBAC"><a href="#访问集群资源-RBAC" class="headerlink" title="访问集群资源(RBAC)"></a>访问集群资源(RBAC)</h3><p>这里着重需要说明的是RBAC: 基于角色的访问控制(Role-Based Access Control)的配置</p>
<p><img data-src="/images/k8s/traefik-cluster-role.png" alt="cluster-role"></p>
<p><img data-src="/images/k8s/traefik-cluster-role-binding-user.png" alt="cluster-role-binding-user"></p>
<p>RBAC实际上很简单,想想平时做的业务系统，你只要知道下面这几个概念你就知道了。</p>
<p>Kubernetes中的service,ingress，configmap,secret等都是资源,一般是一个账号，属于什么角色，这个角色可以操控哪些资源</p>
<blockquote>
<p>比如HR可以查看员工工资,而员工只能知道自己的工资</p>
</blockquote>
<p>所以Kubernetes中也存在着三个基本概念</p>
<ol>
<li>Role : 角色，它其实是一组规则，定义了一组对Kubernetes API对象的操作权限</li>
<li>Subject：被作用者，既可以是“人”，也可以是“机器”，也可以使你在Kubernetes里定义的“用<br>户”。</li>
<li>RoleBinding：定义了“被作用者”和“角色”的绑定关系</li>
</ol>
<p><img data-src="/images/k8s/role-binding-user.png" alt="role-binding-user"></p>
<p>Role对象的rules字段，就是它所定义的权限规则。在上面的例子里，这条规则的含义就是：允许“被作用者”，对mynamespace下面的Pod对象，进行GET、WATCH和LIST操作。</p>
<p>RoleBinding对象里定义了一个subjects字段，即“被作用者”。它的类型是User，即Kubernetes里的用户。这个用户的名字是example-user。</p>
<p>这里的User实际上是Kubernetes的内置账户ServiceAccount。</p>
<p>在Kubernetes中Role和RoleBinding对象都是Namespaced对象，它们对权限的限制规则仅在它们自己的Namespace内有效。 对于非Namespaced（Non-namespaced）对象（比如：Node），或者，某一个Role想要作用于所有的Namespace的时候,就需要使用ClusterRole和ClusterRoleBinding这两个组合了。(也就是我们上面贴出来的配置)</p>
<p>至此,traefik2已经安装完毕。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对应安装第三方提供的组件，安装是存在固定流程的。</p>
<ol>
<li>使用DaemonSet/Deployment的方式安装</li>
<li>指定CRD</li>
<li>指定RBAC</li>
</ol>
<p>对于traefik2而已，如果你想要在work node上安装两个traefik(一个对内，一个对外),那么你至少需要改变三个端口。</p>
]]></content>
      <tags>
        <tag>Kubernetes</tag>
        <tag>traefik2</tag>
      </tags>
  </entry>
  <entry>
    <title>infobright使用以及问题汇总</title>
    <url>/2016/06/09/infobright-use/</url>
    <content><![CDATA[<p>最近好久没有写博客了，主要是最近太忙，一直都在加班，所以没有时间写博客，但是这个博客还是耗费了自己比较大的心血的，从备案到组建，一路过来一路心酸呀，工作一年以来自己进步也蛮大，处理事情的能力也得到了一定的提高，之前接触到的工作使用比较多的是Infobright，由于工作内容涉及到了大量的查询，也不使用事务，所用我们的数据库使用的最多的就是MyIsam以及Brighthouse引擎，但是Infobright的资料比较少，现在就针对自己在这过程中遇到的问题进行一个总结。</p>
<a id="more"></a>

<h3 id="关于Infobright"><a href="#关于Infobright" class="headerlink" title="关于Infobright"></a>关于Infobright</h3><p>Infobright是基于专利技术的列式数据库，一个基于MySQL开发的开源数据仓库（Data Warehouse）软件，可作为MySQL的一个存储引擎来使用，SELECT查询与普通MySQL无区别。</p>
<h3 id="Infobright的优点"><a href="#Infobright的优点" class="headerlink" title="Infobright的优点"></a>Infobright的优点</h3><ol>
<li><p>高压缩比率，平均压缩比可达10：1。（经测试，我们的1500万条697M日志数据压缩比例为6：1，压缩后数据大小仅为114M）</p>
</li>
<li><p>列存储，即使数据量十分巨大，查询速度也很快。（经测试，一条在infobright中的复合查询要30秒，在mysql中要一分多）</p>
</li>
<li><p>不需要建索引，就避免了维护索引及索引随着数据膨胀的问题。把每列数据分块压缩存放，每块有知识网格节点记录块内的统计信息，代替索引，加速搜索。</p>
</li>
<li><p>单一台服务器可以高效地读写30T数据。具有可扩展性，这里是指对于同样的查询，当数据量是10T时，它耗费的时间不应该比1T数据量时慢太多，基本是一个数量级内。</p>
</li>
</ol>
<p><strong>注:实际上infobright取一条记录比mysql要慢很多，但它取100W条记录会比mysql快。所以比较适用于日志、或汇总的大量的数据。</strong></p>
<h3 id="Infobright的限制"><a href="#Infobright的限制" class="headerlink" title="Infobright的限制"></a>Infobright的限制</h3><ol>
<li><p>不支持数据更新：社区版Infobright只能使用“LOAD DATA INFILE”的方式导入数据，不支持INSERT、UPDATE、DELETE</p>
</li>
<li><p>不支持高并发：只能支持10-18多个并发查询</p>
</li>
</ol>
<h3 id="Infobright的安装"><a href="#Infobright的安装" class="headerlink" title="Infobright的安装"></a>Infobright的安装</h3><h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h4><p><a href="http://www.infobright.org/index.php/download/ICE/">infobright下载地址</a></p>
<h4 id="Linux下的安装"><a href="#Linux下的安装" class="headerlink" title="Linux下的安装"></a>Linux下的安装</h4><p>网上很多Linux下的安装版本，但是大都是抄袭张宴的博客，如果需要看Linux下安装，去看张宴的博客就行了</p>
<h4 id="Windows下的安装"><a href="#Windows下的安装" class="headerlink" title="Windows下的安装"></a>Windows下的安装</h4><p><strong>安装步骤</strong><br><img data-src="/images/hexo-infobright_setup_1.png" alt="Infobright安装"></p>
<p><img data-src="/images/hexo-infobright_setup_2.png" alt="Infobright安装"></p>
<p><img data-src="/images/hexo-infobright_setup_3.png" alt="Infobright安装"></p>
<p><strong>查看安装是否成功</strong><br><img data-src="/images/hexo-infobright_setup_4.png" alt="Infobright服务启动"><br>如果服务没有启动，可以通过命令手动启动服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start infobright  --启动服务</span><br><span class="line">net stop infobright  --暂停服务</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/hexo-infobright_setup_5.png" alt="Infobright连接"></p>
<p><img data-src="/images/hexo-infobright_setup_6.png" alt="Infobright连接"></p>
<p><strong>Infobright的配置以及使用</strong><br><img data-src="/images/hexo-infobright_use_2.png" alt="Infobright的配置"><br><img data-src="/images/hexo-infobright_use_1.png" alt="创建BrightHouse数据库表"></p>
<h3 id="Infobright在Java中的使用"><a href="#Infobright在Java中的使用" class="headerlink" title="Infobright在Java中的使用"></a>Infobright在Java中的使用</h3><p>安装好了之后，我们应该如何使用呢？其实使用方式和Mysql的正常使用方式只有细微的区别，ICE版本不支持INSERT,UPDATE,DELETE语句,收费版本的可以,Select语句和Mysql使用一致。</p>
<ol>
<li><strong>建表语句</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_info`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`user_desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=BRIGHTHOUSE <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>在代码中的使用</strong></li>
</ol>
<p>查询语法和Mysql语法一致，没有任何区别(不支持insert、update、delete)</p>
<ol start="3">
<li><p><strong>注意事项</strong><br>Infobright引擎与之前MyISAM引擎不同的一些特性(会影响到我们的特性):</p>
<ul>
<li><p>不支持数据更新，只能使用“LOAD DATA INFILE”的方式导入数据，不支持INSERT、UPDATE、DELETE；如果有修改表的操作，不能使用Infobright的表。</p>
</li>
<li><p>建表时不能有AUTO_INCREMENT自增、unsigned无符号、unique唯一、主键PRIMARY KEY、索引KEY。</p>
</li>
<li><p>varchar、char字段和TEXT字段的长度可能会比之前的短。例如使用text字段，最长支持65535字节，目前只能支持22000左右。</p>
</li>
<li><p>varchar和char字段还可以使用comment lookup，comment lookup能够显著地提高压缩比率和查询性能。但是使用lookup不能离散度太高，例如一个表不能离散超过20000条。<br>comment lookup使用很简单，在创建数据库表的时候如下定义即可：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_info2`</span> (</span><br><span class="line"></span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">20</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;look up&#x27;</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`user_desc`</span> <span class="built_in">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=BRIGHTHOUSE <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>infobright</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>架构师喊我安装两个traefik</title>
    <url>/2020/12/10/install-two-traefiks/</url>
    <content><![CDATA[<p>之前有说过，我用traefik做网关，无论是内外网请求都会经过网关。</p>
<p><img data-src="/images/k8s/request-path.png" alt="请求"></p>
<p>但是我们有一部分API是只有内网会用，为了安全，我们要保证这些内网的API只有内网可以访问到。</p>
<p>但是由于之前的设置，这些API是匿名访问的，如果修改为需要权限，那么需要其他依赖于我们服务的team来做对应的修改，是由于一些原因，这条路走不通。</p>
<a id="more"></a>

<p>摆在我面前的就只有一条路，那就是安装两个traefik,一个对内，一个对外。安装两个traefik很容易，由于traefik安装采用的是DaemonSet的方式，所以两个traefik的访问端口必须不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--entryPoints.traefik.address&#x3D;:8080</span><br></pre></td></tr></table></figure>

<p>比如internet(外网)的traefik的端口是8080，那么internal的traefik就可以是9090。</p>
<p>traefik安装请看我之前的文章–<a href="https://generalthink.github.io/2020/05/22/install-traefik2-in-kubernetes/">在 kubernetes 中安装 traefik2</a>。</p>
<p>然后就可以啦？ 当然没有那么容易,为了实现下面的效果，</p>
<p><img data-src="/images/k8s/request-path-2.png" alt="请求"></p>
<p>对应的IngressRoute也同样需要修改</p>
<p>以前的IngressRoute如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">traefik.containo.us/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IngressRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service-traefik-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">entryPoints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">websecure</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">match:</span> <span class="string">Host(`think123.com`)</span> <span class="string">&amp;&amp;</span> <span class="string">PathPrefix(`/api/anon/health`,</span> <span class="string">`/api/anon/article`)</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">Rule</span></span><br><span class="line">      <span class="attr">services:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">9000</span></span><br></pre></td></tr></table></figure>

<p>我想要<code>/api/anon/article</code>这个request path只能内网访问，那么需要将配置修改如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">traefik.containo.us/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IngressRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service-traefik-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">entryPoints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">websecure</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">match:</span> <span class="string">Host(`think123.com`)</span> <span class="string">&amp;&amp;</span> <span class="string">PathPrefix(`/api/anon/health`)</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">Rule</span></span><br><span class="line">      <span class="attr">services:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">traefik.containo.us/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IngressRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service-internal-traefik-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">entryPoints:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">websecure</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">match:</span> <span class="string">Host(`think123-internal.com`)</span> <span class="string">&amp;&amp;</span> <span class="string">PathPrefix(`/api/anon/article`)</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">Rule</span></span><br><span class="line">      <span class="attr">services:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看上去没问题了，配置好LoadBalance之后，访问对应的域名就可以了。 但是这样还存在一个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -H &#39;Host:www.think123-internal.com&#39; -X GET https:&#x2F;&#x2F;www.think123.com&#x2F;api&#x2F;anon&#x2F;article </span><br></pre></td></tr></table></figure>

<p>通过指定header的方式，我们发现它匹配了 <code>my-service-internal-traefik-ingress</code>这个ingressRoute，最终返回了只有内网用户才能访问的API。</p>
<p>为啥我做了一大堆，安全性问题仍然存在？</p>
<p>实际上是因为无论是内网的traefik还是只监控外网的traefik，它们两个都会加载所有的IngressRoute,所以就有了上面的那个问题。</p>
<p>必须想个办法让它们只加载属于自己的IngressRoute,我去翻阅了下Traefik的文档，发现有3个参数可以用。</p>
<p>第一个是可以指定要监视哪些namespaces,则traefik就只处理它监控下的namespaces请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--providers.kubernetescrd.namespaces&#x3D;default,production</span><br></pre></td></tr></table></figure>

<p>第二个是给资源打上label,但是只对Traefik Custom Resources起作用，对Kubernetes的Service,Secrets这些不起作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--providers.kubernetescrd.labelselector&#x3D;&quot;app&#x3D;traefik&quot;</span><br></pre></td></tr></table></figure>

<p>第三个是指定ingressClass</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--providers.kubernetescrd.ingressclass&#x3D;traefik-internal</span><br></pre></td></tr></table></figure>
<p>我们需要在对应的资源上加上kubernetes.io/ingress.class注解，用于标识要处理的资源对象。</p>
<p>由于我们处理的是同一个namespace下的资源，所以namespace的方式不合适。</p>
<p>而对于第二种或者第三种而言，由于我们对IngressRoute进行处理，所以都是合适的。但是考虑到其他环境存在nginx和traefik共存的情况，我们决定使用ingressClass的方式,实际上nginx也是建议我们这么做的。</p>
<p><img data-src="/images/k8s/multi-ingress-controller.png" alt="multi ingress controller"></p>
<p>最开始我的修改是这样的,首先在DaemonSet模板中添加ingressClass设定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--providers.kubernetescrd.ingressclass&#x3D;$(ingress_class)</span><br></pre></td></tr></table></figure>

<p>接下来只需要在不同的traefik中配置不同的环境变量(configMap)即可。比如internet traefik设置<code>ingress_class=traefik-internet</code>,而intranet traefik该值为空,它被当成默认的ingress controller。</p>
<p>然后在相应的ingressRoute中指定 <code>kubernetes.io/ingress.class: traefik-internet</code>就可以了。 其他IngressRoute不指定该注解。</p>
<p>看上去很棒，给自己点个赞。</p>
<p>可是想象是美好的，现实却给了我无情一击。这样修改完成之后，我发现当我访问 <code>https://www.think123-internal.com/api/anon/article</code>这个api的时候,没有traefik来处理我的请求。</p>
<p>internal traefik不是我的默认traefik吗？我看官方文档还这样写的呀</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If the parameter is non-empty, only resources containing an annotation with the same value are processed.</span><br><span class="line">Otherwise, resources missing the annotation, having an empty value, or the value traefik are processed</span><br></pre></td></tr></table></figure>

<p>难道这个空不是空串，而是不指定的意思？ 真是不讲武德！</p>
<p>所以，我只能换一种修改方式，在DaemonSet的模板中不指定ingressClass,而是在通过kustomize来动态添加。kustomize的使用请参考我的<a href="https://generalthink.github.io/2020/01/03/use-kustomize/">这篇文章</a></p>
<blockquote>
<p>注意，两个traefik只有些许配置不一样，所以，我们安装的时候一般指定一个模板，动态的值则由不同的traefik来指定</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">patches:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">target:</span></span><br><span class="line">      <span class="attr">version:</span> <span class="string">v1beta2</span></span><br><span class="line">      <span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">traefik</span></span><br><span class="line">    <span class="attr">patch:</span> <span class="string">|-</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">op:</span> <span class="string">add</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/spec/template/spec/containers/0/args/-</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">--providers.kubernetescrd.ingressclass=traefik-internet</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在我的配置中，internet traefik名字叫做traefik,internal traefik名字叫做traefik-internal,区分内外网是逻辑区分，而不仅仅是通过名字。</p>
</blockquote>
<p>我们只在internet traefik中指定ingressClass,intranet traefik则不指定。</p>
<p>同样的，IngressRoute也需要动态修改的。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kustomization.yaml</span></span><br><span class="line"><span class="attr">patchesJson6902:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">target:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">traefik.containo.us</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1alpha1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">IngressRoute</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">my-service-traefik-ingress</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">patches/patch-internet-ingressroute.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># patch-internet-ingressroute.yaml</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">op:</span> <span class="string">add</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/metadata/annotations</span></span><br><span class="line">  <span class="attr">value:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress.class:</span> <span class="string">traefik-internet</span></span><br></pre></td></tr></table></figure>

<p>这样，internet traefik就只会处理 <code>kubernetes.io/ingress.class: traefik-internet</code>的ingressRoute了。之前的安全性问题也就不存在了。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol>
<li><a href="https://kubernetes.github.io/ingress-nginx/user-guide/multiple-ingress/">https://kubernetes.github.io/ingress-nginx/user-guide/multiple-ingress/</a></li>
<li><a href="https://doc.traefik.io/traefik/providers/kubernetes-crd/#ingressclass">https://doc.traefik.io/traefik/providers/kubernetes-crd/#ingressclass</a></li>
</ol>
]]></content>
      <tags>
        <tag>kubernetes</tag>
        <tag>traefik</tag>
      </tags>
  </entry>
  <entry>
    <title>大家好,我是Kafka</title>
    <url>/2019/02/27/introduction-of-kafka/</url>
    <content><![CDATA[<p>大家好，我是kafka,可能很多人都听说过我，知道我是2011年出生在LinkedIn的,从那会儿到现在我的功能越发强大了。作为一个优秀而又完整的平台，你可以在我上面冗余地存储巨大的数据量，我有一个具有高吞吐量(数百万/秒)的消息总线，你可以在这上面对经过我的数据进行实时流处理。<br>如果你认为我就只有上面的这些特点的话，那么你真的是太肤浅了。</p>
<p>上面虽然说的很好，但是并未触及到我的核心，这里我给你几个关键字：分布式，水平可扩展，容错，提交日志。</p>
<p>上面这些抽象的词语，我会一一解释它们的含义，并告诉你们我是如何工作的。</p>
<p>内心独白: 本来我是想要以第一人称来写这篇文章的，但是我发现我只能写出上面的了，再多的我就憋不出来了，于是我决定不要为难自己，还是用用第三人称写吧(写作的功底仍然需要锻炼)</p>
<a id="more"></a>

<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>分布式系统由多个运行的计算机系统组成，所有这些计算机在一个集群中一起工作，对终端用户来讲只是一个单一节点。</p>
<p><img data-src="/images/introduction-kafka/distributed_system.png" alt="分布式系统"></p>
<p>kafka也是分布式的，因为它在不同的节点(又被称为broker)上存储，接受以及发送消息，这样做的好处是具有很高的可扩展性和容错性。</p>
<h3 id="水平可扩展性"><a href="#水平可扩展性" class="headerlink" title="水平可扩展性"></a>水平可扩展性</h3><p>在这之前，先看看什么是垂直可扩展，比如你有一个传统的数据库服务器，它开始过度负载，解决这个问题的办法就是给服务器加配置(cpu,内存，SSD)，这就叫做垂直扩展。但是这种方式存在两个巨大的劣势</p>
<ol>
<li>硬件存在限制，不可能无限的添加机器配置</li>
<li>它需要停机时间，通常这是很多公司无法容忍的</li>
</ol>
<p>水平可扩展就是通过添加更多的机器来解决同样的问题，添加新机器不需要停机，而且集群中也不会对机器的数量有任何的限制。问题在于并非所有系统都支持水平可伸缩性，因为它们不是设计用于集群中(集群中工作更加复杂)。</p>
<h3 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h3><p>非分布式系统中容易最致命的问题就是单点失败，如果你唯一的服务器挂掉了，那么我相信你会很崩溃。</p>
<p>而分布式系统的设计方式就是可以以配置的方式来容许失败。在5个节点的kafka集群中，你仍然可以继续工作即使其中两个节点挂掉了。<br>需要注意的是，容错与性能直接相关，你的系统容错程度越高，性能就越差。</p>
<h3 id="提交日志-commit-log"><a href="#提交日志-commit-log" class="headerlink" title="提交日志(commit log)"></a>提交日志(commit log)</h3><p>提交日志(也被称为预写日志或者事物日志)是仅支持附加的持久有序数据结构，你无法修改或者删除记录，它从左往右读并且保证日志的顺序。</p>
<p><img data-src="/images/introduction-kafka/commint_log.png" alt="commit log"></p>
<p>是不是觉得kafka的数据结构如此简单?</p>
<p>是的，从很多方面来讲，这个数据结构就是kafka的核心。这个数据结构的记录是有序的，而有序的数据可以确保我们的处理流程。这两个在分布式系统中都是及其重要的问题。</p>
<p>kafka实际上将所有消息存储到磁盘并在数据结构中对它们进行排序，以便利用<strong>顺序磁盘读取</strong>。</p>
<ol>
<li>读取和写入都是常量时间O(1)(当确定了record id),与磁盘上其他结构的O(log N)操作相比是一个巨大的优势，因为每个磁盘搜索都很耗时。</li>
<li>读取和写入不会相互影响，写不会锁住读，反之亦然。</li>
</ol>
<p>这两点有着巨大的优势， 因为数据大小与性能完全分离。无论你的服务器上有100KB还是100TB的数据，Kafka都具有相同的性能</p>
<h3 id="如何工作"><a href="#如何工作" class="headerlink" title="如何工作"></a>如何工作</h3><p>应用程序(producer)发送消息(record)到kafka服务器(broker),这些消息会被其他应用程序(consumer)所处理，这些消息存储在主题(topic)中，并且消费者订阅该主题以接收新消息。是不是感觉很像你平时写的代码——生产者消费者模式。<br><img data-src="/images/introduction-kafka/work_model.png" alt="工作模式"></p>
<p>随着主题变得非常大，它们会分成更小的分区(partition)，以获得更好的性能和可伸缩性(比如存储了用户相互发送的消息，你可以根据用户名的第一个字母来进行拆分)。Kafka保证分区内的所有消息都按照它们的顺序排序,区分特定消息的方式是通过其偏移量(offset)，你可以将其视为普通数组索引，即为分区中的每个新消息递增的序列号。</p>
<p><img data-src="/images/introduction-kafka/kafka_partition.png" alt="分区"></p>
<p>kafka遵守着愚蠢的broker和聪明的consumer的准则。这意味着kafka不会跟踪消费者读取了哪些记录并删除它们，而是会将它们存储一定的时间(比如1天,以log.retention开头的来决定日志保留时间),直到达到某个阈值。消费者自己轮询kafka的新消息并且告诉它自己想要读取哪些记录。这允许它们按照自己的意愿递增/递减它们所处的偏移量，从而能够重放和重新处理事件。</p>
<p>需要注意的是消费者是属于消费者组的，消费者组有一个或多个消费者。为了避免两个进程读取同样的消息两次，每个partition只能被一个消费者组中的一个消费者访问。</p>
<p><img data-src="/images/introduction-kafka/kafka_consum_data.png" alt="kafka消费数据"></p>
<h3 id="持久化到硬盘"><a href="#持久化到硬盘" class="headerlink" title="持久化到硬盘"></a>持久化到硬盘</h3><p>正如我之前提到的，kafka实际上是将所有记录存储到硬盘而不在RAM中保存任何内容。你想知道这个如何做出这个选择的，其实这背后有很多优化使得这个方案可行。</p>
<ol>
<li>kafka有一个将消息分组的协议，这允许网络请求将消息组合在一起并减少网络开销，服务器反过来一次性保留大量消息，消费者一次获取大量线性块。</li>
<li>磁盘上线性读写非常快，现代磁盘非常慢的概念是由于大量磁盘寻址，但是在大量的线性操作中不是问题。</li>
<li>操作系统对线性操作进行了大量优化，通过预读(预取大块多次)和后写(将小型逻辑写入组成大型物理写入)技术。</li>
<li>操作系统将磁盘文件缓存在空闲RAM中。这称为pagecache,而kafka的读写都大量使用了pagecahce<ol>
<li>写消息的时候消息先从java到page cache,然后异步线程刷盘，消息从page cache刷入磁盘</li>
<li>读消息的时候先从page cache找，有就直接转入socket,没有就先从磁盘load到page cache,然后直接从socket发出去</li>
</ol>
</li>
<li>由于Kafka在整个流程(producer - &gt;broker - &gt;consumer)中以未经修改的标准化二进制格式存储消息,因此它可以使用零拷贝优化。那时操作系统将数据从pagecache直接复制到socket，有效地完全绕过了Kafka broker。</li>
</ol>
<p>所有这些优化都使Kafka能够以接近网络的速度传递消息。</p>
<h3 id="数据分发和复制"><a href="#数据分发和复制" class="headerlink" title="数据分发和复制"></a>数据分发和复制</h3><p>我们来谈谈Kafka如何实现容错以及它如何在节点之间分配数据。</p>
<p>为了使得一个borker挂掉的时候，数据还能得以保留，分区(partition)数据在多个broker中复制。</p>
<p>在任何时候，一个broker拥有一个partition，应用程序读取/写入都要通过这个节点，这个节点叫做—-partition leader。它将收到的数据复制到N个其他broker,这些接收数据的broker叫做follower，follower也存储数据，一旦leader节点死掉的时候，它们就准备竞争上岗成为leader。</p>
<p>这可以保证你成功发布的消息不会丢失，通过选择更改复制因子，你可以根据数据的重要性来交换性能以获得更强的持久性保证<br><img data-src="/images/introduction-kafka/kafka_data_backup.png" alt="4个kafka broker,副本因子是3"></p>
<p>这样如果leader挂掉了,那么其中一个follower就会接替它称为leader。包括leader在内的总副本数就是副本因子(使用–replication-factor指定)上图有1个leader，2个follower,所以副本因子就是3。</p>
<p>但是你可能会问：producer或者consumer怎么知道partition leader是谁？</p>
<p>对生产者/消费者对分区的写/读请求，它们需要知道分区的leader是哪一个，对吧？这个信息肯定是可以获取到的，Kafka使用zookeeper来存储这些元数据。</p>
<h3 id="什么是ZooKeeper"><a href="#什么是ZooKeeper" class="headerlink" title="什么是ZooKeeper"></a>什么是ZooKeeper</h3><p>Zookeeper是一个分布式键值存储。它针对读取进行了高度优化，但写入速度较慢。它最常用于存储元数据和处理群集的机制(心跳，分发更新/配置等)。</p>
<p>它允许服务的客户(Kafka broker)订阅并在发生变更后发送给他们,这就是Kafka如何知道何时切换分区领导者。ZooKeeper本身维护了一个集群，所以它就有很高的容错性，当然它也应该具有，毕竟Kafka很大程度上是依赖于它的。</p>
<p>zookeeper用于存储所有的元数据信息，包括但不限于如下几项:</p>
<ul>
<li>消费者组每个分区的偏移量(现在客户端在单独的kafka topic上存储偏移量)</li>
<li>ACL —— 权限控制</li>
<li>生产者/消费者的流量控制——每秒生产/消费的数据大小。可以参考<a href="https://shiyueqi.github.io/2017/04/27/Kafka-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6Quota%E5%8A%9F%E8%83%BD/">Kafka-流量控制Quota功能</a></li>
<li>partition leader以及它们的健康信息</li>
</ul>
<p>那么produer/consumer是如何知道谁是partition leader的呢？</p>
<p>生产者和消费者以前常常直接连接ZooKeeper来获取这些信息，但是Kafka从0.8和0.9版本开始移除了这种强耦合关系。客户端直接从kafka broker直接获取这些元数据，而让kafka broker从zookeeper那里获取这些元数据。<br><img data-src="/images/introduction-kafka/get_leader_info.png" alt="获取leader"></p>
<p>更多zookeeper的讲解可以参考：<a href="https://juejin.im/post/5b037d5c518825426e024473">漫画：什么是ZooKeeper？</a></p>
<h3 id="流式处理-Streaming"><a href="#流式处理-Streaming" class="headerlink" title="流式处理(Streaming)"></a>流式处理(Streaming)</h3><p>在Kafka中,流处理器是指从输入主题获取连续数据流，对此输入执行某些处理并生成数据流以输出到其他主题(或者外部服务,数据库,容器等等).</p>
<p>什么是数据流呢?首先，数据流是无边界数据集的抽象表示。无边界意味着无限和持续增长。无边界数据集之所以是无限的，是因为随着时间推移，新的记录会不断加入进来。比如信用卡交易,股票交易等事件都可以用来表示数据流</p>
<p>我们可以使用producer/consumer的API直接进行简单处理,但是对于更加复杂的转换比如将流连接到一起,kafka提供了集成<a href="https://kafka.apache.org/documentation/streams/">Stream API</a>库</p>
<p>这个API是在你自己的代码中使用的,它并不是运行在broker上,它的工作原理和consumer API类似,可帮助你在多个应用程序(类似于消费者组)上扩展流处理工作。</p>
<h4 id="无状态处理"><a href="#无状态处理" class="headerlink" title="无状态处理"></a>无状态处理</h4><p>流的无状态处理是确定性处理，其不依赖于任何外部条件,对于任何给定的数据，将始终生成与其他任何内容无关的相同输出。举个例子，我们要做一个简单的数据转换—-“zhangsan” —&gt; “Hello,zhangsan”</p>
<p><img data-src="/images/introduction-kafka/kafka_stream_process.png" alt="Kafka流处理"></p>
<h4 id="流-表二义性"><a href="#流-表二义性" class="headerlink" title="流-表二义性"></a>流-表二义性</h4><p>重要的是要认识到流和表实质上是一样的,流可以被解释称为表,表也可以被解释称为流.</p>
<h5 id="流作为表"><a href="#流作为表" class="headerlink" title="流作为表"></a>流作为表</h5><p>流可以解释为数据的一系列更新，聚合后得结果就是表的最终结果,这项技术被称为事件溯源(<a href="https://martinfowler.com/eaaDev/EventSourcing.html">Event Sourcing</a>)</p>
<p>如果你了解数据库备份同步,你就会知道它们得技术实现被称为流式复制—-将对表的每个更改都发送报副本服务器.比如redis中的AOF以及Mysql中的binlog</p>
<p>Kafka流可以用相同的方式解释 - 当累积形成最终状态时的事件。此类流聚合保存在本地RocksDB中(默认情况下)，被称为KTable。<br><img data-src="/images/introduction-kafka/kafka_stream_table.png" alt="Kafka流转换为表"></p>
<h5 id="表作为流"><a href="#表作为流" class="headerlink" title="表作为流"></a>表作为流</h5><p>可以将表视为流中每个键的最新值的快照。以流记录可以生成表一样，表更新可以生成更改日志流。<br><img data-src="/images/introduction-kafka/kafka_table_stream.png" alt="Kafka表转换为流"></p>
<h4 id="有状态处理"><a href="#有状态处理" class="headerlink" title="有状态处理"></a>有状态处理</h4><p>我们在java中常用的一些操作比如map()或者filter()是没有状态的，它不会要求你保留任何原始数据。但是现实中，大多数的操作都是有状态的(比如count()),因为就需要你存储当前累计的状态。</p>
<p>在流处理器上维护状态的问题是流处理器可能会失败！你需要在哪里保持这种状态才能容错？</p>
<p>一种简单的方法是简单地将所有状态存储在远程数据库中，并通过网络连接到该存储，这样做的问题是大量的网络带宽会使得你的应用程序变慢。一个更微妙但重要的问题是你的流处理作业的正常运行时间将与远程数据库紧密耦合，并且作业将不是自包含的(其他team更改数据库可能会破坏你的处理)。</p>
<p>那么什么是更好的办法呢？<br>回想一下表和流的二元性。这允许我们将流转换为与我们的处理位于同一位置的表。它还为我们提供了一种处理容错的机制 - 通过将流存储在Kafka broker中。</p>
<p>流处理器可以将其状态保持在本地表(例如RocksDB)中，该表将从输入流(可能在某些任意转换之后)更新。当进程失败时，它可以通过重放流来恢复其数据。</p>
<p>你甚至可以将远程数据库作为流的生产者，有效地广播用于在本地重建表的更改日志。</p>
<p><img data-src="/images/introduction-kafka/kafka_deal_statful_data.png" alt="Kafka处理有状态数据"></p>
<h4 id="KSQL"><a href="#KSQL" class="headerlink" title="KSQL"></a>KSQL</h4><p>通常，我们不得不使用JVM语言编写流处理，因为这是唯一的官方Kafka Streams API客户端。<br>2018年4月，KSQL作为一项新特性被发布，它允许你使用熟悉的类似SQL的语言编写简单的stream jobs。你安装了KSQL服务器并通过CLI以交互方式查询以及管理。它使用相同的抽象(KStream和KTable)，保证了Streams API的相同优点(可伸缩性，容错性)，并大大简化了流的工作。</p>
<p>这听起来可能不是很多，但在实践中对于测试内容更有用，甚至允许开发之外的人(例如产品所有者)使用流处理，可以看看Confluent提供的这篇关于<a href="https://www.youtube.com/watch?v=A45uRzJiv7I&t=2m13s">ksql的使用</a></p>
<h3 id="什么时候使用kafka"><a href="#什么时候使用kafka" class="headerlink" title="什么时候使用kafka"></a>什么时候使用kafka</h3><p>正如我们已经介绍的那样，Kafka允许你通过集中式介质获取大量消息并存储它们，而不必担心性能或数据丢失等问题。<br>这意味着它非常适合用作系统架构的核心，充当连接不同应用程序的集中式媒体。Kafka可以成为事件驱动架构的中心部分，使你可以真正地将应用程序彼此分离.</p>
<p><img data-src="/images/introduction-kafka/kafka_when_use.png" alt="什么时候使用Kafka"><br>Kafka允许你轻松地分离不同(微)服务之间的通信。使用Streams API，现在可以比以往更轻松地编写业务逻辑，从而丰富Kafka主题数据以供服务使用。可能性很大，我恳请你探讨公司如何使用Kafka。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Apache Kafka是一个分布式流媒体平台，每天可处理数万亿个事件。Kafka提供低延迟，高吞吐量，容错的发布和订阅管道，并能够处理事件流。我们回顾了它的基本语义(生产者，代理，消费者，主题)，了解了它的一些优化(pagecache)，通过复制数据了解了它的容错能力，并介绍了它不断增长的强大流媒体功能。Kafka已经在全球数千家公司中大量采用，其中包括财富500强企业中的三分之一。随着Kafka的积极开发和最近发布的第一个主要版本1.0(2017年11月1日)，有预测这个流媒体平台将会与关系数据库一样，是数据平台的重要核心。我希望这篇介绍能帮助你熟悉Apache Kafka。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://tech.meituan.com/2015/01/13/kafka-fs-design-theory.html">https://tech.meituan.com/2015/01/13/kafka-fs-design-theory.html</a><br><a href="https://shiyueqi.github.io/2017/04/27/Kafka-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6Quota%E5%8A%9F%E8%83%BD/">https://shiyueqi.github.io/2017/04/27/Kafka-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6Quota%E5%8A%9F%E8%83%BD/</a><br><a href="http://kafka.apache.org/documentation.html#introduction">http://kafka.apache.org/documentation.html#introduction</a><br><a href="https://docs.confluent.io/current/">https://docs.confluent.io/current/</a></p>
]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对象在内存中的布局</title>
    <url>/2020/09/25/java-object-in-meory-with-markword/</url>
    <content><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>Java是用C++写的，所以java对象最终会映射到c++中的某个对象，用这个对象可以描述所有Java对象。而我们所熟知的synchronized锁的优化就是基于这个对象来实现的。</p>
<h3 id="对象在内存中的布局"><a href="#对象在内存中的布局" class="headerlink" title="对象在内存中的布局"></a>对象在内存中的布局</h3><p>Java对象在被创建的时候,在内存分配完成后，虚拟机需要对对象进行必要设置， 例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</p>
<p>这些信息存放在对象的对象头(Object Header)中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等对象头会有不同的设置方式。</p>
<p><strong>在虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)</strong></p>
<a id="more"></a>

<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>HotSpot虚拟机对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳。</p>
<p>这部分数据的长度在32位和64位的虚拟机中分别是32bit和64bit,官方称为”Mark Word”。 考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息。</p>
<p>对象头另一部分是类型指针，即指向对象的类元数据，虚拟机通过这个指针确定该对象是哪个类的实例。</p>
<p>我们可以在JVM源码(hotspot/share/oops/markOop.hpp)中看到对象头中存储内容的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">markOopDesc</span>:</span> <span class="keyword">public</span> oopDesc &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum</span> &#123; age_bits             = <span class="number">4</span>,</span><br><span class="line">         lock_bits            = <span class="number">2</span>,</span><br><span class="line">         biased_lock_bits     = <span class="number">1</span>,</span><br><span class="line">         max_hash_bits        = BitsPerWord - age_bits - lock_bits - biased_lock_bits,</span><br><span class="line">         hash_bits            = max_hash_bits &gt; <span class="number">31</span> ? <span class="number">31</span> : max_hash_bits,</span><br><span class="line">         cms_bits             = LP64_ONLY(<span class="number">1</span>) NOT_LP64(<span class="number">0</span>),</span><br><span class="line">         epoch_bits           = <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/macos-jvm/markOop-object-header.png" alt="对象头"></p>
<ul>
<li>hash: 对象的哈希码</li>
<li>age: 对象的分代年龄</li>
<li>biased_lock : 偏向锁标识位</li>
<li>lock: 锁状态标识位</li>
<li>JavaThread* : 持有偏向锁的线程ID</li>
<li>epoch: 偏向时间戳</li>
</ul>
<p>例如在32位的HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0<br>而在其他状态(轻量级锁，重量级锁，GC标记，可偏向)下对象的存储内容如下表所示</p>
<p><img data-src="/images/macos-jvm/mark-word-32-system.png" alt="32位系统Mark Word"></p>
<h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p>
<h4 id="对其填充"><a href="#对其填充" class="headerlink" title="对其填充"></a>对其填充</h4><p>第三部分对其填充并不是必然存在的，也没有特别的含义，仅是占位符的作用，因为HotSpot VM的内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数，因此当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h3 id="查看对象头"><a href="#查看对象头" class="headerlink" title="查看对象头"></a>查看对象头</h3><p>我们可以通过openjdk的jol工具来查看对象头存储的内容，首先代码如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetRange</span> </span>&#123;</span><br><span class="line">  <span class="comment">// -XX:-UseCompressedOops</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1字节=8位(1byte = 8bit)</span></span><br><span class="line">    System.out.println(VM.current().details());</span><br><span class="line"></span><br><span class="line">    MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">    ClassLayout classLayout = ClassLayout.parseInstance(myClass);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;****New Object****&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(classLayout.toPrintable());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hashCode = myClass.hashCode();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;MyClass hashCode : &quot;</span> + hashCode) ;</span><br><span class="line">    System.out.println(<span class="string">&quot;MyClass hashCode 二进制 &quot;</span> + Integer.toBinaryString(hashCode));</span><br><span class="line">    System.out.println(<span class="string">&quot;MyClass hashCode 二进制长度 &quot;</span> + Integer.toBinaryString(hashCode).length());</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;****After invoke hashCode()****&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(classLayout.toPrintable(myClass));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取系统字节序</span></span><br><span class="line">    System.out.println(<span class="string">&quot;系统当前字节序是：&quot;</span> + ByteOrder.nativeOrder());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  String name = <span class="string">&quot;think123&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>[] other;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出内容如下</p>
<p><img data-src="/images/macos-jvm/jol-object-header.png" alt="对象头"></p>
<p>可以知道对象头占了12个字节,存在3个字节的对其填充。</p>
<p>jvm中使用oopDesc来描述一个对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oopDesc</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">volatile</span> markOop _mark;</span><br><span class="line">  <span class="keyword">union</span> _metadata &#123;</span><br><span class="line">    Klass*      _klass;</span><br><span class="line">    narrowKlass _compressed_klass;</span><br><span class="line">  &#125; _metadata;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到对象头有两部分，mark 部分，官方称为 mark word,存储的是哈希码，对象分代年龄，偏向锁标志等信息。mark word长度是一个系统字宽，在64bit系统上是8个字节。</p>
<p>第二部分是klass的类型指针，指向这个对象是哪个类的实例,这里使用的是union这个联合体，表示变量<code>_klass</code>和<code>_compressed_klass</code>共享同一段内存。未开启指针压缩时使用<code>_klass</code>，开启指针压缩时使用<code>_compressed_klass</code>。narrowKlass实际上是一个32bit的unsigned int类型，因此占用4个字节，所以开启指针压缩后对象的头部长度整体为12字节。</p>
<blockquote>
<p>narrowKlass定义在hotspot/src/share/vm/oops/oopsHierarchy.hpp,它是juint类型，实际上是32bit的unsigned int</p>
</blockquote>
<p>对象体：MyClass中定义了三个字段,int[],String都占用4个字节长度,boolean类型的占用了1个字节长度</p>
<p>填充部分：上面对象头和对象体长度和为21字节，因为要8字节对齐，因此需要填充3字节，这样就刚好等于24字节。</p>
<p>当我们关闭指针压缩后(-XX:-UseCompressedOops),mark word占16个字节，同时也采用8字节进行对其。name和other两个数据域分别占据8字节。而开启指针压缩之后，这两个字节分别占用4个字节。<br>所以开启这个选项是可以节约内存的，从jdk8之后已经默认开启此选项。</p>
<p><img data-src="/images/macos-jvm/markword-no-compress.png" alt="未开启指针压缩"></p>
<p>上面我把当前系统的字节序打印了出来，可以看到当前是小字节序。</p>
<p>举例来说，数值0x2211使用两个字节储存：高位字节是0x22，低位字节是0x11。<br>大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。<br>小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。</p>
<p>因此我们查看myClass的hashCode的时候就要倒着看了。我们查看object header中的hashcode要从第9位到39位(64位系统中,用31字节保存哈希)开始查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">myClass的hashcode(长度为30,最高位补2个0) :</span><br><span class="line"></span><br><span class="line">myClass HashCode :    00100001 01011000 10001000 00001001</span><br><span class="line"></span><br><span class="line">Mark Word中HashCode : 00001001 10001000 01011000 0 0100001</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以发现myClass的hashCode和mark word中的存储刚好是反着来的。</p>
<p>不是说存储hash的只有31位吗？为什么这里用32位来比较呢？我用32位来比较是为了更加易于观察。 实际上MarkWord中保存哈希码最后8位的第一位0是从未使用的25位中借来的(需要结合小字节序)</p>
<p>接下来，我们使用JOL工具查看处于不同锁状态下，mark word中的标志位是怎样的。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>首先我们来看偏向锁，由于JVM默认会在启动后4秒才会启动偏向锁，所以测试时需要设置马上启动偏向锁(-XX:BiasedLockingStartupDelay=0)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -XX:BiasedLockingStartupDelay=0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Layouter layouter = <span class="keyword">new</span> HotSpotLayouter(<span class="keyword">new</span> X86_32_DataModel());</span><br><span class="line"></span><br><span class="line">    MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">    ClassLayout layout = ClassLayout.parseInstance(myClass);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;进入同步代码块之前:&quot;</span>);</span><br><span class="line">    System.out.println(layout.toPrintable());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (myClass) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;同步代码块中:&quot;</span>);</span><br><span class="line">      System.out.println(layout.toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;退出同步代码块后:&quot;</span>);</span><br><span class="line">    System.out.println(layout.toPrintable());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="/images/macos-jvm/biased-lock.png" alt="偏向锁"></p>
<ol>
<li>可以看到在进入同步代码块之前低8位是00000101,表示处于偏向锁(后三位是101),但是现在还没有偏向任何一个线程，因此没有数据</li>
<li>处于同步代码块中以及退出同步代码块时,mark word一致，低8位都是00000101,处于偏向锁，且存储了偏向线程地址以及时间戳等信息。说明退出同步块后，依然保留偏向锁的信息</li>
</ol>
<h3 id="轻量级锁以及重量级锁"><a href="#轻量级锁以及重量级锁" class="headerlink" title="轻量级锁以及重量级锁"></a>轻量级锁以及重量级锁</h3><p>我们使用下面的代码来演示轻量级锁以及重量级时状态位的变化情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//不设置立刻启动偏向锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Layouter layouter = <span class="keyword">new</span> HotSpotLayouter(<span class="keyword">new</span> X86_32_DataModel());</span><br><span class="line"></span><br><span class="line">    MyClass myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">    ClassLayout layout = ClassLayout.parseInstance(myClass);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;创建t1线程之前:&quot;</span>);</span><br><span class="line">    System.out.println(layout.toPrintable());</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">       <span class="keyword">synchronized</span> ((myClass)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;持有锁之前:&quot;</span>);</span><br><span class="line">    System.out.println(layout.toPrintable());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (myClass) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;持有锁中:&quot;</span>);</span><br><span class="line">        System.out.println(layout.toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;释放锁:&quot;</span>);</span><br><span class="line">    System.out.println(layout.toPrintable());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;System.gc() 后&quot;</span>);</span><br><span class="line">    System.gc();</span><br><span class="line">    System.out.println(layout.toPrintable());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img data-src="/images/macos-jvm/lock-change-in-mark-word-1.png"><img data-src="/images/macos-jvm/lock-change-in-mark-word-2.png" alt="轻量级锁和重量级锁"></p>
<p>mark word的状态变更过程如下:</p>
<ol>
<li>创建t1线程前阶段，锁标志位为01，偏向锁标志位为0，处于无锁状态</li>
<li>main线程持有锁之前阶段，标志位为00，属于轻量级锁，<strong>此时t1线程已经持有锁且main线程未请求锁，所以此时无竞争</strong></li>
<li>main线程持有锁阶段，标志位为10，膨胀为重量级锁，<strong>此时t线程已经已经释放了锁，main线程获取锁成功，即此时存在竞争</strong></li>
<li>main线程释放锁阶段，标志位为10，仍为重量级锁，<strong>不会自动降级</strong></li>
<li><strong>System.gc后阶段，恢复为无锁状态，GC年龄变为1</strong></li>
</ol>
<p>至此，我们知道了处于不同锁情况下，状态位的变化情况。</p>
]]></content>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java开发者常用的线上命令</title>
    <url>/2018/04/27/java-programer-always-use-command/</url>
    <content><![CDATA[<h3 id="1-Java命令的使用"><a href="#1-Java命令的使用" class="headerlink" title="1. Java命令的使用"></a>1. Java命令的使用</h3><p>jps、jconsole、jvisualvm等工具的数据来源是这个文件(/tmp/hsperfdata_userName/pid)。所以当该文件不存在或是无法读取时就会出现jps无法查看该进程号,jconsole无法监控等问题,如果该文件不存在或者没有权限均会导致这些命令无法使用,java启动时提供了参数(-Djava.io.tmpdir),可以对这个文件的位置进行设置,而jps、jconsole都只会从/tmp目录读取,而无法从设置后的目录读取信息。</p>
<hr>
<ol>
<li>显示当前所有java进程</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;jdk&#x2F;bin&#x2F;jps -v</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看当前时刻java线程状态</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;jdk&#x2F;bin&#x2F;jstack pid</span><br><span class="line">jstack -F pid   强制性获取线程状态</span><br></pre></td></tr></table></figure>


<p><strong>查看产生的线程文件，主要有以下几种线程修饰</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locked &lt;地址&gt; 目标：使用synchronized申请对象锁成功,监视器的拥有者。</span><br><span class="line"></span><br><span class="line">waiting to lock &lt;地址&gt; 目标：使用synchronized申请对象锁未成功,在进入区等待。</span><br><span class="line"></span><br><span class="line">waiting on &lt;地址&gt; 目标：使用synchronized申请对象锁成功后,释放锁幵在等待区等待。</span><br></pre></td></tr></table></figure>

<p><strong>开发过程中，经常会遇到线程状态,线程状态有如下几种</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runnable:状态一般为RUNNABLE。</span><br><span class="line"></span><br><span class="line">in Object.wait():等待区等待,状态为WAITING或TIMED_WAITING。</span><br><span class="line"></span><br><span class="line">waiting for monitor entry:进入区等待,状态为BLOCKED。</span><br><span class="line"></span><br><span class="line">waiting on condition:等待区等待、被park。</span><br><span class="line"></span><br><span class="line">sleeping:休眠的线程,调用了Thread.sleep()。</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的几点:</strong></p>
<ul>
<li>IO操作是可以以RUNNABLE状态达成阻塞。例如:数据库死锁、网络读写。 格外注意对IO线程的真实状态的分析。 一般来说,被捕捉到RUNNABLE的IO调用,都是有问题的。</li>
<li>wait on monitor entry： 被阻塞的,肯定有问题</li>
<li>in Object.wait()： 注意非线程池等待</li>
</ul>
<h4 id="2-查看java堆内存的细节"><a href="#2-查看java堆内存的细节" class="headerlink" title="2. 查看java堆内存的细节"></a>2. 查看java堆内存的细节</h4><ol>
<li>查看对内存使用情况</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmap -heap pid</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看堆内存对象的数量以及大小</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmap -histo pid</span><br><span class="line">jmap -histo:live pid   查看存活的对象的数量以及大小,会先进行一次full gc</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>将内存的统计信息输出到文件进行分析</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmap -dump:format&#x3D;b,file&#x3D;heapDump  将内存使用的详细情况输出到文件，后期可以使用mat分析</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>监控java运行状态信息</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstat -gcutil 250 5   统计gc信息，每250ms统计一次,总共统计5次</span><br></pre></td></tr></table></figure>

<h3 id="2-Linux命令的使用"><a href="#2-Linux命令的使用" class="headerlink" title="2. Linux命令的使用"></a>2. Linux命令的使用</h3><p>大多数的Java应用都运行在Linux下,所以在很多时候分析Java问题的时候免不了使用Linux帮助辅助分析，这里给出几个常用的Linux命令介绍</p>
<h4 id="1-vi命令"><a href="#1-vi命令" class="headerlink" title="1. vi命令"></a>1. vi命令</h4><p>经常我们需要修改配置文件，这个时候vi就派的上用场了，但是vi命令这个参数太多了，也记不住，我一直都是需要用的时候再查，但是经常使用下来发现其实常用的也就那么几种。</p>
<ol>
<li><p>vi基本分为一般模式、编辑模式与命令行模式</p>
<ul>
<li>一般打开一个文件就是一般模式</li>
<li>在一般模式中,按下“i,I,o,O,A,a,r,R”等任何一个字母进入编辑模式,按下ESC退出到编辑模式进入一般模式</li>
<li>在一般模式中按下“:、/、?”三个中的任何一个按钮,就可以将光标移动到最下面那一行,进入命令行模式</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>一般模式下常用按键</p>
<ul>
<li>G : 移动到这个文件的最后一行</li>
<li>nG : n为数字,移动到这个文件的第n行。例如20G则会移动到第20行(可以配合:set nu)</li>
<li>/word : 向下寻找一个名称为word的字符串,例如你要在文件中查找config这个单词就输入/config</li>
<li>?word : 向上寻找一个名称为Word的字符串</li>
<li>n : 这个n是英文按键,代表重复前一个查找的操作</li>
<li>N : 这个N是英文按钮,代表反向进行前一个查找的操作</li>
<li>:n1,n2s/word1/word2/g : n1与n2为数字,代表在n1与n2行之间查找word1这个串,然后替换成n2这个字符串</li>
<li>dd : 删除光标所在的那一整行</li>
<li>yy : 复制光标所在的那一行</li>
<li>p,P : p为将以复制的数据在光标下一行粘贴,P则为在上一行粘贴</li>
</ul>
</li>
<li><p>一般模式切换到命令行模式的可用按钮</p>
<ul>
<li>:q! : 修改过不保存直接离开,!表示强制</li>
<li>:wq : 保存后离开,也可以用:wq!</li>
<li>ZZ : 大写的Z,如果没有改动则不保存离开,若已经改动过,则保存后离开</li>
<li>:w[filename] : 将编辑的数据保存成另一个文件</li>
<li>:set nu : 显示行号</li>
<li>: set nonu : 取消行号</li>
</ul>
</li>
</ol>
<h4 id="2-文件操作相关命令"><a href="#2-文件操作相关命令" class="headerlink" title="2. 文件操作相关命令"></a>2. 文件操作相关命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. ls -a : 全部的文件,连同隐藏文件(开头为.的文件)</span><br><span class="line">2. cp -a source destination 或者   cp [参数] source1 source2 source3 ... directory    说明: -a的意思是和复制之前的文件属性一模一样</span><br><span class="line">3. rm -f ： 强制删除文件，忽略不存在的文件</span><br><span class="line">4. rm -r : 递归删除,常用于目录的删除,非常危险参数</span><br><span class="line">5. mv [-fiu] source destination 或者      mv [参数] source1 source2 source3 ... directory</span><br><span class="line">    -f:表示强制，如果存在则直接覆盖</span><br><span class="line">    -i:如果已经存在就会询问</span><br><span class="line">    -u:如果已经存在，且source比较新,才会更新</span><br><span class="line"></span><br><span class="line">6. cat -n fileName : 显示文件内容，并显示行号</span><br><span class="line">7. tail [-n number] fileName : 显示文件结尾n行内容，比如tail -20 mylog.log</span><br><span class="line">8. tial -f core.log    显示文件最新10行内容，会自动更新</span><br><span class="line">9. find &#x2F;usr -name fileName   查找usr目录下文件名为fileName的文件，fileName支持正则,比如*.js</span><br><span class="line">10. ls -l | grep file.txt   列出file.txt的文件信息，grep后可以跟震泽表达式</span><br><span class="line">11. tar -czf test.tar.gz &#x2F;test1 &#x2F;test2   压缩文件</span><br><span class="line">12. tar -xvzf test.tar.gz  解压文件</span><br></pre></td></tr></table></figure>

<h4 id="3-系统状态相关命令"><a href="#3-系统状态相关命令" class="headerlink" title="3. 系统状态相关命令"></a>3. 系统状态相关命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. ps -aux | grep java 查看java进程</span><br><span class="line">2. top</span><br><span class="line">    按下数字1可以查看每个逻辑CPU的状态</span><br><span class="line">    top -d 2 -n 3  每2s更新一次状态，总共更新3次</span><br><span class="line">    top -p 574   显示指定的进程信息</span><br><span class="line">    %wa 表示I&#x2F;Owait占用的CPU时间百分比,通常系统变慢都是I&#x2F;O产生的问题比较大</span><br><span class="line">    swap表示虚拟内存，如果被大量使用表示系统的物理内存实在不足</span><br><span class="line">    S 进程状态。D&#x3D;不可中断的睡眠状态 R&#x3D;运行 S&#x3D;睡眠 T&#x3D;跟踪&#x2F;停止 Z&#x3D;僵尸进程</span><br><span class="line"></span><br><span class="line">3. vmstat  如果其中的cs(上下文切换次数)值过高，会导致系统负载过高，排查问题的时候需要用到</span><br><span class="line">4. netstat -anp | grep 8080   查看端口占用情况</span><br></pre></td></tr></table></figure>

<h4 id="4-其他Linux命令"><a href="#4-其他Linux命令" class="headerlink" title="4. 其他Linux命令"></a>4. 其他Linux命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. echo $LANG   查看当前系统编码</span><br><span class="line">2. lsof app.js  查看文件被哪个进程打开了</span><br><span class="line">3. lsof -i :8080 查看哪个端口属于哪个程序</span><br><span class="line">4. lsof -p pid  查看某个进程打开了哪些文件</span><br><span class="line">5. tcpdump -s 0 -i ge1 -A port 8084     监听8084端口收到的数据</span><br><span class="line">6. lsof | wc -l     查看进程打开个多少个文件</span><br><span class="line">7. lsof -p pid |wc -l    查看某个进程打开的文件数</span><br></pre></td></tr></table></figure>


<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://www.hollischuang.com/archives/110">jstack的使用</a></p>
]]></content>
      <categories>
        <category>Java开发命令</category>
      </categories>
      <tags>
        <tag>Java开发常用命令</tag>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes常用命令</title>
    <url>/2019/12/19/k8s-common-command/</url>
    <content><![CDATA[<h4 id="获取所有的namespace"><a href="#获取所有的namespace" class="headerlink" title="获取所有的namespace"></a>获取所有的namespace</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get namespace</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认使用的是 ~/.kube/config这个配置文件，如果文件不再这个目录下可以通过 –kubeconfig configFilePath&gt;指定<br><a href="https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable">https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable</a></p>
</blockquote>
<a id="more"></a>

<h4 id="生成config文件"><a href="#生成config文件" class="headerlink" title="生成config文件"></a>生成config文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl config --kubeconfig&#x3D;config set-cluster &lt;cluste name&gt; --server&#x3D;&lt;kubernetes server address&gt;</span><br><span class="line"></span><br><span class="line">kubectl config --kubeconfig&#x3D;config set-credentials &lt;username&gt; --token&#x3D;&lt;user token&gt;</span><br><span class="line"></span><br><span class="line">kubectl config --kubeconfig&#x3D;config set-context &lt;context name&gt; --cluster&#x3D;&lt;cluster name&gt; --user&#x3D;&lt;username&gt;</span><br><span class="line"></span><br><span class="line">kubectl config --kubeconfig&#x3D;config use-context &lt;current context&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上面的命令生成config文件，通过这个文件就可以使用kubectl访问kubernetes集群</p>
<h4 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create secret tls &lt;cert name&gt; --cert &lt;hostname.crt&gt; --key &lt;hostname.key&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>

<p>生成证书之后就可以在ingress配置spec.tls.hosts.secretName中配置命令中指定的<cert name></p>
<h4 id="生成secret"><a href="#生成secret" class="headerlink" title="生成secret"></a>生成secret</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &lt;secret file&gt;这里常用的就是property文件，内容是key&#x3D;value</span><br><span class="line">kubectl create secret generic &lt;secret name&gt; --from-env-file&#x3D;&lt;secret file&gt; -n &lt;namespace&gt;</span><br><span class="line"></span><br><span class="line"># 删除secret</span><br><span class="line">kubectl delete secret &lt;secret name&gt; -n &lt;namespace&gt;</span><br><span class="line"></span><br><span class="line"># 查看有哪些secret:</span><br><span class="line">kubectl get secrets -n &lt;namespace&gt;</span><br><span class="line"></span><br><span class="line"># 查看secret详细信息</span><br><span class="line">kubectl describe secrets &lt;secret name&gt; -n &lt;namespace&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>secret数据字段存储的是源字符串使用base64编码的。你可以使用下面的命令对其进行base64编码和解码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 编码</span><br><span class="line">echo -n &#39;1f2d1e2e67df&#39; | base64</span><br><span class="line"></span><br><span class="line"># 解码</span><br><span class="line">echo &#39;MWYyZDFlMmU2N2Rm&#39; | base64 --decode</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查看有哪些pod"><a href="#查看有哪些pod" class="headerlink" title="查看有哪些pod"></a>查看有哪些pod</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pods -n &lt;namespace&gt; -o wide</span><br></pre></td></tr></table></figure>

<h4 id="查看deployment"><a href="#查看deployment" class="headerlink" title="查看deployment"></a>查看deployment</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl describe deploy&#x2F;&lt;deployment name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>

<h4 id="查看某个pod日志"><a href="#查看某个pod日志" class="headerlink" title="查看某个pod日志"></a>查看某个pod日志</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl logs &lt;pod name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>

<h4 id="进入到容器内部"><a href="#进入到容器内部" class="headerlink" title="进入到容器内部"></a>进入到容器内部</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winpty kubectl exec &lt;pod name&gt; -n &lt;namespace&gt; -it  -- bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>windows下执行才需要加上winpty,mac是不需要的。 如果bin/bash没有，可以指定bin/sh。</p>
<p>如果你的pod中部署了多个container,你想进入到某一个中，可以使用下面命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">winpty kubectl exec &lt;pod name&gt; -c &lt;container name&gt; -n &lt;name space&gt; -it -- bin&#x2F;sh</span><br></pre></td></tr></table></figure>

<h4 id="水平扩展-收缩"><a href="#水平扩展-收缩" class="headerlink" title="水平扩展/收缩"></a>水平扩展/收缩</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl scale deployment &lt;deployment name&gt; --replicas&#x3D;4</span><br></pre></td></tr></table></figure>

<h4 id="查看滚动更新结果"><a href="#查看滚动更新结果" class="headerlink" title="查看滚动更新结果"></a>查看滚动更新结果</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看deployment</span><br><span class="line">kubectl describe deployment &lt;deployment name&gt; -n &lt;namespace&gt;</span><br><span class="line"></span><br><span class="line"># 或者查看rs</span><br><span class="line">kubectl get rs -n &lt;namespace&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查看历史版本"><a href="#查看历史版本" class="headerlink" title="查看历史版本"></a>查看历史版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl rollout history deployment&#x2F;&lt;deployment name&gt; -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure>

<h4 id="查看某个历史版本的细节"><a href="#查看某个历史版本的细节" class="headerlink" title="查看某个历史版本的细节"></a>查看某个历史版本的细节</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这里的versionNum是通过rollout history查看到的对应的数字</span><br><span class="line">kubectl rollout history deployment&#x2F;&lt;deployment name&gt; --revision&#x3D;&lt;versionNum&gt;</span><br></pre></td></tr></table></figure>

<h4 id="回滚到某个特定版本"><a href="#回滚到某个特定版本" class="headerlink" title="回滚到某个特定版本"></a>回滚到某个特定版本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl rollout undo deployment&#x2F;smcp-service --to-revision&#x3D;&lt;versionNum&gt;</span><br></pre></td></tr></table></figure>

<h4 id="删除rs"><a href="#删除rs" class="headerlink" title="删除rs"></a>删除rs</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl delete rs -l app&#x3D;&lt;label name&gt; -n &lt;namespace&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每次更新都会产生一个新的replica set,如果要删除那些旧的，可以使用这个命令，并通过-l参数指定label来进行删除</p>
<h3 id="将服务器上的服务暴露到本地"><a href="#将服务器上的服务暴露到本地" class="headerlink" title="将服务器上的服务暴露到本地"></a>将服务器上的服务暴露到本地</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl port-forward svc&#x2F;argocd-server -n argocd 8080:443</span><br></pre></td></tr></table></figure>

<p>当我们访问<code>http://localhost:8080</code>的时候，实际上就是访问的kubernetes集群中argocd-server的443端口，同理你可以暴露redis,mongodb等。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>其实kubectl语法都是存在特定格式的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl [command] [TYPE] [NAME] [flags]</span><br></pre></td></tr></table></figure>

<p>写命令忘记的时候，可以使用kubectl -h来查看支持的命令，关于这些命令可以参考 <a href="https://kubernetes.io/docs/reference/kubectl/overview/">官方文档</a></p>
]]></content>
      <tags>
        <tag>Kubernetes</tag>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s rolling update遇到的一个问题</title>
    <url>/2019/12/02/k8s-rolling-update-get-error/</url>
    <content><![CDATA[<p><strong>在使用K8S rolling update的时候,我同时使用JMeter不间断call API，就有少部分请求抛出了这个错误</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;timestamp&quot;:&quot;2019-12-02T07:33:47.120+0000&quot;,</span><br><span class="line">  &quot;status&quot;:500,</span><br><span class="line">  &quot;error&quot;:&quot;Internal Server Error&quot;,</span><br><span class="line">  &quot;message&quot;:&quot;No message available&quot;,</span><br><span class="line">  &quot;path&quot;:&quot;&#x2F;api&#x2F;anon&#x2F;article&#x2F;TW1Tq&#x2F;feed&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>上面的异常是SpringBoot的BasicErrorController抛出的带有错误，HTTP状态和异常消息的详细信息的JSON响应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web.servlet.error;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicErrorController</span> <span class="keyword">extends</span> <span class="title">AbstractErrorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="meta">@RequestMapping</span></span><br><span class="line">  <span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法内部组装了timestamp,error,message,path等信息</span></span><br><span class="line">    Map&lt;String, Object&gt; body = getErrorAttributes(request,</span><br><span class="line">        isIncludeStackTrace(request, MediaType.ALL));</span><br><span class="line">    HttpStatus status = getStatus(request);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(body, status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个错误显然是因为服务更新中，容器服务被直接停止，部分请求仍被分发到终止的容器，导致服务出现500错误，这部分错误请求数据占用比较少。由于是部分请求会产生服务器错误的情况，考虑使用优雅的终止方式，将错误请求降到最低，直至滚动更新不影响用户。</p>
<blockquote>
<p>kubernetes终止pod过程如下</p>
</blockquote>
<ol>
<li>kubernetes停止将新的连接路由到需要终止的pod。已建立的连接将保持不变并保持打开状态。</li>
<li>假设容器将开始停止，Kubernetes将TERM信号发送到Pod中每个容器的根进程。它发送的这个信号无法配置。</li>
<li>等待pod的TerminalGracePeriodSeconds中指定的时间段(默认为30秒),如果此时容器仍在运行，它将发送KILL终止容器</li>
</ol>
<p>由于在更新过程中,我们使用jmeter一直发起请求，所以有部分请求仍会发送到需要delete的pod,很明显在30s内它处理不完这么多的请求,而当过了30s之后，发送KILL命令就导致有些请求失败了。</p>
<p>那么能不能当我们收到通知的时候就不接收新的请求了呢？然后再把正在处理的请求处理完成之后在关闭我们的应用。</p>
<p>由于我们使用的内嵌的tomcat,所以只需要实现对应的接口就行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.connector.Connector;</span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.threads.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.embedded.tomcat.TomcatConnectorCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.event.ContextClosedEvent;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GracefulShutdown</span> <span class="keyword">implements</span> <span class="title">TomcatConnectorCustomizer</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationListener</span>&lt;<span class="title">ContextClosedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMEOUT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Connector connector;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Connector connector)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.connector = connector;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.connector.pause();</span><br><span class="line">    Executor executor = <span class="keyword">this</span>.connector.getProtocolHandler().getExecutor();</span><br><span class="line">    <span class="keyword">if</span> (executor <span class="keyword">instanceof</span> ThreadPoolExecutor) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将状态设置为shutdown,不再接收新的请求，正在跑的任务会执行完</span></span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!threadPoolExecutor.awaitTermination(TIMEOUT, TimeUnit.SECONDS)) &#123;</span><br><span class="line"></span><br><span class="line">          log.warn(<span class="string">&quot;Tomcat thread pool did not shut down gracefully within &quot;</span></span><br><span class="line">                  + TIMEOUT + <span class="string">&quot; seconds. Proceeding with forceful shutdown&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果在规定的时间30s之内还未处理完成，那么直接关闭</span></span><br><span class="line">          threadPoolExecutor.shutdownNow();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!threadPoolExecutor.awaitTermination(TIMEOUT, TimeUnit.SECONDS)) &#123;</span><br><span class="line">              log.error(<span class="string">&quot;Tomcat thread pool did not terminate&quot;</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> GracefulShutdown <span class="title">gracefulShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> GracefulShutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ConfigurableServletWebServerFactory <span class="title">webServerFactory</span><span class="params">(<span class="keyword">final</span> GracefulShutdown gracefulShutdown)</span> </span>&#123;</span><br><span class="line">      TomcatServletWebServerFactory factory = <span class="keyword">new</span> TomcatServletWebServerFactory();</span><br><span class="line">      factory.addConnectorCustomizers(gracefulShutdown);</span><br><span class="line">      <span class="keyword">return</span> factory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上面的设置我们就能实现所说的效果。同时即使在滚动更新的时候，一直有请求不断的call api，也不会出现报错的问题了。</p>
<blockquote>
<p>这里不断call api,类似于一个高并发请求(现在不说点高并发都不好意思说自己是写代码的了,狗头)</p>
</blockquote>
]]></content>
      <tags>
        <tag>K8S</tag>
        <tag>Rolling Update</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S你知道,K9S你可能也知道，那Lens呢？</title>
    <url>/2021/01/29/k8s-lens/</url>
    <content><![CDATA[<p>Kubernetes是用于自动部署、扩展和管理“容器化应用程序”的开源系统，而<a href="https://github.com/derailed/k9s">K9S</a>则提供了一个终端让我们能方便的操作K8S集群，它在github上有10.8K的star</p>
<p>比如查看日志</p>
<p><img data-src="/images/k8s/k9s_logs.png" alt="查看日志"></p>
<p>而<a href="https://github.com/lensapp/lens">Lens</a>也是一个终端工具，它也能让我们更好的操控集群，它在github上也有12.6K star</p>
<p><img data-src="/images/k8s/lens.png" alt="Lens"></p>
<p>Lens的使用比K9S更加方便也更加直观,无论是查看Deployment, Service, Pod。它还可以直接access work node,更是方便至极。</p>
<p><img data-src="/images/k8s/lens-info.png" alt="Lens"></p>
<p>所以，我推荐大家使用Lens。</p>
]]></content>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka consumer的offset的提交方式</title>
    <url>/2019/06/04/kafka-consumer-offset-commit/</url>
    <content><![CDATA[<p>Kafka consumer的offset提交机制有以下两种</p>
<h3 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h3><h4 id="同步提交"><a href="#同步提交" class="headerlink" title="同步提交"></a>同步提交</h4><p>consumer.commitSync()方式提交</p>
<h4 id="异步提交"><a href="#异步提交" class="headerlink" title="异步提交"></a>异步提交</h4><p>consumer.commitAsync(callback)方式提交</p>
<h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p>props.put(“enable.auto.commit”, “true”);<br>props.put(“auto.commit.interval.ms”, “1000”);</p>
<p>通过上面启动自动提交以及设置自动提交间隔时间(默认为5s)</p>
<a id="more"></a>

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="同步提交源码分析"><a href="#同步提交源码分析" class="headerlink" title="同步提交源码分析"></a>同步提交源码分析</h4><p>同步提交的核心代码在ConsumerCoordinator.commitOffsetSync中,核心代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">commitOffsetsSync</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, <span class="keyword">long</span> timeoutMs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  invokeCompletedOffsetCommitCallbacks();</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 组装OffsetCommitRequest</span></span><br><span class="line">  RequestFuture&lt;Void&gt; future = sendOffsetCommitRequest(offsets);</span><br><span class="line">  <span class="comment">// 2. 发送请求</span></span><br><span class="line">  client.poll(future, remainingMs);</span><br><span class="line">  <span class="comment">// 3. 接受到响应之后通知拦截器</span></span><br><span class="line">  <span class="keyword">if</span> (future.succeeded()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (interceptors != <span class="keyword">null</span>)</span><br><span class="line">          interceptors.onCommit(offsets);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (future.failed() &amp;&amp; !future.isRetriable())</span><br><span class="line">      <span class="keyword">throw</span> future.exception();</span><br><span class="line">  <span class="comment">// 4. 如果请求未完成则休眠一段时间,默认是300毫秒</span></span><br><span class="line">  time.sleep(retryBackoffMs);</span><br><span class="line"></span><br><span class="line">  now = time.milliseconds();</span><br><span class="line">  remainingMs = timeoutMs - (now - startMs);</span><br><span class="line">&#125; <span class="keyword">while</span> (remainingMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过常见的几个步骤就向GroupCoordinator发送了offset的同步信息,同时也完成了offset的confirm</p>
<ol>
<li>组装OffsetCommitRequest,准备向GroupCoordinator发送请求</li>
<li>发送请求,底层仍然是NIO</li>
<li>future返回后调用拦截器</li>
<li>如果响应还未返回则继续等待一段时间,默认是300ms</li>
</ol>
<h4 id="异步提交源码分析"><a href="#异步提交源码分析" class="headerlink" title="异步提交源码分析"></a>异步提交源码分析</h4><p>异步提交的核心源码在ConsumerCoordinator.commitOffsetsAsync中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commitOffsetsAsync</span><span class="params">(<span class="keyword">final</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, <span class="keyword">final</span> OffsetCommitCallback callback)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 这里会处理回调</span></span><br><span class="line">  invokeCompletedOffsetCommitCallbacks();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 封装请求</span></span><br><span class="line">  RequestFuture&lt;Void&gt; future = sendOffsetCommitRequest(offsets);</span><br><span class="line">  <span class="keyword">final</span> OffsetCommitCallback cb = callback == <span class="keyword">null</span> ? defaultOffsetCommitCallback : callback;</span><br><span class="line">  <span class="comment">// 3. 添加监听器,如果发送完成则处理回调</span></span><br><span class="line">  future.addListener(<span class="keyword">new</span> RequestFutureListener&lt;Void&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Void value)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (interceptors != <span class="keyword">null</span>)</span><br><span class="line">              interceptors.onCommit(offsets);</span><br><span class="line"></span><br><span class="line">          completedOffsetCommits.add(<span class="keyword">new</span> OffsetCommitCompletion(cb, offsets, <span class="keyword">null</span>));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e)</span> </span>&#123;</span><br><span class="line">          Exception commitException = e;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RetriableException)</span><br><span class="line">              commitException = <span class="keyword">new</span> RetriableCommitFailedException(e);</span><br><span class="line"></span><br><span class="line">          completedOffsetCommits.add(<span class="keyword">new</span> OffsetCommitCompletion(cb, offsets, commitException));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到上面的三个步骤你是否会疑惑,怎么没有poll发送数据呢?其实异步提交offset时发送commitOffsetRequest是在consumer.poll()中完成的,这个时候会把Channel中堆积的数据发送出去。<br>同时同步发送和异步发送还有一个阻塞的区别，也就是上面同步发送未收到响应的时候会休眠一段时间直到收到响应为止。</p>
<blockquote>
<p><a href="https://generalthink.github.io/2019/04/09/kafka-producer-network-request/">Kafka 网络层源码分析</a></p>
</blockquote>
<h4 id="自动发送源码分析"><a href="#自动发送源码分析" class="headerlink" title="自动发送源码分析"></a>自动发送源码分析</h4><p>那么自动发送offset又是在哪里完成的呢？同样的仍然是在consumer.poll()中完成的,之前分析的在poll之前需要加入Group,也就是和GroupCoordinator通信，在这个过程中就会处理offset的自动提交。</p>
<blockquote>
<p>Kafka consumer加入group的分析可以查看这篇<a href="https://generalthink.github.io/2019/05/15/how-to-join-kafka-consumer-group/">文章</a></p>
</blockquote>
<p>源码在ConsumerCoordinator.poll()方法中，核心源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">poll</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeoutMs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> startTime = time.milliseconds();</span><br><span class="line">  <span class="keyword">long</span> currentTime = startTime;</span><br><span class="line">  <span class="keyword">long</span> elapsed = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 处理回调</span></span><br><span class="line">  invokeCompletedOffsetCommitCallbacks();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里省略掉加入Group的源码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 自动提交offset</span></span><br><span class="line">  maybeAutoCommitOffsetsAsync(currentTime);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maybeAutoCommitOffsetsAsync</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 开启了自动提交并且当前时间大于等于下一次自动提交的截止时间</span></span><br><span class="line">  <span class="keyword">if</span> (autoCommitEnabled &amp;&amp; now &gt;= nextAutoCommitDeadline) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 更新截止时间</span></span><br><span class="line">      <span class="keyword">this</span>.nextAutoCommitDeadline = now + autoCommitIntervalMs;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 3. 获取所有已被消费的TopPartition的offset信息</span></span><br><span class="line">      Map&lt;TopicPartition, OffsetAndMetadata&gt; allConsumedOffsets = subscriptions.allConsumed();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4. 异步提交offset，源码参考上面的异步提交方式</span></span><br><span class="line">      commitOffsetsAsync(allConsumedOffsets, <span class="keyword">new</span> OffsetCommitCallback() &#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是经过下面几个步骤就实现了自动提交了</p>
<ol>
<li><p>开启自动提交并且当前时间大于等于下一次自动提交的截止时间</p>
<blockquote>
<p>this.nextAutoCommitDeadline = time.milliseconds() + autoCommitIntervalMs;<br>nextAutoCommitDeadline截止时间等于new KafkaConsumer的系统时间加上自动提交间隔时间</p>
</blockquote>
</li>
<li><p>更新截止时间为现在的时间加上自动提交间隔时间</p>
</li>
<li><p>获取所有已被消费的TopicPartiton的offset信息</p>
</li>
<li><p>异步提交offset</p>
</li>
</ol>
<p>第三步走获取所有已被消费的partition的offset信息，这里不得不说到SubscriptionState这个类，我们来关注下它重要的成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriptionState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该consumer订阅的所有topics</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; subscription;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该consumer所属的group中，所有consumer订阅的topic。该字段只对consumer leader有用</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; groupSubscription;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// partition分配好之后，该字段记录每个partition的消费状态(包含reset策略以及上次消费的position等）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;TopicPartition, TopicPartitionState&gt; assignment;</span><br></pre></td></tr></table></figure>

<p>所以通过SubscriptionState我们就可以获取已被消费的TopicPartition的offset信息,根据这个可以获取所有已消费的offset,然后发送请求commit offset.</p>
]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka Consumer源码之Offset以及Fetcher分析</title>
    <url>/2019/05/31/kafka-consumer-offset/</url>
    <content><![CDATA[<p>上一篇讲了consumer如何加入consumer group的,现在加入组成功之后,就要准备开始消费,但是我们需要知道consumer从offset为多少的位置开始消费。</p>
<p>consumer中关于如何消费有2种策略：</p>
<p><strong>1. 手动指定</strong><br>调用consumer.seek(TopicPartition, offset),然后开始poll</p>
<p><strong>2. 自动指定</strong><br>poll之前给集群发送请求，让集群告知客户端，当前该TopicPartition的offset是多少,这也是我们此次分析的重点.</p>
<a id="more"></a>

<p>在讲如何拉取offset之前,先认识下下面这个类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicPartitionState</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Long position; <span class="comment">// last consumed position</span></span><br><span class="line">  <span class="keyword">private</span> Long highWatermark; <span class="comment">// the high watermark from last fetch</span></span><br><span class="line">  <span class="keyword">private</span> Long logStartOffset; <span class="comment">// the log start offset</span></span><br><span class="line">  <span class="keyword">private</span> Long lastStableOffset;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> paused;  <span class="comment">// whether this partition has been paused by the user</span></span><br><span class="line">  <span class="keyword">private</span> OffsetResetStrategy resetStrategy;  <span class="comment">// the strategy to use if the offset needs resetting</span></span><br><span class="line">  <span class="keyword">private</span> Long nextAllowedRetryTimeMs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>consumer实例订阅的每个 topic-partition 都会有一个对应的 TopicPartitionState 对象，在这个对象中会记录上面内容,最需要关注的就是position这个属性,它表示上一次消费的位置。其中通过consumer.seek方式指定消费offset的时候,其实设置的就是这个position值。</p>
<p>加入group之后，就得去获取offset了,下面的方式就是开始更新position(offset)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateFetchPositions</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeoutMs)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 查看TopicPartitionState的position是否为空,第一次消费肯定为空</span></span><br><span class="line">  cachedSubscriptionHashAllFetchPositions = subscriptions.hasAllFetchPositions();</span><br><span class="line">  <span class="keyword">if</span> (cachedSubscriptionHashAllFetchPositions) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 如果没有有效的offset,那么需要从group coordinator中获取</span></span><br><span class="line">  <span class="keyword">if</span> (!coordinator.refreshCommittedOffsetsIfNeeded(timeoutMs)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 如果还存在partition不知道position,并且设置了offsetreset策略,那么就等待重置，不然就抛出异常</span></span><br><span class="line">  subscriptions.resetMissingPositions();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 向PartitionLeader(GroupCoordinator所在机器)发送ListOffsetRequest重置position</span></span><br><span class="line">  fetcher.resetOffsetsIfNeeded();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码主要分为4个步骤,具体如下:</p>
<ol>
<li><p>首先查看当前TopicPartition的position是否为空，如果不为空，表示知道下次fetch position(拉取数据从哪个位置开始拉取),<br>但是第一次消费这个 TopicPartitionState.position肯定为空。</p>
</li>
<li><p>通过coordinator为缺少fetch position的partition拉取position(last committed offset)</p>
</li>
<li><p>仍不知道partition的position(_consumer_offsets中未保存位移信息),且设置了offsetreset策略,那么就等待重置，<br>如果没有设置重置策略，然就抛出NoOffsetForPartitionException异常。</p>
</li>
<li><p>为那些需要重置fetch position的partition发送ListOffsetRequest重置position(consumer.beginningOffsets(),consumer.endOffsets(),consumer.offsetsForTimes(),consumer.seek()<br>都会发送ListOffRequest请求)</p>
<blockquote>
<p>上面说的几个方法相当于都是用户自己自定义消费的offset,所以可能出现越界(消费位置无法在实际分区中查到)的情况，所以也是也是会发送ListOffsetRequest请求的，即触发auto.offset.reset参数的执行<br>比如现在某个partitiion的可拉取offset最大值为100,如果你指定消费offset=200的位置,那肯定拉取不到，此时就会根据auto.offset.reset策略将拉取位置重置为100(默认为latest)</p>
</blockquote>
</li>
</ol>
<p>我们先看下第二个步骤是如何fetch position的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; <span class="title">fetchCommittedOffsets</span><span class="params">(<span class="keyword">final</span> Set&lt;TopicPartition&gt; partitions,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                        <span class="keyword">final</span> <span class="keyword">long</span> timeoutMs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </span><br><span class="line">    <span class="comment">// 1. 封装FetchRequest请求</span></span><br><span class="line">    future = sendOffsetFetchRequest(partitions);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通过KafkaClient发送</span></span><br><span class="line">    client.poll(future, remainingTimeAtLeastZero(timeoutMs, elapsedTime));</span><br><span class="line">    <span class="keyword">final</span> RequestFuture&lt;Map&lt;TopicPartition, OffsetAndMetadata&gt;&gt; future;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取请求的响应数据</span></span><br><span class="line">    <span class="keyword">if</span> (future.succeeded()) &#123;</span><br><span class="line">      <span class="keyword">return</span> future.value();</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的步骤和我们之前提到的发送其他请求毫无区别,基本就是这三个套路，在获取到响应之后，会设置TopicPartition的position值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refreshCommittedOffsetsIfNeeded</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeoutMs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Set&lt;TopicPartition&gt; missingFetchPositions = subscriptions.missingFetchPositions();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets = fetchCommittedOffsets(missingFetchPositions, timeoutMs);</span><br><span class="line">  <span class="keyword">if</span> (offsets == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;TopicPartition, OffsetAndMetadata&gt; entry : offsets.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">final</span> TopicPartition tp = entry.getKey();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获取response中的offset</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> offset = entry.getValue().offset();</span><br><span class="line">      log.debug(<span class="string">&quot;Setting offset for partition &#123;&#125; to the committed offset &#123;&#125;&quot;</span>, tp, offset);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 实际就是设置SubscriptionState的position值</span></span><br><span class="line">      <span class="keyword">this</span>.subscriptions.seek(tp, offset);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过subscriptions.seek()方法为每个TopicPartition设置position值后,到了这里就知道从哪里开发消费订阅topic下的partition了。</p>
<p>第三个步骤什么时候发起FetchRequest拿不到position呢?</p>
<p>我们知道消费位移(consume offset)是保存在_consumer_offsets这个topic里面的,当我们进行消费的时候需要知道上次消费到了什么位置。<br>那么就会发起请求去看上次消费到了topic的partition的哪个位置，但是这个消费位移是有保存时长的,默认为7天(broker端通过<br>offsets.retention.minutes)。</p>
<p>之后隔了一段时间进行消费，这个这个间隔时间超过参数的配置值，那么原先的位移信息就会丢失，最后只能通过客户端参数auto.offset.reset来确定开始消费的位置。</p>
<p>如果我们第一次消费topic,那么在_consumer_offsets中也是找不到消费位移的，所以就会执行第四个步骤，发起ListOffsetRequest请求根据配置的reset策略(auto.offset.reset)来决定开始消费的位置。</p>
<p>发起这个请求和之前的请求没有什么特殊之处,都是组装请求体，然后调用poll发起请求，最后处理response,处理response的核心代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">future.addListener(<span class="keyword">new</span> RequestFutureListener&lt;ListOffsetResult&gt;() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ListOffsetResult result)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, OffsetData&gt; fetchedOffset : result.fetchedOffsets.entrySet()) &#123;</span><br><span class="line">         TopicPartition partition = fetchedOffset.getKey();</span><br><span class="line">         OffsetData offsetData = fetchedOffset.getValue();</span><br><span class="line">         Long requestedResetTimestamp = resetTimestamps.get(partition);</span><br><span class="line">         resetOffsetIfNeeded(partition, requestedResetTimestamp, offsetData);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetOffsetIfNeeded</span><span class="params">(TopicPartition partition, Long requestedResetTimestamp, OffsetData offsetData)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!subscriptions.isAssigned(partition)) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Skipping reset of partition &#123;&#125; since it is no longer assigned&quot;</span>, partition);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!subscriptions.isOffsetResetNeeded(partition)) &#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Skipping reset of partition &#123;&#125; since reset is no longer needed&quot;</span>, partition);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!requestedResetTimestamp.equals(offsetResetStrategyTimestamp(partition))) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果reset策略设置的是latest，那么requestedResetTimestamp = -1，如果是earliest,requestedResetTimestamp = -2</span></span><br><span class="line">      log.debug(<span class="string">&quot;Skipping reset of partition &#123;&#125; since an alternative reset has been requested&quot;</span>, partition);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.info(<span class="string">&quot;Resetting offset for partition &#123;&#125; to offset &#123;&#125;.&quot;</span>, partition, offsetData.offset);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置对应的TopicPartition fetch的position</span></span><br><span class="line">      subscriptions.seek(partition, offsetData.offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里解释下auto.offset.reset的两个值(latest,earliest)的区别,假设我们现在要消费MyConsumerTopic的数据,它有3个分区,生产者往这个topic发送了10条数据,然后分区数据按照MyConsumerTopic-0(3条数据),MyConsumerTopic-1(3条数据),MyConsumerTopic-2(4条数据)这样分配。</p>
<p>当设置为latest的时候,返回的offset具体到每个partition就是HW值(partition0就是3,partition1也是3,partition2是4)</p>
<p>当设置为earliest的时候,就会从起始处(LogStartOffset,不是LSO)开始消费，这里就是从0开始</p>
<p><img data-src="/images/introduction-kafka/kafka-partition-analysis.png" alt="名词解析"></p>
<ol>
<li>**LogStartOffset:**表示partition的起始位置,初始值为0,由于消息的增加以及日志清除策略影响，这个值会阶段性增大。尤其注意这个不能缩写未LSO,LSO代表的是LastStableOffset,和事务有关。</li>
<li>**ConsumerOffset:**消费位移，表示partition的某个消费者消费到的位移位置。</li>
<li><strong>HighWatermark</strong>: 简称HW,代表消费端能看到的partition的最高日志位移,HW大于等于ConsumerOffset的值。</li>
<li><strong>LogEndOffset</strong>: 简称LEO,代表partition的最高日志位移，第消费者不可见,HW到LEO这之间的数据未被follwer完全同步。</li>
</ol>
<p>现在万事俱备只欠东风了,加入组，也确定了拉取的offset,那么现在就应该去拉取数据了,其核心源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; pollForFetches(<span class="keyword">final</span> <span class="keyword">long</span> timeoutMs) &#123;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取fetcher已经拉取到的数据</span></span><br><span class="line">  <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = fetcher.fetchedRecords();</span><br><span class="line">  <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> records;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上次fetch到的数据已经全部拉取了,需要再次发送fetch请求,从broker拉取数据</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组装请求,将发往同一个节点的请求放到一起</span></span><br><span class="line">  fetcher.sendFetches();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 真正开始发送,底层同样使用NIO</span></span><br><span class="line">  client.poll(pollTimeout, startMs, () -&gt; &#123;</span><br><span class="line">     <span class="keyword">return</span> !fetcher.hasCompletedFetches();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 group 需要 rebalance,直接返回空数据,这样更快地让 group 进行稳定状态</span></span><br><span class="line">  <span class="keyword">if</span> (coordinator.rejoinNeededOrPending()) &#123;</span><br><span class="line">     <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取拉取到的数据</span></span><br><span class="line">  <span class="keyword">return</span> fetcher.fetchedRecords();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里需要注意的是fetcher.sendFetches(),在发送请求的同时会注册回调函数，当有response的时候，会解析response，讲返回的数据放到Fetcher的成员变量中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.send(fetchTarget, request)</span><br><span class="line">  .addListener(<span class="keyword">new</span> RequestFutureListener&lt;ClientResponse&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ClientResponse resp)</span> </span>&#123;</span><br><span class="line">        FetchResponse&lt;Records&gt; response = (FetchResponse&lt;Records&gt;) resp.responseBody();</span><br><span class="line">        </span><br><span class="line">        Set&lt;TopicPartition&gt; partitions = <span class="keyword">new</span> HashSet&lt;&gt;(response.responseData().keySet());</span><br><span class="line">        FetchResponseMetricAggregator metricAggregator = <span class="keyword">new</span> FetchResponseMetricAggregator(sensors, partitions);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, FetchResponse.PartitionData&lt;Records&gt;&gt; entry : response.responseData().entrySet()) &#123;</span><br><span class="line">            TopicPartition partition = entry.getKey();</span><br><span class="line">            <span class="keyword">long</span> fetchOffset = data.sessionPartitions().get(partition).fetchOffset;</span><br><span class="line">            FetchResponse.PartitionData fetchData = entry.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将返回的数据放到ConcurrentLinkedQueue&lt;CompletedFetch&gt;</span></span><br><span class="line">            completedFetches.add(<span class="keyword">new</span> CompletedFetch(partition, fetchOffset, fetchData, metricAggregator,</span><br><span class="line">                    resp.requestHeader().apiVersion()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下的获取拉取到的数据我就不做过多分析了,以免有凑字数嫌疑,至此Kafka Consumer中如何拉取消息的整体流程分析完毕,接下来的文章会分析partition的分配以及offset的提交，敬请期待。</p>
]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka Consumer源码分析之分区方案</title>
    <url>/2019/06/06/kafka-consumer-partition-assign/</url>
    <content><![CDATA[<p>consumer提供三种不同的分区策略，可以通过<code>partition.assignment.strategy</code>参数进行配置,默认使用的策略是<code>org.apache.kafka.clients.consumer.RangeAssignor</code>,还存在<code>org.apache.kafka.clients.consumer.RoundRobinAssignor</code>和<code>org.apache.kafka.clients.consumer.StickyAssignor</code>这两种，它们的关系图如下所示。</p>
<p><img data-src="/images/introduction-kafka/kafka-partition-assignor.png" alt="partition分配机制"></p>
<a id="more"></a>

<p>当我们想要自定义partition分配策略的时候只需要继承<code>AbstractPartitionAssignor</code>这个类就行了。</p>
<h3 id="AbstractPartitionAssignor"><a href="#AbstractPartitionAssignor" class="headerlink" title="AbstractPartitionAssignor"></a>AbstractPartitionAssignor</h3><p>这个抽象类有一个抽象方法，其他子类都是通过复写它的抽象方法来实现分区分配的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; assign(Map&lt;String, Integer&gt; partitionsPerTopic,</span><br><span class="line">                                                             Map&lt;String, Subscription&gt; subscriptions);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>assign() 这个方法，有两个参数：</p>
<ol>
<li>partitionsPerTopic：所订阅的每个 topic 与其 partition 数的对应关系，metadata 没有的 topic 将会被移除</li>
<li>subscriptions：每个 consumerId 与其所订阅的 topic 列表的关系。</li>
</ol>
<h3 id="RangeAssignor-分区分配"><a href="#RangeAssignor-分区分配" class="headerlink" title="RangeAssignor 分区分配"></a>RangeAssignor 分区分配</h3><p>先看下这个策略的分区代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; assign(Map&lt;String, Integer&gt; partitionsPerTopic,</span><br><span class="line">                                             Map&lt;String, Subscription&gt; subscriptions) &#123;</span><br><span class="line">  <span class="comment">// 1. 获取每个topic被多少个consumer订阅了</span></span><br><span class="line"> Map&lt;String, List&lt;String&gt;&gt; consumersPerTopic = consumersPerTopic(subscriptions);</span><br><span class="line">  <span class="comment">// 2. 存储最终的分配方案</span></span><br><span class="line"> Map&lt;String, List&lt;TopicPartition&gt;&gt; assignment = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> <span class="keyword">for</span> (String memberId : subscriptions.keySet())</span><br><span class="line">     assignment.put(memberId, <span class="keyword">new</span> ArrayList&lt;TopicPartition&gt;());</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;String&gt;&gt; topicEntry : consumersPerTopic.entrySet()) &#123;</span><br><span class="line">     String topic = topicEntry.getKey();</span><br><span class="line">     List&lt;String&gt; consumersForTopic = topicEntry.getValue();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 3. 每个topic的partition数量</span></span><br><span class="line">     Integer numPartitionsForTopic = partitionsPerTopic.get(topic);</span><br><span class="line">     <span class="keyword">if</span> (numPartitionsForTopic == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">     Collections.sort(consumersForTopic);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 4. 表示平均每个consumer会分配到多少个partition</span></span><br><span class="line">     <span class="keyword">int</span> numPartitionsPerConsumer = numPartitionsForTopic / consumersForTopic.size();</span><br><span class="line">     <span class="comment">// 5. 平均分配后还剩下多少个partition未被分配</span></span><br><span class="line">     <span class="keyword">int</span> consumersWithExtraPartition = numPartitionsForTopic % consumersForTopic.size();</span><br><span class="line"></span><br><span class="line">     List&lt;TopicPartition&gt; partitions = AbstractPartitionAssignor.partitions(topic, numPartitionsForTopic);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 6. 这里是关键点,分配原则是将未能被平均分配的partition分配到前consumersWithExtraPartition个consumer</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = consumersForTopic.size(); i &lt; n; i++) &#123;</span><br><span class="line">         <span class="keyword">int</span> start = numPartitionsPerConsumer * i + Math.min(i, consumersWithExtraPartition);</span><br><span class="line">         <span class="keyword">int</span> length = numPartitionsPerConsumer + (i + <span class="number">1</span> &gt; consumersWithExtraPartition ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">         assignment.get(consumersForTopic.get(i)).addAll(partitions.subList(start, start + length));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> assignment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面最重要的就是第六步，它决定了如何分配的具体方案，其分配规则是:先将分区数平均分配给consumer，对于剩下不能被平均分配的partition，会将其分配到前 consumersWithExtraPartition 个 consumer 上，也就是前 consumersWithExtraPartition 个 consumer 获得 topic-partition 列表会比后面多一个。</p>
<p>举个例子,假设一个topic有5个partiton,然后一个group中有3个consumer都订阅了这个topic,那么range的分配方式如下</p>
<ul>
<li>consumer 0: start–&gt;0, length–&gt;2, topic-partition–&gt;p0,p1</li>
<li>consumer 1: start–&gt;2, length–&gt;2, topic-partition–&gt;p2,p3</li>
<li>consumer 2: start–&gt;4, length–&gt;1, topic-partition–&gt;p4</li>
</ul>
<p>如果group中有consumer没有订阅这个topic，那么就不会参与分配，对于多个topic的分配方案,和单个topic的分配是一样的,同样的再举个例子。</p>
<p>现在有2个topic,一个partition有3个,一个partition有5个,group中有3个consumer，但是只有前面2个consumer订阅了第一个topic,而另外一个topic则被所有consumer都订阅了，那么其分配方案取下：</p>
<table>
<thead>
<tr>
<th>consumer</th>
<th>订阅topic1</th>
<th>订阅topci2</th>
</tr>
</thead>
<tbody><tr>
<td>consumer0</td>
<td>t1-p0, t1-p1</td>
<td>t2-p0, t2-p1</td>
</tr>
<tr>
<td>consumer1</td>
<td>t1-p2</td>
<td>t2-p2, t2-p3</td>
</tr>
<tr>
<td>consumer2</td>
<td></td>
<td>t2-p4</td>
</tr>
</tbody></table>
<p>其实也可以看到，随着分区数的变化,这种方式的分配并不均匀，类似的情况如果扩大，则部分消费者可能会消费很多partition，而部分消费者又会闲置。</p>
<h3 id="RoundRobinAssignor-分区分配"><a href="#RoundRobinAssignor-分区分配" class="headerlink" title="RoundRobinAssignor 分区分配"></a>RoundRobinAssignor 分区分配</h3><p>同样的还是想来看下它的源代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; assign(Map&lt;String, Integer&gt; partitionsPerTopic,</span><br><span class="line">                                                    Map&lt;String, Subscription&gt; subscriptions) &#123;</span><br><span class="line">  Map&lt;String, List&lt;TopicPartition&gt;&gt; assignment = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String memberId : subscriptions.keySet())</span><br><span class="line">      assignment.put(memberId, <span class="keyword">new</span> ArrayList&lt;TopicPartition&gt;());</span><br><span class="line">  <span class="comment">// 1. 环状链表,存储所有的consumer,一次迭代完之后又会回到原点</span></span><br><span class="line">  CircularIterator&lt;String&gt; assigner = <span class="keyword">new</span> CircularIterator&lt;&gt;(Utils.sorted(subscriptions.keySet()));</span><br><span class="line">  <span class="comment">// 2. 获取所有订阅的topic的partition总数</span></span><br><span class="line">  <span class="keyword">for</span> (TopicPartition partition : allPartitionsSorted(partitionsPerTopic, subscriptions)) &#123;</span><br><span class="line">      <span class="keyword">final</span> String topic = partition.topic();</span><br><span class="line">      <span class="keyword">while</span> (!subscriptions.get(assigner.peek()).topics().contains(topic))</span><br><span class="line">          assigner.next();</span><br><span class="line">      assignment.get(assigner.next()).add(partition);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> assignment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其分配规则很简单列出所有的topic-partition以及所有的consumer,然后开始分配,先每个consumer都分配一轮,一轮分配完成之后接着下一轮继续分配，直到分配完为止。<br>同样的举个例子,假设一个topic有5个partiton,然后一个group中有3个consumer都订阅了这个topic,那么roundrobin的分配方式如下；</p>
<ul>
<li>consuemr 0: topic-partition–&gt;p0,p3</li>
<li>consumer 1: topic-partition–&gt;p1,p4</li>
<li>consumer 2: topic-partition–&gt;p2</li>
</ul>
<p>对于多个consumer订阅多个topic的情况，这里也举一个例子说明</p>
<p>现在有3个topic,一个有2个partition,一个有3个partition,另外一个有4个partition,group中有3个consumer,第一个consumer订阅了第一个topic,第二个consumer订阅了前两个topic,第三个consumer订阅了三个topic，那么它们的分配方案如下：</p>
<table>
<thead>
<tr>
<th>consumer</th>
<th>topic1</th>
<th>topic2</th>
<th>topic3</th>
</tr>
</thead>
<tbody><tr>
<td>consumer1</td>
<td>t1-p0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>consumer2</td>
<td>t1-p1</td>
<td>t2-p0, t2-p3</td>
<td></td>
</tr>
<tr>
<td>consumer3</td>
<td></td>
<td>t2-p1</td>
<td>t3-p0, t3-p1, t3-p2, t3-p3</td>
</tr>
</tbody></table>
<p>很明显consumer3要是把t2-p1也分配给consumer2就会显得更加均匀一些了。</p>
<h3 id="StickyAssignor-分区分配"><a href="#StickyAssignor-分区分配" class="headerlink" title="StickyAssignor 分区分配"></a>StickyAssignor 分区分配</h3><p>sticky这样的分区策略是从0.11版本才开始引入的，它主要有两个目的</p>
<ol>
<li>分区的分配要尽可能均匀</li>
<li>分区的分配要尽可能与上次分配的保持相同</li>
</ol>
<p>当两者冲突的时候，第一个目标优先于第二个目标。</p>
<p>源码我就不贴出来了，因为这个类的源码是上面两个类的源码的10倍。</p>
<p>sticky这样的分区方式作用发生分区重分配的时候，尽可能地让前后两次分配相同，进而减少系统资源的损耗及其他异常情况的发生。以上面那个例子举例，如果采用这种分配方式那么其分配结果如下：</p>
<table>
<thead>
<tr>
<th>consumer</th>
<th>topic1</th>
<th>topic2</th>
<th>topic3</th>
</tr>
</thead>
<tbody><tr>
<td>consumer1</td>
<td>t1-p0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>consumer2</td>
<td>t1-p1, t2-p1</td>
<td>t2-p0, t2-p3</td>
<td></td>
</tr>
<tr>
<td>consumer3</td>
<td></td>
<td></td>
<td>t3-p0, t3-p1, t3-p2, t3-p3</td>
</tr>
</tbody></table>
<p>上面三个分区策略有着不同的分配方式，在实际使用过程中，需要根据自己的需求选择合适的策略，但是如果你只有一个consumer,那么选择哪个方式都是一样的，但是如果是多个consumer不在同一台设备上进行消费，那么sticky方式应该更加合适。</p>
<h4 id="自定义分区策略"><a href="#自定义分区策略" class="headerlink" title="自定义分区策略"></a>自定义分区策略</h4><p>如之前所说，只需要继承AbstractPartitionAssignor并复写其中方法即可(当然也可以直接实现PartitionAssignor接口),其中有两个方法需要复写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, List&lt;TopicPartition&gt;&gt; <span class="title">assign</span><span class="params">(Map&lt;String, Integer&gt; partitionsPerTopic,Map&lt;String, Subscription&gt; subscriptions)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>其中assign()方法表示的是分区分配方案的实现，而name()方法则表示了这个分配策略的唯一名称，比如之前提到的range,roundrobin和sticky,这个名字会在和GroupCoordinator的通信中返回，通过它consumer leader来确定整个group的分区方案(分区策略是由group中的consumer共同投票决定的，谁使用的多,就是用哪个策略),对于加入group的分析可以参考之前的<a href="https://generalthink.github.io/2019/05/15/how-to-join-kafka-consumer-group">文章</a></p>
]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka Consumer消费数据你要考虑哪些问题?</title>
    <url>/2019/05/06/kafka-consumer-use/</url>
    <content><![CDATA[<h3 id="如何消费数据"><a href="#如何消费数据" class="headerlink" title="如何消费数据"></a>如何消费数据</h3><p>我们已经知道了如何发送数据到Kafka,既然有数据发送,那么肯定就有数据消费,消费者也是Kafka整个体系中不可缺少的一环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConsumerDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须设置的属性</span></span><br><span class="line">    props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;192.168.239.131:9092&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;group1&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可选设置属性</span></span><br><span class="line">    props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    <span class="comment">// 自动提交offset,每1s提交一次</span></span><br><span class="line">    props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;auto.offset.reset&quot;</span>,<span class="string">&quot;earliest &quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;client.id&quot;</span>, <span class="string">&quot;zy_client_id&quot;</span>);</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">    <span class="comment">// 订阅test1 topic</span></span><br><span class="line">    consumer.subscribe(Collections.singletonList(<span class="string">&quot;test1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">        records.forEach(record -&gt; &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;topic = %s ,partition = %d,offset = %d, key = %s, value = %s%n&quot;</span>, record.topic(), record.partition(),</span><br><span class="line">                    record.offset(), record.key(), record.value());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="push-还是-pull"><a href="#push-还是-pull" class="headerlink" title="push 还是 pull"></a>push 还是 pull</h4><p>Kafka Consumer采用的是主动拉取broker数据进行消费的。一般消息中间件存在推送(server推送数据给consumer)和拉取(consumer主动取服务器取数据)两种方式，这两种方式各有优劣。</p>
<p>如果是选择推送的方式最大的阻碍就是服务器不清楚consumer的消费速度，如果consumer中执行的操作又是比较耗时的，那么consumer可能会不堪重负,甚至会导致系统挂掉。</p>
<p>而采用拉取的方式则可以解决这种情况，consumer根据自己的状态来拉取数据,可以对服务器的数据进行延迟处理。但是这种方式也有一个劣势就是服务器没有数据的时候可能会一直轮询，不过还好Kafka在poll()有参数允许消费者请求在“长轮询”中阻塞，等待数据到达(并且可选地等待直到给定数量的字节可用以确保传输大小)。</p>
<h4 id="必须属性"><a href="#必须属性" class="headerlink" title="必须属性"></a>必须属性</h4><p>上面代码中消费者必须的属性有4个,这里着重说一下group.id这个属性,kafka Consumer和Producer不一样,Consummer中有一个Consumer group(消费组)，由它来决定同一个Consumer group中的消费者具体拉取哪个partition的数据,所以这里必须指定group.id属性。</p>
<ol>
<li>bootstrap.servers<br>连接Kafka集群的地址，多个地址以逗号分隔</li>
<li>key.deserializer<br>消息中key反序列化类,需要和Producer中key序列化类相对应</li>
<li>value.deserializer<br>消息中value的反序列化类,需要和Producer中Value序列化类相对应</li>
<li>group.id<br>消费者所属消费组的唯一标识</li>
</ol>
<h4 id="订阅-取消主题"><a href="#订阅-取消主题" class="headerlink" title="订阅/取消主题"></a>订阅/取消主题</h4><ol>
<li>使用subscribe()方法订阅主题</li>
<li>使用assign()方法订阅确定主题和分区<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitionInfoList = consumer.partitionsFor(<span class="string">&quot;topic1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> != partitionInfoList) &#123;</span><br><span class="line">  <span class="keyword">for</span>(PartitionInfo partitionInfo : partitionInfoList) &#123;</span><br><span class="line">      consumer.assign(Collections.singletonList(</span><br><span class="line">        <span class="keyword">new</span> TopicPartition(partitionInfo.topic(), partitionInfo.partition())));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
通过subscribe()方法订阅主题具有消费者自动再均衡(reblance)的功能，存在多个消费者的情况下可以根据分区分配策略来自动分配各个消费者与分区的关系。当组内的消费者增加或者减少时，分区关系会自动调整。实现消费负载均衡以及故障自动转移。使用assign()方法订阅则不具有该功能。</li>
</ol>
<ol start="3">
<li>取消主题<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.unsubscribe();</span><br><span class="line">consumer.subscribe(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">consumer.assign(<span class="keyword">new</span> ArrayList&lt;TopicPartition&gt;());</span><br></pre></td></tr></table></figure>
上面的三行代码作用相同，都是取消订阅，其中unsubscribe()方法即可以取消通过subscribe()方式实现的订阅，还可以取消通过assign()方式实现的订阅。</li>
</ol>
<h3 id="如何更好的消费数据"><a href="#如何更好的消费数据" class="headerlink" title="如何更好的消费数据"></a>如何更好的消费数据</h3><p>开头处的代码展示了我们是如何消费数据的,但是代码未免过于简单,我们测试的时候这样写没有问题,但是实际开发过程中我们并不会这样写，我们会选择更加高效的方式,这里提供两种方式供大家参考。</p>
<ol>
<li>一个Consumer group,多个consumer,数量小于等于partition的数量</li>
</ol>
<p><img data-src="/images/introduction-kafka/kafka_multi_consumer.png" alt="多个consumer"></p>
<ol start="2">
<li>一个consumer,多线程处理事件</li>
</ol>
<p><img data-src="/images/introduction-kafka/kafka_multi_event_handler.png" alt="多事件处理器"></p>
<p>第一种方式每个consumer都要维护一个独立的TCP连接，如果分区数和创建consumer线程的数量过多，会造成不小系统开销。但是如果处理消息足够快速，消费性能也会提升,如果慢的话就会导致消费性能降低。</p>
<p>第二种方式是采用一个consumer，多个消息处理线程来处理消息，其实在生产中，瓶颈一般是集中在消息处理上的(可能会插入数据到数据库，或者请求第三方API)，所以我们采用多个线程来处理这些消息。</p>
<p>当然可以结合第一二种方式，采用多consumer+多个消息处理线程来消费Kafka中的数据,核心代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumerNum; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据属性创建Consumer</span></span><br><span class="line">  <span class="keyword">final</span> Consumer&lt;String, <span class="keyword">byte</span>[]&gt; consumer = consumerFactory.getConsumer(getServers(), groupId);</span><br><span class="line">  consumerList.add(consumer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//订阅主题</span></span><br><span class="line">  consumer.subscribe(Arrays.asList(<span class="keyword">this</span>.getTopic()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//consumer.poll()拉取数据</span></span><br><span class="line">  BufferedConsumerRecords bufferedConsumerRecords = <span class="keyword">new</span> BufferedConsumerRecords(consumer);</span><br><span class="line"></span><br><span class="line">  getExecutor().scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//进行消息处理</span></span><br><span class="line">      consumeEvents(bufferedConsumerRecords);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> sleepTime = intervalMillis - (System.currentTimeMillis() - startTime);</span><br><span class="line">      <span class="keyword">if</span> (sleepTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Thread.sleep(sleepTime);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;, <span class="number">0</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不过这种方式不能顺序处理数据，如果你的业务是顺序处理，那么第一种方式可能更适合你。所以实际生产中请根据业务选择最适合自己的方式。</p>
<h3 id="消费数据考虑哪些问题"><a href="#消费数据考虑哪些问题" class="headerlink" title="消费数据考虑哪些问题?"></a>消费数据考虑哪些问题?</h3><p>在Kafka中无论是producer往topic中写数据,还是consumer从topic中读数据,都避免不了和offset打交道,关于offset主要有以下几个概念。</p>
<p><img data-src="/images/introduction-kafka/kafka-partition-offset.png" alt="Kafka Offset"></p>
<ul>
<li>Last Committed Offset：consumer group最新一次 commit 的 offset，表示这个 group 已经把 Last Committed Offset 之前的数据都消费成功了。</li>
<li>Current Position：consumer group 当前消费数据的 offset，也就是说，Last Committed Offset 到 Current Position 之间的数据已经拉取成功，可能正在处理，但是还未 commit。</li>
<li>Log End Offset(LEO)：记录底层日志(log)中的<strong>下一条消息的 offset。</strong>,对producer来说，就是即将插入下一条消息的offset。</li>
<li>High Watermark(HW)：已经成功备份到其他 replicas 中的最新一条数据的 offset，也就是说 Log End Offset 与 High Watermark 之间的数据已经写入到该 partition 的 leader 中，但是还未完全备份到其他的 replicas 中，consumer是无法消费这部分消息(未提交消息)。</li>
</ul>
<p>每个Kafka副本对象都有两个重要的属性：LEO和HW。注意是所有的副本，而不只是leader副本。关于这两者更详细解释，建议参考<a href="https://www.cnblogs.com/huxi2b/p/7453543.html">这篇文章</a>。</p>
<p>对于消费者而言，我们更多时候关注的是消费完成之后如何和服务器进行消费确认，告诉服务器这部分数据我已经消费过了。</p>
<p>这里就涉及到了2个offset，一个是current position,一个是处理完毕向服务器确认的committed offset。显然,异步模式下committed offset是落后于current position的。如果consumer挂掉了,那么下一次消费数据又只会从committed offset的位置拉取数据，就会导致数据被重复消费。</p>
<h4 id="提交策略如何选择"><a href="#提交策略如何选择" class="headerlink" title="提交策略如何选择"></a>提交策略如何选择</h4><p>Kafka提供了3种提交offset的方式</p>
<ol>
<li>自动提交</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动提交,默认true</span></span><br><span class="line">props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="comment">// 设置自动每1s提交一次</span></span><br><span class="line">props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>手动同步提交offset</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.commitSync();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>手动异步提交offset</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.commitAsync();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面说了既然异步提交offset可能会重复消费,那么我使用同步提交是否就可以表明这个问题呢？我只能说too young,too sample。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">  records.forEach(record -&gt; &#123;</span><br><span class="line">      insertIntoDB(record);</span><br><span class="line">      consumer.commitSync();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显不行,因为insertIntoDB和commitSync()做不到原子操作,如果insertIntoDB()成功了，但是提交offset的时候consumer挂掉了，然后服务器重启，仍然会导致重复消费问题。</p>
<h4 id="是否需要做到不重复消费？"><a href="#是否需要做到不重复消费？" class="headerlink" title="是否需要做到不重复消费？"></a>是否需要做到不重复消费？</h4><p>只要保证处理消息和提交offset得操作是原子操作，就可以做到不重复消费。我们可以自己管理committed offset,而不让kafka来进行管理。</p>
<p>比如如下使用方式:</p>
<ol>
<li>如果消费的数据刚好需要存储在数据库，那么可以把offset也存在数据库，就可以就可以在一个事物中提交这两个结果，保证原子操作。</li>
<li>借助搜索引擎，把offset和数据一起放到索引里面，比如Elasticsearch</li>
</ol>
<p>每条记录都有自己的offset,所以如果要管理自己的offset还得要做下面事情</p>
<ol>
<li>设置enable.auto.commit=false</li>
<li>使用每个ConsumerRecord提供的offset来保存消费的位置。</li>
<li>在重新启动时使用seek(TopicPartition, long)恢复上次消费的位置。</li>
</ol>
<p>通过上面的方式就可以在消费端实现”Exactly Once”的语义,即保证只消费一次。但是是否真的需要保证不重复消费呢？这个得看具体业务,重复消费数据对整体有什么影响在来决定是否需要做到不重复消费。</p>
<h4 id="再均衡-reblance-怎么办？"><a href="#再均衡-reblance-怎么办？" class="headerlink" title="再均衡(reblance)怎么办？"></a>再均衡(reblance)怎么办？</h4><p>再均衡是指分区的所属权从一个消费者转移到另一个消费者的行为，再均衡期间，消费组内的消费组无法读取消息。为了更精确的控制消息的消费，我们可以再订阅主题的时候，通过指定监听器的方式来设定发生再均衡动作前后的一些准备或者收尾的动作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(Collections.singletonList(<span class="string">&quot;test3&quot;</span>), <span class="keyword">new</span> ConsumerRebalanceListener() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsAssigned</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//再均衡之前和消费者停止读取消息之后被调用</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsRevoked</span><span class="params">(Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//重新分配分区之后和消费者开始消费之前被调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体如何做得根据具体的业务逻辑来实现,如果消息比较重要，你可以在再均衡的时候处理offset,如果不够重要，你可以什么都不做。</p>
<h4 id="无法消费的数据怎么办"><a href="#无法消费的数据怎么办" class="headerlink" title="无法消费的数据怎么办?"></a>无法消费的数据怎么办?</h4><p>可能由于你的业务逻辑有些数据没法消费这个时候怎么办？同样的还是的看你认为这个数据有多重要或者多不重要，如果重要可以记录日志,把它存入文件或者数据库，以便于稍候进行重试或者定向分析。如果不重要就当做什么事情都没有发生好了。</p>
<h3 id="实际开发中我的处理方式"><a href="#实际开发中我的处理方式" class="headerlink" title="实际开发中我的处理方式"></a>实际开发中我的处理方式</h3><p>我开发的项目中,用到kafka的其中一个地方是消息通知(谁给你发了消息,点赞,评论等),大概的流程就是用户在client端做了某些操作，就会发送数据到kafka,然后把这些数据进行一定的处理之后插入到HBase中。</p>
<p>其中采用了 N consumer thread + N Event Handler的方式来消费数据,并采用自动提交offset。对于无法消费的数据往往只是简单处理下，打印下日志以及消息体(无法消费的情况非常非常少)。</p>
<p>得益于HBase的多version控制,即使是重复消费了数据也无关紧要。这样做没有去避免重复消费的问题主要是基于以下几点考虑</p>
<ol>
<li>重复消费的概率较低，服务器整体性能稳定</li>
<li>即便是重复消费了数据,入库了HBase,获取数据也是只有一条,不影响结果的正确性</li>
<li>有更高的吞吐量</li>
<li>编程简单，不用单独去处理以及保存offset</li>
</ol>
<h3 id="几个重要的消费者参数"><a href="#几个重要的消费者参数" class="headerlink" title="几个重要的消费者参数"></a>几个重要的消费者参数</h3><ul>
<li><p>fetch.min.bytes</p>
<p>配置poll()拉取请求过程种能从Kafka拉取的最小数据量，如果可用数据量小于它指定的大小会等到有足够可用数据时才会返回给消费者，其默认值时1B</p>
</li>
<li><p>fetch.max.wait.ms</p>
<p>和fetch.min.bytes有关,用于指定Kafka的等待时间，默认时间500ms。如果fetch.min.bytes设置为1MB,fetch.max.wait.ms设置为100ms,Kafka收到消费者请求后,要么返回1MB数据,要么在100ms后返回所有可用数据,就看哪个提交得到满足。</p>
</li>
<li><p>max.poll.records</p>
<p>用于控制单次调用poll()能返回的最大记录数量，默认为500条数据</p>
</li>
<li><p>partition.assignment.stragety</p>
<p>分区会被分配给群组的消费者,这个参数用于指定分区分配策略。默认是RangeAssignore,可选的还有RoundRobinAssignor。同样它还支持自定义</p>
</li>
</ul>
<p>其他更多参数请参考官方文档。</p>
]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>从Kafka到NIO</title>
    <url>/2019/04/22/kafka-nio-write/</url>
    <content><![CDATA[<p>在谈NIO之前，简单回顾下内核态和用户态</p>
<p>内核空间是Linux内核运行的空间，而用户空间是用户程序的运行空间，为了保证内核安全，它们之间是隔离的，即使用户的程序崩溃了，内核也不受影响。<br>内核空间可以执行任意命令，调用系统的一切资源，用户空间只能执行简单运算，不能直接调用系统资源(I/O,进程资源,内存分配，外设，计时器，网络通信等)，必须通过系统接口(又称 system call)，才能向内核发出指令。</p>
<p><img data-src="/images/introduction-kafka/linux-structure.png" alt="内核图"></p>
<a id="more"></a>

<p>用户进程通过系统调用访问系统资源的时候，需要切换到内核态，而这对应一些特殊的堆栈和内存环境，必须在系统调用前建立好。而在系统调用结束后，cpu会从内核态切回到用户态，而堆栈又必须恢复成用户进程的上下文。而这种切换就会有大量的耗时。</p>
<h3 id="进程缓冲区"><a href="#进程缓冲区" class="headerlink" title="进程缓冲区"></a>进程缓冲区</h3><p>一般程序在读取文件的时候先申请一块内存数组，称为buffer，然后每次调用read，读取设定字节长度的数据，写入buffer。(用较小的次数填满buffer)。之后的程序都是从buffer中获取数据，当buffer使用完后，在进行下一次调用，填充buffer。这里的buffer我们称为用户缓冲区，它的目的是为了减少频繁I/O操作而引起频繁的系统调用，从而降低操作系统在用户态与核心态切换所耗费的时间。</p>
<h3 id="内核缓冲区"><a href="#内核缓冲区" class="headerlink" title="内核缓冲区"></a>内核缓冲区</h3><p>除了在进程中设计缓冲区，内核也有自己的缓冲区。</p>
<p>当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。</p>
<p>但若是内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，为其它进程提供服务。</p>
<p>等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程，当然不同的io模型，在调度和使用内核缓冲区的方式上有所不同。</p>
<p>你可以认为，read是把数据从内核缓冲区复制到进程缓冲区。write是把进程缓冲区复制到内核缓冲区。</p>
<p>当然，write并不一定导致内核的写动作，比如os可能会把内核缓冲区的数据积累到一定量后，再一次写入。这也就是为什么断电有时会导致数据丢失。</p>
<p>所以，我们进行IO操作的请求过程如下:用户进程发起请求(调用系统函数)，内核接收到请求后(进程会从用户态切换到内核态),从I/O设备中获取数据到内核buffer中，再将内核buffer中的数据copy到用户进程的地址空间，该用户进程获取到数据后再响应客户端。</p>
<h3 id="I-O复用模型"><a href="#I-O复用模型" class="headerlink" title="I/O复用模型"></a>I/O复用模型</h3><p>JavaNIO使用了I/O复用模型</p>
<p><img data-src="/images/introduction-kafka/io_multi.png" alt="I/O复用"></p>
<p>从图中可以看出，我们阻塞在select调用，等待数据报套接字变为可读。当select返回套接字可读这一条件的时候，我们调用recvfrom把所读数据从内核缓冲区复制到应用进程缓冲区。</p>
<blockquote>
<p>那么内核态怎么判断I/O流可读可写？<br>内核针对读缓冲区和写缓冲区来判断是否可读可写</p>
</blockquote>
<p>而java从1.5开始就使用epoll代替了之前的select,它对select有所增强，比较有特点的是epoll支持水平触发(epoll默认)和边缘触发两种方式。</p>
<blockquote>
<p>epoll比select高效主要几种在两点,这个可以参考知乎的这个回答(<a href="https://www.zhihu.com/question/20122137/answer/146866418">https://www.zhihu.com/question/20122137/answer/146866418</a>)</p>
<ol>
<li>减少用户态和内核态之间的文件句柄拷贝</li>
<li>减少对可读可写文件句柄的遍历</li>
</ol>
</blockquote>
<p>epoll和NIO的操作方式对应图如下:</p>
<p><img data-src="/images/introduction-kafka/nio_compare_epoll.png" alt="epoll"></p>
<ol>
<li>epoll_ctl    注册事件</li>
<li>epoll_wait   轮询所有的socket</li>
<li>处理对应的事件</li>
</ol>
<p>epoll中比较有趣的是水平触发(LT)和边缘触发(ET)。</p>
<p>水平触发(条件触发)：读缓冲区只要不为空，就一直会触发读事件；写缓冲区只要不满(发送得速度比写得速度快)，就一直会触发写事件。这个比较符合编程习惯，也是epoll的缺省模式。</p>
<p>边缘触发(状态触发)：读缓冲区的状态，从空转为非空的时候，触发1次；写缓冲区的状态，从满转为非满的时候，触发1次。比如你发送一个大文件，把写缓存区塞满了，之后缓存区可以写了，就会发生一次从满到不满的切换。</p>
<p>通过分析，我们可以看出：<br>对于LT模式，要避免”写的死循环”问题：写缓冲区为满的概率很小，也就是”写的条件”会一直满足，所以如果你注册了写事件，没有数据要写，但它会一直触发，所以在LT模式下，写完数据，一定要取消写事件。</p>
<p>对应ET模式，要避免”short read”问题:比如你收到100个字节，它触发1次，但你只读到了50个字节，剩下的50个字节不读，它也不会再次触发，此时这个socket就废了。因此在ET模式，一定要把”读缓冲区”的数据读完。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>代码太长了，我就只列出一段服务器端的主要代码,client端的比较简单，写法和server端也类似就不列出来了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Selector selector &#x3D; Selector.open();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建通道ServerSocketChannel</span><br><span class="line">ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();</span><br><span class="line">&#x2F;&#x2F; 将通道设置为非阻塞</span><br><span class="line">serverSocketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">ServerSocket serverSocket &#x3D; serverSocketChannel.socket();</span><br><span class="line">serverSocket.bind(new InetSocketAddress(8989));</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 将通道(Channel)注册到通道管理器(Selector)，并为该通道注册selectionKey.OP_ACCEPT事件</span><br><span class="line">* 注册该事件后，当事件到达的时候，selector.select()会返回，</span><br><span class="line">* 如果事件没有到达selector.select()会一直阻塞。</span><br><span class="line">*&#x2F;</span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 循环处理</span><br><span class="line">while (true) &#123;</span><br><span class="line">    &#x2F;&#x2F; 当注册事件到达时，方法返回，否则该方法会一直阻塞</span><br><span class="line">    selector.select();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取监听事件</span><br><span class="line">    Set&lt;SelectionKey&gt; selectionKeys &#x3D; selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; iterator &#x3D; selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 迭代处理</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取事件</span><br><span class="line">        SelectionKey key &#x3D; iterator.next();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 移除事件，避免重复处理</span><br><span class="line">        iterator.remove();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 客户端请求连接事件，接受客户端连接就绪</span><br><span class="line">       if (key.isAcceptable()) &#123;</span><br><span class="line">           ServerSocketChannel server &#x3D; (ServerSocketChannel) key.channel();</span><br><span class="line">           SocketChannel socketChannel &#x3D; server.accept();</span><br><span class="line">           socketChannel.configureBlocking(false);</span><br><span class="line">           &#x2F;&#x2F; 给通道设置写事件，客户端监听到写事件后，进行读取操作</span><br><span class="line">           socketChannel.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">        &#125; else if(key.isWritable()) &#123;</span><br><span class="line">            System.out.println(&quot;write&quot;);</span><br><span class="line">            handleWrite(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当client连接上server的时候就会发现server一直收到写事件,<strong>write会一直打印</strong>。所以使用条件触发的API 时，如果应用程序不需要写就不要关注socket可写的事件，否则就会无限次的立即返回一个write ready通知。大家常用的select就是属于条件触发这一类，长期关注socket写事件会出现CPU 100%的毛病。所以在使用Java的NIO编程的时候，在没有数据可以往外写的时候要取消写事件，在有数据往外写的时候再注册写事件。</p>
<p>取消写事件可以这样写 <code>selectionKey.interestOps(key.interestOps() &amp; ~SelectionKey.OP_WRITE);</code></p>
<h3 id="Kafka中如何处理的"><a href="#Kafka中如何处理的" class="headerlink" title="Kafka中如何处理的"></a>Kafka中如何处理的</h3><p>在上一篇对Kafka网络层的分析中,我们知道了它是通过NIO和服务端进行通信的。其中在KafkaChannel的send()方法里面有这样一段代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">send</span><span class="params">(Send send)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  send.writeTo(transportLayer);</span><br><span class="line">  <span class="keyword">if</span> (send.completed())</span><br><span class="line">    transportLayer.removeInterestOps(SelectionKey.OP_WRITE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> send.completed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>请注意这里的**transportLayer.removeInterestOps(SelectionKey.OP_WRITE)**，它移除了注册的OP_WRITE事件。</p>
<p>既然取消了，肯定会添加。在发送数据之前KafkaChannel的setSend()方法里面又注册了OP_WRITE事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSend</span><span class="params">(Send send)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.send != <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Attempt to begin a send operation with prior send operation still in progress, connection id is &quot;</span> + id);</span><br><span class="line">  <span class="keyword">this</span>.send = send;</span><br><span class="line">  <span class="keyword">this</span>.transportLayer.addInterestOps(SelectionKey.OP_WRITE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以还是那句话: <strong>在没有数据可以往外写的时候要取消写事件，在有数据往外写的时候再注册写事件。</strong></p>
]]></content>
      <tags>
        <tag>Kafka</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka Producer消息收发设计</title>
    <url>/2019/04/26/kafka-producer-keypoint/</url>
    <content><![CDATA[<p>前几篇文章分析了Kafka的发送流程以及NIO的使用方式，但是还是留下了不少坑，这里就对剩下的问题做一个总结。</p>
<h3 id="收到的数据为什么要缓存起来"><a href="#收到的数据为什么要缓存起来" class="headerlink" title="收到的数据为什么要缓存起来?"></a>收到的数据为什么要缓存起来?</h3><p>Kafka中Selector读取从远端回来的数据的时候会先把收到的数据缓存起来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attemptRead</span><span class="params">(SelectionKey key, KafkaChannel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">//if channel is ready and has bytes to read from socket or buffer, and has no</span></span><br><span class="line">  <span class="comment">//previous receive(s) already staged or otherwise in progress then read from it</span></span><br><span class="line">  <span class="keyword">if</span> (channel.ready() &amp;&amp; (key.isReadable() || channel.hasBytesBuffered()) &amp;&amp; !hasStagedReceive(channel)</span><br><span class="line">      &amp;&amp; !explicitlyMutedChannels.contains(channel)) &#123;</span><br><span class="line">      NetworkReceive networkReceive;</span><br><span class="line">      <span class="keyword">while</span> ((networkReceive = channel.read()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          madeReadProgressLastPoll = <span class="keyword">true</span>;</span><br><span class="line">          addToStagedReceives(channel, networkReceive);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在NetworkClient中，往下传的是一个完整的ClientRequest，进到Selector，暂存到channel中的，也是一个完整的Send对象(1个数据包)。但这个Send对象，交由底层的channel.write(Bytebuffer b)的时候，并不一定一次可以完全发送，可能要调用多次write，才能把一个Send对象完全发出去。这是因为write是非阻塞的，不是等到完全发出去，才会返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Send send = channel.write();</span><br><span class="line"><span class="keyword">if</span> (send != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.completedSends.add(send);</span><br><span class="line">    <span class="keyword">this</span>.sensors.recordBytesSent(channel.id(), send.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里如果返回send==null就表示没有发送完毕，需要等到下一次Selector.poll再次进行发送。所以当下次发送的时候如果Channel里面的Send只发送了部分，那么此次这个node就不会处于ready状态，就不会从RecordAccumulator取出要往这个node发的数据,等到Send对象发送完毕之后，这个node才会处于ready状态，就又可以取出数据进行处理了。</p>
<p>同样，在接收的时候，channel.read(Bytebuffer b)，一个response也可能要read多次，才能完全接收。所以就有了上面的while循环代码。</p>
<h3 id="如何确定消息接收完成"><a href="#如何确定消息接收完成" class="headerlink" title="如何确定消息接收完成?"></a>如何确定消息接收完成?</h3><p>从上面知道，底层数据的通信，是在每一个channel上面，2个源源不断的byte流，一个send流，一个receive流。<br>send的时候，还好说，发送之前知道一个完整的消息的大小。<br>但是当我们接收消息response的时候，这个信息可能是不完整的(剩余的数据要晚些才能获得)，也可能包含不止一条消息。那么我们是怎么判断消息发送完毕的呢？<br>对于消息的读取我们必须考虑消息结尾是如何表示的,标识消息结尾通常有以下几种方式：</p>
<ol>
<li>固定的消息大小。</li>
<li>将消息的长度作为消息的前缀。</li>
<li>用一个特殊的符号来标识消息的结束。</li>
</ol>
<p>很明显第一种和第三种方式不是很合适，因此Kafka采用了第二种方式来确定要发送消息的大小。在消息头部放入了4个字节来确定消息的大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收消息，前4个字节表示消息的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkReceive</span> <span class="keyword">implements</span> <span class="title">Receive</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String source;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//确定消息size</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//整个消息response的buffer</span></span><br><span class="line">  <span class="keyword">private</span> ByteBuffer buffer;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NetworkReceive</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.source = source;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//分配4字节的头部</span></span><br><span class="line">      <span class="keyword">this</span>.size = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">      <span class="keyword">this</span>.buffer = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">this</span>.maxSize = UNLIMITED;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息发送,前4个字节表示消息大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkSend</span> <span class="keyword">extends</span> <span class="title">ByteBufferSend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NetworkSend</span><span class="params">(String destination, ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(destination, sizeDelimit(buffer));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer[] sizeDelimit(ByteBuffer buffer) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ByteBuffer[] &#123;sizeBuffer(buffer.remaining()), buffer&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ByteBuffer <span class="title">sizeBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//4个字节表示消息大小</span></span><br><span class="line">    ByteBuffer sizeBuffer = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    sizeBuffer.putInt(size);</span><br><span class="line">    sizeBuffer.rewind();</span><br><span class="line">    <span class="keyword">return</span> sizeBuffer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OP-WRITE何时就绪"><a href="#OP-WRITE何时就绪" class="headerlink" title="OP_WRITE何时就绪?"></a>OP_WRITE何时就绪?</h3><p>上一篇文章虽然讲了epoll的原理，但是我相信还是有人觉得很迷惘，这里换个简单的说法再说下OP_WRITE事件。<br>OP_WRITE事件的就绪条件并不是发生在调用channel的write方法之后，也不是发生在调用channel.register(selector,SelectionKey.OP_WRITE)后,而是在当底层缓冲区有空闲空间的情况下。因为写缓冲区在绝大部分时候都是有空闲空间的，所以如果你注册了写事件，这会使得写事件一直处于写就绪，选择处理现场就会一直占用着CPU资源。所以，只有当你确实有数据要写时再注册写操作，并在写完以后马上取消注册。</p>
<h3 id="max-in-flight-requests-per-connection"><a href="#max-in-flight-requests-per-connection" class="headerlink" title="max.in.flight.requests.per.connection"></a>max.in.flight.requests.per.connection</h3><p>这个参数指定了生产者在收到服务器响应之前可以发送多少个消息，找Kafka Producer中对应有一个类InFlightRequests,表示在天上飞的请求,也就是请求发出去了response还没有回来的请求数,这个参数也是判断节点是否ready的关键因素。只有ready的节点数据才能从Accumulator中取出来进行发送。</p>
]]></content>
      <tags>
        <tag>Kafka</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka Producer网络层源码解析</title>
    <url>/2019/04/09/kafka-producer-network-request/</url>
    <content><![CDATA[<p><a href="https://generalthink.github.io/2019/03/07/kafka-producer-source-code-analysis/">上一篇</a>讲了Kafka Producer发送消息的主体流程，这一篇我们关注下Kafka的网络层是如何实现的。<br>对于发送消息而言，Producer是客户端，Broker是服务器端。<br>Kafka使用了JavaNIO向服务器发送消息，所以在这之前需要了解java nio的基本知识。这次网络层源码分析从metadata request切入。</p>
<h3 id="开局一张图"><a href="#开局一张图" class="headerlink" title="开局一张图"></a>开局一张图</h3><p><img data-src="/images/introduction-kafka/kafka_producer_network.png"></p>
<a id="more"></a>

<p>上面是Kafka producer网络层的主体流程，先看下有一个大体印象。</p>
<p>Kafka的底层使用的是Java NIO,Kafka中针对NIO的Selector的封装类也叫Selector，对Channel的封装类叫做KafkaChannel。后面如果没有特殊说明，Selector都是指Kafka中的Selector。</p>
<h3 id="metadata-request"><a href="#metadata-request" class="headerlink" title="metadata request"></a>metadata request</h3><p>先来回顾下Kafka 发送消息的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">KafkaProducer&lt;String,String&gt; producer = createProducer();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">  producer.send(<span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;codeTest&quot;</span>,<span class="string">&quot;key&quot;</span> + (i+<span class="number">1</span>),<span class="string">&quot;value&quot;</span> + (i+<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中首先会初始化KafkaProducer，在初始化KafkaProducer的时候，同时我们也会初始化Kafka发送消息的客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">KafkaClient client = kafkaClient != <span class="keyword">null</span> ? kafkaClient : <span class="keyword">new</span> NetworkClient(</span><br><span class="line">        <span class="keyword">new</span> Selector(config.getLong(ProducerConfig.CONNECTIONS_MAX_IDLE_MS_CONFIG),</span><br><span class="line">                <span class="keyword">this</span>.metrics, time, <span class="string">&quot;producer&quot;</span>, channelBuilder, logContext),</span><br><span class="line">        ...);</span><br></pre></td></tr></table></figure>
<p>创建NetworkClient(implements KafkaClient)的同时会创建一个Selector，这个是对java.nio.Selector的封装，发送请求，接收响应，处理连接完成以及现有的断开连接都是通过它的poll()方法调用完成的。</p>
<h4 id="等待metadata更新"><a href="#等待metadata更新" class="headerlink" title="等待metadata更新"></a>等待metadata更新</h4><p>我们都知道Kafka读写消息都是通过leader的，只有知道了leader才能发送消息到kafka，在我们的<a href="https://generalthink.github.io/2019/02/27/introduction-of-kafka/">大家好,我是Kafka</a>一文中，我们讲了首先会发起metadata request,从中就可以获取到集群元信息(leader,partiton,ISR列表等),那么是在哪里发起metadata request的呢？</p>
<p>调用KafkaProducer的doSend()(send()–&gt;doSend())方法时，第一步就是通过<strong>waitOnMetadata</strong>等待集群元数据(topic,partition,node等)可用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cluster cluster = metadata.fetch();</span><br><span class="line">Integer partitionsCount = cluster.partitionCountForTopic(topic);</span><br><span class="line"><span class="comment">//如果此时已经有partition的信息了</span></span><br><span class="line"><span class="keyword">if</span> (partitionsCount != <span class="keyword">null</span> &amp;&amp; (partition == <span class="keyword">null</span> || partition &lt; partitionsCount))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ClusterAndWaitTime(cluster, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> version = metadata.requestUpdate();</span><br><span class="line">  <span class="comment">//唤醒Sender()线程,Sender会被poll阻塞(参见java.nio.Channels.Selector.poll())</span></span><br><span class="line">  sender.wakeup();</span><br><span class="line">  <span class="comment">//等待metadata的更新,会一直阻塞直到当前版本大于最近一次版本</span></span><br><span class="line">  metadata.awaitUpdate(version, remainingWaitMs);</span><br><span class="line">  cluster = metadata.fetch();</span><br><span class="line">  elapsed = time.milliseconds() - begin;</span><br><span class="line">  remainingWaitMs = maxWaitMs - elapsed;</span><br><span class="line">  partitionsCount = cluster.partitionCountForTopic(topic);</span><br><span class="line">&#125; <span class="keyword">while</span> (partitionsCount == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>如果metadata中不包含对应topic的metadata信息,那么就请求更新metadata,如果没有更新则一直会在这个while循环中，这个循环主要做了以下几件事</p>
<ol>
<li>调用metadata.requestUpdate();将needUpdate属性设置为true(表示强制更新),返回当前version(用于判断是否更新过了)</li>
<li>唤醒Sender线程，实际上是唤醒NetworkClient中Selector,避免Selector一直在poll中等待</li>
<li>执行metadata.awaitUpdate等待metadata的更新，未更新则一直阻塞。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待元数据更新，直到当前版本大于我们知道的最新版本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">awaitUpdate</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> lastVersion, <span class="keyword">final</span> <span class="keyword">long</span> maxWaitMs)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">long</span> remainingWaitMs = maxWaitMs;</span><br><span class="line">  <span class="keyword">while</span> ((<span class="keyword">this</span>.version &lt;= lastVersion) &amp;&amp; !isClosed()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (remainingWaitMs != <span class="number">0</span>)</span><br><span class="line">          wait(remainingWaitMs);</span><br><span class="line">      <span class="keyword">long</span> elapsed = System.currentTimeMillis() - begin;</span><br><span class="line">      remainingWaitMs = maxWaitMs - elapsed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h4><p>现在我们知道了会等待元数据更新，那么到底是在哪里更新的呢?上面有讲到唤醒了Sender线程,在run()方法中会去调用KafkaClient.poll()方法，这里会对metadata request进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ClientResponse&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//处理metadata</span></span><br><span class="line">  <span class="keyword">long</span> metadataTimeout = metadataUpdater.maybeUpdate(now);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里会调用java.nio.Selector.select()方法</span></span><br><span class="line">  <span class="keyword">this</span>.selector.poll(Utils.min(timeout, metadataTimeout, defaultRequestTimeoutMs));</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里会对metadata response进行处理，就可以获取到kafka metadata的信息</span></span><br><span class="line">  handleCompletedReceives(responses, updatedNow);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> responses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在看看metadata request如何发送的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">maybeUpdate</span><span class="params">(<span class="keyword">long</span> now, Node node)</span> </span>&#123;</span><br><span class="line">  String nodeConnectionId = node.idString();</span><br><span class="line">  <span class="comment">//已经连接，且Channel已经ready,且没有请求被发送到给定节点</span></span><br><span class="line">  <span class="keyword">if</span> (canSendRequest(nodeConnectionId, now)) &#123;</span><br><span class="line">      <span class="comment">//这里会最终调用NetworkClient.doSend()方法,实际上是将Send对象设置到KafkaChannel中，并没有进行网络IO</span></span><br><span class="line">      sendInternalMetadataRequest(metadataRequest, nodeConnectionId, now);</span><br><span class="line">      <span class="keyword">return</span> defaultRequestTimeoutMs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (connectionStates.canConnect(nodeConnectionId, now)) &#123;</span><br><span class="line">      <span class="comment">//初始化连接</span></span><br><span class="line">      initiateConnect(node, now);</span><br><span class="line">      <span class="keyword">return</span> reconnectBackoffMs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Long.MAX_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码先查看是否可以发送请求,如果可以发送请求就直接将数据设置到KafkaChannel中。如果不能发送就查看当前是否可以连接，如果可以则初始化连接，初始化连接的代码在Selector.connect()方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(String id, InetSocketAddress address, <span class="keyword">int</span> sendBufferSize, <span class="keyword">int</span> receiveBufferSize)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    </span><br><span class="line">  SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">  <span class="comment">//设置keepAlive以及socket的一些属性(比如发送数据缓存区大小以及接收数据缓冲区大小)</span></span><br><span class="line">  configureSocketChannel(socketChannel, sendBufferSize, receiveBufferSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实际上调用socketChannel.connect(address);</span></span><br><span class="line">  <span class="keyword">boolean</span> connected = doConnect(socketChannel, address);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将socketChannel注册到nioSelector中,同时将生成KafkaChannel(对java.nio.Channel的封装)</span></span><br><span class="line">  <span class="comment">//并将KafkaChannel绑定到java.nio.SelectionKey中</span></span><br><span class="line">  SelectionKey key = registerChannel(id, socketChannel, SelectionKey.OP_CONNECT);</span><br><span class="line"><span class="comment">// connectct为true代表该连接不会再触发CONNECT事件，所以这里要单独处理</span></span><br><span class="line">  <span class="keyword">if</span> (connected) &#123;</span><br><span class="line">      <span class="comment">// 加入到一个单独的集合中</span></span><br><span class="line">      immediatelyConnectedKeys.add(key);</span><br><span class="line">      <span class="comment">// 取消对该连接的CONNECT事件的监听</span></span><br><span class="line">      key.interestOps(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> SelectionKey <span class="title">registerChannel</span><span class="params">(String id, SocketChannel socketChannel, <span class="keyword">int</span> interestedOps)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  SelectionKey key = socketChannel.register(nioSelector, interestedOps);</span><br><span class="line">  KafkaChannel channel = buildAndAttachKafkaChannel(socketChannel, id, key);</span><br><span class="line">  <span class="keyword">this</span>.channels.put(id, channel);</span><br><span class="line">  <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果熟悉NIO的话，上面的代码看上去就很熟悉，主要就是设置设置channel以及selectionKey的关系。<br>需要注意的是doConnect()方法返回为true的情况,在非阻塞模式下，对于local connection，连接可能马上就建立好了，那该方法会返回true，对于这种情况，不会再触发之后的connect事件。因此kafka用一个单独的集合immediatelyConnectedKeys将这些特殊的连接记录下来。在接下来的步骤会进行特殊处理。<br>这里要留意到KafkaChannel就是在这里被创建的。到这里我们就要来看看KafkaChannel和Selector有哪些属性是需要我们注意的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaChannel</span> </span>&#123;</span><br><span class="line">  <span class="comment">//继承java.nio.channels.Channel，可读可写,对socketChannel的封装</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TransportLayer transportLayer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过它来创建Buffer和回收Buffer</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MemoryPool memoryPool;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//收到的数据</span></span><br><span class="line">  <span class="keyword">private</span> NetworkReceive receive;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//发送的数据</span></span><br><span class="line">  <span class="keyword">private</span> Send send;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selector</span> <span class="keyword">implements</span> <span class="title">Selectable</span>, <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//java nio中的Selector</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> java.nio.channels.Selector nioSelector;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//kafka服务器节点和Channel之间对应关系</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, KafkaChannel&gt; channels;</span><br><span class="line">  <span class="comment">//发送完成的请求</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Send&gt; completedSends;</span><br><span class="line">  <span class="comment">//完整的消息响应</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;NetworkReceive&gt; completedReceives;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//暂存的消息响应</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;KafkaChannel, Deque&lt;NetworkReceive&gt;&gt; stagedReceives;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//立即连接上的SelectionKey</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;SelectionKey&gt; immediatelyConnectedKeys;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//用于分配ByteBuffer</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MemoryPool memoryPool;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="轮询数据"><a href="#轮询数据" class="headerlink" title="轮询数据"></a>轮询数据</h4><p>初始化连接完成之后，这个时候就是开始轮询了，在Selector.poll()方法中关于数据读写的逻辑如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* check ready keys */</span></span><br><span class="line">  <span class="keyword">int</span> numReadyKeys = select(timeout);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (numReadyKeys &gt; <span class="number">0</span> || !immediatelyConnectedKeys.isEmpty() || dataInBuffers) &#123;</span><br><span class="line">      Set&lt;SelectionKey&gt; readyKeys = <span class="keyword">this</span>.nioSelector.selectedKeys();</span><br><span class="line"></span><br><span class="line">      pollSelectionKeys(readyKeys, <span class="keyword">false</span>, endSelect);</span><br><span class="line">      <span class="comment">// 清除所有SelectionKey，避免下一次在进行处理</span></span><br><span class="line">      readyKeys.clear();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//处理发起连接时，马上就建立连接的请求，这种一般只在broker和client在同一台机器上才存在</span></span><br><span class="line">      pollSelectionKeys(immediatelyConnectedKeys, <span class="keyword">true</span>, endSelect);</span><br><span class="line">      immediatelyConnectedKeys.clear();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将暂存起来的网络响应添加到已完成网络响应集合里面</span></span><br><span class="line">  addToCompletedReceives();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pollSelectionKeys</span><span class="params">(Set&lt;SelectionKey&gt; selectionKeys,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">boolean</span> isImmediatelyConnected,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">long</span> currentTimeNanos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (SelectionKey key : determineHandlingOrder(selectionKeys)) &#123;</span><br><span class="line">    KafkaChannel channel = channel(key);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">boolean</span> sendFailed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//READ事件</span></span><br><span class="line">    <span class="keyword">if</span> (channel.ready() &amp;&amp; (key.isReadable() || channel.hasBytesBuffered()) &amp;&amp; !hasStagedReceive(channel)</span><br><span class="line">    &amp;&amp; !explicitlyMutedChannels.contains(channel)) &#123;</span><br><span class="line"></span><br><span class="line">      NetworkReceive networkReceive;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//read方法会从channel中将数据读取到Buffer中(还是通过KafkaChannel中的transportLayer)，</span></span><br><span class="line">      <span class="keyword">while</span> ((networkReceive = channel.read()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!stagedReceives.containsKey(channel))</span><br><span class="line">          stagedReceives.put(channel, <span class="keyword">new</span> ArrayDeque&lt;NetworkReceive&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将读到的请求存起来</span></span><br><span class="line">        Deque&lt;NetworkReceive&gt; deque = stagedReceives.get(channel);</span><br><span class="line">        deque.add(receive);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//写事件</span></span><br><span class="line">  <span class="keyword">if</span> (channel.ready() &amp;&amp; key.isWritable()) &#123;</span><br><span class="line">    <span class="comment">//从buffer中写入数据到Channel(KafkaChannel中的transportLayer)</span></span><br><span class="line">    Send send = channel.write();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码主要做了两件事儿</p>
<ol>
<li>读取网络返回的请求，从Channel读进Buffer，Buffer是有容量限制的，所以可能一次只能读取一个req的部分数据。只有读到一个完整的req的情况下，channel.read()方法才返回非null</li>
<li>发送数据，从Buffer写入Channel,这里发起了真正的网络IO</li>
</ol>
<p>读出数据后，会先放到stagedReceives集合中，然后在addToCompletedReceives()方法中对于每个channel都会从stagedReceives取出一个NetworkReceive（如果有的话），放入到completedReceives中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToCompletedReceives</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.stagedReceives.isEmpty()) &#123;</span><br><span class="line">    Iterator&lt;Map.Entry&lt;KafkaChannel, Deque&lt;NetworkReceive&gt;&gt;&gt; iter = <span class="keyword">this</span>.stagedReceives.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;KafkaChannel, Deque&lt;NetworkReceive&gt;&gt; entry = iter.next();</span><br><span class="line">        KafkaChannel channel = entry.getKey();</span><br><span class="line">        <span class="comment">//被mute的channel会被放到explicitlyMutedChannels中,chanel被mute是在服务端(scala)执行的</span></span><br><span class="line">        <span class="keyword">if</span> (!explicitlyMutedChannels.contains(channel)) &#123;</span><br><span class="line">            Deque&lt;NetworkReceive&gt; deque = entry.getValue();</span><br><span class="line">            addToCompletedReceives(channel, deque);</span><br><span class="line">            <span class="keyword">if</span> (deque.isEmpty())</span><br><span class="line">                iter.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据官方代码注释这样做的原因有2点,还可以参考(<a href="https://github.com/apache/kafka/pull/5920)%E3%80%82">https://github.com/apache/kafka/pull/5920)。</a></p>
<ol>
<li>对于SSL连接，数据内容是加密的，不能精准的确定本次需要读取的数据大小，只能尽可能的多读，这样会导致可能会比请求的数据读的要多。那如果该channel之后没有数据可以读，会导致多读的数据将不会被处理。</li>
<li>kafka需要确保一个channel上request被处理的顺序是其发送的顺序。因此对于每个channel而言，每次poll上层最多只能看见一个请求，当该请求处理完成之后，再处理其他的请求。对Server端和Client端来说处理方式不一样。Selector这个类在Client和Server端都会调用，所以这里存在两种情况<ol>
<li>应用在 Server 端时，Server 为了保证消息的时序性，在 Selector 中提供了两个方法：mute(String id) 和 unmute(String id)，对该 KafkaChannel 做标记来保证同时只能处理这个 Channel 的一个 request（可以理解为排它锁）。当 Server 端接收到 request 后，先将其放入 stagedReceives 集合中，此时该 Channel 还未 mute，这个 Receive 会被放入 completedReceives 集合中。Server 在对 completedReceives 集合中的 request 进行处理时，会先对该 Channel mute，处理后的 response 发送完成后再对该 Channel unmute，然后才能处理该 Channel 其他的请求</li>
<li>应用在 Client 端时，Client 并不会调用 Selector 的 mute() 和 unmute() 方法，client 发送消息的时序性而是通过 InFlightRequests(保存了max.in.flight.requests.per.connection参数的值) 和 RecordAccumulator 的 mutePartition 来保证的，因此对于 Client 端而言，这里接收到的所有 Receive 都会被放入到 completedReceives 的集合中等待后续处理。</li>
</ol>
</li>
</ol>
<h4 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h4><p>现在响应数据已经收到了，在KafkaClient.poll方法中会调用handleCompletedReceives()方法处理已经完成的响应</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCompletedReceives</span><span class="params">(List&lt;ClientResponse&gt; responses, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (NetworkReceive receive : <span class="keyword">this</span>.selector.completedReceives()) &#123;</span><br><span class="line">        String source = receive.source();</span><br><span class="line">        InFlightRequest req = inFlightRequests.completeNext(source);</span><br><span class="line">        Struct responseStruct = parseStructMaybeUpdateThrottleTimeMetrics(receive.payload(), req.header,</span><br><span class="line">            throttleTimeSensor, now);</span><br><span class="line">      </span><br><span class="line">       <span class="comment">//根据返回的数据结构解析对应body</span></span><br><span class="line">        AbstractResponse body = AbstractResponse.parseResponse(req.header.apiKey(), responseStruct);</span><br><span class="line">        maybeThrottle(body, req.header.apiVersion(), req.destination, now);</span><br><span class="line">        <span class="comment">//处理MetadataResponse数据,从中解析topic,partition,broker的对应关系</span></span><br><span class="line">        <span class="keyword">if</span> (req.isInternalRequest &amp;&amp; body <span class="keyword">instanceof</span> MetadataResponse)</span><br><span class="line">            metadataUpdater.handleCompletedMetadataResponse(req.header, now, (MetadataResponse) body);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (req.isInternalRequest &amp;&amp; body <span class="keyword">instanceof</span> ApiVersionsResponse)</span><br><span class="line">            handleApiVersionsResponse(responses, req, now, (ApiVersionsResponse) body);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            responses.add(req.completed(body, now));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此,发送metadata request的流程已经分析完毕，发送消息的流程和metadata request的流程大体是一致的,这里就不做过多分析了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结下发送流程</p>
<ol>
<li>sender 线程第一次调用 poll() 方法时，初始化与 node 的连接；</li>
<li>sender 线程第二次调用 poll() 方法时，发送 Metadata 请求；</li>
<li>sender 线程第三次调用 poll() 方法时，获取 metadataResponse，并更新 metadata。</li>
</ol>
<p>经过上述 sender 线程三次调用 poll()方法，所请求的 metadata 信息才会得到更新，此时 Producer 线程也不会再阻塞，开始发送消息。</p>
<p>分析Kafka网络层的构成的时候,一定要搞清楚NIO的处理流程，进一步理解Kafka中的Selector和KafkaChannel。</p>
<p>本次源代码分析基于kafka-client-2.0.0版本。</p>
]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么零拷贝可以提升Kafka性能?</title>
    <url>/2019/07/19/kafka-zerocopy/</url>
    <content><![CDATA[<h3 id="从操作系统说起"><a href="#从操作系统说起" class="headerlink" title="从操作系统说起"></a>从操作系统说起</h3><p>计算机系统是由“硬件”和“软件”两大部分组成，计算机硬件包括一个或多个处理器(CPU)、内存、键盘、显示器、磁盘、I/O接口以及其他一些外围设备比如打印机，绘图仪等等。<br>总之，计算机硬件部分是一个由多种电子和机械设备组成的硬件系统。</p>
<p>为了让人方便正确使用这些设备，就需要编写若干程序来管理这些设备，正是这些程序组成了计算机的软件系统。软件也可以分为两大类：系统软件和应用软件。人们首先直接在硬件上加载一层程序，用它来管理整个计算机硬件设备以及一些软件信息资源，同时还为用户提供开发应用程序的环境，这就是操作系统软件和实用软件。应用软件是在操作系统支持下，为实现用户要求而编制的各种应用程序。</p>
<p><img data-src="/images/introduction-kafka/computer-layer.png" alt="操作系统层次结构图"></p>
<a id="more"></a>

<p>CPU、内存和I/O接口组成的主设备通常称为主机，把没有加载操作系统的主机叫做裸机。裸机与操作系统软件的接口是由CPU的指令系统和厂商提供的系统BIOS组成。</p>
<p>由于操作系统向用户隐藏了系统使用的硬件设备，因此操作系统要为它上面的应用系统软件提供一组命令或系统调用接口供用户程序使用。比如我们需要使用磁盘，可以通过系统命名或系统调用来间接完成，而不需要亲自手动编写一个磁盘设备驱动程序。因此对于用户来说，当计算机加载操作系统后，用户不直接与计算机硬件打交道，而是利用操作系统提供的命令和功能区使用计算机。</p>
<p>由于操作系统处于硬件和软件的中央位置，因此很早就有人把操作系统成为计算机系统软件的核心，简称<strong>核心</strong>或<strong>内核</strong>。</p>
<h3 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h3><p>从系统安全和保护的角度出发，在进行计算机体系结构设计时，处理机的执行模式一般设定为两种：分别称为内核模式(内核态)和用户模式(用户态)。当处理机处于内核模式执行时，意味着系统除了可以执行一般指令外，还可以执行特权指令，即可以执行访问各种控制寄存器的指令、I/O指令以及程序状态字。</p>
<p>当处理机处于用户模式执行时，只能执行一般指令，而不允许执行特权指令。这样做可以保护核心代码不受用户程序有意和无意的攻击。<br>显然，处理机在运行期间需要在内核模式和用户模式之前进行切换。</p>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>Kafka使用零拷贝(Zero-Copy)技术来提供它的性能，所谓的零拷贝是指将数据直接从磁盘文件复制到网卡设备中，而不需要经由应用程序之手，减少了内核和用户模式之间的上下文切换，零拷贝技术通过DMA技术实现。</p>
<blockquote>
<p>直接存储器存取方式(Direct Memory Access, DMA)<br>DMA控制方式是以存储器为中心，在主存和I/O设备之间建立一条直接通路，在DMA控制器的控制下进行设备和主存之间的数据交换。这种方式只在传输开始和传输结束时才需要CPU的干预。它非常适用于高速设备与主存之间的成批数据传输。</p>
</blockquote>
<p>我们看下下面这样的这样一个场景：</p>
<p>客户端在游览器中发起请求获取内容，到看到具体内容经历了什么?</p>
<p><img data-src="/images/introduction-kafka/os-message-flow.png" alt="消息发送"></p>
<p>首先，该请求经过解析后，通过系统调用由用户态转为核心态执行，在核心态由操作系统中的TCP/IP协议代码和网卡驱动程序控制网卡把请求发送到相应的网络上，<br>等待Web服务器相应。当服务器返回时，由网卡接受，并通过内核传送给客户程序。</p>
<p>在服务器端，内核通过网卡从网络上接受Web请求，并通过系统调用传递给Web服务器。Web服务器根据此服务请求执行相应的服务进程，并由内核把结果发送到网络上传送给用户。</p>
<p>从上图中可以看到如果服务器从准备数据到发送数据经历了下面4个过程。</p>
<ol>
<li>调用read()时，将文件中的内容复制到内核模式下的Read Buffer中</li>
<li>CPU控制将内核模式数据复制到用户模式下</li>
<li>调用send()时，用用户模式下的内容复制到内核模式下的Socket Buffer中。</li>
<li>将内核模式下的Socket Buffer的数据复制到网卡设备中发送。</li>
</ol>
<p>从上面过程可以看出，数据是先从内核模式–&gt;用户模式–&gt;内核模式，浪费了2次复制过程：第一次是从内核模式复制到用户模式；第二次是从用户模式再复制回内核模式，而且在上面的过程中，内核和用户模式的上下文切换也是4次。</p>
<p>如果采用了零拷贝技术，那么应用程序就可以直接请求内核把磁盘中的数据传输给Socket.</p>
<p>零拷贝技术通过DMA技术将文件内容复制到内核模式下的Read Buffer中。不过没有数据被复制到Socket Buffer，只有包含数据的位置和长度的信息的文件描述符被加到Socket Buffer中。DMA引擎直接将数据从内核模式中传递到网卡设备。这里上下文切换变成了2次,也只经历了2次复制过程就从磁盘中传送出去了。</p>
]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>从字节码角度来看try-catch-finally是如何执行的</title>
    <url>/2020/09/01/konw-try-catch-finally-with-bytecode/</url>
    <content><![CDATA[<p>三年前，我做了一道关于try-catch-finnaly的面试题，但我做错了，当时面试官问我为啥错了，我告诉它，我平常不会写这么傻逼的代码，然后面试官就没有问我了。。。。</p>
<p>最近看到其他面试的童鞋，又让我想起了这道题，刚好也试着分析下。</p>
<p>我们知道Java虚拟机栈是线程私有的，它的生命周期与线程相同。虚拟机栈是Java虚拟机运行时数据区一部分，它描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<strong>每一个方法从调用直至执行完成的过程就对应着一个帧栈在虚拟机中入栈到出栈的过程。</strong></p>
<a id="more"></a>

<p>加载和存储指令用于将数据在帧栈中的局部变量和操作数栈之前来回传输，这类指令包括如下内容：</p>
<ol>
<li><p>将一个局部变量加载到操作栈：iload， iload_&lt;n&gt;、aload、aload_&lt;n&gt;等</p>
</li>
<li><p>将一个数值从操作数栈存储到局部变量表： istore、 istore_&lt;n&gt;、astore、astore_&lt;n&gt;等</p>
</li>
<li><p>将一个常量加载到操作数栈： ldc、iconst_&lt;i&gt;等</p>
</li>
</ol>
<p>比如我们下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      System.out.println(getNumber());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      x=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      x=<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">      x=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码输出结果是1，我们首先来看看它的字节码是怎样的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public static int getNumber();</span><br><span class="line">  Code:</span><br><span class="line">   0: iconst_1</span><br><span class="line">   1: istore_0</span><br><span class="line">   2: iload_0</span><br><span class="line">   3: istore_1</span><br><span class="line">   4: iconst_3</span><br><span class="line">   5: istore_0</span><br><span class="line">   6: iload_1</span><br><span class="line">   7: ireturn</span><br><span class="line">   8: astore_1</span><br><span class="line">   9: iconst_2</span><br><span class="line">  10: istore_0</span><br><span class="line">  11: iload_0</span><br><span class="line">  12: istore_2</span><br><span class="line">  13: iconst_3</span><br><span class="line">  14: istore_0</span><br><span class="line">  15: iload_2</span><br><span class="line">  16: ireturn</span><br><span class="line">  17: astore_3</span><br><span class="line">  18: iconst_3</span><br><span class="line">  19: istore_0</span><br><span class="line">  20: aload_3</span><br><span class="line">  21: athrow</span><br><span class="line">Exception table:</span><br><span class="line">   from    to  target type</span><br><span class="line">       0     4     8   Class java&#x2F;lang&#x2F;Exception</span><br><span class="line">       0     4    17   any</span><br><span class="line">       8    13    17   any</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我来根据字节码来分析下是代码是如何运行的:</p>
<p>操作数栈: 先进后出的一个数据结构<br>局部变量表: 可以认为是一个数组，下标从0开始</p>
<p>以下是执行每一条指令的时候操作数栈和局部变量表的变化情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iconst_1(将int类型数字1放入操作数栈顶):</span><br><span class="line">操作数栈: 1</span><br><span class="line">局部变量表：</span><br><span class="line"></span><br><span class="line">istore_0(将操作数栈顶int型数字出栈存入变量表第1个本地变量):</span><br><span class="line">操作数栈: </span><br><span class="line">局部变量表：1</span><br><span class="line"></span><br><span class="line">iload_0(将变量表第1个int型本地变量推送至栈顶):</span><br><span class="line">操作数栈: 1</span><br><span class="line">局部变量表:</span><br><span class="line"></span><br><span class="line">istore_1(将操作数栈顶int型数字出栈存入变量表第2个本地变量):</span><br><span class="line">操作数栈:</span><br><span class="line">局部变量表: null 1</span><br><span class="line"></span><br><span class="line">iconst_3(将int类型数字3放入操作数栈顶):</span><br><span class="line">操作数栈: 3</span><br><span class="line">局部变量表: null 1</span><br><span class="line"></span><br><span class="line">istore_0(将操作数栈顶int型数字出栈存入变量表第1个本地变量):</span><br><span class="line">操作数栈: </span><br><span class="line">局部变量表: 3 1</span><br><span class="line"></span><br><span class="line">iload1(将变量表第2个int型本地变量推送至栈顶):</span><br><span class="line">操作数栈: 1</span><br><span class="line">局部变量表: 3</span><br><span class="line"></span><br><span class="line">ireturn(从栈顶返回int型数字，方法结束):</span><br><span class="line">返回1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到ireturn后面的代码就不会被执行了，我们也就不进行翻译了。<strong>实际上try-catch-finally字节码块中是没有finally的，</strong>根据字节码我们可以将代码简化成这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">int</span> returnValue;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    x=<span class="number">1</span>;</span><br><span class="line">    returnValue = x;</span><br><span class="line">    x = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    x=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那如果将代码变成这样呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    x=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span>&#123;</span><br><span class="line">    x=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我相信你能知道输出的结果是3，我们同样来看下字节码是怎样的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int getNumber();</span><br><span class="line">  Code:</span><br><span class="line">     0: iconst_1</span><br><span class="line">     1: istore_0</span><br><span class="line">     2: iload_0</span><br><span class="line">     3: istore_1</span><br><span class="line">     4: iconst_3</span><br><span class="line">     5: istore_0</span><br><span class="line">     6: iload_0</span><br><span class="line">     7: ireturn</span><br><span class="line">     8: astore_1</span><br><span class="line">     9: iconst_2</span><br><span class="line">    10: istore_0</span><br><span class="line">    11: iload_0</span><br><span class="line">    12: istore_2</span><br><span class="line">    13: iconst_3</span><br><span class="line">    14: istore_0</span><br><span class="line">    15: iload_0</span><br><span class="line">    16: ireturn</span><br><span class="line">    17: astore_3</span><br><span class="line">    18: iconst_3</span><br><span class="line">    19: istore_0</span><br><span class="line">    20: iload_0</span><br><span class="line">    21: ireturn</span><br><span class="line">  Exception table:</span><br><span class="line">     from    to  target type</span><br><span class="line">         0     4     8   Class java&#x2F;lang&#x2F;Exception</span><br><span class="line">         0     4    17   any</span><br><span class="line">         8    13    17   any</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样的我们只分析执行到的部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iconst_1(将int类型数字1放入操作数栈顶):</span><br><span class="line">操作数栈: 1</span><br><span class="line">局部变量表：</span><br><span class="line"></span><br><span class="line">istore_0(将操作数栈顶int型数字出栈存入变量表第1个本地变量):</span><br><span class="line">操作数栈: </span><br><span class="line">局部变量表：1</span><br><span class="line"></span><br><span class="line">iload_0(将变量表第1个int型本地变量推送至栈顶):</span><br><span class="line">操作数栈: 1</span><br><span class="line">局部变量表：</span><br><span class="line"></span><br><span class="line">istore_1(将操作数栈顶int型数字出栈存入变量表第2个本地变量):</span><br><span class="line">操作数栈: </span><br><span class="line">局部变量表： null 1</span><br><span class="line"></span><br><span class="line">iconst_3(将int类型数字3放入操作数栈顶):</span><br><span class="line">操作数栈: 3</span><br><span class="line">局部变量表：null 1</span><br><span class="line"></span><br><span class="line">istore_0(将操作数栈顶int型数字出栈存入变量表第1个本地变量):</span><br><span class="line">操作数栈: </span><br><span class="line">局部变量表：3 1</span><br><span class="line"></span><br><span class="line"># 注意这里和上面字节码的不同之处在于上面是加载变量表中的第二个int类型本地变量</span><br><span class="line">iload_0(将变量表第1个int型本地变量推送至栈顶):</span><br><span class="line">操作数栈: 3</span><br><span class="line">局部变量表：1</span><br><span class="line"></span><br><span class="line">ireturn(从栈顶返回int型数字，方法结束):</span><br><span class="line">返回3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面都只是分析了try-finally，我们接着分析下try-catch-finally是如何的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    x = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    x = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前的代码很明显不会抛出异常，所以就用不到异常表中的内容，但是这里肯定是产生异常(1/0)，而在java中对异常的处理在字节码层面是使用Exception Table来完成的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static int getNumber();</span><br><span class="line">Code:</span><br><span class="line"> 0: iconst_1</span><br><span class="line"> 1: iconst_0</span><br><span class="line"> 2: idiv</span><br><span class="line"> 3: istore_0</span><br><span class="line"> 4: iload_0</span><br><span class="line"> 5: istore_1</span><br><span class="line"> 6: iconst_3</span><br><span class="line"> 7: istore_0</span><br><span class="line"> 8: iload_0</span><br><span class="line"> 9: ireturn</span><br><span class="line">10: astore_1</span><br><span class="line">11: iconst_2</span><br><span class="line">12: istore_0</span><br><span class="line">13: iload_0</span><br><span class="line">14: istore_2</span><br><span class="line">15: iconst_3</span><br><span class="line">16: istore_0</span><br><span class="line">17: iload_0</span><br><span class="line">18: ireturn</span><br><span class="line">19: astore_3</span><br><span class="line">20: iconst_3</span><br><span class="line">21: istore_0</span><br><span class="line">22: iload_0</span><br><span class="line">23: ireturn</span><br><span class="line">Exception table:</span><br><span class="line"> from    to  target type</span><br><span class="line">     0     6    10   Class java&#x2F;lang&#x2F;Exception</span><br><span class="line">     0     6    19   any</span><br><span class="line">    10    15    19   any</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个异常表(Exception table)含义是如果当字节码在第from行到第to行之间（不包含to行）出现了类型为type或者其子类的异常则转到第target行继续处理。当type的值为any时，代表任意异常情况都需要转向到target处进行处理。</p>
<p>异常表也相当于指明了代码有可能的分支执行情况。老规矩，我们一行一行来分析字节码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iconst_1(将int类型数字1放入操作数栈顶):</span><br><span class="line">操作数栈: 1</span><br><span class="line">局部变量表：</span><br><span class="line"></span><br><span class="line">iconst_0(将int类型数字0放入操作数栈顶):</span><br><span class="line">操作数栈: 0 1</span><br><span class="line">局部变量表：</span><br><span class="line"></span><br><span class="line">idiv(将操作数栈顶两int型数值相除，并将结果压入栈顶):</span><br><span class="line">操作数栈:</span><br><span class="line">局部变量表:</span><br><span class="line"></span><br><span class="line">经过上面的操作(1&#x2F;0)抛出异常，此时根据异常表，执行第10行的字节码</span><br><span class="line"></span><br><span class="line">astore_1(将栈顶引用型数字存入变量表第2个本地变量，因为栈顶为空，所以都为空):</span><br><span class="line">操作数栈:</span><br><span class="line">局部变量表:</span><br><span class="line"></span><br><span class="line">iconst_2(将int类型数字2放入操作数栈顶)</span><br><span class="line">操作数栈: 2</span><br><span class="line">局部变量表：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">istore_0(将操作数栈顶int型数字出栈存入变量表第1个本地变量):</span><br><span class="line">操作数栈: </span><br><span class="line">局部变量表：2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iload_0(将变量表第1个int型本地变量推送至栈顶):</span><br><span class="line">操作数栈: 2</span><br><span class="line">局部变量表：</span><br><span class="line"></span><br><span class="line">istore_2(将操作数栈顶int型数字出栈存入变量表第1个本地变量):</span><br><span class="line">操作数栈: </span><br><span class="line">局部变量表：2</span><br><span class="line"></span><br><span class="line">iconst_3(将int类型数字3放入操作数栈顶):</span><br><span class="line">操作数栈: 3</span><br><span class="line">局部变量表：2</span><br><span class="line"></span><br><span class="line">istore_0(将操作数栈顶int型数字出栈存入变量表第1个本地变量):</span><br><span class="line">操作数栈: </span><br><span class="line">局部变量表：3</span><br><span class="line"></span><br><span class="line">iload_0(将变量表第1个int型本地变量推送至栈顶):</span><br><span class="line">操作数栈: 3</span><br><span class="line">局部变量表：</span><br><span class="line"></span><br><span class="line">ireturn(从栈顶返回int型数字，方法结束):</span><br><span class="line">返回3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经过上面的分析我们可以知道，try-catch-finally就是很普通的指令跳转而已，我们最需要记住的是当return的时候，实际上并不会马上return，而是会将这个结果存入这个临时变量，然后再返回这个临时变量。由于本文所举例的代码中使用的是基本类型，所以对值的修改看上去没有起作用，但是如果“i”是对可变类对象的引用，并且对象的内容在finally块中进行了更改，则这些更改也将反映在返回的值中。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>道友,JAXB了解下</title>
    <url>/2020/03/18/learn-java-jaxb/</url>
    <content><![CDATA[<h3 id="什么是JAXB"><a href="#什么是JAXB" class="headerlink" title="什么是JAXB"></a>什么是JAXB</h3><p>JAXB(Java Architecture for XML Binding简称JAXB)允许Java开发人员将Java类映射为XML表示方式。JAXB提供两种主要特性：将一个Java对象序列化为XML，以及反向操作，将XML解析成Java对象。换句话说，JAXB允许以XML格式存储和读取数据，而不需要程序的类结构实现特定的读取XML和保存XML的代码。</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><table>
<thead>
<tr>
<th>注解</th>
<th>作用域</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@XmlRootElement</td>
<td>Class,Enum</td>
<td>定义XML根元素</td>
</tr>
<tr>
<td>@XmlAccessorType</td>
<td>Package,Class</td>
<td>定义JAXB引擎用于绑定的Java类的字段和属性。它具有四个值：PUBLIC_MEMBER，FIELD，PROPERTY和NONE。</td>
</tr>
<tr>
<td>@XmlAccessorOrde</td>
<td>Package,Class</td>
<td>定义子项顺序</td>
</tr>
<tr>
<td>@XmlType</td>
<td>Class,Enum</td>
<td>类型映射(java到xml)。它定义了其子类型的名称和顺序。</td>
</tr>
<tr>
<td>@XmlElement</td>
<td>Field</td>
<td>将字段或属性映射到XML元素</td>
</tr>
<tr>
<td>@XmlAttribute</td>
<td>Field</td>
<td>将字段或属性映射到XML属性</td>
</tr>
<tr>
<td>@XmlTransient</td>
<td>Field</td>
<td>防止将字段或属性映射到XML</td>
</tr>
<tr>
<td>@XmlValue</td>
<td>Field</td>
<td>将字段或属性映射到XML标签上的文本值</td>
</tr>
<tr>
<td>@XmlList</td>
<td>Field,Parameter</td>
<td>将集合映射到以空格分隔的值列表。</td>
</tr>
<tr>
<td>@XmlElementWrapper</td>
<td>Field</td>
<td>将Java集合映射到XML包装的集合</td>
</tr>
<tr>
<td>@XmlJavaTypeAdapter</td>
<td>PACKAGE,FIELD,METHOD,TYPE,PARAMETER</td>
<td>复杂对象转换器</td>
</tr>
</tbody></table>
<a id="more"></a>

<h4 id="XmlRootElement"><a href="#XmlRootElement" class="headerlink" title="@XmlRootElement"></a>@XmlRootElement</h4><p>将类或枚举类型映射到XML根元素。当使用@XmlRootElement时，其值在XML文档中表示为XML根元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlRootElement(name = &quot;employee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的xml如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">employee</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="XmlAccessorType"><a href="#XmlAccessorType" class="headerlink" title="@XmlAccessorType"></a>@XmlAccessorType</h4><p>使用Java类中的哪些字段或属性来生成xml。它有四个选项</p>
<ol>
<li>FIELD : 除使用了@XmlTransient注解的字段外，类中的每个非静态，非transient字段都会被映射。</li>
<li>NONE : 除非使用某些JAXB注释专门对其进行注释，否则所有字段或属性均不会被映射。</li>
<li>PROPERTY : Java类中除了使用@XmlTransient的属性，其他每个getter/setter对都将被映射,即如果没有getter/setter方法则不会被映射</li>
<li>PUBLIC_MEMBER : 除使用了@XmlTransient注解的字段外,其他每个公共的getter/setter对以及每一个public字段都会被映射</li>
</ol>
<p>默认值是PUBLIC_MEMBER, PROPERTY和PUBLIC_MEMBER一样，都需要具有public的getter/setter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlRootElement(name = &quot;employee&quot;)</span></span><br><span class="line"><span class="meta">@XmlAccessorType(XmlAccessType.PROPERTY)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String firstName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(Integer id, String firstName, String lastName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">      <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">      <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getTId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> firstName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成的xml如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">employee</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">firstName</span>&gt;</span>zhang<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">TId</span>&gt;</span>1<span class="tag">&lt;/<span class="name">TId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">employee</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意这里的TId实际上是和getter/setter方法关联的,我们一般使用的时候使用最多的是FIELD</p>
<h4 id="XmlAccessorOrder"><a href="#XmlAccessorOrder" class="headerlink" title="@XmlAccessorOrder"></a>@XmlAccessorOrder</h4><p>控制类中字段和属性的顺序。有ALPHABETICAL(字母顺)和UNDEFINED(类中字段顺序)两个选择</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@XmlRootElement(name = &quot;employee&quot;)</span></span><br><span class="line"><span class="meta">@XmlAccessorType(XmlAccessType.FIELD)</span></span><br><span class="line"><span class="meta">@XmlAccessorOrder(XmlAccessOrder.ALPHABETICAL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String firstName;</span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br><span class="line">  <span class="keyword">private</span> Department department;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@XmlRootElement(name = &quot;department&quot;)</span></span><br><span class="line"><span class="meta">@XmlAccessorType(XmlAccessType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成的xml如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">employee</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">department</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>100<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>软件开发<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">department</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">firstName</span>&gt;</span>zhang<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">lastName</span>&gt;</span>san<span class="tag">&lt;/<span class="name">lastName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">employee</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="XmlType"><a href="#XmlType" class="headerlink" title="@XmlType"></a>@XmlType</h4><p>将java类或者枚举映射成schema类型,可以指明类型name, namespace 以及子元素顺序。不过一般只使用propOrder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@XmlRootElement(name = &quot;employee&quot;)</span></span><br><span class="line"><span class="meta">@XmlAccessorType(XmlAccessType.FIELD)</span></span><br><span class="line"><span class="meta">@XmlType(propOrder=&#123;&quot;department&quot;, &quot;firstName&quot;, &quot;id&quot; , &quot;lastName&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String firstName;</span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br><span class="line">  <span class="keyword">private</span> Department department;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果和上面@XmlAccessorOrder的例子一样。在使用@XmlType的propOrder 属性时，必须列出JavaBean对象中的所有属性，否则会报错</p>
<h4 id="XmlElement"><a href="#XmlElement" class="headerlink" title="@XmlElement"></a>@XmlElement</h4><p>将java bean属性映射到对应的xml元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@XmlRootElement(name = &quot;employee&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@XmlElement(name=&quot;employeeId&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="meta">@XmlElement</span></span><br><span class="line">  <span class="keyword">private</span> String firstName;</span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br><span class="line">  <span class="keyword">private</span> Department department;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出xml如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">employee</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">employeeId</span>&gt;</span>1<span class="tag">&lt;/<span class="name">employeeId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">firstName</span>&gt;</span>zhang<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">employee</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还可以指定对应的java类型</p>
<h4 id="XmlAttribute"><a href="#XmlAttribute" class="headerlink" title="@XmlAttribute"></a>@XmlAttribute</h4><p>将JavaBean属性映射到XML属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@XmlRootElement(name = &quot;employee&quot;)</span></span><br><span class="line"><span class="meta">@XmlAccessorType(XmlAccessType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@XmlAttribute</span></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String firstName;</span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br><span class="line">  <span class="keyword">private</span> Department department;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">employee</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">firstName</span>&gt;</span>zhang<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">lastName</span>&gt;</span>san<span class="tag">&lt;/<span class="name">lastName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">department</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>100<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>软件开发<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">department</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">employee</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="XmlTransient"><a href="#XmlTransient" class="headerlink" title="@XmlTransient"></a>@XmlTransient</h4><p>防止将JavaBean属性/类型映射到XML。当放置在一个类上时，它指示类不应映射到XML。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlRootElement(name = &quot;employee&quot;)</span></span><br><span class="line"><span class="meta">@XmlAccessorType(XmlAccessType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@XmlTransient</span></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String firstName;</span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br><span class="line">  <span class="keyword">private</span> Department department;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>xml如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">employee</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">firstName</span>&gt;</span>zhang<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">lastName</span>&gt;</span>san<span class="tag">&lt;/<span class="name">lastName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">department</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>100<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>软件开发<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">department</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">employee</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="XmlValue"><a href="#XmlValue" class="headerlink" title="@XmlValue"></a>@XmlValue</h4><p>用于一个类到XML Schema的映射</p>
<h4 id="XmlList"><a href="#XmlList" class="headerlink" title="@XmlList"></a>@XmlList</h4><p>用于将属性映射到列表类型，单个元素多个值以空格拼接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@XmlRootElement(name &#x3D; &quot;employee&quot;)</span><br><span class="line">@XmlAccessorType(XmlAccessType.FIELD)</span><br><span class="line">public class Employee implements Serializable &#123;</span><br><span class="line">  List&lt;String&gt; hobbies;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; standalone&#x3D;&quot;yes&quot;?&gt;</span><br><span class="line">&lt;employee&gt;</span><br><span class="line">  &lt;hobbies&gt;Swimming&lt;&#x2F;hobbies&gt;</span><br><span class="line">  &lt;hobbies&gt;basketball&lt;&#x2F;hobbies&gt;</span><br><span class="line">&lt;&#x2F;employee&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用了@XmlList注解之后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@XmlRootElement(name &#x3D; &quot;employee&quot;)</span><br><span class="line">@XmlAccessorType(XmlAccessType.FIELD)</span><br><span class="line">public class Employee implements Serializable &#123;</span><br><span class="line">  @XmlList</span><br><span class="line">  List&lt;String&gt; hobbies;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; standalone&#x3D;&quot;yes&quot;?&gt;</span><br><span class="line">&lt;employee&gt;</span><br><span class="line">    &lt;hobbies&gt;Swimming basketball&lt;&#x2F;hobbies&gt;</span><br><span class="line">&lt;&#x2F;employee&gt;</span><br></pre></td></tr></table></figure>

<h4 id="XmlElementWrapper"><a href="#XmlElementWrapper" class="headerlink" title="@XmlElementWrapper"></a>@XmlElementWrapper</h4><p>根据集合来产生包装元素。它必须与collection属性一起使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlRootElement(name = &quot;employee&quot;)</span></span><br><span class="line"><span class="meta">@XmlAccessorType(XmlAccessType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@XmlElementWrapper</span></span><br><span class="line">  <span class="meta">@XmlElement(name=&quot;hobby&quot;)</span></span><br><span class="line">  List&lt;String&gt; hobbies;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成的xml如下:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> standalone=<span class="string">&quot;yes&quot;</span>?&gt;</span><br><span class="line">&lt;employee&gt;</span><br><span class="line">  &lt;hobbies&gt;</span><br><span class="line">    &lt;hobby&gt;Swimming&lt;/hobby&gt;</span><br><span class="line">    &lt;hobby&gt;basketball&lt;/hobby&gt;</span><br><span class="line">  &lt;/hobbies&gt;</span><br><span class="line">&lt;/employee&gt;</span><br></pre></td></tr></table></figure>

<p>当然了，它还可以有更具有组合性质的做法，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlRootElement(name = &quot;employee&quot;)</span></span><br><span class="line"><span class="meta">@XmlAccessorType(XmlAccessType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@XmlElementWrapper</span></span><br><span class="line">  <span class="meta">@XmlElements(&#123;</span></span><br><span class="line"><span class="meta">     @XmlElement(name=&quot;work&quot;, type=Work.class),</span></span><br><span class="line"><span class="meta">     @XmlElement(name=&quot;family&quot;, type = Family.class)</span></span><br><span class="line"><span class="meta">  &#125;)</span></span><br><span class="line">  List&lt;Contact&gt; contact;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@XmlRootElement</span></span><br><span class="line"><span class="meta">@XmlAccessorType(XmlAccessType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Contact</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@XmlRootElement</span></span><br><span class="line"><span class="meta">@XmlAccessorType(XmlAccessType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Family</span> <span class="keyword">extends</span> <span class="title">Contact</span></span>&#123;</span><br><span class="line">  String phone;</span><br><span class="line">  String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@XmlRootElement</span></span><br><span class="line"><span class="meta">@XmlAccessorType(XmlAccessType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">extends</span> <span class="title">Contact</span></span>&#123;</span><br><span class="line">  String phone;</span><br><span class="line">  String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后输出的xml格式如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">employee</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">contact</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">work</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phone</span>&gt;</span>028-123445<span class="tag">&lt;/<span class="name">phone</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>xxwork<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">work</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phone</span>&gt;</span>18312345678<span class="tag">&lt;/<span class="name">phone</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>xx family<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">contact</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">employee</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="XmlJavaTypeAdapter"><a href="#XmlJavaTypeAdapter" class="headerlink" title="@XmlJavaTypeAdapter"></a>@XmlJavaTypeAdapter</h4><p>Xml和Java属性的转换器,用于复杂对象的转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XmlRootElement(name = &quot;employee&quot;)</span></span><br><span class="line"><span class="meta">@XmlAccessorType(XmlAccessType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@XmlJavaTypeAdapter(Country2String.class)</span></span><br><span class="line">    Country country;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country2String</span> <span class="keyword">extends</span> <span class="title">XmlAdapter</span>&lt;<span class="title">String</span>, <span class="title">Country</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Country <span class="title">unmarshal</span><span class="params">(String code)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Country.findCountry(code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">marshal</span><span class="params">(Country country)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> country.getCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Country&gt; INSTANCES = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      INSTANCES.add(<span class="keyword">new</span> Country(<span class="string">&quot;zh&quot;</span>, <span class="string">&quot;china&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Country <span class="title">findCountry</span><span class="params">(String codeParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCES.stream()</span><br><span class="line">            .filter(country -&gt; codeParam.equalsIgnoreCase(country.getCode()))</span><br><span class="line">            .findFirst()</span><br><span class="line">            .get();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JAXB-Example"><a href="#JAXB-Example" class="headerlink" title="JAXB Example"></a>JAXB Example</h3><p>最后附上JAXB转换xml的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jaxbObjectToXML</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    JAXBContext jaxbContext = JAXBContext.newInstance(Employee.class);</span><br><span class="line">    Marshaller jaxbMarshaller = jaxbContext.createMarshaller();</span><br><span class="line"></span><br><span class="line">    jaxbMarshaller</span><br><span class="line">            .setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">    StringWriter sw = <span class="keyword">new</span> StringWriter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Write XML to StringWriter</span></span><br><span class="line">    jaxbMarshaller.marshal(employee, sw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Verify XML Content</span></span><br><span class="line">    String xmlContent = sw.toString();</span><br><span class="line"></span><br><span class="line">    System.out.println( xmlContent );</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (JAXBException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>XML</tag>
        <tag>JAXB</tag>
      </tags>
  </entry>
  <entry>
    <title>揭秘,门面日志如何自动发现日志组件</title>
    <url>/2019/09/06/log-framework-search-princeple/</url>
    <content><![CDATA[<h3 id="commons-logging"><a href="#commons-logging" class="headerlink" title="commons-logging"></a>commons-logging</h3><p>commons-logging是apache提供的一个通用的日志接口，是为了避免和具体的日志方案直接耦合的一种实现。通过commons-logging用户可以自己选择log4j或者jdk自带的logging作为具体实现。</p>
<p>使用commons-logging的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Log log = LogFactory.getLog(<span class="keyword">this</span>.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>Log是一个接口，LogFactory的内部会去装载具体的日志系统，并获得实现该Log接口的实现类，其具体流程如下</p>
<ol>
<li>通过系统属性org.apache.commons.logging.LogFactory加载LogFactory的实现</li>
<li>如果未找到，则通过服务发现机制(SPI)在META-INF/services/org.apache.commons.logging.LogFactory寻找实现类进行加载</li>
<li>如果未找到，则从classpath下寻找commons-logging.properties文件，根据文件中org.apache.commons.logging.LogFactory配置进行加载</li>
<li>如果仍未找到,则使用默认配置：如果找到Log4j 则默认使用log4j 实现，如果仍没有则使用JDK14Logger 实现，再没有则使用commons-logging 内部提供的SimpleLog 实现</li>
</ol>
<p>所以只要你引入了log4j的jar包以及对其进行了配置底层就会直接使用log4j来进行日志输出了,其实质就是在org.apache.commons.logging.impl.Log4JLogger(commons-logging包)的getLogger方法调用了log4j的Logger.getLogger来返回底层的Logger,当记录日志的时候就会通过这个Logger写日志。</p>
<h3 id="Slf4j"><a href="#Slf4j" class="headerlink" title="Slf4j"></a>Slf4j</h3><p>slf4j全称为Simple Logging Facade for JAVA，java简单日志门面。其使用方式如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>slf4j和commons-logging不一样的是，如果你没有具体的日志组件(logback,log4j等)，它是无法打印日志的，如果你在一个maven项目里面只引入slf4j的jar包，然后记录日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Main.class);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      logger.info(<span class="string">&quot;slf4j&quot;</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就会出现下面的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</span><br><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:&#x2F;&#x2F;www.slf4j.org&#x2F;codes.html#StaticLoggerBinder for further details.</span><br></pre></td></tr></table></figure>

<p>如果你此时引入log4j或者logback的jar包就会打印出日志。</p>
<p>通过LoggerFactory.getLogger()查看其实现原理，其加载Logger核心源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Set&lt;URL&gt; <span class="title">findPossibleStaticLoggerBinderPathSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  Set&lt;URL&gt; staticLoggerBinderPathSet = <span class="keyword">new</span> LinkedHashSet&lt;URL&gt;();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      ClassLoader loggerFactoryClassLoader = LoggerFactory.class.getClassLoader();</span><br><span class="line">      Enumeration&lt;URL&gt; paths;</span><br><span class="line">      <span class="keyword">if</span> (loggerFactoryClassLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">          paths = ClassLoader.getSystemResources(<span class="string">&quot;org/slf4j/impl/StaticLoggerBinder.class&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          paths = loggerFactoryClassLoader.getResources(<span class="string">&quot;org/slf4j/impl/StaticLoggerBinder.class&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (paths.hasMoreElements()) &#123;</span><br><span class="line">          URL path = paths.nextElement();</span><br><span class="line">          staticLoggerBinderPathSet.add(path);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">      Util.report(<span class="string">&quot;Error getting resources from path&quot;</span>, ioe);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> staticLoggerBinderPathSet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其主要思想就是去classpath下找org/slf4j/impl/StaticLoggerBinder.class,即所有slf4j的实现,无论是log4j还是logback都有实现类，同学们可以看下自己项目中的jar包。</p>
<p>如果引入了多个实现，编译器会在编译的时候选择其中一个实现类进行绑定,也会将具体绑定的哪个日志框架告诉你</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reportActualBinding</span><span class="params">(Set&lt;URL&gt; binderPathSet)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (binderPathSet != <span class="keyword">null</span> &amp;&amp; binderPathSet.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        Util.report(<span class="string">&quot;Actual binding is of type [&quot;</span> + StaticLoggerBinder.getSingleton().getLoggerFactoryClassStr() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="/images/java/logback-slf4j.png" alt="具体实现"></p>
]]></content>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB中有几种日志?</title>
    <url>/2019/06/27/logs-in-mongodb/</url>
    <content><![CDATA[<p>任何一种数据库都有各种各样的日志，MongoDB也不例外。MongoDB中有4种日志，分别是系统日志、Journal日志、oplog主从日志、慢查询日志等。这些日志记录着MongoDB数据库不同方面的踪迹。下面分别介绍这几种日志。</p>
<a id="more"></a>

<h3 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h3><p>系统日志在MongoDB数据库中很重要，它记录着MongoDB启动和停止的操作，以及服务器在运行过程中发生的任何异常信息。</p>
<p>配置系统日志的方法比较简单，在启动mongod时指定logpath参数即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongod -logpath&#x3D;&#x2F;data&#x2F;log&#x2F;mongodb&#x2F;serverlog.log -logappend</span><br></pre></td></tr></table></figure>

<p>系统日志会向logpath指定的文件持续追加。</p>
<h3 id="Journal日志"><a href="#Journal日志" class="headerlink" title="Journal日志"></a>Journal日志</h3><p>journaling(日记) 日志功能则是 MongoDB 里面非常重要的一个功能 ， 它保证了数据库服务器在意外断电 、 自然灾害等情况下数据的完整性。它通过预写式的redo日志为MongoDB增加了额外的可靠性保障。开启该功能时,MongoDB会在进行写入时建立一条Journal日志,其中包含了此次写入操作具体更改的磁盘地址和字节。因此一旦服务器突然停机，可在启动时对日记进行重放，从而重新执行那些停机前没能够刷新到磁盘的写入操作。</p>
<p>MongoDB配置WiredTiger引擎使用内存缓冲区来保存journal记录,WiredTiger根据以下间隔或条件将缓冲的日志记录同步到磁盘</p>
<ol>
<li>从MongoDB 3.2版本开始每隔50ms将缓冲的journal数据同步到磁盘</li>
<li>如果写入操作设置了j:true，则WiredTiger强制同步日志文件</li>
<li>由于MongoDB使用的journal文件大小限制为100MB,因此WiredTiger大约每100MB数据创建一个新的日志文件。当WiredTiger创建新的journal文件时，WiredTiger会同步以前journal文件</li>
</ol>
<p>MongoDB达到上面的提交，便会将更新操作写入日志。这意味着MongoDB会批量地提交更改，即每次写入不会立即刷新到磁盘。不过在默认设置下，系统发生崩溃时，不可能丢失超过50ms的写入数据。</p>
<p>数据文件默认每60秒刷新到磁盘一次，因此Journal文件只需记录约60s的写入数据。日志系统为此预先分配了若干个空文件，这些文件存放在/data/db/journal目录中，目录名为_j.0、_j.1等<br>长时间运行MongoDB后，日志目录中会出现类似_j.6217、_j.6218的文件，这些是当前的日志文件，文件中的数值会随着MongoDB运行时间的增长而增大。数据库正常关闭后，日记文件会被清除(因为正常关闭后就不在需要这些文件了).</p>
<blockquote>
<p>向mongodb中写入数据是先写入内存，然后每隔60s在刷盘，同样写入journal,也是先写入对应的buffer，然后每隔50ms在刷盘到磁盘的journal文件<br>使用WiredTiger，即使没有journal功能，MongoDB也可以从最后一个检查点(checkpoint,可以想成镜像)恢复;但是，要恢复在上一个检查点之后所做的更改，还是需要使用Journal</p>
</blockquote>
<p>如发生系统崩溃或使用kill -9命令强制终止数据库的运行，mongod会在启动时重放journal文件，同时会显示出大量的校验信息。</p>
<blockquote>
<p>上面说的都是针对WiredTiger引擎,对于MMAPv1引擎来说有一点不一样，首先它是每100ms进行刷盘，其次它是通过private view写入journal文件,通过shared view写入数据文件。这里就不过多讲解了，因为MongoDB 4.0已经不推荐使用这个存储引擎了。<br>从MongoDB 3.2版本开始WiredTiger是MongoDB推荐的默认存储引擎</p>
</blockquote>
<p>需要注意的是如果客户端的写入速度超过了日记的刷新速度，mongod则会限制写入操作，直到日记完成磁盘的写入。这是mongod会限制写入的唯一情况。</p>
<h3 id="固定集合-Capped-Collection"><a href="#固定集合-Capped-Collection" class="headerlink" title="固定集合(Capped Collection)"></a>固定集合(Capped Collection)</h3><p>在讲下面两种日志之前先来认识下capped collection。</p>
<p>MongoDB中的普通集合是动态创建的，而且可以自动增长以容纳更多的数据。MongoDB中还有另一种不同类型的集合，叫做固定集合。固定集合需要事先创建好，而且它的大小是固定的。固定集合的行为类型与循环队列一样。如果没有空间了，最老的文档会被删除以释放空间，新插入的文档会占据这块空间。</p>
<p>创建固定集合：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.createCollection(&quot;collectionName&quot;,&#123;&quot;capped&quot;:true, &quot;size&quot;:100000, &quot;max&quot;:100&#125;)</span><br></pre></td></tr></table></figure>
<p>创建了一个大小为100000字节的固定大小集合,文档数量为100.不管先到达哪个限制，之后插入的新文档就会把最老的文档挤出集合：<strong>固定集合的文档数量不能超过文档数量限制，也不能超过大小限制。</strong></p>
<p>固定集合创建之后就不能改变,无法将固定集合转换为非固定集合,但是可以将常规集合转换为固定集合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.runCommand(&#123;&quot;convertToCapped&quot;: &quot;test&quot;, &quot;size&quot; : 10000&#125;);</span><br></pre></td></tr></table></figure>

<p>固定集合可以进行一种特殊的排序，称为自然排序(natural sort),自然排序返回结果集中文档的顺序就是文档在磁盘的顺序。自然顺序就是文档的插入顺序，因此自然排序得到的文档是从旧到新排列的。当然也可以按照从新到旧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.my_capped_collection.find().sort(&#123;&quot;$natural&quot;: -1&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="oplog主从日志"><a href="#oplog主从日志" class="headerlink" title="oplog主从日志"></a>oplog主从日志</h3><p>Replica Sets复制集用于在多台服务器之间备份数据。MongoDB的复制功能是使用操作日志oplog实现的，操作日志包含了主节点的每一次写操作。oplog是主节点的local数据库中的一个固定集合。备份节点通过查询这个集合就可以知道需要进行复制的操作。</p>
<blockquote>
<p>一个mongod实例中的所有数据库都使用同一个oplog，也就是所有数据库的操作日志(插入，删除，修改)都会记录到oplog中</p>
</blockquote>
<p>每个备份节点都维护着自己的oplog,记录着每一次从主节点复制数据的操作。这样，每个成员都可以作为同步源给其他成员使用。<br>如图所示，备份节点从当前使用的同步源中获取需要执行的操作，然后在自己的数据集上执行这些操作，最后再将这些操作写入自己的oplog,如果遇到某个操作失败的情况(只有当同步源的数据损坏或者数据与主节点不一致时才可能发生),那么备份节点就会停止从当前的同步源复制数据。</p>
<p><img data-src="/images/mongodb/oplog-copy.png" alt="复制数据"></p>
<p>oplog中按顺序保存着所有执行过的写操作，replica sets中每个成员都维护者一份自己的oplog，每个成员的oplog都应该跟主节点的oplog完全一致(可能会有一些延迟)</p>
<p>如果某个备份节点由于某些原因挂了，但它重新启动后，就会自动从oplog中最后一个操作开始进行同步。由于复制操作的过程是想复制数据在写入oplog,所以备份节点可能会在已经同步过的数据上再次执行复制操作。MongoDB在设计之初就考虑到了这种情况:将oplog中的同一个操作执行多次，与只执行一次的效果是一样的。</p>
<p>由于oplog大小是固定的，它只能保持特定数量的操作日志。通常，oplog使用空间的增长速度与系统处理写请求的速率几乎相同：如果主节点上每分钟处理了1KB的写入请求，那么oplog很可能也会在一分钟内写入1KB条操作日志。</p>
<p>但是，有一些例外：如果单次请求能够影响到多个文档(比如删除多个文档或者多文档更新),oplog中就会出现多条操作日志。如果单个操作会影响多个文档，那么每个受影响的文档都会对应oplog的一条日志。因此，如果执行db.student.remove()删除了10w个文档，那么oplog中也就会有10w条操作日志，每个日志对应一个被删除的文档。如果执行大量的批量操作，oplog很快就会被填满。</p>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>MongoDB中使用系统分析器(system profiler)来查找耗时过长的操作。系统分析器记录固定集合system.profile中的操作，并提供大量有关耗时过长的操作信息，但相应的mongod的整体性能也会有所下降。因此我们一般定期打开分析器来获取信息。</p>
<p>默认情况下，系统分析器处于关闭状态，不会进行任何记录。可以在shell中运行<code>db.setProfilingLevel()</code>开启分析器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.setProfilingLevel(level,&lt;slowms&gt;) 0&#x3D;off 1&#x3D;slow 2&#x3D;all</span><br></pre></td></tr></table></figure>

<p>第一个参数是指定级别，不同的级别代表不同的意义，0表示关闭，1表示默认记录耗时大于100毫秒的操作，2表示记录所有操作。第二个参数则是自定义“耗时过长”标准，比如记录所有耗时操作500ms的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.setProfilingLevel(1,500);</span><br></pre></td></tr></table></figure>

<p>如果开启了分析器而system.profile集合并不存在，MongoDB会为其建立一个大小为若干MB的固定集合(capped collection)。如希望分析器运行更长时间，可能需要更大的空间记录更多的操作。此时可以关闭分析器，删除并重新建立一个新的名为system.profile的固定集合，并令其容量符合要求。然后在数据库上重新启用分析器。</p>
<blockquote>
<p>可以通过db.system.profile.stats()查看集合的最大容量</p>
</blockquote>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的main线程是如何被创建的？</title>
    <url>/2020/07/27/main-thread-in-java/</url>
    <content><![CDATA[<p>当我们运行Java程序main方法的时候，我们都知道当前线程是main线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.currentThread().getName()</span><br></pre></td></tr></table></figure>

<p>那么这个main线程是被谁启动,又是在什么时候被启动的呢?我们通过源码一探究竟。</p>
<a id="more"></a>

<p>jvm的启动入口是main.c,由于我之前可以在mac上调试jvm了，所以我通过下面的参数进行启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -Xss512K -XX:+UseConcMarkSweepGC -Xms512M Main arg1&#x3D;think123 arg2&#x3D;666</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(String arg: args) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;input arg : &quot;</span> + arg);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;main thread name : &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c中首先会通过启动器来创建启动jvm</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> JLI_Launch(margc, margv,</span><br><span class="line">  jargc, (<span class="keyword">const</span> <span class="keyword">char</span>**) jargv,</span><br><span class="line">  <span class="number">0</span>, <span class="literal">NULL</span>,</span><br><span class="line">  VERSION_STRING,</span><br><span class="line">  DOT_VERSION,</span><br><span class="line">  (const_progname != <span class="literal">NULL</span>) ? const_progname : *margv,</span><br><span class="line">  (const_launcher != <span class="literal">NULL</span>) ? const_launcher : *margv,</span><br><span class="line">  jargc &gt; <span class="number">0</span>,</span><br><span class="line">  const_cpwildcard, const_javaw, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>JLI_Launch的实现在java.c文件中,它的主要流程是</p>
<ol>
<li><p>创建执行环境，主要是确定jrepath/jvmpath</p>
</li>
<li><p>加载jvm</p>
</li>
<li><p>解析参数</p>
</li>
<li><p>初始化jvm,执行main方法</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">int</span> JNICALL</span><br><span class="line">JLI_Launch(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv,              <span class="comment">/* main argc, argv */</span></span><br><span class="line">  <span class="keyword">int</span> jargc, <span class="keyword">const</span> <span class="keyword">char</span>** jargv,          <span class="comment">/* java args */</span></span><br><span class="line">  <span class="keyword">int</span> appclassc, <span class="keyword">const</span> <span class="keyword">char</span>** appclassv,  <span class="comment">/* app classpath */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* fullversion,                <span class="comment">/* full version defined */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* dotversion,                 <span class="comment">/* UNUSED dot version defined */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* pname,                      <span class="comment">/* program name */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* lname,                      <span class="comment">/* launcher name */</span></span><br><span class="line">  jboolean javaargs,                      <span class="comment">/* JAVA_ARGS */</span></span><br><span class="line">  jboolean cpwildcard,                    <span class="comment">/* classpath wildcard*/</span></span><br><span class="line">  jboolean javaw,                         <span class="comment">/* windows-only javaw */</span></span><br><span class="line">  jint ergo                               <span class="comment">/* unused */</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">char</span> jvmpath[MAXPATHLEN];</span><br><span class="line">  <span class="keyword">char</span> jrepath[MAXPATHLEN];</span><br><span class="line">  <span class="keyword">char</span> jvmcfg[MAXPATHLEN];</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建执行环境</span></span><br><span class="line">  CreateExecutionEnvironment(&amp;argc, &amp;argv,</span><br><span class="line">                             jrepath, <span class="keyword">sizeof</span>(jrepath),</span><br><span class="line">                             jvmpath, <span class="keyword">sizeof</span>(jvmpath),</span><br><span class="line">                             jvmcfg,  <span class="keyword">sizeof</span>(jvmcfg));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!IsJavaArgs()) &#123;</span><br><span class="line">      SetJvmEnvironment(argc,argv);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ifn.CreateJavaVM = <span class="number">0</span>;</span><br><span class="line">  ifn.GetDefaultJavaVMInitArgs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载JVM</span></span><br><span class="line">  <span class="keyword">if</span> (!LoadJavaVM(jvmpath, &amp;ifn)) &#123;</span><br><span class="line">      <span class="keyword">return</span>(<span class="number">6</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析参数</span></span><br><span class="line">  <span class="keyword">if</span> (!ParseArguments(&amp;argc, &amp;argv, &amp;mode, &amp;what, &amp;ret, jrepath)) &#123;</span><br><span class="line">      <span class="keyword">return</span>(ret);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化JVM</span></span><br><span class="line">  <span class="keyword">return</span> JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码我保留了主体流程,将其他代码省略掉了。</p>
<h3 id="创建执行环境"><a href="#创建执行环境" class="headerlink" title="创建执行环境"></a>创建执行环境</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateExecutionEnvironment</span><span class="params">(<span class="keyword">int</span> *pargc, <span class="keyword">char</span> ***pargv,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">char</span> jrepath[], jint so_jrepath,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">char</span> jvmpath[], jint so_jvmpath,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">char</span> jvmcfg[],  jint so_jvmcfg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    jboolean jvmpathExists;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置可执行文件的path,这里的path是java这个可执行程序的绝对路径，比如我这里是</span></span><br><span class="line">    <span class="comment">// /Users/xxx/jvm/jdk12-06222165c35f/build/macosx-x86_64-server-slowdebug/jdk/bin/java</span></span><br><span class="line">    <span class="comment">// 后面会根据这个路径来计算JREPath以及JDKPath</span></span><br><span class="line">    SetExecname(*pargv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> * jvmtype    = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span>  argc         = *pargc;</span><br><span class="line">    <span class="keyword">char</span> **argv       = *pargv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到jre path</span></span><br><span class="line">    <span class="keyword">if</span> (!GetJREPath(jrepath, so_jrepath, JNI_FALSE) ) &#123;</span><br><span class="line">        JLI_ReportErrorMessage(JRE_ERROR1);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到jvm path</span></span><br><span class="line">    <span class="keyword">if</span> (!GetJVMPath(jrepath, jvmtype, jvmpath, so_jvmpath)) &#123;</span><br><span class="line">        JLI_ReportErrorMessage(CFG_ERROR8, jvmtype, jvmpath);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mac os独有操作    </span></span><br><span class="line">    MacOSXStartup(argc, argv);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是jvmpath/jrepath的长度不能超过1024字节,所以我们安装java的时候一定要注意文件夹层次不能太深</p>
</blockquote>
<p>执行完上面的代码之后,jvmpath/jrepath的值如下</p>
<p><img data-src="/images/macos-jvm/execution-env.png" alt="执行环境"></p>
<p>着重注意下这里的jvmpath的值是libjvm.dylib,这个就是我们要使用的JVM动态链接库(windows中是jvm.dll,linux中是libjvm.so)</p>
<h3 id="加载JVM"><a href="#加载JVM" class="headerlink" title="加载JVM"></a>加载JVM</h3><p>接下来加载JVM，实际上是加载libjvm.dylib这个动态链接库。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">LoadJavaVM</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *jvmpath, InvocationFunctions *ifn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dl_info dlinfo;</span><br><span class="line">    <span class="keyword">void</span> *libjvm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STATIC_BUILD</span></span><br><span class="line">  <span class="comment">// 通过dlopen加载动态库文件(libjvm.dylib),并返回一个句柄</span></span><br><span class="line">  libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  libjvm = dlopen(<span class="literal">NULL</span>, RTLD_FIRST);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (libjvm == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      JLI_ReportErrorMessage(DLL_ERROR1, __LINE__);</span><br><span class="line">      JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());</span><br><span class="line">      <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过dlsym函数将libjvm中JNI_CreateJavaVM函数地址绑定到ifn的CreateJavaVM属性</span></span><br><span class="line">  ifn-&gt;CreateJavaVM = (CreateJavaVM_t)</span><br><span class="line">      dlsym(libjvm, <span class="string">&quot;JNI_CreateJavaVM&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ifn-&gt;CreateJavaVM == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());</span><br><span class="line">      <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过dlsym函数将libjvm中JNI_GetDefaultJavaVMInitArgs函数地址绑定到ifn的GetDefaultJavaVMInitArgs属性</span></span><br><span class="line">  ifn-&gt;GetDefaultJavaVMInitArgs = (GetDefaultJavaVMInitArgs_t)</span><br><span class="line">      dlsym(libjvm, <span class="string">&quot;JNI_GetDefaultJavaVMInitArgs&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ifn-&gt;GetDefaultJavaVMInitArgs == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());</span><br><span class="line">      <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同上将libjvm中的GetCreatedJavaVMs函数地址绑定到ifn的GetCreatedJavaVMs属性</span></span><br><span class="line">  ifn-&gt;GetCreatedJavaVMs = (GetCreatedJavaVMs_t)</span><br><span class="line">  dlsym(libjvm, <span class="string">&quot;JNI_GetCreatedJavaVMs&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ifn-&gt;GetCreatedJavaVMs == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());</span><br><span class="line">      <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>LoadJVM主要做了以下2件事</p>
<ol>
<li>通过dlopen加载libjvm.dylib动态链接库</li>
<li>绑定动态链接库中的函数到InvocationFunctions这个结构体的属性中</li>
</ol>
<blockquote>
<p>dlopen和dlsym系统提供的函数,dlsym一般和dlopen配合使用</p>
</blockquote>
<h3 id="解析命令行参数"><a href="#解析命令行参数" class="headerlink" title="解析命令行参数"></a>解析命令行参数</h3><p>在ParseArguments函数中主要解析的是命令行参数比如-classpath,-version,-help等,但是这里最重要的是解析-Xss,-Xmx,-Xms这三个参数,因为这三个参数格式和其他不一样。都是参数名称后面跟上具体大小</p>
<p><img data-src="/images/macos-jvm/parse-arg.png" alt="参数解析"></p>
<blockquote>
<p>单位只能是T(t),G(g),M(m),K(k)这8个中的一个</p>
</blockquote>
<p>其他参数解析和判定会在初始化JVM的时候完成</p>
<h3 id="初始化VM"><a href="#初始化VM" class="headerlink" title="初始化VM"></a>初始化VM</h3><p>JVMInit方法最终会调用java_md_macosx.m中的ContinueInNewThread0方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ContinueInNewThread0(<span class="keyword">int</span> (JNICALL *continuation)(<span class="keyword">void</span> *), jlong stack_size, <span class="keyword">void</span> * args) &#123;</span><br><span class="line">  <span class="keyword">int</span> rslt;</span><br><span class="line">  <span class="keyword">pthread_t</span> tid;</span><br><span class="line">  <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">  pthread_attr_init(&amp;attr);</span><br><span class="line">  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置stack_size(-Xss参数解析出来的值)</span></span><br><span class="line">  <span class="keyword">if</span> (stack_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    pthread_attr_setstacksize(&amp;attr, stack_size);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_attr_setguardsize(&amp;attr, <span class="number">0</span>); <span class="comment">// no pthread guard page on java threads</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一个参数是线程提示符指针,第二个参数是线程属性</span></span><br><span class="line">  <span class="comment">// 第三个参数是线程运行函数的起始地址,第四个参数是运行函数参数</span></span><br><span class="line">  <span class="keyword">if</span> (pthread_create(&amp;tid, &amp;attr, (<span class="keyword">void</span> *(*)(<span class="keyword">void</span>*))continuation, (<span class="keyword">void</span>*)args) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">void</span> * tmp;</span><br><span class="line">    pthread_join(tid, &amp;tmp);</span><br><span class="line">    rslt = (<span class="keyword">int</span>)(<span class="keyword">intptr_t</span>)tmp;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   </span><br><span class="line">    rslt = continuation(args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pthread_attr_destroy(&amp;attr);</span><br><span class="line">  <span class="keyword">return</span> rslt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pthread_create函数作用是创建一个线程(<strong>我们的main线程就这样被创建出出来了</strong>),pthread_create的第三个参数continuation传递进来的函数是JavaMain,这就相当于java线程中run方法。它位于java.c中,由于函数过长，我只保留了比较重要的部分</p>
<blockquote>
<p>IEEE标准1003.1c中定义了线程的标准,它定义的线程包叫做Pthread,大部分UNIX系统都支持这个标准。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> JNICALL <span class="title">JavaMain</span><span class="params">(<span class="keyword">void</span> * _args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line"> ... 省略代码</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过CreateJavaVM方法初始化JVM,这里逻辑比较复杂，暂时不做展开</span></span><br><span class="line">  <span class="comment">// 初始化jvm中的时候会解析和检查其他参数,比如-XX:+UseConcMarkSweepGC</span></span><br><span class="line">  <span class="keyword">if</span> (!InitializeJVM(&amp;vm, &amp;env, &amp;ifn)) &#123;</span><br><span class="line">    JLI_ReportErrorMessage(JVM_ERROR1);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载我们要运行的class</span></span><br><span class="line">  mainClass = LoadMainClass(env, mode, what);</span><br><span class="line">  CHECK_EXCEPTION_NULL_LEAVE(mainClass);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 获取main方法id(main方法入口地址)</span></span><br><span class="line">  mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">                                     <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br><span class="line">  CHECK_EXCEPTION_NULL_LEAVE(mainID);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用main方法</span></span><br><span class="line">  (*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等到所有非守护进程结束后,销毁VM</span></span><br><span class="line">  LEAVE();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用main方法则是通过jni.cpp中的jni_invoke_static方法,而该方法最终是通过JavaCalls::call(javaCalls.cpp)完成的。</p>
<blockquote>
<p>javaCalls::call方法只有java线程才能调用该方法</p>
</blockquote>
<p>至此我们的main线程就被启动起来了。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>创建线程的几种主流方式</title>
    <url>/2021/01/21/methods-of-create-thread/</url>
    <content><![CDATA[<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>继承Thread类，并重写它的run方法，就可以创建一个线程了，当然线程是如何真正被启动，可以参考我之前的 <a href="https://juejin.cn/post/6858058928467968008">为什么start方法才能启动线程,而run不行？</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThinkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;think123&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> ThinkThread().start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">  System.out.println(<span class="string">&quot;实现了Runnable接口&quot;</span>)</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure>

<p>构造Thread时传入Runnable类型的参数，也可以创建一个线程</p>
<h3 id="通过线程池创建线程"><a href="#通过线程池创建线程" class="headerlink" title="通过线程池创建线程"></a>通过线程池创建线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提交 Runnable 任务</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 Callable 任务</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 Runnable 任务及结果引用。 future.get()==result</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Runnable类型的参数和Callable类型的参数不同之处在于Runnable 接口的 run() 方法是没有返回值的，所以 submit(Runnable task)这个方法返回的 Future 仅可以用来断言任务已经结束了，类似于 Thread.join()。 而Callable是一个接口，它有一个call()方法，这个方法是有返回值的，这个可以通过 future.get() l获取任务执行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建议手动创建线程池，这里只是为了举例</span></span><br><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Future future = service.submit(() -&gt; <span class="string">&quot;think123&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(future.get());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="通过FutureTask创建线程"><a href="#通过FutureTask创建线程" class="headerlink" title="通过FutureTask创建线程"></a>通过FutureTask创建线程</h3><p>FutureTask继承了Runnable和Future接口,所以我们可以将FutureTask对象作为任务提交到线程池执行，也可以直接被Thread执行，而且还可以获取到任务执行结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureTask task = <span class="keyword">new</span> FutureTask(() -&gt; <span class="string">&quot;666&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(task);</span><br><span class="line">t1.start();;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞main线程，直到t1执行完成</span></span><br><span class="line">System.out.println(task.get());</span><br></pre></td></tr></table></figure>

<p>FutureTask的源码很简单，当执行run方法时，会将执行的结果保存在内部变量 outcome 中，即便是抛出了异常，此时也会将异常记录到outcome中。</p>
<p>当调用 get 方法时，如果还未执行完成，则会阻塞调用方。执行完成后会将正常的结果返回，如果call方法中抛出了异常，则将其封装成 ExecutionException 抛出。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面介绍了Java中常用的创建线程执行的方式，可以发现，实际上都是通过 创建Thread来执行的，实际上也是可以算作一种，如果面试官问题，你可以先装一下说之后一种，然后峰回路转，给他说说为什么之后一种。</p>
<blockquote>
<p>当然还有其他方式，比如TimerTask, Quartz Job但是实际上都是类似的。</p>
</blockquote>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Git中仓库拆分的两种方式</title>
    <url>/2024/05/30/migrate-service-in-git/</url>
    <content><![CDATA[<p>最近要把项目中的子模块单独拆分为一个项目,并且移动到新的仓库地址，同时需要保留所有提交记录以及所有分支(包括未上线-未合并到master分支)的代码,我这里总结了2种方式以供大家参考。</p>
<h3 id="项目现状"><a href="#项目现状" class="headerlink" title="项目现状"></a>项目现状</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bv_sc_server</span><br><span class="line">|───bvpro-modules</span><br><span class="line">    │  ├─bvpro-job</span><br><span class="line">    │  │  ├─src</span><br><span class="line">    │  │  │  └─main</span><br><span class="line">    │  │  │      ├─java</span><br><span class="line">    │  │  │      │  └─com</span><br><span class="line">    │  │  │      │      └─bvpro</span><br><span class="line">    │  │  │      │          └─job</span><br><span class="line">    |  ├─bvpro-file</span><br><span class="line">    │  │  ├─src</span><br><span class="line">    │  │  │  └─main</span><br><span class="line">    │  │  │      ├─java</span><br><span class="line">    │  │  │      │  └─com</span><br><span class="line">    │  │  │      │      └─bvpro</span><br><span class="line">    │  │  │      │          └─file    </span><br></pre></td></tr></table></figure>
<p>&lt;!-more–&gt;</p>
<p>项目中有很多子模块，我需要将他们单独独立出来放到放到一个新的仓库,同时只保留各自仓库的代码。 </p>
<p>比如我有一个分支feature/migrate-data,它同时修改了bvpro-file以及bvpro-job的代码，那么迁移过去的效果希望是<br>新的bvpro-file和bvpro-job仓库都有这个分支，同时也只包含当前仓库的代码，而不再想之前一样混杂着多个模块的代码。</p>
<p>因此调研了下发现有两种方案可以达到这样的目的，一种是git subtree, 一种是git filter-repo。 </p>
<h3 id="git-subtree"><a href="#git-subtree" class="headerlink" title="git subtree"></a>git subtree</h3><p>需要拆分的仓库叫做 bv_sc_server, 现在需要拆分的模块是 bv_sc_server/bvpro-modules/bvpro-job, 拆分后的新仓库叫做bvpro-job</p>
<ol>
<li><p>先在代码服务器(比如gitlab)上新建一个空的仓库， 比如bvpro-job</p>
</li>
<li><p>在本地文件夹clone刚创建的新仓库, 和bv_sc_server在同一个目录下</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone http:&#x2F;&#x2F;localhost:8090&#x2F;sc_group&#x2F;bvpro-job.git</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入bv_sc_server这个仓库的目录下进行拆分,当前处于master分支(这个分支是需要迁移的分支)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git subtree split -P bvpro-modules&#x2F;bvpro-job -b feature&#x2F;split-bvpro-job</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>进入到bvpro-job这个新仓库,执行以下命令: <ul>
<li>cd ../bvpro-job</li>
<li>git pull ..\bv_sc_server feature/split-bvpro-job</li>
<li>git remote remove origin</li>
<li>git remote add origin <a href="http://localhost:8090/sc_group/bvpro-job.git">http://localhost:8090/sc_group/bvpro-job.git</a></li>
<li>git push –set-upstream origin –all</li>
</ul>
</li>
</ol>
<p>到这里我们就把bv_sc_server中bvpro-job模块的master分支代码迁移到了新的仓库，但是其他分支还没有迁移过去,所以这里我们重复执行下操作</p>
<p>这里为了不相互影响，我们将本地bvpro-job目录删除，然后重新新建一个空白bvpro-job目录。然后在重复执行上面的命令,这里为了演示方便我就将命令写到一起。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd bvpro-job</span><br><span class="line">git clone http:&#x2F;&#x2F;localhost:8090&#x2F;sc_group&#x2F;bvpro-job.git</span><br><span class="line">cd ..&#x2F;bv_sc_server</span><br><span class="line">#切换到需要迁移的分支</span><br><span class="line">git checkout feature&#x2F;SCA-5034_AutoApprovalForTcAndSc</span><br><span class="line">git subtree split -P bvpro-modules&#x2F;bvpro-job -b  split&#x2F;SCA-5034_AutoApprovalForTcAndSc</span><br><span class="line">cd ..&#x2F;bvpro-job</span><br><span class="line">git pull ..\bv_sc_server split&#x2F;SCA-5034_AutoApprovalForTcAndSc</span><br><span class="line">git remote remove origin</span><br><span class="line">git remote add origin http:&#x2F;&#x2F;localhost:8090&#x2F;sc_group&#x2F;bvpro-job.git</span><br><span class="line"># 新clone的仓库默认是master分支(也可能是main), 然后推送到远端的feature分支</span><br><span class="line">git push --set-upstream origin master:feature&#x2F;SCA-5034_AutoApprovalForTcAndSc</span><br></pre></td></tr></table></figure>

<p>这样就完成了feature/SCA-5034_AutoApprovalForTcAndSc分支的迁移了,这样迁移也只保留了bvpro-job有关的代码，如果这个分支在以前的其他模块也有代码,那么也要按照这样的方式进行迁移，同时有多少个分支需要迁移就需要执行多次上面的命令。</p>
<p>可以发现这样迁移的效率是很低的，要是分支或者提交记录很多一天的时间都耗在这上面了。当然如果你只想要迁移master分支代码，这种方式也是很不错的，关键是这个命令是git自带的。</p>
<h3 id="git-filter-repo"><a href="#git-filter-repo" class="headerlink" title="git filter-repo"></a>git filter-repo</h3><p>这个命令并不是git自带的,但是它也很赫赫有名，毕竟官方都推荐使用它进行迁移。</p>
<p>使用它是有限制的，首先python版本要在3.5以上,git版本要在2.2以上。因为我使用的是windows,所以下面演示windows上的安装方式</p>
<ol>
<li>安装git-filter-repo<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m pip install --user git-filter-repo</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>记录下安装的地址，然后配置环境变量，然后就可以使用git filter-repo这个命令了。</p>
<ol start="2">
<li>git clone bv_sc_server项目,默认master分支,最好是最新的,这样子命令运行错了也不影响你的开发</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone http:&#x2F;&#x2F;localhost:8090&#x2F;sc_group&#x2F;bv_sc_server.git bvpro-job</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>拆分</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd bvpro-job</span><br><span class="line"></span><br><span class="line"># 只保留bvpro-modules&#x2F;bvpro-job这个路径的代码</span><br><span class="line">git filter-repo --path bvpro-modules&#x2F;bvpro-job</span><br><span class="line"></span><br><span class="line"># 将bvpro-modules&#x2F;bvpro-job这个目录提升为根目录</span><br><span class="line">git filter-repo --subdirectory-filter bvpro-modules&#x2F;bvpro-job</span><br><span class="line"></span><br><span class="line"># 上面两句可以合并成下面这句，还可以指定要保留的分支</span><br><span class="line">git filter-repo --path bvpro-modules&#x2F;bvpro-job --subdirectory-filter bvpro-modules&#x2F;bvpro-job --branches &lt;保留的分支名称&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的命令执行完成后,bv_sc_server这个目录下的代码就只有以前bvpro-job的代码了</p>
<ol start="4">
<li>推送</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin http:&#x2F;&#x2F;localhost:8090&#x2F;sc_group&#x2F;bvpro-job.git</span><br><span class="line"></span><br><span class="line">git push --set-upstream origin --all</span><br></pre></td></tr></table></figure>
<p>这样子就将bvpro-job这个子模块的所有代码，commit以及分支都迁移到了新的仓库，不用再想subtree一样针对特定的分支反复操作了， 所以我是推荐使用这个命令的。</p>
]]></content>
      <tags>
        <tag>git</tag>
        <tag>filter-repo</tag>
        <tag>subtree</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB设计技巧</title>
    <url>/2019/10/18/mongodb-design-skill/</url>
    <content><![CDATA[<h3 id="范式化设计还是反范式"><a href="#范式化设计还是反范式" class="headerlink" title="范式化设计还是反范式"></a>范式化设计还是反范式</h3><p>考虑下这样的场景，我们的订单数据是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">商品：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_id&quot;: productId,</span><br><span class="line">  &quot;name&quot;: name,</span><br><span class="line">  &quot;price&quot;: price,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">订单:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_id&quot;: orderId,</span><br><span class="line">  &quot;user&quot;: userId,</span><br><span class="line">  &quot;items&quot;: [</span><br><span class="line">    productId1,</span><br><span class="line">    productId2,</span><br><span class="line">    productId3</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>当我们查询订单内容的时候，先通过orderId查询订单，然后在通过订单信息中的productId查询到对应的商品信息。这种设计下一次查询无法获取完整的订单。</p>
<p>范式化结果就是读取速度比较忙，当所有订单的一致性会有保证。</p>
<p>在来看看反范式化设计</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">订单:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_id&quot;: orderId,</span><br><span class="line">  &quot;user&quot;: userId,</span><br><span class="line">  &quot;items&quot;: [</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;_id&quot;: productId1,</span><br><span class="line">    &quot;name&quot;: name,</span><br><span class="line">    &quot;price&quot;: price,</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    &quot;_id&quot;: productId2,</span><br><span class="line">    &quot;name&quot;: name,</span><br><span class="line">    &quot;price&quot;: price,</span><br><span class="line">   &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里将商品信息作为内嵌文档存在订单数据中，这样当显示的时候就只需要一次查询就可以了。</p>
<p>反范式读取速度快，一致性稍弱，商品信息的变更不能原子性地更新到多个文档。</p>
<p>那么我们一般使用哪一个呢？我们在设计的时候要考虑以下问题</p>
<ol>
<li>读写比是怎样的？</li>
</ol>
<p>可能读取了商品信息一万次才修改一次它的详细信息，为了那一次写入快一点或者保证一致性，搭上一万次的读取消耗值得吗？还有你认为引用的数据多久会更新一次？更新越少，越适合反范式化。有些极少变化的数据几乎根本不值得引用。比如名字，性别，地址等。</p>
<ol start="2">
<li>一致性重要吗？</li>
</ol>
<p>如果是肯定的，则应该范式化。</p>
<ol start="3">
<li>要不要快速的读取？<br>如果想要读取尽可能快，则要反范式化。在这个引用中就无所谓了，所以不能算考量因素，实时的应用要尽可能地反范式化。</li>
</ol>
<p>订单文档非常适合反范式化，因为其中的商品信息不经常变化。就算变了也不必更新到所有订单。范式化再次就没有什么优势可言了。</p>
<p>所以本例中就是将订单反范式化。</p>
<h3 id="嵌入时间点数据"><a href="#嵌入时间点数据" class="headerlink" title="嵌入时间点数据"></a>嵌入时间点数据</h3><p>当一个商品打折或者换了图片，并不需要更改原来的订单中的信息。类似这种特定于某一时刻的时间点数据，都应该做嵌入处理。</p>
<p>在我们上面提到的订单文档中有一处也是这样，地址就属于时间点数据。若某人更新了个人信息，那么并不需要改变其以往的订单内容。</p>
<h3 id="千万不要嵌入不断增加的数据"><a href="#千万不要嵌入不断增加的数据" class="headerlink" title="千万不要嵌入不断增加的数据"></a>千万不要嵌入不断增加的数据</h3><p>MongoDB存储数据的机制决定了对数组不断追加数据是很低效的。在正常使用中数组和对象大小应该相对固定。</p>
<p>嵌入20，100，或者100000个子文档都不是问题，关键是提前这么做，之后基本保持不变。否则放任文档增长会使得系统慢的你受不了。</p>
<p>对于那些不断增加的内容，必须评论这个时候应该将其作为单独的文档处理比较合适。</p>
<h3 id="尽可能预先分配空间"><a href="#尽可能预先分配空间" class="headerlink" title="尽可能预先分配空间"></a>尽可能预先分配空间</h3><p>只要知道文档开始比较小，后来会变为确定的大小就可以使用这种优化方法，一开始插入文档的时候，就用和最终数据大小一样的垃圾数据填充，比如添加一个garbage字段(其中包含一个字符串，串大小与文档最终大小相同)，然后马上重置字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.insert(&#123;&quot;_id&quot; : 1,&#x2F;* other fields *&#x2F;, &quot;garbase&quot;: longString&#125;);</span><br><span class="line">db.collection.update(&#123;&quot;_id&quot; : 1, &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样，MongDB就会为文档今后的增长分配足够的空间</p>
<blockquote>
<p>mongodb中存储文档是预留了空间的，允许文档扩容，但是当文档增大到一定地步的时候，就会超过原本分配的空间，此时文档就会进行移动</p>
</blockquote>
<h3 id="用数组存放要匿名访问的内嵌数据"><a href="#用数组存放要匿名访问的内嵌数据" class="headerlink" title="用数组存放要匿名访问的内嵌数据"></a>用数组存放要匿名访问的内嵌数据</h3><p>一个常见的问题就是内嵌的信息到底是用数组还是用子文档存。如果确切知道要查询的内容，就要用子文档。如果有时候不太清楚查询的具体内容，就要用数组。当知道一些条目的查询条件时，通常该使用数组。</p>
<p>假设我想记录下游戏中某些物品的属性。我们可以这样建模</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_id&quot;: 1,</span><br><span class="line">  &quot;items&quot; : &#123;</span><br><span class="line"></span><br><span class="line">    &quot;slingshot&quot;: &#123;</span><br><span class="line">      &quot;type&quot; : &quot;weapon&quot;,</span><br><span class="line">      &quot;damage&quot; : 30,</span><br><span class="line">      &quot;ranged&quot; : true</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &quot;jar&quot; : &#123;</span><br><span class="line">      &quot;type&quot;: &quot;container&quot;,</span><br><span class="line">      &quot;contains&quot;: &quot;fairy&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>假设要找出所有damage大于20的武器，子文档不支持这种查找方式，你只能知晓具体某种物品的信息才能查找，比如{“items.jar.damage”: {“$gt”:20}}.<br>如果无需标识符，就要用数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_id&quot;: 1,</span><br><span class="line">  &quot;items&quot; : [</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot; : &quot;slingshot&quot;</span><br><span class="line">      &quot;type&quot; : &quot;weapon&quot;,</span><br><span class="line">      &quot;damage&quot; : 30,</span><br><span class="line">      &quot;ranged&quot; : true</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot; : &quot;jar&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;container&quot;,</span><br><span class="line">      &quot;contains&quot;: &quot;fairy&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比如{”items.damage”:{“$gt”:20}}就行了。如果还需要多条件查询，可以使用$elemMatch.</p>
<h3 id="如何使用自增id代替ObjectId"><a href="#如何使用自增id代替ObjectId" class="headerlink" title="如何使用自增id代替ObjectId"></a>如何使用自增id代替ObjectId</h3><p>有时候在使用过程中受限于业务或者其他情况，并不想使用ObjectId,而是想要使用自动Id来代替。但是MongoDB本身并没有提供这个功能，那么如何实现呢？</p>
<p>可以新建一个collection来保存自增id</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;59ed8d3df772d09a67eb25f6&quot;),</span><br><span class="line">    &quot;fieldName&quot; : &quot;user&quot;,</span><br><span class="line">    &quot;seq&quot; : NumberLong(100064)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>fieldName表示哪个集合,那么下次要使用的时候只用取出这个值加1就可以了。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> Long <span class="title">getNextSequence</span><span class="params">(String fieldName, <span class="keyword">long</span> gap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Query query = <span class="keyword">new</span> Query();</span><br><span class="line">        query.addCriteria(Criteria.where(<span class="string">&quot;fieldName&quot;</span>).is(fieldName));</span><br><span class="line"></span><br><span class="line">        Update update = <span class="keyword">new</span> Update();</span><br><span class="line">        update.inc(<span class="string">&quot;seq&quot;</span>, gap);</span><br><span class="line"></span><br><span class="line">        FindAndModifyOptions options = FindAndModifyOptions.options();</span><br><span class="line">        options.upsert(<span class="keyword">true</span>);</span><br><span class="line">        options.returnNew(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        Counter counter = mongoTemplate.findAndModify(query, update, options, Counter.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (counter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> counter.getSeq();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Exception when getNextSequence from mongodb&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="不要到处使用索引"><a href="#不要到处使用索引" class="headerlink" title="不要到处使用索引"></a>不要到处使用索引</h3><p>索引是很强大，但是要提醒你的是，不是所有查询都可以用索引的。比如你要返回集合中90%的文档而非获取一些记录，就不应该使用索引。</p>
<p>如果对这种查询用了索引，结果就是几乎遍历整个索引树，把其中一部分，比方说40GB的索引都加载到内存。然后按照索引中的指针加载集合中200GB的文档数据，最终将加载<br>200GB + 40GB = 240GB的数据，比不用索引还多。</p>
<p>所以索引一般用在返回结果只是总体数据的小部分的时候。根据经验，一旦要大约返回集合一般的数据就不要使用索引了。</p>
<p>若是已经对某个字段建立了索引，又想在大规模查询时不使用它(因为使用索引可能会较低效),可以使用自然排序来强制MongoDB禁用索引。自然排序就是“按照磁盘上的存储顺序返回数据”,这样MongDB就不会使用索引了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.students.find().sort(&#123;&quot;$natural&quot; : 1&#125;);</span><br></pre></td></tr></table></figure>

<p>如果某个查询不用索引，MongoDB就会做全表扫描。</p>
<h3 id="索引覆盖查询"><a href="#索引覆盖查询" class="headerlink" title="索引覆盖查询"></a>索引覆盖查询</h3><p>如果你想要返回某些字段且这些字段都可以放到索引中，那么MongoDB可以做索引覆盖查询，这种查询不会访问指针指向的文档，而是直接用索引的数据返回结果，比如有如下索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.students.ensureIndex(x : 1, y : 1, z : 1);</span><br></pre></td></tr></table></figure>

<p>现在查询被索引的字段，并要求只返回这些字段，MongoDB就没有必要加载整个文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.students.find(&#123;&quot;x&quot; : &quot;xxx&quot;, &quot;y&quot; : &quot;xxx&quot;&#125;,&#123;x : 1, y : 1, z : 1, &quot;_id&quot; : 0&#125;);</span><br></pre></td></tr></table></figure>

<p>注意由于_id是默认返回的，而它又不是索引的一部分，所以MongoDB就需要到文档中获取_id,去掉它，就可以仅根据索引返回结果了。</p>
<p>若是查询值返回几个字段，则考虑将其放到索引中，即使不对他们执行查询，也能做索引覆盖查询。比如上面的字段z。</p>
<h3 id="AND查询要点"><a href="#AND查询要点" class="headerlink" title="AND查询要点"></a>AND查询要点</h3><p>假设要查询满足条件A、B、C的文档。满足A的文档有40000，满足B的有9000，满足C的有200，要是让MongoDB按照这个顺序查询，效率可不高。</p>
<p>如果把C放到最前，然后是B，然后是A，则针对B,C只需要查询最多200个文档。</p>
<p>这样工作量显著减少了。要是已知某个查询条件更加苛刻，则要将其放置到最前面。</p>
<h3 id="OR型查询要点"><a href="#OR型查询要点" class="headerlink" title="OR型查询要点"></a>OR型查询要点</h3><p>OR与AND查询相反，匹配最多的查询语句应该放到最前面，因为MongDB每次都要匹配不在结果集中的文档。</p>
<h3 id="单表查询尽量使用Respostory"><a href="#单表查询尽量使用Respostory" class="headerlink" title="单表查询尽量使用Respostory"></a>单表查询尽量使用Respostory</h3><p>开发中，对于简单的查询我一般使用MongoRepository来实现功能，如果有复杂的结合MongoTemplate，注意这两者是可以混合使用的。</p>
<h3 id="converter的建议"><a href="#converter的建议" class="headerlink" title="converter的建议"></a>converter的建议</h3><p>开发中我们要写对于一个collection,其中有些特殊的类型(比如枚举)需要我们写converter,大多时候是双向的，比如db–&gt;collection和collection–&gt;db<br>如果只有一个类型需要转换，我们可以针对这一个属性进行转换，比如下面的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@WritingConverter</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserStatusToIntConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">UserStatus</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">convert</span><span class="params">(UserStatus userStatus)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userStatus.getStatus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ReadingConverter</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserStatusFromIntConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">Integer</span>, <span class="title">UserStatus</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserStatus <span class="title">convert</span><span class="params">(Integer source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UserStatus.findStatus(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个字段还好，如果一个类中有很多个字段都需要做转换的话，就会产生很多个converter,这个时候我们可以写一个类级别的转换器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ReadingConverter</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperateLogFromDbConverter</span> <span class="keyword">extends</span> <span class="title">AbstractReadingConverter</span>&lt;<span class="title">Document</span>, <span class="title">OperateLog</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> OperateLog <span class="title">convert</span><span class="params">(Document source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      OperateLog opLog = convertBasicField(source);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (source.containsKey(<span class="string">&quot;_id&quot;</span>)) &#123;</span><br><span class="line">          opLog.setId(source.getLong(<span class="string">&quot;_id&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (source.containsKey(<span class="string">&quot;module&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">          opLog.setModule(ModuleEnum.findModule(source.getInteger(<span class="string">&quot;module&quot;</span>)));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (source.containsKey(<span class="string">&quot;opType&quot;</span>)) &#123;</span><br><span class="line">          opLog.setOpType(OpTypeEnum.findOpType(source.getInteger(<span class="string">&quot;opType&quot;</span>)));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (source.containsKey(<span class="string">&quot;level&quot;</span>)) &#123;</span><br><span class="line">          opLog.setLevel(OpLevelEnum.findOpLevel(source.getInteger(<span class="string">&quot;level&quot;</span>)));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> opLog;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> OperateLog <span class="title">convertBasicField</span><span class="params">(Document source)</span> </span>&#123;</span><br><span class="line">      Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">      <span class="keyword">return</span> gson.fromJson(source.toJson(), OperateLog.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码我用了GSON做common field的转换，如果你不这样写，就需要判断每个字段，然后进行填充。</p>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>你知道MongoDB的10种索引吗?</title>
    <url>/2020/04/01/mongodb-index/</url>
    <content><![CDATA[<h3 id="为什么要有索引"><a href="#为什么要有索引" class="headerlink" title="为什么要有索引"></a>为什么要有索引</h3><p>查询快! 查询快！ 查询快！</p>
<h3 id="MongoDB的10种索引"><a href="#MongoDB的10种索引" class="headerlink" title="MongoDB的10种索引?"></a>MongoDB的10种索引?</h3><p>创建索引语法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.&lt;collection_name&gt;.createIndex( &lt;key and index type specification&gt;, &lt;options&gt; )</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>我们的record Collection存在如下document</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_id&quot;: ObjectId(&quot;570c04a4ad233577f97dc459&quot;),</span><br><span class="line">  &quot;score&quot;: 1034,</span><br><span class="line">  &quot;userId&quot;: 123,</span><br><span class="line">  &quot;location&quot;: &#123; state: &quot;ZH&quot;, city: &quot;ChengDu&quot; &#125;,</span><br><span class="line">  &quot;addr&quot;: [</span><br><span class="line">    &#123;zip: &quot;10036&quot;, detail: &quot;高家村五组&quot;&#125;,</span><br><span class="line">    &#123;zip: &quot;94231&quot;, detail: &quot;王家镇三组701&quot;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="id索引"><a href="#id索引" class="headerlink" title="_id索引"></a>_id索引</h4><p>mongodb会自动为document中的_id字段加上索引，所以能用_id查询就用_id查询</p>
<h4 id="单键索引"><a href="#单键索引" class="headerlink" title="单键索引"></a>单键索引</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.records.createIndex( &#123; score: 1 &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.records.createIndex( &#123; userId: 1, score: 1&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="多值索引"><a href="#多值索引" class="headerlink" title="多值索引"></a>多值索引</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.records.createIndex( &#123; &quot;addr.zip&quot;: 1 &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="地理空间索引"><a href="#地理空间索引" class="headerlink" title="地理空间索引"></a>地理空间索引</h4><p>MongoDB为坐标平面查询提供了专门的索引，称为地理空间索引。这种查询需要两个维度，所以参数是2d。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.map.ensureIndex(&#123;&quot;gps&quot; : &quot;2d&quot;&#125;);</span><br></pre></td></tr></table></figure>
<p>gps键的值必须是某种形式的一对值：一个包含2个元素的数组或者是包含2个键的内嵌文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;gps&quot; : [0,100]&#125;</span><br><span class="line">&#123;&quot;gps&quot; : &#123;&quot;x&quot; : -30 , &quot;y&quot; : 30&#125;&#125;</span><br><span class="line">&#123;&quot;gps&quot; : &#123;&quot;latitude&quot; : -180, &quot;longitude&quot; : 180 &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>至于键名可以随意。默认情况下，地理空间索引假设值范围是-180~180(对经纬度来说很方便),我们同样可以使用参数来对索引进行定制,比如下面的星图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.star.trek.ensureIndex(&#123;&quot;light-years&quot; : &quot;2d&quot;&#125; , &#123;&quot;min&quot; : -1000, &quot;max&quot; : 1000, bits；10&#125;， &#123;collation: &#123;locale: &quot;simple&quot;&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的bits指定的是索引精度，默认情况下2d index使用的是26位精度，在默认范围-180~180中,大约等于60cm误差，最大可以设置32位精度。<br>索引精度不影响查询精度，降低精度的优点是插入操作的处理开销较低，并且占用的空间更少。较高精度的优点是查询扫描索引的较小部分以返回结果。</p>
<p>collation(排序规则)允许用户为字符串比较指定特定于语言的规则，例如字母和重音符号的规则。</p>
<p>地理空间的查询需要$near，它需要两个目标值的数组作为参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.map.find(&#123;&quot;gps&quot; : &#123;&quot;$near&quot; : [40,-73]&#125;&#125;).limit(10);</span><br></pre></td></tr></table></figure>
<p>默认查100个文档，如果不需要这么多，就应该设置一个少点的值以节约资源。</p>
<p>还可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.runCommand(&#123;geoNear : &quot;map&quot;, near: [40,-73],num : 10&#125;)</span><br></pre></td></tr></table></figure>
<p>geoNear的方式会返回每个文档到查询点的距离。</p>
<p>还可以查询矩形和圆形内所有的点,这个时候就要将原来的$near换成$geoWithin .<br>对于矩形要使用$box选项，它的参数是2个元素的数组，第一个元素指定了左下角坐标，第二个指定了右上角坐标</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.map.find(&#123;&quot;gps&quot; : &#123;&quot;$geoWithin &quot; : &#123;&quot;$box&quot; : [[10,20],[15,30]]&#125;&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>如果要查询圆形，则要使用$center，参数变成了圆心和半径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.map.find(&#123;&quot;gps&quot; : &#123;&quot;$geoWithin &quot; : &#123;&quot;$center&quot; : [[12,25],5]&#125;&#125;&#125;);</span><br></pre></td></tr></table></figure>


<p>地理空间查询既可以使用平面几何，也可以使用球面几何，根据使用的查询和索引类型来决定。 2dsphere 索引只能支持球面几何，而 2d索引同时支持平面和球面几何。<br>然而，在 2dsphere索引上使用球面几何的查询将会更高效和准确。</p>
<blockquote>
<p>2dsphere : <a href="https://docs.mongodb.com/manual/core/2dsphere/">https://docs.mongodb.com/manual/core/2dsphere/</a></p>
</blockquote>
<p>它的应用场景可以是 查找附近美食，查找附近停车场等数据。</p>
<h4 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h4><p>创建索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.&lt;collection_name&gt;.createIndex(&#123;&lt;key&gt;: &quot;text&quot;&#125;);</span><br></pre></td></tr></table></figure>

<p>查询数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.&lt;collection_name&gt;.find( &#123; $text: &#123; $search: &quot;green&quot; &#125; &#125; );</span><br></pre></td></tr></table></figure>

<p>查询以及排序:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.&lt;collection_name&gt;.find(</span><br><span class="line">&#123;</span><br><span class="line"> &quot;$text&quot;: &#123;</span><br><span class="line">    &quot;$search&quot;: &quot;green&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;textScore&quot;: &#123;</span><br><span class="line">    &quot;$meta&quot;: &quot;textScore&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">).sort(&#123;</span><br><span class="line">  &quot;textScore&quot;: &#123;</span><br><span class="line">    &quot;$meta&quot;: &quot;textScore&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意这里的textScore并不是集合中的某个字段，而是mongodb根据搜索结果计算该条数据的分数(匹配度预告,值越大)</p>
<h4 id="TTL索引"><a href="#TTL索引" class="headerlink" title="TTL索引"></a>TTL索引</h4><p>我在之前的文章讲到过这个<a href="https://juejin.im/post/5d4241d0e51d4561f95ee9c4">索引</a>，它实际上是一个具有生命周期的索引,这种索引允许为每一个文档设置一个超时时间。一个文档达到预设置的老化程度后就会被删除。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.user_session.createIndex(&#123;&quot;updated&quot;:1&#125;,&#123;expireAfterSeconds:60*60*24&#125;);</span><br></pre></td></tr></table></figure>
<p>如果一个文档的updated字段存在并且它的值是日期类型，当服务器时间比文档的updated字段的时间晚expireAfterSeconds秒时，文档就会被删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.getCollection(&#39;user_session&#39;).insert(</span><br><span class="line">  &#123;</span><br><span class="line">    _id: NumberInt(1),</span><br><span class="line">    &quot;updated&quot;:new Date(),</span><br><span class="line">     username:&#39;lisi&#39;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="部分索引"><a href="#部分索引" class="headerlink" title="部分索引"></a>部分索引</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.&lt;collection_name&gt;.createIndex(</span><br><span class="line">&#123;&#39;wechat&#39;: 1 &#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;partialFilterExpression&quot;: &#123;</span><br><span class="line">    &quot;wechat&quot;: &#123;</span><br><span class="line">      &quot;$exists&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的索引表示对存在wechat字段的文档进行索引。部分索引仅索引集合中符合指定过滤器表达式的文档，降低了索引创建和维护的性能成本。</p>
<p>部分索引提供了稀疏索引功能的超集，应优先于稀疏索引使用</p>
<h4 id="稀疏索引"><a href="#稀疏索引" class="headerlink" title="稀疏索引"></a>稀疏索引</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.addresses.createIndex( &#123; &quot;xmpp_id&quot;: 1 &#125;, &#123; sparse: true &#125; )</span><br></pre></td></tr></table></figure>
<p>索引不索引不包含xmpp_id字段的文档。</p>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.createIndex( &#123; _id: &quot;hashed&quot; &#125;)</span><br></pre></td></tr></table></figure>
<p>哈希索引指按照某个字段的hash值来建立索引，目前主要用于MongoDB Sharded Cluster的Hash分片，hash索引只能满足字段完全匹配的查询，不能满足范围查询</p>
<h3 id="后台方式创建索引"><a href="#后台方式创建索引" class="headerlink" title="后台方式创建索引"></a>后台方式创建索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.&lt;collection_name&gt;.createIndex( &lt;key and index type specification&gt;, &#123;background: true&#125;)</span><br></pre></td></tr></table></figure>

<p>建立索引即耗时也费力，还需要消耗很多资源。使用{background: true}选项可以使这个过程在后台完成，同时正常处理请求。要是不包括这个选项，数据库会阻塞建立索引期间的所有请求。<br>阻塞的做法会让索引建立得更快，同时也意味着应用在此期间不能应答。即便后台进行也会对正常操作有些影响，所以最好选在无关紧要的时刻。后台创建索引也会增加负载，好在不会让服务器宕机。</p>
<p>不过从4.2版本开始,所有索引构建都使用优化的构建过程，该过程仅在构建过程的开始和结束时才持有排他锁。其余的构建过程将产生交错的读写操作。如果指定该属性，MongoDB将忽略这个选项。</p>
]]></content>
      <tags>
        <tag>MongoDB</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB的锁事</title>
    <url>/2019/07/05/mongodb-locks/</url>
    <content><![CDATA[<p>MongoDB有4个粒度级别的锁</p>
<ol>
<li>Global(MongoD 实例) – 所有的数据库上加锁</li>
<li>Database – 锁定某个数据库</li>
<li>Collection – 锁定某个集合</li>
<li>Document – 锁定某个文档</li>
</ol>
<p>MongoDB本身只提供Global,Database,Collection三个级别的锁,Document级别的锁是由存储引擎提供的(Wired Tiger提供了Document级别的锁)</p>
<a id="more"></a>

<p>MongoDB允许多个客户端读取和写入相同的数据。为了确保一致性，它使用锁和其他并发控制措施来防止多个客户端同时修改同一条数据。总之，这些机制保证对单个文档的所有写入完全或根本不发生，并且客户端永远不会看到数据的不一致视图。如果你想保证多个文档的并发性,就需要使用事务,MongoDB从4.0版本开始支持多文档事务(包括复制集),但是对分片集群的事务支持要从4.2版本才开始支持。</p>
<p>MongoDB使用<strong>多粒度锁</strong>，允许操作锁定全局，数据库或集合级别，并允许各个存储引擎在集合级别下实现自己的并发控制(例如WiredTiger提供了文档级别的锁)。MongoDB使用读写锁，并且允许并发读共享对资源(database或者collection)的访问。</p>
<p>除了用于读取的共享(S)锁(读锁)和用于写入操作的排它(X)锁(写锁)之外，意向共享(IS)和意向排它(IX)锁表示使用更精细的粒度锁定读取或写入资源的意图。但我们锁定某个资源的时候，使用意向锁来锁定比它更高级别的资源，这也是多粒度锁的核心。</p>
<p>对一个数据行或者document加意向锁的含义是:当前事务想要在这个节点或者这个节点的子节点加某种锁(共享或者排它)，有了意向锁以后，对任何数据加共享锁或者排它锁都要先加意向锁再加具体锁。</p>
<p><img data-src="/images/mongodb/node.png" alt="节点"></p>
<p>当我们对d1这个document进行写入的时候，需要给它加上X锁(排它锁),这个时候要先去它上层的资源Global,D1(database),C1(collection)加上IX(意向排它锁),加了之后才能在d1上加实际的排它锁。如果实际的锁加在C1等非叶子节点情况也是一样的。</p>
<p>加意向锁最主要的作用就是在加实际的锁的时候，通过检查父节点是否已经存在了意向锁来确定当前是否可以加上锁。</p>
<p>比如d1上持有了实际的排它锁，这个时候C1,D1,Global都有一个意向排它锁。此时如果有另外的请求想要在C1上加实际的共享锁(读),但是C1已经有了意向排它锁了,所以就加不成了，需要等待。</p>
<p>如果此时想要在d2上加共享锁。此时需要先去它的上层节点添加意向共享锁,虽然C1,D1已经存在了意向排它锁，但是仍然可以加上意向共享锁，因为它们是兼容的。</p>
<p>把意向锁的相容性和实际锁放进一个表格进行对别下：</p>
<table>
<thead>
<tr>
<th></th>
<th>IS(意向共享)</th>
<th>IX(意向排它)</th>
<th>S(共享)</th>
<th>X(排它)</th>
</tr>
</thead>
<tbody><tr>
<td>IS(意向共享)</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>IX(意向排它)</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>S(共享)</td>
<td>true</td>
<td>false</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>X(排它)</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
</tbody></table>
<p>对于大多数读写操作，WiredTiger存储引擎使用乐观并发控制。WiredTiger仅在全局，数据库和集合级别使用意向锁。当存储引擎检测到两个操作之间的冲突时，会发生写入冲突，导致MongoDB透明地重试该操作。一些全局操作(通常是涉及多个数据库的短期操作)仍然需要全局“实例范围”锁定。其他一些操作（例如删除集合）仍需要独占数据库锁。</p>
<p>我们MongoDB中使用db.serverStatus()或者db.currentOp()命令的输出中，锁模式表示如下：</p>
<table>
<thead>
<tr>
<th>锁模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>共享锁(S)</td>
</tr>
<tr>
<td>W</td>
<td>排它锁(X)</td>
</tr>
<tr>
<td>r</td>
<td>意向共享锁(IS)</td>
</tr>
<tr>
<td>w</td>
<td>意向排它锁(IX)</td>
</tr>
</tbody></table>
<p>所以我们要注意对应关系,不要弄错了。下面的表格列出了一些操作以及它们用于文档级锁定存储引擎的锁类型：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>Database</th>
<th>Collection</th>
</tr>
</thead>
<tbody><tr>
<td>query</td>
<td>r(意向共享锁)</td>
<td>r(意向共享锁)</td>
</tr>
<tr>
<td>insert</td>
<td>w(意向排它锁)</td>
<td>w(意向排它锁)</td>
</tr>
<tr>
<td>remove</td>
<td>w(意向排它锁)</td>
<td>w(意向排它锁)</td>
</tr>
<tr>
<td>update</td>
<td>w(意向排它锁)</td>
<td>w(意向排它锁)</td>
</tr>
<tr>
<td>aggregation(聚合)</td>
<td>r(意向共享锁)</td>
<td>r(意向共享锁)</td>
</tr>
<tr>
<td>create an index(前台)</td>
<td>W(排它锁)</td>
<td></td>
</tr>
<tr>
<td>create an index(后台)</td>
<td>w(意向排它锁)</td>
<td>w(意向排它锁)</td>
</tr>
<tr>
<td>list collections</td>
<td>r(意向共享锁)</td>
<td></td>
</tr>
<tr>
<td>map-reduce</td>
<td>W(排它锁) 以及 R(共享锁)</td>
<td>w(意向排它锁)以及r(意向共享锁)</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 复制集那点事儿</title>
    <url>/2019/10/30/mongodb-replica-set/</url>
    <content><![CDATA[<h3 id="何以高可用"><a href="#何以高可用" class="headerlink" title="何以高可用?"></a>何以高可用?</h3><p>我们以前用Mysql的时候，经常是一台服务器走天下，如果只是用于学习，是没有问题的，但是在生产环境中，这样的风险是很大的，如果服务器因为网络原因或者崩溃了，就会导致数据库一段时间了不可用，这样的体验很不好。</p>
<p>那么应该怎么办呢？既然一台机器不行，我就多上几台机器总可以了吧，比如我上个两台，让他们互为主备，相互同步数据。想到这里我就只想说一个字，稳。</p>
<blockquote>
<p>其实redis,mongodb,kafka等分布式应用基本上都是这样的思想</p>
</blockquote>
<p>MongoDB也差不多是这样的思想。它通过复制集来解决这个问题,MongoDB复制集由一组Mongod进程组成，包含一个Primary节点和多个Secondary节点，Mongodb Driver(客户端)的所有数据都写入Primary，Secondary从Primary同步写入的数据，以保持复制集内所有成员存储相同的数据集，提供数据的高可用。</p>
<p>要想成为primary节点，你必须保证大多数节点都同意才行,大多数的节点就是副本中一半以上的成员。</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>成员总数</th>
<th>大多数</th>
<th>容忍失败数</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>4</td>
<td>3</td>
</tr>
</tbody></table>
<p>为什么要要求大多数呢？其实是为了避免出现两个primary节点。比如一个五个节点的复制集，其中3个成员不可用，剩下的2个仍然正常工作。这两个工作的节点由于不能满足复制集大多数的要求（这个例子中要求要有3个节点才是大多数)，所以他们无法选择主节点，即使其中有一个节点是primary节点，当它注意到它无法获取大多数节点的支持时，它就会退位，成为备份节点。</p>
<p>如果让这两个节点可以选出primary节点，问题是另外3个节点可能不是真正挂了，而只是网络不可达而已。另外3个节点就一定可以选择出primary节点，这样就存在了两个primary节点了。<br>所以要求大多数就可以避免产生两个primary节点的问题。</p>
<blockquote>
<p>如果MongoDB副本集可以拥有多个primary节点,那么就会面临写入冲突的问题，在支持多线程写入的系统中解决冲突的方式有手动解决和让操作系统任选一个这两种方式，但是这两种方式都不易实现，无法保证写入的数据不被其他节点修改，因此mongodb只支持单一的primary节点，这样使得开发更容易。</p>
</blockquote>
<p>当一个备份节点无法与主节点连通时，它会联系并请求其他副本集成员将自己选举为主节点，其他成员会做几项理性的检查：自身是否能够与主节点连通？希望被选举为主节点的备份节点的数据是否最新？有没有其他更高优先级的成员可以被选举为主节点？<br>如果竞选节点成员能够得到大多数投票，就会成为主节点。但是一旦大多数成员中只有一个否决了本次选举，选举就会取消。</p>
<blockquote>
<p>在日志中可以看到得票数为比较大的负数的情况，因为一张否决票相当于10000张赞成票。如果有2张赞成票，2张否决票，那么选举结果就是-19998，依此类推。</p>
</blockquote>
<h3 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h3><p>我们一般在部署的时候，副本集节点个数至少是3个(因为它允许1个失败),这也就意味着数据要被复制三份。<br><img data-src="/images/mongodb/1-primary-2-secondary.png"></p>
<h4 id="仲裁者-arbiter"><a href="#仲裁者-arbiter" class="headerlink" title="仲裁者(arbiter)"></a>仲裁者(arbiter)</h4><p>很多人的应用程序使用量比较小，不想保存三份数据，只想要保存两份就行了，保存第三份纯粹是浪费。对于这种部署MongoDB也是支持的。它有一种特殊的成员叫做仲裁者(arbiter)，它唯一的作用就是参与选举，它既不保存数据也不为客户端提供服务，只是为了帮助只有两个成员的副本集满足大多数这个条件而已。<br><img data-src="/images/mongodb/arbiter.png" alt="arbiter"></p>
<blockquote>
<p>仲裁者其实也是有缺点的。如果真有一个节点挂了(数据无法恢复),另一个成员称为主节点。为了数据安全，就需要一个新的备份节点，并且将主节点的数据备份到备份节点。复制数据会对服务器造成很大的压力，会拖慢应用程序。相反如果有三个数据成员即使其中一个挂了，仍有一个主节点和一个备份节点，不影响正常运作。这个时候还可以用剩下的那个备份节点来初始化一个新的备份节点服务器，而不依赖于主节点。所以如果可能尽可能在副本集中使用奇数个数据成员，而不要使用仲裁者。</p>
</blockquote>
<h4 id="优先级-priority"><a href="#优先级-priority" class="headerlink" title="优先级(priority)"></a>优先级(priority)</h4><p>如果想让一个节点有更大的机会成为primary的话这需要设置优先级，比如我添加一个优先级为2的成员(默认为1)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rs.add(&#123;&quot;_id&quot;:4, &quot;host&quot;: &quot;10.17.28.190:27017&quot;, &quot;priority&quot; : 2&#125;);</span><br></pre></td></tr></table></figure>

<p>假设其他都是默认优先级，只要10.17.28.190拥有最新数据，那么当前primary节点就会自动退位，10.17.28.190会被选举为新的主节点。如果它的数据不够新，那么当前主节点就会保持不变。</p>
<p>如果设置priority为0，表示不会被选为primary节点。</p>
<h4 id="投票权-vote"><a href="#投票权-vote" class="headerlink" title="投票权(vote)"></a>投票权(vote)</h4><p>由于复制集成员最多50个,而参与Primary成员投票的最多7个,所以其他成员的vote必须设置为0(priority也必须为0)。<br>尽管无投票权的成员不会在选举中投票，但这些成员拥有副本集数据的副本，并且可以接受来自客户端应用程序的读取操作。</p>
<h4 id="隐藏成员-hidden"><a href="#隐藏成员-hidden" class="headerlink" title="隐藏成员(hidden)"></a>隐藏成员(hidden)</h4><p>客户端不会像隐藏成员发送请求，隐藏成员也不会作为复制源(尽管当其他复制源不可用时隐藏成员)。因此很多人将不够强大的服务器或者备份服务器隐藏起来。通过设置hidden:true可以设置隐藏，只有优先级为0的才能被隐藏。<br>可使用Hidden节点做一些数据备份、离线计算的任务，不会影响复制集的服务</p>
<h4 id="延迟备份节点-slaveDelay"><a href="#延迟备份节点-slaveDelay" class="headerlink" title="延迟备份节点(slaveDelay)"></a>延迟备份节点(slaveDelay)</h4><p>数据可能会因为人为错误而遭到毁灭性的破坏，为了防止这类问题，可以使用slaveDelay设置一个延迟的备份节点。</p>
<p>延迟备份节点的数据回比主节点延迟指定的时间(单位是秒),slaveDelay要求优先级是0，如果应用会将读请求路由到备份节点，应该将延迟备份节点隐藏掉，以免读请求被路由到延迟备份节点。</p>
<p>因Delayed节点的数据比Primary落后一段时间，当错误或者无效的数据写入Primary时，可通过Delayed节点的数据来恢复到之前的时间点。</p>
<h4 id="修改副本集配置"><a href="#修改副本集配置" class="headerlink" title="修改副本集配置"></a>修改副本集配置</h4><p>比如我有个副本集叫做rs0,我想修改增加或者删除成员，修改成员的配置(vote,hidden,priority等)可以通过reconfig命令</p>
<blockquote>
<p><a href="https://docs.mongodb.com/manual/reference/method/rs.reconfig/">https://docs.mongodb.com/manual/reference/method/rs.reconfig/</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cfg &#x3D; rs.conf();</span><br><span class="line">cfg.members[1].priority &#x3D; 2;</span><br><span class="line">rs.reconfig(cfg);</span><br></pre></td></tr></table></figure>

<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>Primary与Secondary之间通过oplog来同步数据，Primary上的写操作完成后，会向特殊的local.oplog.rs特殊集合写入一条oplog，Secondary不断的从Primary取新的oplog并应用。</p>
<p>因oplog的数据会不断增加，local.oplog.rs被设置成为一个capped集合，当容量达到配置上限时，会将最旧的数据删除掉。由于复制操作的过程是先复制数据在写入oplog，oplog必须具有幂等性，即重复应用也会得到相同的结果。</p>
<p>我向test库的coll集合插入了一条数据之后(<code>db.coll.insert(&#123;count:1&#125;)</code>)，调用db.isMaster()命令可以看到当前节点的最后一次写入时间戳</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; db.isMaster()</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ismaster&quot; : true,</span><br><span class="line">  &quot;secondary&quot; : false,</span><br><span class="line">  &quot;lastWrite&quot; : &#123;</span><br><span class="line">    &quot;opTime&quot; : &#123;</span><br><span class="line">            &quot;ts&quot; : Timestamp(1572509087, 2),</span><br><span class="line">            &quot;t&quot; : NumberLong(1)</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;lastWriteDate&quot; : ISODate(&quot;2019-10-31T08:04:47Z&quot;),</span><br><span class="line">    &quot;majorityOpTime&quot; : &#123;</span><br><span class="line">            &quot;ts&quot; : Timestamp(1572509087, 2),</span><br><span class="line">            &quot;t&quot; : NumberLong(1)</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;majorityWriteDate&quot; : ISODate(&quot;2019-10-31T08:04:47Z&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>命令会返回很多数据，这里我只列出了小部分，可以看到我们当前所在节点是master节点(primary),如果当前节点不是primary,也会通过primary属性告诉你当前primary节点是哪个,同时最后一次写入的时间戳是1572509087。</p>
<p>此时我们登录另一台secondary节点,切换到local数据库,执行命令<code>db.oplog.rs.find()</code>命令,会返回很多条数据，这里我们查看最后一条即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  &quot;ts&quot; : Timestamp(1572509087, 2), </span><br><span class="line">  &quot;t&quot; : NumberLong(1), </span><br><span class="line">  &quot;h&quot; : NumberLong(&quot;6139682004250579847&quot;), </span><br><span class="line">  &quot;v&quot; : 2, </span><br><span class="line">  &quot;op&quot; : &quot;i&quot;, </span><br><span class="line">  &quot;ns&quot; : &quot;test.coll&quot;, </span><br><span class="line">  &quot;ui&quot; : UUID(&quot;1be7f8d0-fde2-4d68-89ea-808f14b326da&quot;), </span><br><span class="line">  &quot;wall&quot; : ISODate(&quot;2019-10-31T08:04:47.925Z&quot;), </span><br><span class="line">  &quot;o&quot; : &#123; </span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;5dba959fcf287dfd8727a1bf&quot;), </span><br><span class="line">    &quot;count&quot; : 1 </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到oplog的ts和isMater()命令返回的lastTime.opTime.ts的值是一致的,证明我们的数据是最新的，如果你这个时候访问其他节点查看oplog.rs的数据，会发现数据是一模一样的。<br>在来解释下字段含义</p>
<ul>
<li>ts : 操作时间，当前timestamp + 计数器，计数器每秒都被重置</li>
<li>h：操作的全局唯一标识</li>
<li>v：oplog版本信息</li>
<li>op：操作类型<ul>
<li>i：插入操作</li>
<li>u：更新操作</li>
<li>d：删除操作</li>
<li>c：执行命令（如createDatabase，dropDatabase）</li>
</ul>
</li>
<li>n：空操作，特殊用途</li>
<li>ns：操作针对的集合</li>
<li>o：操作内容，可以看到我这里插入的字段是count，值是1</li>
<li>o2：操作查询条件，仅update操作包含该字段</li>
</ul>
<h4 id="初始化同步"><a href="#初始化同步" class="headerlink" title="初始化同步"></a>初始化同步</h4><p>副本集中的成员启动之后，就会检查自身状态，确定是否可以从某个成员那里进行同步。如果不行的话，它会尝试从副本的另一个成员那里进行完整的数据复制。这个过程就是初始化同步(initial syncing)。</p>
<p>init sync过程包含如下步骤</p>
<ol>
<li>准备工作删除所有已存在的数据库，以一个全新的状态开始同步</li>
<li>将同步源的所有记录全部复制到本地(除了local)</li>
<li>oplog同步第一步,克隆过程中的所有操作都会被记录到oplog中，如果有文档在克隆过程中被移动了，就有可能会被遗漏，导致没有被克隆，对于这样的文档，可能需要重新克隆</li>
<li>oplog同步过程第二步，将第一个oplog同步中的操作记录下来</li>
<li>创建索引</li>
<li>如果当前节点的数据仍然远远落后于同步源，那么oplog同步过程的最后一步就是将创建索引期间的所有操作全部同步过来，防止该成员成为备份节点。</li>
<li>完成初始化同步之后，切换到普通同步状态，这时当前成员就可以称为备份节点了。</li>
</ol>
<p>总结起来就是从其他节点同步全量数据，然后不过从Primary的local.oplog.rs集合里查询最新的oplog并应用到自身。</p>
<blockquote>
<p>查询固定集合使用的tailable cursor(<a href="https://docs.mongodb.com/manual/core/tailable-cursors/">https://docs.mongodb.com/manual/core/tailable-cursors/</a>)</p>
</blockquote>
<h3 id="Primary选举"><a href="#Primary选举" class="headerlink" title="Primary选举"></a>Primary选举</h3><p>Primary选举除了在复制集初始化时发生，还有如下场景</p>
<ol>
<li>复制集reconfig</li>
<li>Secondary节点检测到Primary宕机时，会触发新Primary的选举</li>
<li>当有Primary节点主动stepDown（主动降级为Secondary）时，也会触发新的Primary选举</li>
</ol>
<p>Primary的选举受节点间心跳、优先级、最新的oplog时间等多种因素影响。</p>
<h4 id="节点间心跳"><a href="#节点间心跳" class="headerlink" title="节点间心跳"></a>节点间心跳</h4><p>复制集成员间默认每2s会发送一次心跳信息，如果10s未收到某个节点的心跳，则认为该节点已宕机；如果宕机的节点为Primary，Secondary（前提是可被选为Primary）会发起新的Primary选举。</p>
<blockquote>
<p>心跳是为了知道其他成员状态,哪个是主节点，哪个可以作为同步源，哪个挂掉了等等信息</p>
</blockquote>
<p>成员状态:</p>
<ol>
<li>STARTUP : 刚启动时处于这个状态，加载副本集成功后就进入STARTUP2状态</li>
<li>STARTUP2 : 整个初始化同步都处于这个状态，这个状态下，MongDB会创建几个线程，用于处理复制和选举，然后就会切换到RECOVERING状态</li>
<li>RECOVERING : 表示运行正常，当暂时不能处理读取请求。如果有成员处于这个状态，可能会造成轻微系统过载</li>
<li>ARBITER : 仲裁者处于这个状态</li>
<li>DOWN : 一个正常运行的成员不可达，就处于DOWN状态。这个状态有可能是网络问题</li>
<li>UNKNOWN : 成员无法到达其他任何成员，其他成员就知道无法它处于什么状态，就会处于UNKNOWN。表明这个未知状态的成员挂掉了。或者两个成员间存在网络访问问题。</li>
<li>REMOVED : 被移除副本集时处于的状态,添加回来后，就会回到正常状态</li>
<li>ROLLBACK : 处于数据回滚时就处于ROLLBACK状态。回滚结束后，会换为RECOVERING状态，然后成为备份节点。</li>
<li>FATAL : 发生不可挽回错误，也不再尝试恢复，就处于这个状态。这个时候通常应该重启服务器</li>
</ol>
<h4 id="节点优先级"><a href="#节点优先级" class="headerlink" title="节点优先级"></a>节点优先级</h4><ol>
<li>每个节点都倾向于投票给优先级最高的节点</li>
<li>优先级为0的节点不会主动发起Primary选举</li>
<li>当Primary发现有优先级更高Secondary，并且该Secondary的数据落后在10s内，则Primary会主动降级，让优先级更高的Secondary有成为Primary的机会。</li>
</ol>
<h4 id="OpTime"><a href="#OpTime" class="headerlink" title="OpTime"></a>OpTime</h4><p>最新optime（最近一条oplog的时间戳）的节点才能被选为主,请看上面对oplog.rs的分析。</p>
<h4 id="网络分区"><a href="#网络分区" class="headerlink" title="网络分区"></a>网络分区</h4><p>只有大多数投票节点间保持网络连通，才有机会被选Primary；如果Primary与大多数的节点断开连接，Primary会主动降级为Secondary。当发生网络分区时，可能在短时间内出现多个Primary，故Driver在写入时，最好设置<strong>大多数成功</strong>的策略，这样即使出现多个Primary，也只有一个Primary能成功写入大多数。</p>
<h3 id="复制集的读写设置"><a href="#复制集的读写设置" class="headerlink" title="复制集的读写设置"></a>复制集的读写设置</h3><h4 id="Read-Preference"><a href="#Read-Preference" class="headerlink" title="Read Preference"></a>Read Preference</h4><p>默认情况下，复制集的所有读请求都发到Primary，Driver可通过设置Read Preference来将读请求路由到其他的节点。</p>
<ol>
<li>primary： 默认规则，所有读请求发到Primary</li>
<li>primaryPreferred： Primary优先，如果Primary不可达，请求Secondary</li>
<li>secondary： 所有的读请求都发到secondary</li>
<li>secondaryPreferred：Secondary优先，当所有Secondary不可达时，请求Primary</li>
<li>nearest：读请求发送到最近的可达节点上（通过ping探测得出最近的节点）</li>
</ol>
<h4 id="Write-Concern"><a href="#Write-Concern" class="headerlink" title="Write Concern"></a>Write Concern</h4><p>默认情况下，Primary完成写操作即返回，Driver可通过设置<a href="https://docs.mongodb.org/manual/core/write-concern/">Write Concern</a>来设置写成功的规则。</p>
<p>如下的write concern规则设置写必须在大多数节点上成功，超时时间为5s。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.products.insert(</span><br><span class="line">  &#123; item: &quot;envelopes&quot;, qty : 100, type: &quot;Clasp&quot; &#125;,</span><br><span class="line">  &#123; writeConcern: &#123; w: majority, wtimeout: 5000 &#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>上面的设置方式是针对单个请求的，也可以修改副本集默认的write concern，这样就不用每个请求单独设置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cfg &#x3D; rs.conf()</span><br><span class="line">cfg.settings &#x3D; &#123;&#125;</span><br><span class="line">cfg.settings.getLastErrorDefaults &#x3D; &#123; w: &quot;majority&quot;, wtimeout: 5000 &#125;</span><br><span class="line">rs.reconfig(cfg)</span><br></pre></td></tr></table></figure>
<h3 id="回滚（rollback）"><a href="#回滚（rollback）" class="headerlink" title="回滚（rollback）"></a>回滚（rollback）</h3><p>Primary执行了一个写请求之后挂了，但是备份节点还没有来得及复制这次操作。新选举出来的主节点结就会漏掉这次写操作。当旧Primary恢复之后，就要回滚部分操作。</p>
<p>比如一个复制集存在两个数据中心,DC1中存在A(primary),B两个节点,DC2中存在C,D,E这三个节点。<br>如果DC1出现了故障。其中DC1这个数据中心的最后的操作是126,但是126没有被复制到另外的数据中心。所以DC2中服务器最新的操作是125</p>
<p>DC2的数据中心仍然满足副本集大多数的要求(5台，DC2有3台),因此其中一个会被选举成为新的主节点，这个节点会继续处理后续的写入操作。<br>当网络恢复之后，DC1中心的服务器就会从其他服务器同步126之后的操作，但是无法找到。这种时候DC1中的A,B就会进入回滚过程。</p>
<p>回滚回将失败之前未复制的操作撤销。拥有126操作的服务器会在DC2的服务器的oplog寻找共同的操作点。这里会定位125，这是两个数据中心相匹配的最后一个操作。</p>
<p>这时，服务器会查看这些没有被复制的操作，将受这些操作影响的文档写入一个.bson文件，保存在数据目录下的rollback目录中。</p>
<p>如果126是一个更新操作，服务器回将126更新的文档写入collectionName.bson文件。如果想要恢复被回滚的操作，可以使用mongorestore命令。</p>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB中的定时索引</title>
    <url>/2019/07/15/mongodb-ttl-index/</url>
    <content><![CDATA[<p>MongoDB中存在一种索引,叫做TTL索引(time-to-live index,具有生命周期的索引)，这种索引允许为每一个文档设置一个超时时间。一个文档达到预设置的老化程度后就会被删除。<br>数据到期对于某些类型的信息非常有用，例如机器生成的事件数据，日志和会话信息，这些信息只需要在数据库中保存有限的时间。</p>
<p>在createIndex中指定expireAfterSeconds选项就可以创建一个TTL索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 超时时间为24小时,默认是前台运行，可以通过background:true设置为后台模式</span><br><span class="line">db.user_session.createIndex(&#123;&quot;updated&quot;:1&#125;,&#123;expireAfterSeconds:60*60*24&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>这样在updated字段上创建了一个TTL索引。如果一个文档的updated字段存在并且它的值是日期类型，当服务器时间比文档的updated字段的时间晚expireAfterSeconds秒时，文档就会被删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.getCollection(&#39;user_session&#39;).insert(</span><br><span class="line">  &#123;</span><br><span class="line">    _id: NumberInt(1),</span><br><span class="line">    &quot;updated&quot;:new Date(),</span><br><span class="line">     username:&#39;lisi&#39;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>mongodb保存时间使用的UTC时间，在查询出来的结果的时候会转换为GMT时间，所以你看到保存的时间和电脑时间相差8个小时(GMT+8)<br>db.getCollection(‘user_session’).find({updated:{$gt: new Date(“2019-07-12 14:00:00”)}})  在查询的时候可以使用new Date()直接进行时间的比较，new Date传入的参数是GMT时间</p>
</blockquote>
<p>为了防止活跃的会话被删除，可以在会话上有活动发生时将updated字段的值更新为当前时间。只要updated的时间距离当前时间达到24小时。相应的文档就会被删除。</p>
<p>MongoDB的TTL功能依赖于mongodb中的后台线程，该线程读取索引中的日期类型值并从集合中删除过期的文档。<br>MongoDB每分钟对TTL索引进行一次清理，所以不应该依赖以秒为单位的时间保证索引的存活状态。而且TTL索引不保证在到期时立即删除过期数据。文档到期的时间与MongoDB从数据库中删除文档的时间之间可能存在延迟。由于删除过期文档的后台任务每60秒运行一次。所以，文档可能在文档到期和后台任务运行之间的期间保留在集合中。</p>
<blockquote>
<p>源码在 <a href="https://github.com/mongodb/mongo/blob/master/src/mongo/db/ttl.cpp">https://github.com/mongodb/mongo/blob/master/src/mongo/db/ttl.cpp</a></p>
</blockquote>
<p>mongodb不支持使用createIndex来重新设置过期时间，只可以使用collMod命令修改expireAfterSeconds的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.runCommand(&#123;collMod:&quot;user_session&quot;,index: &#123;name:&quot;updated_1&quot;,expireAfterSeconds: 120&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>修改成功后，你会收到这样的消息(之前的过期时间是一分钟,现在修改为2分钟)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;expireAfterSeconds_old&quot; : 60.0,</span><br><span class="line">    &quot;expireAfterSeconds_new&quot; : 120.0,</span><br><span class="line">    &quot;ok&quot; : 1.0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在一个给定的集合上可以有多个TTL索引，你可以在created和updated字段分别建立ttl索引,但是不能同时使用两个字段建立复合ttl索引,也不能在同一个字段上又是创建TTL索引，又是创建普通索引，但是可以像“普通索引”一样用来优化排序和查询。</p>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot中使用profile的几种方式</title>
    <url>/2024/06/05/multi-profile-in-springboot/</url>
    <content><![CDATA[<p>最近项目中进行仓库拆分了之后,因为引入了公共包,所以就存在可能有snapshot版本以及release版本问题,比如我想要在dev环境的时候import snapshot版本,prod环境的时候又使用release版本，为了不频繁修改pom.xml文件，因此决定使用POM的profile来解决这个问题。 </p>
<p>当然由于maven默认是不下载snapshot包的，因此我们要配置让它下载，这里分为全局配置和项目级别配置</p>
<h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>在pom文件中添加如下内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--修改成自己私服地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:18081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--主要是这里--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>在maven的settings.xml中新增配置,如果不配置profile，只配置mirror,是下载不了snapshot包的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>bv-profile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:18081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回到正题，如何使用maven的profile呢？</p>
<h3 id="maven-profile"><a href="#maven-profile" class="headerlink" title="maven profile"></a>maven profile</h3><p>同样的首先在pom.xml中新增配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">spring.profiles.active</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">spring.profiles.active</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bvpro.api.version</span>&gt;</span>2.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">bvpro.api.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">spring.profiles.active</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">spring.profiles.active</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bvpro.api.version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">bvpro.api.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定配置文件所在的resource目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>db/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>static/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>mapper/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 选择要打包的配置文件和日志，当然也可以不加打包所有配置文件，然后由具体服务器来选择使用哪个 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>bootstrap.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>bootstrap-$&#123;spring.profiles.active&#125;.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>logback.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>比如这里我就设定了两个profile(dev, prod), 然后他们引用某个包的版本不一样，然后应用包的时候这样使用就行了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bvpro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bvpro-common-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;bvpro.api.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后项目中的bootstrap.yml文件中修改如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Spring</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="comment"># 环境配置</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">@spring.profiles.active@</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后当我们打包的时候 <code>mvn clean package -P dev</code> 就可以打包dev环境的配置，同时 @spring.profiles.active@ 会被替换成dev</p>
<p>当然如果你使用idea的时候就更加简单了，只需要勾选profile=dev就行了。</p>
<h3 id="docker中使用"><a href="#docker中使用" class="headerlink" title="docker中使用"></a>docker中使用</h3><p>我们知道在使用dockerfile的时候也可以指定环境变量,然后启动的时候就可以根据环境变量来启动了,比如这样子</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8-jre-alpine</span><br><span class="line">ENV env_java_debug_enabled=<span class="literal">false</span></span><br><span class="line">EXPOSE 8080</span><br><span class="line">WORKDIR /app</span><br><span class="line">ADD target/smcp-web.jar /app/target/smcp-web.jar</span><br><span class="line">ADD run.sh /app</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Dspring.profiles.active=test&quot;</span>, <span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;target/smcp-web.jar&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后run.sh这样写:</p>
<p>可以看到我们在dockerfile中使用了ENV来指定我们要启动什么环境，但是这种方式太僵硬了, 因为相当于把启动什么环境给写死了，后面想要切换到其他环境的时候还要去修改dockerfile,这种方式看上去不太行呀</p>
<h3 id="SPRING-PROFILES-ACTIVE"><a href="#SPRING-PROFILES-ACTIVE" class="headerlink" title="SPRING_PROFILES_ACTIVE"></a>SPRING_PROFILES_ACTIVE</h3><p>好在springboot项目启动的时候会去读这样的一个特殊环境变量 SPRING_PROFILES_ACTIVE， 如果环境变量中配置了这个值，那么会根据这个值找到对应的profile, 然后启动对应的环境，所以我么可以在启动的时候指定这个环境变量就行了， 所以可以这样子</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8-jre-alpine</span><br><span class="line">ENV spring_profiles_active=dev</span><br><span class="line">ENV env_java_debug_enabled=<span class="literal">false</span></span><br><span class="line">EXPOSE 8080</span><br><span class="line">WORKDIR /app</span><br><span class="line">ADD target/smcp-web.jar /app/target/smcp-web.jar</span><br><span class="line">ADD run.sh /app</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;target/smcp-web.jar&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>这里预设了spring_profiles_active的值是dev,当启动的时候你可以更改这个值。</p>
<p>如果你使用docker-compose来启动,那么也可以在docker-compose文件中配置environment,比如</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">SPRING_PROFILES_ACTIVE=prod</span></span><br></pre></td></tr></table></figure>

<p>这就是指定profile的各种方式了，使用这种方式我们可以更加精确的控制我们需要启动的环境，并且还是最少的修改。</p>
]]></content>
      <tags>
        <tag>maven</tag>
        <tag>SpringBoot</tag>
        <tag>profile</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql必知必会读书笔记</title>
    <url>/2016/08/30/mysql-basic-note/</url>
    <content><![CDATA[<ol>
<li><p>查看有哪些库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前库中有哪些表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看表中有哪些列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">columns</span> <span class="keyword">from</span>  table_name;</span><br><span class="line"><span class="keyword">describe</span> table_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看服务器状态</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看建表语句或者创建数据库的语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> table_name</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> database_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用来显示授权用户的安全权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用来显示服务器错误或者警告</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">errors</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">warnings</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>limit语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 表示从第三行(包括)开始取值，取四条数据(mysql的行是从0开始的)</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table_name <span class="keyword">limit</span> <span class="number">3</span>,<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mysql5版本支持同样语义的写法:</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table_name <span class="keyword">limit</span> <span class="number">4</span> <span class="keyword">offset</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sql语句中使用全限定名称</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> table_name.column_name <span class="keyword">from</span> database_name.table_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>order by 的说明<br>order by 多个列的时候,只有当第一个列相同的时候,才会根据第二个列进行排序,以此类推,但是如果第一个列是唯一的话,<br>那么就不会根据其他列进行排序</p>
</li>
<li><p>mysql在执行匹配的时候默认不区分大小写</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这样可能查询出name=&#x27;li&#x27;的结果</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">&#x27;Li&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是否为空或者不为空</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>and的优先级大于or优先级</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 表示查询age &lt; 10的任何数据和(id = 13并且age &gt; 20)的数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> age &lt; <span class="number">10</span> <span class="keyword">or</span> <span class="keyword">id</span> = <span class="number">13</span> <span class="keyword">and</span> age &gt; <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>in和or的比较<br>in和or的作用一致,但是in比or更加清晰,而且一般来说in的效率比or高,而且in还可以包含子查询</p>
</li>
<li><p>使用通配符</p>
<ul>
<li>%表示任意字符出现任意次数,比如select id from table_name where name like ‘jack%’;表示查询所有名称为jack开头的数据<br>通配符可以在任意位置并且可以使用多个通配符,值得注意的是%代表搜索模式中给定位置的0个、1个或者多个字符。</li>
<li>_通配符只匹配一个字符</li>
<li>不要过度使用通配符,因为它的效率不高,不要讲通配符放在匹配模式的开始处,因为这样搜索起来是最慢的,如果你在某个字段使用了索引,然后使用通配符进行查询,如果将通配符放到开始处,那么就不会使用索引。不要把通配符放错位置了</li>
</ul>
</li>
<li><p>Mysql中的正则表达式</p>
<ol>
<li><p>使用regexp关键字</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">&#x27;zhangsan&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用点(.)来表示任意一个字符</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找出id为1000,2000,3000等的name</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">id</span> regexp <span class="string">&#x27;.000&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>如果数据库中存在id:10 name:pack10 这样一条数据,那么以下两条sql中第一条不会返回任何数据,而第二条会返回</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">&#x27;10&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">name</span> regexp <span class="string">&#x27;10&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>因为like匹配整个列,如果数据在列值中出现的话,那么like不会找到它，除非使用%进行模糊匹配。<br>但是regexp则可以在列值内进行匹配,如果找到则会返回,当然可以使用<code>^10$</code>这种方式进行匹配整个列值。</p>
</li>
<li><p>匹配是不区分大小写的,除非手动加上binary关键字,比如name regexp binary ‘zhangsan’;</p>
</li>
<li><p>or匹配,比如 id regexp ‘100|200|300’;</p>
</li>
<li><p>匹配单一的字符,那么使用[]将内容括起来,比如我要查看a,b,1,2这几个字符,那么就是name regexp ‘[ab12]test’;</p>
</li>
<li><p>匹配非操作，使用^,比如<code>[^123]</code>将会匹配非1,2,3这些字符的数据</p>
</li>
<li><p>匹配范围,可以使用[0-9A-Za-z]等方式使用</p>
</li>
<li><p>特殊字符的匹配</p>
</li>
</ol>
<blockquote>
<p>匹配特殊字符,如果想要在正则表达式中匹配. |[]这些正则中特殊的字符,那么需要进行转义,在Mysql中使用\进行转义,比如regexp ‘\.’,如果需要匹配\那么就需要使用\\</p>
</blockquote>
<ol start="10">
<li>元字符的引用</li>
</ol>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\t</td>
<td>制表</td>
</tr>
<tr>
<td>\v</td>
<td>纵向制表</td>
</tr>
</tbody></table>
</li>
</ol>
<pre><code>11. 匹配字符类

| 字符  | 说明  |
|---|---|
| [:alnum:]  | 任意字母和数字,(同[a-zA-Z0-9])  |
| [:alpha:]  | 任意字母(同[a-aA-Z]) |
| [:blank:]  | 空格和制表,(同[\\t]) |
| [:cntrl:]  | ASCII控制字符(ASCII 0到31和127) |
| [:digit:]  | 任意数字(同[0-9])  |
| [:graph:]  | 与[:print:]相同,但不包含空格  |
| [:lower:]  | 任意小写字母,(同[a-z]) |
| [:print:]  | 任意可打印字符  |
| [:punct:]  | 既不在[:alpha:]又不在[:cntrl:]中的任意字符 |
| [:space:]  | 包含空格在内的任意空格字符(同[\\f\\n\\r\\t\\v])  |
| [:upper:]  | 任意大写字母(同[A-Z])  |
| [:xdigit:]  | 任意十六进制数字(同[a-fA-F0-9])  |


12. 重复元字符

| 字符  | 说明  |
|---|---|
| *  | 0个或多个匹配  |
| +  | 1个或多个匹配(同&#123;1,&#125;)  |
| ?  | 0个或1个匹配(同&#123;0,1&#125;)  |
| n  | 指定数目的匹配  |
| &#123;n,&#125;  | 不少于指定数目的匹配  |
| &#123;n,m&#125;  | 匹配数目的范围,m不超过255  |

举例说明:
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 得到的答案为(1 stricks)或者 (5 strick)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; table_name &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt; regex &lt;span class=&quot;string&quot;&gt;&amp;#x27;\\([1-9] stricks?\\)&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 匹配连在一起的任意四位数字: &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; table_name &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; regext &lt;span class=&quot;string&quot;&gt;&amp;#x27;[[:digit:]]&amp;#123;4&amp;#125;&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;


13. 为了匹配特定位置的文本,需要使用定位符

| 字符  | 说明  |
|---|---|
| ^  | 文本的开始  |
| $  | 文本的结尾  |
| [[:&lt;:]]  | 词的开始  |
| [[:&gt;:]]  | 词的结尾 |

下面的sql返回结果为1
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;.3abc&amp;#x27;&lt;/span&gt; REGEXP &lt;span class=&quot;string&quot;&gt;&amp;#x27;^[0-9\\.]&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;</code></pre>
<ol start="17">
<li><p>Mysql函数</p>
<ol>
<li>concat()拼接串,参数需要一个或者多个串,各个串之间用逗号间隔</li>
<li>rtirm()删除右边空格,ltrim()删除左边空格,trim删除左右两边空格</li>
<li>常用文本处理函数</li>
</ol>
<table>
<thead>
<tr>
<th>文本函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Left()</td>
<td>返回串左边的字符</td>
</tr>
<tr>
<td>Length()</td>
<td>返回串的长度</td>
</tr>
<tr>
<td>Locate()</td>
<td>找出串的一个子串</td>
</tr>
<tr>
<td>Lower()</td>
<td>将串转换成为小写</td>
</tr>
<tr>
<td>LTrim()</td>
<td>去掉左边的空格</td>
</tr>
<tr>
<td>Right()</td>
<td>返回串右边的字符</td>
</tr>
<tr>
<td>RTrim()</td>
<td>去掉右边的空格</td>
</tr>
<tr>
<td>SubString()</td>
<td>返回子串的字符</td>
</tr>
<tr>
<td>Upper()</td>
<td>将串转换成大写</td>
</tr>
</tbody></table>
<ol start="4">
<li>常用日期和时间处理函数</li>
</ol>
<table>
<thead>
<tr>
<th>日期函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>AddDate()</td>
<td>增加一个日期(天、周等)</td>
</tr>
<tr>
<td>AddTime()</td>
<td>增加一个时间(时、分等)</td>
</tr>
<tr>
<td>CurDate()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CurTime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>Date()</td>
<td>返回日期时间的日期部分</td>
</tr>
<tr>
<td>DateDiff()</td>
<td>计算两个日期之差</td>
</tr>
<tr>
<td>Date_Add()</td>
<td>高度灵活的日期运算函数</td>
</tr>
<tr>
<td>Date_Format()</td>
<td>返回一个格式化的日期或者字符串</td>
</tr>
<tr>
<td>Day()</td>
<td>返回一个日期的天数部分</td>
</tr>
<tr>
<td>DayOfWeek()</td>
<td>对于一个日期,返回对应的星期几</td>
</tr>
<tr>
<td>Hour()</td>
<td>返回一个时间的小时部分</td>
</tr>
<tr>
<td>Minute()</td>
<td>返回一个时间的分钟部分</td>
</tr>
<tr>
<td>Month()</td>
<td>返回一个日期的月份部分</td>
</tr>
<tr>
<td>Now()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>Second()</td>
<td>返回一个时间的秒部分</td>
</tr>
<tr>
<td>Time()</td>
<td>返回一个日期时间的时间部分</td>
</tr>
<tr>
<td>Year()</td>
<td>返回一个日期的年份部分</td>
</tr>
</tbody></table>
</li>
</ol>
<pre><code>5. 聚集函数
count(*)对表中行的数目进行计数,不管表列中包含的是空值(NULL)还是非空值
count(column)对特定列中具有值的行进行计数,忽略NULL值

Max()一般用于找出最大的数值或者日期值,但是在用于文本数据时,如果数据按照相应的列进行排序,则Max()返回最后一行。
Max(),Min()均忽略列值为NULL的行</code></pre>
<ol start="18">
<li><p>使用group by</p>
<ol>
<li><p>group by 可以包含任意列<br> 如果在group by 子句中嵌套了分组,数据将在最后规定的分组上进行汇总<br> group by子句中列出的每个列都必须是检索列或者有效的表达式(但不能是聚集函数)<br> 除掉聚集计算语句外,select语句中的每个列都必须在group by子句中给出<br> 如果分组列中具有NULL值,则NULL将作为一个分组返回,如果列中有多行NULL值,它们将分为一组。<br> group by子句必须出现在where之后,order by 之前</p>
</li>
<li><p>使用having来进行对分组进行过滤,例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">sum</span>(score) <span class="keyword">from</span> table_name <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">having</span> <span class="keyword">sum</span>(score) &gt; <span class="number">120</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>having和where的区别</p>
</li>
</ol>
<p>where在数据分组前进行过滤,having在数据分组后进行过滤</p>
<ol start="20">
<li><p>使用子查询</p>
<ol>
<li><p>使用子查询的时候,必须保证select语句与where子句中存在相同数目的列</p>
</li>
<li><p>ANSI SQL规范首选inner join语法</p>
</li>
<li><p>自连接(将一个表当做两个表看)的使用:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> <span class="keyword">id</span> = (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> score &gt; <span class="number">60</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> table_name <span class="keyword">as</span> t1,table_name <span class="keyword">as</span> t2 <span class="keyword">where</span> t1.id == t2.pid;</span><br></pre></td></tr></table></figure></li>
<li><p>MySQL中的各种连接<br> 左外连接也叫左连接（left outer join也可以简写为left join）<br>   显示左表的所有数据，然后根据条件与右表进行匹配，如果有匹配的就加在左表的后面，如果有多条匹配数据，则显示多条。<br> 没有的话，该行的右表就以null值填充。</p>
<p> 右连接（right outerjoin 也可以简写为right join）<br>   显示右表的所有数据，然后根据条件与左表匹配，如果有匹配的就加在左表的后面，如果有多条匹配数据，则显示多条。<br> 没有的话，该行以null值填充。（和左连接类似）</p>
<p> 何为左表、右表呢 ？在join的左边就称为左表，右边就称为右表</p>
</li>
</ol>
</li>
<li><p>union的使用</p>
<ol>
<li><p>组合查询,利用union可以将多条select语句将它们的结果组合成当个结果集,union规则：<br> union必须由两条或者两条以上的select语句组成,语句之间可以用union分割<br> union中的每个查询必须包含相同的列、表达式或聚集函数(不过各个列不需要以相同的次序输出)<br> 列数据类型必须兼容：类型不必完全相同,当必须是DBMS可以隐含的转换的类型(例如:不同的数值类型或不同的日期类型)</p>
</li>
<li><p>union会将返回的结果集中重复的数据行自动取消(即只会返回一行),如果想匹配所有返回行,这需要使用union all</p>
</li>
</ol>
</li>
<li><p>全文本搜索</p>
<ol>
<li><p>MyIsam引擎支持全文本搜索,InnoDB不支持</p>
</li>
<li><p>启用全文本搜索支持,一般在创建表的时候启用全文搜索</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tabl_name (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    note_text <span class="built_in">text</span> <span class="literal">null</span>,</span><br><span class="line">    fulltext(note_text)</span><br><span class="line">)<span class="keyword">engine</span>=myisam</span><br></pre></td></tr></table></figure></li>
<li><p>在导入的时候不要使用fulltext,因为会维护一份索引导致导入过慢</p>
</li>
<li><p>Match()指定被搜索的列,Against()指定要使用的搜索表达式使用:select node_text from table_name where Match(node_text) against(‘rabbit’);</p>
</li>
<li><p>传递给Match()的值必须与FullText()定义的相同,如果指定多个列,则必须列出他们(而且次序正确)</p>
</li>
<li><p>fullText不区分大小写,除非使用binary关键字</p>
</li>
<li><p>使用Like也能达到相同的想过,但是使用FullText会对返回的结果集进行排序,出现的关键字在前面的可能会最先返回,即具有高优先级的最先返回(可能这正是你想要的行)</p>
</li>
<li><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将其放在select中如果文本中包括rabbit返回的rank值就大于0,否则就为0,这也证明了fullText是如何排除行,如何排序结果的</span></span><br><span class="line"><span class="keyword">select</span> node_text，<span class="keyword">Match</span>(node_text) against(<span class="string">&#x27;rabbit&#x27;</span>) <span class="keyword">as</span> <span class="keyword">rank</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>插入</p>
<ol>
<li>使用insert的时候最好指定列</li>
<li>如果表的定义允许,则可以在insert操作中省略某些列,省略的列必须满足以下某个条件。<ul>
<li>该列允许为NULL值(无值或空值)</li>
<li>在表定义中给出默认值，这表示如果不给出值，将使用默认值</li>
</ul>
</li>
<li>MySql经常被多个客户访问,对处理什么请求以及用什么次序管理是Mysql的任务,insert操作可能很耗时(特别是有很多索引需要更新的时候),而且他可能降低等待处理的select语句的性能。如果数据检索是重要的(通常是这样),则可以通过在insert和into中间添加关键字LOW_PRIORITY,指示Mysql降低insert语句的的优先级。</li>
<li>插入多条数据<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此举可以提高insert的性能</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;zhangsan&#x27;</span>),(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;lisi&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li>insert select语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_name(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> table_name2</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>更新和删除</p>
<ol>
<li>使用update的时候最好指定条件,也可以使用子查询</li>
<li>如果用update语句更新多行,并且在更新的时候其中的一行或者多行出现错误,则整个update操作被取消(错误发生前更新的所有行为被恢复到它们原有的值),如果想即使发生了错误,也继续进行更新,可以使用ignore关键字,如下所示：update ignore table_name</li>
<li>delete删除的是表的行,而不包含表本身</li>
<li>如果想要快速删除表中的所有数据,可以使用truncate table语句,它完成相同的工作,但是它更快(truncate实际上是删除原来的表并重新新建一个表,而不是逐行删除表中的数据)</li>
</ol>
</li>
<li><p>创建和操纵表</p>
<ol>
<li>如果你仅仅现在一个表不存在的时候创建它,那么可以使用create table table_name if not exists 语句</li>
<li>mysql不允许使用函数作为列的默认值,它只支持常量</li>
<li>常用引擎<br> InnoDB是一个可靠的事务处理引擎，它不支持全文搜索<br> MyIsam是一个性能极高的引擎,它支持全文搜索<br> Memory在功能上等同于MyIsam,但是由于数据存储在内存中,速度很快(特别适合于临时表)</li>
<li>引擎类型可以互用,但是外键不能跨引擎</li>
<li>alter table用于更改表结构,必须给出以下信息:<br> 在alter table之后必须要给出要更改的表名(该表必须存在,否则将出错)<br> 所做更改的列表</li>
<li>删除表<br><code>drop table table_name;</code></li>
<li>重命名表<br><code>rename table table_name1 to table_name2;</code></li>
<li>重命名多个表<br><code>rename table table1 to table2,table3 to table4;</code></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql-index-optimize-method</title>
    <url>/2024/09/23/mysql-index-optimize-method/</url>
    <content><![CDATA[<p>·</p>
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>索引优化</tag>
        <tag>join</tag>
        <tag>explain</tag>
      </tags>
  </entry>
  <entry>
    <title>面试官问我MySQL的行格式是怎样的</title>
    <url>/2022/05/07/mysql-row-format/</url>
    <content><![CDATA[<p>行格式(row format)决定了我们插入的一行数据，是如何存储在数据库中的，MySQL有4种行格式，分别是REDUNDANT，COMPACT，DYNAMIC，COMPRESSED。</p>
<p>不同行格式区别:</p>
<table>
<thead>
<tr>
<th>行格式</th>
<th>紧凑存储</th>
<th>增强可变长度列存储</th>
<th>大索引键前缀</th>
<th>压缩支持</th>
<th>支持的表空间类型</th>
<th>所需文件格式</th>
</tr>
</thead>
<tbody><tr>
<td>REDUNDANT</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>system, file-per-table, general</td>
<td>Antelope or Barracuda</td>
</tr>
<tr>
<td>COMPACT</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>system, file-per-table, general</td>
<td>Antelope or Barracuda</td>
</tr>
<tr>
<td>DYNAMIC</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>system, file-per-table, general</td>
<td>Barracuda</td>
</tr>
<tr>
<td>COMPRESSED</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>file-per-table, general</td>
<td>Barracuda</td>
</tr>
</tbody></table>
<a id="more"></a>


<p>MySQL 5.7默认使用的是Dynamic的行格式。</p>
<p>我们可以在创建表的时候指定字符集和行格式。</p>
<blockquote>
<p>字符集表示我们插入的字符是用几个字节编码的，比如ASCII用一个字节，GB2312用2个字节,utf8使用3个字节,utf8mb4用4个字节(如果存储emoj表情就要用这个字符集)</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`price`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`code`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 ROW_FORMAT=Dynamic;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在讲下面行格式的时候，我们使用这个表进行讲解</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> record_format_demo (</span><br><span class="line"> c1 <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line"> c2 <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"> c3 <span class="built_in">CHAR</span>(<span class="number">10</span>),</span><br><span class="line"> c4 <span class="built_in">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">) <span class="keyword">CHARSET</span>=<span class="keyword">ascii</span> ROW_FORMAT=Redundant;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> record_format_demo(c1, c2, c3, c4) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;d&#x27;</span>), </span><br><span class="line">  (<span class="string">&#x27;eeee&#x27;</span>, <span class="string">&#x27;fff&#x27;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Redundant行格式"><a href="#Redundant行格式" class="headerlink" title="Redundant行格式"></a>Redundant行格式</h3><p>Redundant行格式是一个比较老的行格式了,现在也就只有MySQL的一些系统表会使用它了，平常咱们一般不用，但是这个行格式我觉得是能搞明白其他行格式的基础。</p>
<h4 id="行格式结构"><a href="#行格式结构" class="headerlink" title="行格式结构"></a>行格式结构</h4><p><img data-src="/images/mysql/mysql-innodb-record-format.png" alt="Redundant行格式"></p>
<p>如上图所示，整个行格式分为记录的额外信息和记录的真实数据两部分，其中记录的额外信息又分为字段长度偏移列表和记录头信息两部分。</p>
<ol>
<li>字段长度偏移列表</li>
</ol>
<p>在Redundant行格式中,会把所有字段的真实数据占⽤的字节长度都存放在记录的开头部位，从⽽形成⼀个字段长度偏移列表，字段长度占⽤的字节数按照列的顺序逆序存放,逆序存放,逆序存放！</p>
<ol start="2">
<li><p>记录头信息<br>Redundant⾏格式的记录头信息占⽤6字节，48个⼆进制位，这些⼆进制位代表的意思如下</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小(bit)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预留位1</td>
<td>1</td>
<td>未使用</td>
</tr>
<tr>
<td>预留位2</td>
<td>1</td>
<td>未使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>该记录是否删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+树每层非叶子节点最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>当前记录组拥有记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>当前记录在页面堆位置信息</td>
</tr>
<tr>
<td>n_field</td>
<td>10</td>
<td>记录中列数量</td>
</tr>
<tr>
<td>1byte_offs_flag</td>
<td>1</td>
<td>字段长度偏移列表中每个列对应的偏移量是使⽤1字节还是2字节表⽰的</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>下一条记录的相对位置</td>
</tr>
</tbody></table>
</li>
<li><p>真实数据</p>
</li>
</ol>
<p>对于record_format_demo表来说，记录的真实数据除了c1、c2、c3、c4这⼏个我们⾃⼰定义的列的数据以外，MySQL会为每个记录默认的添加⼀些列（也称为隐藏列），具体的列如下</p>
<ol>
<li>DB_ROW_ID(row_id) : 当表没有定义主键，则选择unique键作为主键，如果仍没有，则默认添加一个名为DB_ROW_ID的隐藏列作为主键，占用6个字节。也就是说这个列只有当没有主键也没有唯一索引时才存在</li>
<li>DB_TRX_ID(transaction_id): 事务id,占用6字节</li>
<li>DB_ROLL_PTR(roll_pointer): 占用7个字节,回滚指针(后面MVCC的时候会用到)</li>
</ol>
<p>所以，对我们的数据来讲，其行格式数据如下<br><img data-src="/images/mysql/innodb-redundant-row1.png" alt="数据"></p>
<h4 id="列长度如何计算"><a href="#列长度如何计算" class="headerlink" title="列长度如何计算"></a>列长度如何计算</h4><p>⽐如第⼀条记录的字段⻓度偏移列表就是：<br>25 24 1A 17 13 0C 06 </p>
<p>因为它是逆序排放的，所以按照列的顺序排列就是：<br>06 0C 13 17 1A 24 25 </p>
<p>计算各个列长度则按照以下方法(字符集是ascii,一个字符占用1个字节)：<br>第⼀列(<code>row_id</code>)的⻓度就是 0x06个字节，也就是6个字节。<br>第⼆列(<code>transaction_id</code>)的⻓度就是 (0x0C - 0x06)个字节，也就是6个字节。<br>第三列(<code>roll_pointer</code>)的⻓度就是 (0x13 - 0x0C)个字节，也就是7个字节。<br>第四列(<code>c1</code>)的⻓度就是 (0x17 - 0x13)个字节，也就是4个字节。<br>第五列(<code>c2</code>)的⻓度就是 (0x1A - 0x17)个字节，也就是3个字节。<br>第六列(<code>c3</code>)的⻓度就是 (0x24 - 0x1A)个字节，也就是10个字节。<br>第七列(<code>c4</code>)的⻓度就是 (0x25 - 0x24)个字节，也就是1个字节。</p>
<p>在记录头信息中的1byte_offs_flag用于表示 字段长度偏移列表中每个列对应的偏移量是使⽤1字节还是2字节表⽰的 ，这个值是如何计算的呢？</p>
<ol>
<li>当记录的真实数据占⽤的字节数不⼤于127（⼗六进制0x7F，⼆进制01111111）时，每个列对应的偏移量占⽤1个字节。</li>
<li>当记录的真实数据占⽤的字节数⼤于127，但不⼤于32767（⼗六进制0x7FFF，⼆进制0111111111111111）时，每个列对应的偏移量占⽤2个字节。</li>
<li>当记录大于32767的时候，此时的记录已经存放到了溢出页中，在本页中只保留前768个字节和20个字节的溢出页⾯地址（当然这20个字节中还记录了⼀些别的信息）。因为字段⻓度偏移列表处只需要记录每个列在本页⾯中的偏移就好了，所以每个列使⽤2个字节来存储偏移量就够了。</li>
</ol>
<p>我们的第一条记录真实数据总长度 = 37(6+6+7+4+3+10+1),小于127，所以采用1字节记录偏移量。为了在解析记录的时候知道列偏移量是采用1字节还是2字节表示，因此使用1byte_offs_flag来决定，当它的值为1时，表明使用1个字节存储，当值为0时，表明使用2字节存储。</p>
<p>需要注意下记录头信息的next_record,你可以把它理解为指针,通过它我们可以指向下一条记录的位置(多条记录是如何连接的会在下一篇文章讲到哈)，当我们指针在这个位置的时候往后读是真实数据的位置，往前读就是字段的长度列表，所以我们长度列表逆序存放就能和真实数据一一对应。<br><img data-src="/images/mysql/mysql-redundant-read-data.png" alt="读取数据"></p>
<h4 id="Redundant行格式对NULL值的处理"><a href="#Redundant行格式对NULL值的处理" class="headerlink" title="Redundant行格式对NULL值的处理"></a>Redundant行格式对NULL值的处理</h4><p>列对应偏移量值的第一个比特位作为列值是否为NULL的依据，当解析一条记录某个列时，首先查看这个比特位的值是否为1，如果是1，那么该列的值就是NULL，否则则不是NULL。(现在你知道为什么记录数据长度为什么会有127和32767这两个临界点了吧)</p>
<blockquote>
<p>这个bit位也可以称为NULL比特位</p>
</blockquote>
<p>对于值为NULL的列，如果是定长类型，NULL值也将占用记录的真实数据部分，数据采用0x00字节填充。如果是变长数据类型，则不在记录的真实数据处占用任何存储空间。</p>
<p>如上图我们的第二条数据， C3列的值是NULL,类型是CHAR(10),占⽤记录的真实数据部分10字节(，所以我们看到在Redundant⾏格式中使⽤0x00000000000000000000来表⽰NULL值。</p>
<p>C3列长度偏移量是0xA4，二进制是 10100100，最高位是1，表明该列值是NULL,将高位去掉变成 0100100(十进制的36)， C2列对应偏移量是0x1A(十进制的26),因此其长度是36-26=10</p>
<p>C4列是Varchar类型，对应偏移量是0xA4,C3列偏移量也是0XA4,表明其长度是0(不占用真实数据存储空间),而其二进制高位是1,表明该列值是NULL。</p>
<p>为什么定长类型NULL值也要占用固定空间呢？<br>官方文档告诉我对于一个固定长度的列，该列的固定长度被保留在记录的数据部分。为NULL值保留的固定空间允许列从NULL值更新到非NULL值，而不会引起索引页的碎片化。</p>
<h3 id="Compact行格式"><a href="#Compact行格式" class="headerlink" title="Compact行格式"></a>Compact行格式</h3><p>Compact行格式是Dynamic和Compressed两种行格式的基础，了解了它就了解了其他两种结构</p>
<h4 id="行格式结构-1"><a href="#行格式结构-1" class="headerlink" title="行格式结构"></a>行格式结构</h4><p><img data-src="/images/mysql/innodb-compact-row-format.png" alt="Compact行格式"></p>
<p>如上图,Compact行格式中记录额外信息分为变长字段长度列表，NULL值列表，记录头信息。</p>
<p>变长字段列表中存储的是非空的变长字段的数据长度,变长字段存储的数据是不固定的，所以我们需要将数据占用的字节数也存起来。 同样的，这里占用的长度也是逆序存放，逆序存放，逆序存放的。</p>
<blockquote>
<p>varchar(M),VARBINARY(M),各种TEXT以及各种BLOB类型，mysql把拥有这些数据类型的列称为变长字段</p>
</blockquote>
<h4 id="对NULL值的处理"><a href="#对NULL值的处理" class="headerlink" title="对NULL值的处理"></a>对NULL值的处理</h4><p>Redundant是将列对应偏移量值的第一个比特位作为列值是否为NULL的依据，但是在Compact中是单独有一个NULL值列表来存储值为NULL的字段。NULL值列表是如何确认的呢？</p>
<ol>
<li>首先统计表接口中允许为NULL值的列(主键和unique key是不允许为NULL的)</li>
<li>如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储NULL的列对应⼀个⼆进制位，⼆进制位按照列的顺序逆序排列,逆序排列,逆序排列<ul>
<li>⼆进制位的值为1时，代表该列的值为NULL。 </li>
<li>⼆进制位的值为0时，代表该列的值不为NULL。</li>
</ul>
</li>
<li>MySQL规定NULL值列表必须⽤整数个字节的位表⽰，如果使⽤的⼆进制位个数不是整数个字节，则在字节的⾼位补0。<blockquote>
<p>如果一个表中有9个允许为NULL的列,那么就需要用2个字节表示</p>
</blockquote>
</li>
</ol>
<p>对于我们上面的两条数据来说(c1,c3,c4允许为NULL)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#39;aaaa&#39;, &#39;bbb&#39;, &#39;cc&#39;, &#39;d&#39;), </span><br><span class="line">(&#39;eeee&#39;, &#39;fff&#39;, NULL, NULL);</span><br></pre></td></tr></table></figure>

<p>第一条数据NULL值列表为 00000000(都不为空)<br>第二条数据NULL值列表为 00000110,c1不为null，所以是0,c3为null,所以是1，c4是null，所以是1，其倒序结果就是00000110</p>
<h4 id="记录头"><a href="#记录头" class="headerlink" title="记录头"></a>记录头</h4><p>和Redundant不同,Compact的记录头信息使用了5个字节(40bit)来表示记录头信息,其具体信息如下</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小(bit)</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预留位1</td>
<td>1</td>
<td>未使用</td>
</tr>
<tr>
<td>预留位2</td>
<td>1</td>
<td>未使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>该记录是否删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+树每层非叶子节点最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>当前记录组拥有记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>当前记录在页面堆位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表⽰当前记录的类型，0表⽰普通记录，1表⽰B+树⾮叶⼦节点记录,2表⽰最⼩记录，3表⽰最⼤记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>下一条记录的相对位置</td>
</tr>
</tbody></table>
<p>可以看到相比Redundant,Compact多了一个record_type的字段，少了n_field和1byte_offs_flag两个字段。 我们之前提到过 1byte_offs_flag 是用来表示 字段长度偏移列表中每个列对应的偏移量是使⽤1字节还是2字节表⽰的， 但是Compact却没有，那变长字段长度列表中字段长度到底是用1个字节表示还是2个字节表示呢？</p>
<h4 id="列长度如何计算-1"><a href="#列长度如何计算-1" class="headerlink" title="列长度如何计算"></a>列长度如何计算</h4><p>还记得Redundant将列对应偏移量值的第一个比特位作为列值是否为NULL的依据吗？Compact思路也是类似的，它使用字节的第一位来表示.</p>
<ol>
<li>假设某个字符集中表⽰⼀个字符最多需要使⽤的字节数为W，也就是使⽤SHOW CHARSET语句的结果中的Maxlen列，⽐⽅说utf8字符集中的W就是3，gbk字符集中的W就是2，ascii字符集中的W就是1。 </li>
<li>对于变长类型VARCHAR(M)来说，这种类型表⽰能存储最多M个字符（注意是字符不是字节），所以这个类型能表⽰的字符串最多占⽤的字节数就是M×W。</li>
<li>假设它实际存储的字符串占⽤的字节数是L。 所以确定使⽤1个字节还是2个字节表⽰真正字符串占⽤的字节数的规则就是这样：</li>
</ol>
<ul>
<li>如果M×W &lt;= 255，那么使⽤1个字节来表⽰真正字符串占⽤的字节数。<br>  也就是说InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最⼤字节数不⼤于255时，可以认为只使⽤1个字节来表⽰真正字符串占⽤的字节数。 </li>
<li>如果M×W &gt; 255，则分为两种情况： <ul>
<li>如果L &lt;= 127，则⽤1个字节来表⽰真正字符串占⽤的字节数。 </li>
<li>如果L &gt; 127，则⽤2个字节来表⽰真正字符串占⽤的字节数。<br>InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最⼤字节数⼤于255时，该怎么区分它正在读的某个字节是⼀个单独的字段长度还是半个字段长度 呢？该字节的第⼀个⼆进制位作为标志位：如果该字节的第⼀个位为0，那该字节就是⼀个单独的字段长度（使⽤⼀个字节表⽰不⼤于127(01111111)的⼆进制的第⼀个位都 为0），如果该字节的第⼀个位为1，那该字节就是半个字段长度。 对于⼀些占⽤字节数⾮常多的字段，⽐⽅说某个字段长度⼤于了16KB，那么如果该记录在单个页⾯中⽆法存储 时，InnoDB会把⼀部分数据存放到所谓的溢出页中，在变长字段长度列表处只存储留在本页⾯中的长度，所以使⽤两个字节也可以存放下来。<br>总结⼀下就是说：如果该可变字段允许存储的最⼤字节数（M×W）超过255字节并且真实存储的字节数（L）超过127字节，则使⽤2个字节，否则使⽤1个字节。</li>
</ul>
</li>
</ul>
<blockquote>
<p>上面的内容参考了小孩子大佬的&lt;&lt;MySQL是怎样运行的:从根儿上理解MYSQL&gt;&gt;,大家可以在掘金购买它的小册或者对应的实体书。 他是从Compact讲到Redundant的，但是我觉得从Redundant的格式到Compact<br>格式其实更容易理解,过度更容易。这也是我的一个理解，供大家参考。</p>
</blockquote>
<h3 id="行溢出"><a href="#行溢出" class="headerlink" title="行溢出"></a>行溢出</h3><p>在Compact和Reduntant⾏格式中，对于占⽤存储空间⾮常⼤的列，在记录的真实数据处只会存储该列的⼀部分数据，把剩余的数据分散存储在⼏个其他的页中，然后记录的真实数据处⽤20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页⾯中的数据的占⽤的字节数），从⽽可以找到剩余数据所在的页。</p>
<p>对于Compact和Reduntant⾏格式来说，如果某⼀列中的数据⾮常多的话，在本记录的真实数据处只会存储该列的前768个字节的数据和⼀个指向其他页的地址(如果一个页都放不下,那么就会使用链表将多个页链接起来)，然后把剩下的数据存放 到其他页中，这个过程也叫做⾏溢出，存储超出768字节的那些页⾯也被称为溢出⻚。</p>
<p>需要注意的是并不仅仅只有变长字段的列才会发生行溢出，blob,text都有可能，甚至大于或等于768字节的固定长度的列也会被编码为可变长度的列，它可以被存储在页面外。例如，如果字符集的最大字节长度大于3，一个CHAR(255)列可以超过768字节，正如utf8mb4那样。</p>
<h3 id="Dynamic和Compressed⾏格式"><a href="#Dynamic和Compressed⾏格式" class="headerlink" title="Dynamic和Compressed⾏格式"></a>Dynamic和Compressed⾏格式</h3><p>Dynamic和Compressed⾏格式，现在使⽤的MySQL版本是5.7，它的默认⾏格式就是Dynamic，这俩⾏格式和Compact⾏格式挺像，只不过在处理⾏溢出数据时有点⼉分歧，它们不会在记录的真实数据处存储字段真实数据的前768个字节，⽽是把所有的字节都存储到其他页⾯中，只在记录的真实数据处存储其他页⾯的地</p>
<p><img data-src="/images/mysql/innodb-overflow-page.png" alt="溢出页"></p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol>
<li>&lt;&lt;MySQL是怎样运行的:从根儿上理解MYSQL&gt;&gt;</li>
<li>官方文档: <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html</a></li>
<li>官方文档: <a href="https://dev.mysql.com/doc/internals/en/innodb-field-contents.html">https://dev.mysql.com/doc/internals/en/innodb-field-contents.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx语法入门</title>
    <url>/2020/05/28/nginx-config-grammer/</url>
    <content><![CDATA[<p>nginx应该是我们常用到的一个软件了，它的用法和语法也很简单，本文主要介绍nginx语法以及各个模块作用。</p>
<h3 id="Nginx配置目录"><a href="#Nginx配置目录" class="headerlink" title="Nginx配置目录"></a>Nginx配置目录</h3><p>当我们安装好nginx之后，我们主要关注两个文件夹</p>
<ol>
<li><p>/etc/nginx/conf.d/ 文件夹，是我们进行子配置的配置项存放处，/etc/nginx/nginx.conf 主配置文件会默认把这个文件夹中所有子配置项都引入</p>
<blockquote>
<p>windows下，是对应的安装目录下的conf目录。</p>
</blockquote>
</li>
<li><p>/usr/share/nginx/html/ 文件夹，通常静态文件都放在这个文件夹，你也可以放到其他地方</p>
<blockquote>
<p>windows下,对应的目录是在安装目录下的html目录。</p>
</blockquote>
</li>
</ol>
<a id="more"></a>


<h3 id="Nginx的常用命令"><a href="#Nginx的常用命令" class="headerlink" title="Nginx的常用命令"></a>Nginx的常用命令</h3><ol>
<li><p>查看Nginx版本号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure>
</li>
<li><p>nginx帮助命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -h</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证配置语法是否正确</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件修改重装载命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>块速停止或关闭nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure>
</li>
<li><p>正常停止或关闭(会等到worker处理完成请求后关闭)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>注意windows下需要将nginx.exe加入环境变量,然后才能执行上面的命令。不要双击启动，不然只能从任务列表中删除</p>
</blockquote>
<h3 id="Nginx配置语法"><a href="#Nginx配置语法" class="headerlink" title="Nginx配置语法"></a>Nginx配置语法</h3><ol>
<li>配置文件由指令与指令块构成</li>
<li>每条指定以分号(<code>;</code>)结尾,指令与参数间以空格符号分割</li>
<li>指令块以大括号(<code>&#123;&#125;</code>)将多条指令组织在一起</li>
<li>include语句允许组合多个配置文件以提升可维护性</li>
<li>使用<code>#</code>符号添加注释</li>
<li>使用<code>$</code>符号使用变量</li>
<li>部分指令参数支持正则表达式</li>
</ol>
<p>当我们打开nginx.conf文件你会看到和下面类似的结果:</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># nginx进程数，一般设置成和CPU个数一样</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="comment"># 每个进程允许最大并发数</span></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># 引入其他配置,mime.types文件存储的是文件扩展名与类型映射表</span></span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 日志格式(使用了变量)</span></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                     <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 服务器配置</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># 监听端口</span></span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="comment"># 监听域名</span></span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 访问地址</span></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当nginx以上面的配置加载启动后，我们就可以访问 <a href="http://localhost这个地址了,然后默认会返回html目录下的index.html文件内容./">http://localhost这个地址了,然后默认会返回html目录下的index.html文件内容。</a></p>
<p>nginx的配置块嵌套关系如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">main</span><br><span class="line"></span><br><span class="line">events &#123;...&#125;</span><br><span class="line"></span><br><span class="line"># 表示这里面的所有内容都由http模块来进行解析,比如mail这种是不起作用的</span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">  # 指定上游服务器</span><br><span class="line">  upstream &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  # 用于A&#x2F;B test</span><br><span class="line">  split_clients &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  # 基于已有变量,创建新变量</span><br><span class="line">  map &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  # 根据客户端地址创建新变量的geo模块</span><br><span class="line">  geo &#123;...&#125;</span><br><span class="line"></span><br><span class="line">  # 服务器</span><br><span class="line">  server &#123;</span><br><span class="line">    if() &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    location &#123;</span><br><span class="line">      limit_except &#123;...&#125;</span><br><span class="line">      if() &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#123;...&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  server &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="nginx指令"><a href="#nginx指令" class="headerlink" title="nginx指令"></a>nginx指令</h3><p>上面列出了一些常用的指令块，但是指令块中可以写哪些指令呢？指令那么多，我需要去背吗？我告诉你完全用不着，记不住的时候查文档就行了。</p>
<p>我们都知道nginx实际是由很多个模块组合到一起的，哪些模块提供了哪些功能一看便知。</p>
<p>首先打开nginx的官方文档(nginx.org/en/docs),从中我们可以看到nginx提供了哪些变量,哪些模块。</p>
<p><img data-src="/images/nginx/nginx-module-reference.png" alt="nginx模块"></p>
<p>模块提供了各种功能,基本上看到名字也就明白了提供哪方面的功能。</p>
<p>当我们点开某一个module的时候，如果那个module没有build进去,那么它会告诉你如下信息</p>
<p><img data-src="/images/nginx/nginx-not-built-module.png" alt="nginx未build module提示"></p>
<blockquote>
<p>nginx -V 可以查看nginx的配置参数，可以看到除了核心模块之外还添加了哪些模块。</p>
</blockquote>
<p>在比如我们查看ngx_http_core_module看看这个模块提供了提供的root指令</p>
<p><img data-src="/images/nginx/nginx-root-order.png" alt="root指令"></p>
<p>从上图中示例可以看出来，root指令写的位置是在location指令块中的。但是它还能写到http,server这两个指令块中。</p>
<p>这个指令的context指的是指令能够出现的位置。</p>
<blockquote>
<p> 如果块指令可以在括号内包含其他指令，则将其称为context(上下文,比如event,http,server,location)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Syntax: log_format name [escape&#x3D;default|json|none] string ...;</span><br><span class="line">Default:  </span><br><span class="line">log_format combined &quot;...&quot;;</span><br><span class="line">Context:  http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Syntax: access_log path [format [buffer&#x3D;size] [gzip[&#x3D;level]] [flush&#x3D;time] [if&#x3D;condition]];</span><br><span class="line">access_log off;</span><br><span class="line">Default:  </span><br><span class="line">access_log logs&#x2F;access.log combined;</span><br><span class="line">Context:  http, server, location, if in location, limit_except</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比如log_format只能出现在http指令块中，而access_log则可以出现在http和server,location这些指令块中。</p>
<p>你是不是会疑惑，既然一个指令能出现在多个指令块中,那么到底哪个会生效呢？</p>
<p><strong>在nginx中存储值得指令继承规则是向上覆盖。当子配置存在时，直接覆盖父配置块,子配置不存在时，直接使用父配置块。</strong></p>
<blockquote>
<p>存储值的指令指的是指令后面的数据是一个值。 比如 root html; root后面跟的就是一个值。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S中只挂载文件,不要挂载目录</title>
    <url>/2019/11/19/only-mount-file-in-k8s/</url>
    <content><![CDATA[<p>在kubernetes中部署前端项目(使用nginx作为服务器)的时候,遇到了一个报错,报错信息如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019&#x2F;11&#x2F;19 02:16:31 [emerg] 1#1: open() &quot;&#x2F;etc&#x2F;nginx&#x2F;mime.types&quot; failed (2: No such file or directory) in &#x2F;etc&#x2F;nginx&#x2F;nginx.conf:14</span><br><span class="line">nginx: [emerg] open() &quot;&#x2F;etc&#x2F;nginx&#x2F;mime.types&quot; failed (2: No such file or directory) in &#x2F;etc&#x2F;nginx&#x2F;nginx.conf:14</span><br></pre></td></tr></table></figure>

<p>提示的意思是没有找到mine.types文件,也就是说容器内/etc/nginx下不存在这个文件。但是这个文件不是nginx提供的吗?</p>
<a id="more"></a>

<p>我赶忙看了下我是如何部署这个容器的。</p>
<p>dockerfile:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM nginx:1.17.3</span><br><span class="line">COPY dist &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br></pre></td></tr></table></figure>

<p>deployment.yml:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">smcp-web</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">nginx-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">smcp-web</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">smcp-web</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">smcp-web</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">docker-registry.xxx.com/fe/fe-nginx:no-nginx-conf</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-conf</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/nginx</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-conf</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">nginx-conf</span></span><br><span class="line">          <span class="attr">items:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nginx.conf</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">nginx.conf</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就会将在configMap中声明的nginx.conf对应内容挂载到/etc/nginx(mountPath)/nginx.conf文件中。</p>
<blockquote>
<p>kubectl create configmap nginx-conf –from-file=nginx.conf=./path/to/nginx.conf -n nginx-test</p>
</blockquote>
<p>一想到这里我大概知道了原因，<strong>是因为我们挂载的是整个/etc/nginx目录,但是我们这个目录里面只加了nginx.conf,而容器中/etc/nginx目录下面还有很多其他的文件，<br>我们直接挂载了整个目录进去，其他的文件会随着目录的挂载而消失，自然读取配置就出了问题。</strong></p>
<p>现在问题已经知道了，如何解决呢?</p>
<p>要是可以只挂载这个文件就好了，查阅了下文档，发现subPath完全可以满足我们的需求。</p>
<blockquote>
<p>subPath的目的是为了在单一Pod中多次使用同一个volume而设计的</p>
</blockquote>
<p>所以将spec部分修改如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">smcp-web</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker-registry.xxx.com/fe/fe-nginx:no-nginx-conf</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-conf</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/etc/nginx/nginx.conf</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">nginx.conf</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-conf</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">nginx-conf</span></span><br></pre></td></tr></table></figure>

<p>这样我们就做到了将nginx.conf文件挂载到/etc/nginx目录下，同时不影响原有目录中的内容。</p>
]]></content>
      <tags>
        <tag>Kubernetes</tag>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈Java中的基本数据类型</title>
    <url>/2016/07/18/primitive-type-in-java/</url>
    <content><![CDATA[<h3 id="认识Java中的基本数据类型"><a href="#认识Java中的基本数据类型" class="headerlink" title="认识Java中的基本数据类型"></a>认识Java中的基本数据类型</h3><p>Java中有8大基本数据类型,它的对应包装类型以及数据范围如下:</p>
<table>
<thead>
<tr>
<th align="left">基本数据类型名称</th>
<th align="left">封装数据类型名称</th>
<th align="left">所占字节数</th>
<th align="left">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boolean</td>
<td align="left">Boolean</td>
<td align="left">1</td>
<td align="left">true/false</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">Byte</td>
<td align="left">1</td>
<td align="left">-128~127</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">Character</td>
<td align="left">2</td>
<td align="left">0~65535</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">Short</td>
<td align="left">2</td>
<td align="left">-32768~32767</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">Integer</td>
<td align="left">4</td>
<td align="left">-2的31次方到2的31次方-1</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">Long</td>
<td align="left">8</td>
<td align="left">2的63次方到2的63次方-1</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">Float</td>
<td align="left">4</td>
<td align="left">3.402823e+38 ~ 1.401298e-45</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">Double</td>
<td align="left">8</td>
<td align="left">1.797693e+308~ 4.9000000e-324</td>
</tr>
</tbody></table>
<p><strong>具体的字节数可以通过Character.SIZE,Double.SIZE等方法进行查看所占bit位,除以8就是所占字节数。</strong></p>
<p>值得一提的是Float.MIN_VALUE以及Double.MIN_VALUE以表示的是Float以及Double所能表示的最小正数，也就是说存在这样一种情况，0到±Float.MIN_VALUE之间的值float类型无法表示，0 到±Double.MIN_VALUE之间的值double类型无法表示。这并没有什么好奇怪的，因为这些范围内的数值超出了它们的精度范围。</p>
<h3 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h3><p>在编译阶段，若将原始类型int赋值给Integer类型，就会将原始类型自动编译为Integer.valueOf(int)，这种叫做装箱；如果将Integer类型赋值给int类型，则会自动转换调用intValue()方法，这种叫做拆箱。</p>
<p>我们来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span>  Integer(<span class="number">42</span>);</span><br><span class="line">Integer j = <span class="keyword">new</span>  Integer(<span class="number">42</span>);</span><br><span class="line">System.out.println(i &gt; j ? <span class="number">1</span> : i == j ? <span class="number">0</span> : -<span class="number">1</span>);<span class="comment">//-1</span></span><br></pre></td></tr></table></figure>

<p>返回的是-1这是为什么呢? 执行i&gt;j的时候会导致自动拆箱,也就是说直接比较它们的基本类型值,比较的结果肯定是否定的,那么接下来就会比较i==j,这里比较的是对象的引用,返回当然为false,所以最终结果为-1.</p>
<p>修改方案1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i2 &#x3D; i;</span><br><span class="line">int j2 &#x3D; j;</span><br><span class="line">System.out.println(i2 &gt; j2 ? 1 : i2 &#x3D;&#x3D; j2 ? 0 : -1);</span><br></pre></td></tr></table></figure>

<p>修改方案2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(i &gt; j ? 1 : i.intValue() &#x3D;&#x3D; j.intValue() ? 0 : -1);</span><br></pre></td></tr></table></figure>

<h3 id="基本数据类型和封装类型的比较"><a href="#基本数据类型和封装类型的比较" class="headerlink" title="基本数据类型和封装类型的比较"></a>基本数据类型和封装类型的比较</h3><p>先来看一段代码,关于基本数据类型和封装类型之间的比较</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Integer i &#x3D; 127;</span><br><span class="line">    Integer i2 &#x3D; 127;</span><br><span class="line">    </span><br><span class="line">    int i3 &#x3D; 127;</span><br><span class="line">    </span><br><span class="line">    Integer j &#x3D; 128;</span><br><span class="line">    Integer j2 &#x3D; 128;</span><br><span class="line">    int j3 &#x3D; 128;</span><br><span class="line">    </span><br><span class="line">    Integer k &#x3D; new Integer(127);</span><br><span class="line">    Integer k2 &#x3D; 127;</span><br><span class="line">    </span><br><span class="line">    Integer m &#x3D; -128;</span><br><span class="line">    int m2 &#x3D; -128;</span><br><span class="line">    </span><br><span class="line">    Integer q &#x3D; -129;</span><br><span class="line">    Integer q2 &#x3D; -129;</span><br><span class="line">    int q3 &#x3D; -129;</span><br><span class="line">    Integer q4 &#x3D; q3;</span><br><span class="line"></span><br><span class="line">    System.out.println(i &#x3D;&#x3D; i2);&#x2F;&#x2F;true</span><br><span class="line">    System.out.println(i &#x3D;&#x3D; i3);&#x2F;&#x2F;true</span><br><span class="line">    System.out.println(j &#x3D;&#x3D; j2);&#x2F;&#x2F;false</span><br><span class="line">    System.out.println(j &#x3D;&#x3D; j3);&#x2F;&#x2F;true</span><br><span class="line">    System.out.println(k &#x3D;&#x3D; k2);&#x2F;&#x2F;false</span><br><span class="line">    System.out.println(k &#x3D;&#x3D; i3);&#x2F;&#x2F;true</span><br><span class="line">    System.out.println(m &#x3D;&#x3D; m2);&#x2F;&#x2F;true</span><br><span class="line">    System.out.println(q &#x3D;&#x3D; q2);&#x2F;&#x2F;false</span><br><span class="line">    System.out.println(q &#x3D;&#x3D; q3);&#x2F;&#x2F;true</span><br><span class="line">    System.out.println(q &#x3D;&#x3D; q4);&#x2F;&#x2F;false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面的结果可以看出了当Integer和int比较的时候，实际上是在做拆箱操作,当Integer和<br>Integer进行比较的时候会发现当值的范围在-128到127之间比较的时候总是为true(k==k2这种比较特殊,因为k是new的一个对象),那么为什么会出现当值在-128在127之间的时候比较总会相等呢？是因为Integer这个类对这个区间的数据做了一个缓存，具体可以查看JDK源码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low &#x3D; -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        &#x2F;&#x2F; high value may be configured by property</span><br><span class="line">        int h &#x3D; 127;</span><br><span class="line">        String integerCacheHighPropValue &#x3D;</span><br><span class="line">        sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">        if (integerCacheHighPropValue !&#x3D; null) &#123;</span><br><span class="line">            int i &#x3D; parseInt(integerCacheHighPropValue);</span><br><span class="line">            i &#x3D; Math.max(i, 127);</span><br><span class="line">            &#x2F;&#x2F; Maximum array size is Integer.MAX_VALUE</span><br><span class="line">            h &#x3D; Math.min(i, Integer.MAX_VALUE - (-low));</span><br><span class="line">        &#125;</span><br><span class="line">        high &#x3D; h;</span><br><span class="line"></span><br><span class="line">        cache &#x3D; new Integer[(high - low) + 1];</span><br><span class="line">        int j &#x3D; low;</span><br><span class="line">        for(int k &#x3D; 0; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] &#x3D; new Integer(j++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private IntegerCache() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    assert IntegerCache.high &gt;&#x3D; 127;</span><br><span class="line">    if (i &gt;&#x3D; IntegerCache.low &amp;&amp; i &lt;&#x3D; IntegerCache.high)</span><br><span class="line">      return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出Integer缓存的结果区间,不错我们可以通过VM参数来修改缓存的High值。</p>
<p>查看源码可以看到Byte缓存了(byte)(-128<del>127)之间的值,Character缓存了(char)(0-127)之间的值,Short缓存了(short)(-128</del>127)之间的值,Long缓存了(long)(-128~127)之间的值</p>
<h3 id="类型之间的强制转换"><a href="#类型之间的强制转换" class="headerlink" title="类型之间的强制转换"></a>类型之间的强制转换</h3><p>关于强制转换，我们同样先看一段代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int s &#x3D; 32768;</span><br><span class="line">    </span><br><span class="line">System.out.println((short)s);&#x2F;&#x2F;-32768</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果为什么会这样呢？因为int是4个字节，也就是32位,而short是2个字节也就是16位，其最高位需要用来表示是正数还是负数，所以其最大值只有32767。当int转换为short的时候高位就被截断了.</p>
<p>当一个小数据向大数据转换的时候，系统会自动将其转换而不用我们手动添加转换，这些类型由”小”到”大”分别为 (byte，short，char)–int–long–float—double。这里我们所说的”大”与”小”,并不是指占用字节的多少,而是指表示值的范围的大小。</p>
<p>比如以下的代码都是编译通过的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">12</span>;</span><br><span class="line">   <span class="keyword">int</span> i = b;</span><br><span class="line">   <span class="keyword">long</span> lon = i;</span><br><span class="line">   <span class="keyword">float</span> f = lon;</span><br><span class="line">   <span class="keyword">double</span> d = f;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果低级类型为char型，向高级类型（整型）转换时，会转换为对应ASCII码值，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c=<span class="string">&#x27;c&#x27;</span>; <span class="keyword">int</span> i=c;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;output:&quot;</span>+i);<span class="comment">//output:99</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于byte,short,char三种类型而言,他们是平级的,因此不能相互自动转换,可以使用下述的强制类型转换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">short i&#x3D;99 ; char c&#x3D;(char)i; </span><br><span class="line">System.out.println(&quot;output:&quot;+c);&#x2F;&#x2F;output:c</span><br></pre></td></tr></table></figure>

<p><strong>所以，高等级的数据类型转换为低等级的数据类型的时候一定要慎重，尽量不去做这种操作</strong></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>优先级队列(PriorityQueue)源码解析</title>
    <url>/2019/12/23/priority-queue-analysis/</url>
    <content><![CDATA[<h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><p>Java中的PriorityQueue采用的是堆这种数据结构来实现的,而存储堆采用的则是数组。</p>
<p>二叉树当中，叶子节点全部在最底层，除了叶子节点外,每个节点都有左右两个子节点，这种二叉树就叫作满二叉树。</p>
<p>如果叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树就叫作完全二叉树。</p>
<p>堆是一个完全二叉树,堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值,对于每个节点的值都大于等于子树中每个节点值的堆，我们叫做大顶堆，对于每个节点的值都小于等于子树中每个节点值的堆，我们叫做小顶堆。</p>
<p><img data-src="/images/java/big-small-heap.png" alt="堆"></p>
<a id="more"></a>

<h3 id="如何实现一个堆"><a href="#如何实现一个堆" class="headerlink" title="如何实现一个堆"></a>如何实现一个堆</h3><p><img data-src="/images/java/store-heap.png" alt="数组存储"></p>
<p>可以看出来，数组中下标为i的节点，其左子节点就是下标为 <code>i*2+1</code> 的节点,右子节点则是下标为 <code>i*2+2</code> 的节点。</p>
<p>PriorityQueue数据结构如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组</span></span><br><span class="line">  <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组中元素个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>我们一般对堆中数据的操作无非是新增元素和删除元素,当做这两个操作的时候,需要继续满足堆的两个特性，不可避免就需要重建堆,这个过程叫做堆化。</p>
<h4 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h4><p>新增的时候，我们将插入的数据暂时放置到数组中的最后一个位置，运气好的话,它就刚好满足堆特性，也不需要移动元素了。不好的话就需要移动元素位置了。</p>
<p>移动过程如下：新插入的节点与父节点比较大小，如果不满足子节点大于等于父节点的大小关系(小顶堆)，则互换两个节点，一直重复这个过程，直到父子节点满足刚才说的那种关系</p>
<p><img data-src="/images/java/heapify.png" alt="堆化过程"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="keyword">int</span> i = size;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">      grow(i + <span class="number">1</span>);</span><br><span class="line">  size = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第一次插入放入数组的第一个位置(下标从0开始)</span></span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">      queue[<span class="number">0</span>] = e;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      siftUp(i, e);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆化过程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">  Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 父节点位置 (k-1)/2,这里采用无符号右移(值为整数)</span></span><br><span class="line">    <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    Object e = queue[parent];</span><br><span class="line">    <span class="comment">// 2. 如果要插入的元素大于父节点元素的值，则结束堆化过程</span></span><br><span class="line">    <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 3. 交换元素位置</span></span><br><span class="line">    queue[k] = e;</span><br><span class="line">    k = parent;</span><br><span class="line">  &#125;</span><br><span class="line">  queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下插入元素时的主要过程</p>
<ol>
<li>判断插入元素是否为空，为空则抛出NPE异常</li>
<li>在判断数组是否需要扩容,如果是则进行扩容</li>
<li>如果是第一次插入元素，则放入数组的第一个位置</li>
<li>如果不是则进行堆化过程<ol>
<li>找到父节点位置 : (k-1) &gt;&gt;&gt; 1</li>
<li>判断插入元素的值是否大于父节点(小顶堆)，如果是则结束堆化过程 </li>
<li>如果不是则交换元素位置</li>
<li>持续上面的1,2,3步骤，直到插入的节点已经是堆顶结点(k==0)</li>
</ol>
</li>
</ol>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>对于小顶堆而言,当删除堆顶元素之后，就需要把第二小的元素放到堆顶,那么第二小的元素就会出现在左右子节点中。当删除后，如果我们还是迭代的从左右子节点中选择最小元素放入堆顶，就会造成数组空洞，我用下面的图来演示这个问题。</p>
<p><img data-src="/images/java/array-holes.png" alt="数组空洞"></p>
<p>那怎么办？我们发现由于删除了一个元素,所以在移动的过程中会导致空洞，那么能不能找一个元素把这个洞填起来呢？当然莫问题啦。</p>
<p>我们可以在删除堆顶元素的时候，将最后一个元素拿来补位。由于在堆化的过程中，都是交换操作，就不会出现数组空洞了。</p>
<p><img data-src="/images/java/heapify-when-remove.png" alt="删除时堆化"></p>
<p>我们在来看看源码中是如何写的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// k=0, x=queue[size-1]</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">  Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">  <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">  <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">      <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到左右子节点中小的那个节点</span></span><br><span class="line">      Object c = queue[child];</span><br><span class="line">      <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">          ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">          c = queue[child = right];</span><br><span class="line">      <span class="comment">// 如果比小的那个节点值还要小,则循环结束</span></span><br><span class="line">      <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 移动数据</span></span><br><span class="line">      queue[k] = c;</span><br><span class="line">      k = child;</span><br><span class="line">  &#125;</span><br><span class="line">  queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是这里的结束条件是<code>k &lt; half</code>,为什么呢？因为我们的堆化是从上到下，只会找一边(要么是左子树，要么是右子树)。</p>
<h3 id="大顶堆如何实现"><a href="#大顶堆如何实现" class="headerlink" title="大顶堆如何实现"></a>大顶堆如何实现</h3><p>我们上面的例子中举例的是小顶堆，那么大顶堆PriorityQueue支持吗？当然支持，我们可以在构造函数中传入Comparator来指定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> o2 - o1;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  queue.add(<span class="number">2</span>);</span><br><span class="line">  queue.add(<span class="number">4</span>);</span><br><span class="line">  queue.add(<span class="number">3</span>);</span><br><span class="line">  queue.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      System.out.println(queue.poll());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5  4  3  2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>PriorityQueue</tag>
      </tags>
  </entry>
  <entry>
    <title>这种日志记录方式，你一定用得上!</title>
    <url>/2021/04/08/record-all-links-log/</url>
    <content><![CDATA[<p>不知道你有没有经历过被日志支配的恐惧？我就经历过，以前在服务器上要找到一个请求经过所有链路的日志，并串联起来发现真的好难，而且有了日志还没用，最好还有有参数，有响应可以串联起来整个业务逻辑，最大程度进行场景复原，那段找日志的时光真是不堪回首，令人难忘，好在后来我离开了再没去服务器上看过日志了。</p>
<p>针对这种场景，怎么解呢？针对每次请求如果我们生成一个id,每次打印日志的时候都把这个id打印出来，那么当我们搜索每次请求的时候，根据这个id进行搜索就行了,本文也是基于这个思路来实现这个功能的。</p>
<a id="more"></a>
<h3 id="请求链路"><a href="#请求链路" class="headerlink" title="请求链路"></a>请求链路</h3><p>client —&gt;  tomcat —&gt; other API</p>
<p>为了简化我们的请求逻辑,这里假设client访问我们的tomcat,然后tomcat访问外部服务</p>
<h3 id="记录请求参数以及响应"><a href="#记录请求参数以及响应" class="headerlink" title="记录请求参数以及响应"></a>记录请求参数以及响应</h3><p>为了记录请求参数以及响应结果，我们需要借助Filter来解决这个问题</p>
<p><img data-src="/images/java/logging-filter.png" alt="LoggingFilter"></p>
<h3 id="记录Restful请求以及响应"><a href="#记录Restful请求以及响应" class="headerlink" title="记录Restful请求以及响应"></a>记录Restful请求以及响应</h3><p>一般而言，我们的服务会调用其他服务，无论你是使用的dubbo还是http，我们都能通过拦截器来记录请求和响应参数，我们以rest来进行举例</p>
<p><img data-src="/images/java/rest-interceptor.png" alt="Inteceptor"></p>
<p>由于我们的response是stream,我们想要消费多次(一次返回给调用者，一次用于记录),所以我们必须对这个response进行封装</p>
<p><img data-src="/images/java/rest-config.png" alt="Config"></p>
<h3 id="Log4j2配置"><a href="#Log4j2配置" class="headerlink" title="Log4j2配置"></a>Log4j2配置</h3><p><img data-src="/images/java/log4j2-config1.png" alt="log4j2配置"></p>
<p>至此,我们的日志记录已经初具雏形了，这个时候当我们访问后端请求时,就可以通过返回的requestId去服务器上查询这次请求的链路日志</p>
<p><img data-src="/images/java/test-logging.png" alt="requestId"></p>
<p>后台日志如下</p>
<p><img data-src="/images/java/log.png" alt="后台日志"></p>
<p>查询时我们可以使用这样的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat api.log | grep $&#123;requestId&#125;</span><br></pre></td></tr></table></figure>

<p>这样就足够了吗？不，还不够好。我们可以将我们的日志发送到ElasticSearch,然后通过Kibana进行搜索，这样就不用每次查看日志都还要登录服务器了</p>
<h3 id="自定义appender"><a href="#自定义appender" class="headerlink" title="自定义appender"></a>自定义appender</h3><p>由于需要将日志发送到ES,所以我们需要自定义appender来发送日志，一个简单的appender的如下</p>
<p><img data-src="/images/java/esAppender.png" alt="ESAppender"></p>
<p>然后在Log4j中进行如下配置即可</p>
<p><img data-src="/images/java/log4j2-config2.png" alt="log4j2配置"></p>
<p>这里我的es使用的是本地安装的es,所以在运行的时候需要先启动es</p>
<h3 id="在Kibana中查询"><a href="#在Kibana中查询" class="headerlink" title="在Kibana中查询"></a>在Kibana中查询</h3><p><img data-src="/images/java/kibana-search-log.png" alt="日志"></p>
<p>至此，我们的日志平台就搭建起来了，以后别人就别想那么容易的推锅给你了。</p>
<p>所以的代码我都上传到了我的github: (<a href="https://github.com/generalthink/code">https://github.com/generalthink/code</a>)</p>
<p>以供大家参考</p>
]]></content>
  </entry>
  <entry>
    <title>RESTful资源命名最佳实践</title>
    <url>/2019/09/20/restful-resource-naming-practise/</url>
    <content><![CDATA[<p>在Rest中，数据的呈现方式叫做资源(Resource)。拥有强大而一致的REST资源命名策略,是最好的设计决策。</p>
<p>一个资源可以是单个的也可以是一个集合。比如customers是一个集合，而customer是单个资源。我们可以定义customers这个集合的资源的URI是<code>/customers</code>,而单个customer资源的URI是<code>/customers/&#123;customerId&#125;</code>。</p>
<p>资源也可以包含子集合的资源。比如，使用<code>/customers/&#123;customerId&#125;/accounts</code> 来表示某个customer下的account集合资源。同样的，对于account集合资源下的单个account我们可以定义成这样:<code>/customers/&#123;customerId&#125;/accounts/&#123;accountId&#125;</code></p>
<p>REST API使用统一资源标识符（URI）来寻址资源。REST API设计者应该创建URI，将REST API的资源模型传达给潜在的客户端开发人员。当资源命名良好时，API直观且易于使用。如果做得不好，那么相同的API会感觉难以使用和理解。</p>
<a id="more"></a>

<h3 id="使用名词来表示资源"><a href="#使用名词来表示资源" class="headerlink" title="使用名词来表示资源"></a>使用名词来表示资源</h3><p>RESTful URI应该引用作为事物（名词）的资源而不是引用动作（动词），因为名词具有动词不具有的属性 - 类似于具有属性的资源。资源的一些示例是：</p>
<ol>
<li>系统的用户</li>
<li>用户账户(银行的场景): </li>
<li>网络设备</li>
</ol>
<p>它们的资源URI可以被设计成下面这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices </span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices&#x2F;&#123;device-id&#125; </span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;user-management&#x2F;users&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;user-management&#x2F;users&#x2F;&#123;id&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了更好的说明我们把资源原型分为四个种类(document,collection,store 以及 controller),你应该总是把资源放到其中一个原型中，并且遵守它的统一命名。</p>
<h4 id="document"><a href="#document" class="headerlink" title="document"></a>document</h4><p>文档资源是一种类似于对象实例或数据库记录的单一概念(比如mysql中的一行记录,Mongodb中的document),在REST中，你可以将其视为资源集合中的单个资源。文档的状态表示通常包括具有值的字段和指向其他相关资源的链接。</p>
<p>使用单数名称表示文档资源原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices&#x2F;&#123;device-id&#125;</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;user-management&#x2F;users&#x2F;&#123;id&#125;</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;user-management&#x2F;users&#x2F;admin</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h4><p>集合资源是服务端管理的资源目录。客户可以建议将新资源添加到集合中。但是，要由集合选择是否创建新资源。集合资源选择它想要包含的内容，并决定每个包含的资源的URI。</p>
<p>使用复数名称表示集合资源原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;user-management&#x2F;users</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;user-management&#x2F;users&#x2F;&#123;id&#125;&#x2F;accounts</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><p>store是<strong>客户端管理的资源库</strong>,store资源允许API客户端放入资源，取出资源，并决定何时删除它们。store永远不会生成新的URI。相反，每个存储的资源都有一个客户端在最初放入存储时选择的URI。</p>
<p>使用复数名称表示store资源原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;cart-management&#x2F;users&#x2F;&#123;id&#125;&#x2F;carts</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;song-management&#x2F;users&#x2F;&#123;id&#125;&#x2F;playlists</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><p>controller资源有点像程序的概念,controller资源就像可执行函数，带有参数和返回值;输入和输出。</p>
<p>使用动词表示controller原型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看用户的信用卡</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;cart-management&#x2F;users&#x2F;&#123;id&#125;&#x2F;cart&#x2F;checkout</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 播放整个播放列表</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;song-management&#x2F;users&#x2F;&#123;id&#125;&#x2F;playlist&#x2F;play</span><br></pre></td></tr></table></figure>

<p>这里的controller为什么要用动词呢?其实大家可以想象下Spring中Controller做了什么事情,它调用了service组合成各个业务逻辑,将数据组合起来之后进行返回.</p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>使用一致的资源命名约定和URI格式，以最小化和最大可读性和可维护性。你可以实现以下设计提示以实现一致性：</p>
<h4 id="使用正斜杠（-）表示层次关系"><a href="#使用正斜杠（-）表示层次关系" class="headerlink" title="使用正斜杠（/）表示层次关系"></a>使用正斜杠（/）表示层次关系</h4><p>正斜杠（/）字符用于URI的路径部分，以指示资源之间的层次关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;device-management</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices&#x2F;&#123;id&#125;</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices&#x2F;&#123;id&#125;&#x2F;scripts</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices&#x2F;&#123;id&#125;&#x2F;scripts&#x2F;&#123;id&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不要在URI中使用尾部正斜杠（-）"><a href="#不要在URI中使用尾部正斜杠（-）" class="headerlink" title="不要在URI中使用尾部正斜杠（/）"></a>不要在URI中使用尾部正斜杠（/）</h4><p>作为URI路径中的最后一个字符，正斜杠（/）不会添加语义值，并可能导致混淆。最好完全放弃它们</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*这个版本更好*&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用连字符（-）来提高URI的可读性"><a href="#使用连字符（-）来提高URI的可读性" class="headerlink" title="使用连字符（ - ）来提高URI的可读性"></a>使用连字符（ - ）来提高URI的可读性</h4><p>要使你的URI易于扫描和解释，请使用连字符（ - ）字符来提高长路径段中名称的可读性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 更好可读性</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;inventory-management&#x2F;managed-entities&#x2F;&#123;id&#125;&#x2F;install-script-location</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可读性不够高</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;inventory-management&#x2F;managedEntities&#x2F;&#123;id&#125;&#x2F;installScriptLocation</span><br></pre></td></tr></table></figure>

<h4 id="不用使用下滑线"><a href="#不用使用下滑线" class="headerlink" title="不用使用下滑线 _"></a>不用使用下滑线 _</h4><p>可以使用下划线代替连字符作为分隔符 - 但是根据应用程序的字体，下划线 _ 字符可能会在某些浏览器或屏幕中被部分遮挡或完全隐藏。为避免这种混淆，请使用连字符 - 而不是下划线 _。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 更具可读性</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;inventory-management&#x2F;managed-entities&#x2F;&#123;id&#125;&#x2F;install-script-location</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 更容易出错</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;inventory_management&#x2F;managed_entities&#x2F;&#123;id&#125;&#x2F;install_script_location</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="在URI中使用小写字母"><a href="#在URI中使用小写字母" class="headerlink" title="在URI中使用小写字母"></a>在URI中使用小写字母</h4><p>方便时，URI路径中应始终首选小写字母。</p>
<p><a href="http://www.rfc-base.org/txt/rfc-3986.txt">RFC 3986</a>将URI定义为区分大小写，但协议和host除外</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">http:&#x2F;&#x2F;api.example.org&#x2F;my-folder&#x2F;my-doc</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">HTTP:&#x2F;&#x2F;API.EXAMPLE.ORG&#x2F;my-folder&#x2F;my-doc</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">http:&#x2F;&#x2F;api.example.org&#x2F;My-Folder&#x2F;my-doc</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，1和2是相同的，但3不是,因为它使用大写字母的My-Folder。</p>
<h4 id="不要使用文件扩展名"><a href="#不要使用文件扩展名" class="headerlink" title="不要使用文件扩展名"></a>不要使用文件扩展名</h4><p>文件扩展名看起来很糟糕，不会增加任何优势。删除它们也会减少URI的长度。没理由保留它们。除了上述原因，如果你想使用文件扩展突出显示API的媒体类型，那么你应该依赖于通过Content-Type标头传达的媒体类型来确定如何处理正文的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 不要这样用</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices.xml</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正确的URI</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="切勿在URI中使用CRUD函数名称"><a href="#切勿在URI中使用CRUD函数名称" class="headerlink" title="切勿在URI中使用CRUD函数名称"></a>切勿在URI中使用CRUD函数名称</h3><p>URI不应用于指示执行CRUD功能。URI应该用于唯一标识资源，而不是对它们的任何操作。应使用HTTP请求方法来指示执行哪个CRUD功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取所有设备</span><br><span class="line">HTTP GET http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices</span><br><span class="line">&#x2F;&#x2F; 创建新设备</span><br><span class="line">HTTP POST http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据给定id获取设备</span><br><span class="line">HTTP GET http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices&#x2F;&#123;id&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据给定id更新设备</span><br><span class="line">HTTP PUT http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices&#x2F;&#123;id&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据给定id删除设备</span><br><span class="line">HTTP DELETE http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices&#x2F;&#123;id&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用查询组件过滤URI集合"><a href="#使用查询组件过滤URI集合" class="headerlink" title="使用查询组件过滤URI集合"></a>使用查询组件过滤URI集合</h3><p>很多时候，你会遇到需要根据某些特定资源属性对需要排序，过滤或限制的资源集合的要求。为此，不要创建新的API  - 而是在资源集合API中启用排序，过滤和分页功能，并将输入参数作为查询参数传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices?region&#x3D;USA</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices?region&#x3D;USA&amp;brand&#x3D;XYZ</span><br><span class="line">http:&#x2F;&#x2F;api.example.com&#x2F;device-management&#x2F;managed-devices?region&#x3D;USA&amp;brand&#x3D;XYZ&amp;sort&#x3D;installation-date</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantReadWriteLock源码分析</title>
    <url>/2020/12/16/rrw-analysis/</url>
    <content><![CDATA[<p>针对读多写少的场景，Java提供了另外一个实现Lock接口的读写锁ReentrantReadWriteLock(RRW),之前分析过ReentrantLock是一个独占锁，同一时间只允许一个线程访问。</p>
<p>而 RRW 允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。<br>读写锁内部维护了两个锁，一个是用于读操作的ReadLock，一个是用于写操作的 WriteLock。</p>
<p>读写锁遵守以下三条基本原则</p>
<ol>
<li>允许多个线程同时读共享变量；</li>
<li>只允许一个线程写共享变量；</li>
<li>如果一个写线程正在执行写操作，此时禁止读线程读共享变量。</li>
</ol>
<a id="more"></a>

<h3 id="读写锁如何实现"><a href="#读写锁如何实现" class="headerlink" title="读写锁如何实现"></a>读写锁如何实现</h3><p>RRW也是基于AQS实现的，它的自定义同步器(继承自AQS)需要在同步状态state上维护多个读线程和一个写线程的状态。RRW的做法是使用高低位来实现一个整形控制两种状态，一个int占4个字节，一个字节8位。所以高16位表示读，低16位表示写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 10000000000000000(65536)</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 65535</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1111111111111111</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读锁(共享锁)的数量,只计算高16位的值</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写锁(独占锁)的数量</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="获取读锁"><a href="#获取读锁" class="headerlink" title="获取读锁"></a>获取读锁</h3><p>当线程获取读锁时，首先判断同步状态低16位，如果存在写锁，则获取锁失败，进入CLH队列阻塞，反之，判断当前线程是否应该被阻塞，如果不应该阻塞则尝试 CAS 同步状态，获取成功更新同步锁为读状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">           </span><br><span class="line">  Thread current = Thread.currentThread();</span><br><span class="line">  <span class="keyword">int</span> c = getState();</span><br><span class="line">  <span class="comment">// 如果当前已经有写锁了，则获取失败</span></span><br><span class="line">  <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">      getExclusiveOwnerThread() != current)</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 获取读锁数量</span></span><br><span class="line">  <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非公平锁实现中readerShouldBlock()返回true表示CLH队列中有正在排队的写锁</span></span><br><span class="line">  <span class="comment">// CAS设置读锁的状态值</span></span><br><span class="line">  <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">      r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">      compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 省略记录获取readLock次数的代码</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 针对上面失败的条件进行再次处理</span></span><br><span class="line">  <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 无线循环</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果不是当前线程持有写锁，则进入CLH队列阻塞</span></span><br><span class="line">      <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果reader应该被阻塞</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">        <span class="comment">// Make sure we&#x27;re not acquiring read lock reentrantly</span></span><br><span class="line">        <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前线程没有持有读锁，即不存在锁重入情况。则进入CLH队列阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享锁的如果超出了限制</span></span><br><span class="line">    <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CAS设置状态值</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 省略记录readLock次数的代码</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SHARED_UNIT</code>的值是65536，也就是说，当第一次获取读锁的后，state的值就变成了65536。<br><strong>在公平锁的实现中当CLH队列中有排队的线程，<code>readerShouldBlock()</code>方法就会返回为true。非公平锁的实现中则是当CLH队列中存在等待获取写锁的线程就返回true</strong></p>
<p>还需要注意的是获取读锁的时候，如果当前线程已经持有写锁，是仍然能获取读锁成功的。后面会提到锁的降级，如果你对那里的代码有疑问，可以在回过头来看看这里申请锁的代码</p>
<h3 id="释放读锁"><a href="#释放读锁" class="headerlink" title="释放读锁"></a>释放读锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">           </span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 减去65536</span></span><br><span class="line">    <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">    <span class="comment">// 只有当state的值变成0才会真正的释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">        <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放锁时，state的值需要减去65536，因为当第一次获取读锁后，state值变成了65536。</p>
<p>任何一个线程释放读锁的时候只有在<code>state==0</code>的时候才真正释放了锁，比如有100个线程获取了读锁，只有最后一个线程执行<code>tryReleaseShared</code>方法时才真正释放了锁，此时会唤醒CLH队列中的排队线程。</p>
<h3 id="获取写锁"><a href="#获取写锁" class="headerlink" title="获取写锁"></a>获取写锁</h3><p>一个线程尝试获取写锁时，会先判断同步状态 state 是否为0。如果 state 等于 0，说明暂时没有其它线程获取锁；如果 state 不等于 0，则说明有其它线程获取了锁。</p>
<p>此时再判断state的低16位(w)是否为0，如果w为0，表示其他线程获取了读锁，此时进入CLH队列进行阻塞等待。</p>
<p>如果w不为0，则说明其他线程获取了写锁，此时需要判断获取了写锁的是不是当前线程，如果不是则进入CLH队列进行阻塞等待，如果获取了写锁的是当前线程，则判断当前线程获取写锁是否超过了最大次数，若超过，抛出异常。反之则更新同步状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取写锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           </span><br><span class="line">  Thread current = Thread.currentThread();</span><br><span class="line">  <span class="keyword">int</span> c = getState();</span><br><span class="line">  <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断state是否为0</span></span><br><span class="line">  <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取锁失败</span></span><br><span class="line">      <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断当前线程获取写锁是否超出了最大次数65535</span></span><br><span class="line">      <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 锁重入</span></span><br><span class="line">      setState(c + acquires);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 非公平锁实现中writerShouldBlock()永远返回为false</span></span><br><span class="line">  <span class="comment">// CAS修改state的值</span></span><br><span class="line">  <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">      !compareAndSetState(c, c + acquires))</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CAS成功后，设置当前线程为拥有独占锁的线程</span></span><br><span class="line">  setExclusiveOwnerThread(current);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在公平锁的实现中当CLH队列中存在排队的线程,那么<code>writerShouldBlock()</code>方法就会返回为true，此时获取写锁的线程就会被阻塞。</p>
<h3 id="释放写锁"><a href="#释放写锁" class="headerlink" title="释放写锁"></a>释放写锁</h3><p>释放写锁的逻辑比较简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 写锁是否被当前线程持有</span></span><br><span class="line">  <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">  <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有其他线程持有写锁</span></span><br><span class="line">  <span class="keyword">if</span> (free)</span><br><span class="line">      setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">  setState(nextc);</span><br><span class="line">  <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="锁的升级？"><a href="#锁的升级？" class="headerlink" title="锁的升级？"></a>锁的升级？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 准备读缓存</span></span><br><span class="line">readLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  v = map.get(key);</span><br><span class="line">  <span class="keyword">if</span>(v == <span class="keyword">null</span>) &#123;</span><br><span class="line">    writeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(map.get(key) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新缓存代码，省略</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  readLock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于上面的代码，先是获取读锁，然后再升级为写锁，这样的行为叫做锁的升级。可惜RRW不支持，这样会导致写锁永久等待，最终导致线程被永久阻塞。所以<strong>锁的升级是不允许的</strong>。</p>
<h3 id="锁的降级"><a href="#锁的降级" class="headerlink" title="锁的降级"></a>锁的降级</h3><p>虽然锁的升级不允许，但是锁的降级却是可以的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">ReadLock readLock = lock.readLock();</span><br><span class="line"></span><br><span class="line">WriteLock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; dataMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processCacheData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  readLock.lock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!cacheValid()) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放读锁，因为不允许</span></span><br><span class="line">    readLock.unlock();</span><br><span class="line"></span><br><span class="line">    writeLock.lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!cacheValid()) &#123;</span><br><span class="line">          dataMap.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;think123&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 降级为读锁</span></span><br><span class="line">      readLock.lock();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 仍然持有读锁</span></span><br><span class="line">    System.out.println(dataMap);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      readLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cacheValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !dataMap.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="RRW需要注意的问题"><a href="#RRW需要注意的问题" class="headerlink" title="RRW需要注意的问题"></a>RRW需要注意的问题</h3><ol>
<li><p>在读取很多、写入很少的情况下，RRW 会使写入线程遭遇饥饿（Starvation）问题，也就是说写入线程会因迟迟无法竞争到锁而一直处于等待状态。</p>
</li>
<li><p>写锁支持条件变量，读锁不支持。读锁调用newCondition() 会抛出UnsupportedOperationException 异常</p>
</li>
</ol>
<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p>之前有写过AQS的实现，ReentrantLock的实现，可以参考我下面的文章</p>
<ol>
<li><a href="https://generalthink.github.io/2020/11/20/sourcecode-of-AQS/">AQS源码分析</a></li>
<li><a href="https://generalthink.github.io/2020/11/23/about-ReentrantLock-problems/">ReentrantLock分析</a></li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机中的补码</title>
    <url>/2016/02/14/show-number-in-computer/</url>
    <content><![CDATA[<h3 id="二进制表示法"><a href="#二进制表示法" class="headerlink" title="二进制表示法"></a>二进制表示法</h3><p>在计算机的世界里,只有0和1,我们也通常使用0和1来表示数字,比如8在计算机(8位机)中的二进制表示法就是00001000，那么负数呢？在计算机中如何表示负数呢？</p>
<p>大学学习过的计算机原理中告诉我们负数在计算机中是使用补码(<strong>维基百科中也叫作二补数</strong>)进行表示的，那么介绍这种表示方法之前想要介绍几个概念。</p>
<p><strong>原码</strong>：将一个整数，转换成二进制，就是其原码。如单字节的5的原码为：0000 0101；-5的原码为1000 0101</p>
<p><strong>反码</strong>：正数的反码就是其原码；负数的反码是将原码中，除符号位以外，每一位取反。如单字节的5的反码为：0000 0101；-5的原码为1111 1010。</p>
<p><strong>补码</strong>：正数的补码就是其原码；负数的反码+1就是补码。如单字节的5的补码为：0000 0101；-5的补码为1111 1011。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Integer.toBinaryString(-<span class="number">5</span>));</span><br><span class="line">   System.out.println(Integer.toBinaryString(<span class="number">5</span>));</span><br><span class="line">   <span class="comment">//在我的计算机中的输出结果为：</span></span><br><span class="line">   -<span class="number">5</span>的二进制为：<span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111011</span></span><br><span class="line"><span class="number">5</span>的二进制为： <span class="number">101</span></span><br></pre></td></tr></table></figure>

<p>为什么要使用补码表示负数？<br>假设我们不使用补码,而仍然采用高位标示符号位的方法，那么-5我们可以表示为1000 0101，那么我们来做一个加法。看看8+(-5)=3是否可以正确实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0 0 1 0 0 0</span><br><span class="line">1 0 0 0 0 1 0 1 </span><br><span class="line">------------------</span><br><span class="line">1 0 0 0 1 1 0 1</span><br></pre></td></tr></table></figure>
<p>最终的结果是-13,很明显这个结果并不是我们想要的,难道需要为正数和负数相加设计一套新的电路？</p>
<p>现在我们来看看使用补码的方式，同样运行8+(-5)=3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>   </span><br><span class="line">------------------</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>  此时产生了溢出位，将被自动舍弃。</span><br><span class="line"></span><br><span class="line">[<span class="number">1000</span> <span class="number">0101</span>(-<span class="number">5</span>源码)------&gt;<span class="number">1111</span> <span class="number">1010</span>(-<span class="number">5</span>反码,除符号位之外取反)-----&gt;<span class="number">1111</span> <span class="number">1011</span>(补码)]</span><br></pre></td></tr></table></figure>

<p>此时，得到的就是我们想要的结果3了。</p>
<h3 id="补码的本质"><a href="#补码的本质" class="headerlink" title="补码的本质"></a>补码的本质</h3><p>在回答补码为什么能正确实现加法运算之前，我们先看看它的本质，也就是那两个步骤的转换方法是怎么来的。<br>要将正数转成对应的负数，其实只要用0减去这个数就可以了。比如，-8其实就是0-8。<br>已知8的二进制是00001000，-8就可以用下面的式子求出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">　<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">－<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> １<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">－－－－－－－－－</span><br></pre></td></tr></table></figure>

<p>因为00000000（被减数）小于0000100（减数），所以不够减。请回忆一下小学算术，如果被减数的某一位小于减数，我们怎么办？很简单，问上一位借1就可以了。</p>
<p>所以，0000000也问上一位借了1，也就是说，被减数其实是100000000，算式也就改写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">－<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">－－－－－－－－－</span><br><span class="line">　<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure>
<p>进一步观察，可以发现100000000 = 11111111 + 1，所以上面的式子可以拆成两个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">　<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">－<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line">－－－－－－－－－</span><br><span class="line">　<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">＋<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">－－－－－－－－－</span><br><span class="line">　<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure>
<p>2的补码的两个转换步骤就是这么来的。</p>
<h3 id="为什么正数加法适用补码"><a href="#为什么正数加法适用补码" class="headerlink" title="为什么正数加法适用补码?"></a>为什么正数加法适用补码?</h3><p>实际上，我们要证明的是，X-Y或X+(-Y)可以用X加上Y的2的补码完成。<br>Y的2的补码等于(11111111-Y)+1。所以，X加上Y的2的补码，就等于X + (11111111-Y) + 1，我们假定这个算式的结果等于Z，即 Z = X + (11111111-Y) + 1</p>
<p>那么Z = X - Y + 100000000 =  X-Y(100000000在8位机中产生了溢出),这就证明了可以使用补码来进行负数的加法运算</p>
<h3 id="关于补码的其他说明"><a href="#关于补码的其他说明" class="headerlink" title="关于补码的其他说明"></a>关于补码的其他说明</h3><ol>
<li><a href="http://www.ruanyifeng.com/blog/2009/08/twos_complement.html">二进制补码</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8">二补数–维基百科</a></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>关于锁使用的补充说明</title>
    <url>/2018/07/24/something-about-synchronized/</url>
    <content><![CDATA[<p>上一篇文章我讲了下synchronized关于锁优化的问题，但是还是有人不太清楚临界区到底是什么，也对notify的机制有点疑惑，这篇文章就来分析一下。</p>
<h3 id="什么是临界区"><a href="#什么是临界区" class="headerlink" title="什么是临界区"></a>什么是临界区</h3><p>我们都知道Synchroinzed可以修饰代码块，实例方法,静态方法，区别只是持有的对象锁不一样罢了，持有了这把锁你就可以为所欲为了，就好比很多人去抢厕所，如果大家都在一个厕所里面上，那么很明显会发生很多不可描述的事儿,所以就需要去抢厕所的使用，你抢到了然后你进去厕所把门反锁了，这个时候别人进不来，厕所里面的公共资源你想怎样用就怎样用，只有等你出来之后这个时候其他人才能去抢厕所。如果在你准备上厕所的时候你发现没有厕纸了，这个时候你得要先去拿纸，让别人先用厕所了。</p>
<p>上面的例子也很好的说明了临界区(上面故事的厕所，也就是公共资源),当多个线程去竞争的时候获取锁的这个线程就可以安全的执行，可以保证原子性，一致性，顺序性(JMM)。获取锁这个操作是通过monitorenter,退出临界区的时候是执行monitorexit指令,此时会释放持有的锁。这个时候线程可以继续去竞争,至于是谁竞争上就取决于操作系统了,线程的优先级并不一定能起作用，因为调度是取决于操作系统，不同的操作系统的优先级不一样，可能操作系统总共只有三个级别，但是java中是从1到10的，那么必然会导致有重复，所以调度不要完全依赖优先级。</p>
<p>当遇到没有带厕纸的时候，其实这也对应了一个问题，就是在执行某些操作的时候可能需要等待其他条件先满足在执行，这个时候你就会让出这把锁，让其他线程去执行，等到条件满足了之后你在去运行。</p>
<p>需要注意的是当操作系统分配给我们的时间片用完了的时候这个时候并不会让出锁(Thread.sleep)，而是会等待操作系统的调度，等到下一次执行。</p>
<h3 id="调用了notify-All-后谁会被唤醒？"><a href="#调用了notify-All-后谁会被唤醒？" class="headerlink" title="调用了notify(All)后谁会被唤醒？"></a>调用了notify(All)后谁会被唤醒？</h3><p>这里存在<strong>两种情况</strong></p>
<ol>
<li>如果是通过notify来唤起的线程，那先进入wait的线程会先被唤起来</li>
<li>如果是通过nootifyAll唤起的线程，默认情况是最后进入的会先被唤起来，即LIFO的策略</li>
</ol>
<p>验证这个问题很简单，看看下面这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lock  = <span class="keyword">new</span> Object();</span><br><span class="line">        Thread p = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(lock));</span><br><span class="line">        Thread con = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(lock));</span><br><span class="line"></span><br><span class="line">        p.start();</span><br><span class="line">        con.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span>  <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;producer will wait&quot;</span>);</span><br><span class="line">                lock.wait();</span><br><span class="line">                System.out.println(<span class="string">&quot;producer wait over&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span>  <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟producer先执行</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;consumer will notify&quot;</span>);</span><br><span class="line">            lock.notify();</span><br><span class="line">            System.out.println(<span class="string">&quot;producer notify over&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">producer will wait</span><br><span class="line">consumer will notify</span><br><span class="line">producer notify over</span><br><span class="line">producer wait over</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个结果证明了我刚才说的，只有在退出同步代码块之后才会释放锁，而不是在调用了notify(All)方法就马上去唤醒，但是这只是一个默认策略，也是可以修改的。</p>
<h3 id="wait的线程是否会占用cpu"><a href="#wait的线程是否会占用cpu" class="headerlink" title="wait的线程是否会占用cpu?"></a>wait的线程是否会占用cpu?</h3><p>wait/nofity是通过jvm里的park/unpark机制<a href="https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp#L1507">wait/notify底层原理</a><br>来实现的，在linux下这种机制又是通过pthread_cond_wait/pthread_cond_signal来完成的，pthread_cond_wait其思想就是先释放锁，让其他线程可以执行，然后进入睡眠，等待被唤醒，被唤醒之后重新加锁。<br>因此当线程进入到wait状态的时候其实是会放弃cpu的，也就是说这类线程是不会占用cpu资源。</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>因为一个bug,我还是掀开了openfeign的神秘面纱</title>
    <url>/2023/12/14/spring-cloud-openfeign-analysis/</url>
    <content><![CDATA[<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>最近项目中访问一个外部api报错了，报错信息如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</span><br></pre></td></tr></table></figure>
<p>看着像是证书问题，这个时候我首先想到的是百度下，看看怎么解决。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>百度告诉我说如果你open-feign中使用的是http client,那么可以通过下面的配置来让跳过SSL验证</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">disable-ssl-validation:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>结果还是报同样的错误。 于是我又百度,又重新找了一个解决方法，这次的方案是让我自己重写Client了,具体操作如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Client <span class="title">feignClient</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException, KeyManagementException </span>&#123;</span><br><span class="line">    SSLContext ctx = SSLContext.getInstance(<span class="string">&quot;SSL&quot;</span>);</span><br><span class="line">    X509TrustManager tm = <span class="keyword">new</span> X509TrustManager() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ctx.init(<span class="keyword">null</span>, <span class="keyword">new</span> TrustManager[]&#123;tm&#125;, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">new</span> Client.Default(ctx.getSocketFactory(), (hostName, session) -&gt; <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这把我感觉要起飞了， 一切尽在掌握中,重新deploy,打开postman,测试测试我的接口。</p>
<p>测试后感觉好了但是看日志又没有完全好。 这个接口倒是不报错了，但是我调用内部服务给我报错了，比如我这里的内部服务名称叫做</p>
<p>pro-file, 就现在它没法根据我这个pro-file名字找到对应的IP了，从而导致我这个服务使用不了了。</p>
<p>百度误我！</p>
<h3 id="求人不如求己"><a href="#求人不如求己" class="headerlink" title="求人不如求己"></a>求人不如求己</h3><p>此刻我自信的打开了IDEA, 输入了类名 <code>FeignAutoConfiguration</code> , Spring Cloud关于某个组件的自动注入类大多是XXXConfiguration, 所以按照这么找准没错。</p>
<p>然后我有自信的把断点打在了这个部分 <code>FeignAutoConfiguration:246</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ApacheHttpClient.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(CloseableHttpClient.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;feign.httpclient.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="meta">@Conditional(HttpClient5DisabledConditions.class)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientFeignConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(Client.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Client <span class="title">feignClient</span><span class="params">(HttpClient httpClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApacheHttpClient(httpClient);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新启动项目，好家伙断点没进来呀。 没进来的原因大概率可能是不满足条件,我赶紧看看这里对应的Conditional, 发现了我的代码中没有</p>
<p>设置<code>feign.httpclient.enabled</code>属性的值, 而且这里也没有设置havingValue, 根据源码可以知道， 如果没有设置havingValue, 那么这个属性的值会被和false进行比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//org.springframework.boot.autoconfigure.condition.OnPropertyCondition.Spec#isMatch</span></span><br><span class="line"><span class="comment">// 这里的requiredValue是havingValue</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String value, String requiredValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(requiredValue)) &#123;</span><br><span class="line">        <span class="keyword">return</span> requiredValue.equalsIgnoreCase(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !<span class="string">&quot;false&quot;</span>.equalsIgnoreCase(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>搞半天这个Configurtion相当于没起作用。 </p>
<p>好好好，这么玩是吧。</p>
<p>既然这个配置不生效，那肯定有其他配置生效，我就找找其他配置，最终我在spring-cloud-openfeign-core这个jar包的loadbalancer这个包下面找到了我想要的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(Feign.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(&#123; LoadBalancerClient.class, LoadBalancerClientFactory.class &#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(FeignAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; BlockingLoadBalancerClientAutoConfiguration.class, LoadBalancerAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(FeignHttpClientProperties.class)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="comment">// Order is important here, last should be the default, first should be optional</span></span><br><span class="line"><span class="comment">// see</span></span><br><span class="line"><span class="comment">// https://github.com/spring-cloud/spring-cloud-netflix/issues/2086#issuecomment-316281653</span></span><br><span class="line"><span class="meta">@Import(&#123; HttpClientFeignLoadBalancerConfiguration.class, OkHttpFeignLoadBalancerConfiguration.class,</span></span><br><span class="line"><span class="meta">        HttpClient5FeignLoadBalancerConfiguration.class, DefaultFeignLoadBalancerConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignLoadBalancerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为我们项目是采用springcloud alibaba进行开发，所以引入了spring-cloud-loadbalancer这个包,因此这个这个配置类就会生效，由于我们没有配置使用httpclient,同样也未使用okhttp,所以生效的配置类只有一个，那就是 <code>DefaultFeignLoadBalancerConfiguration</code></p>
<p>这个配置类中retryClient会被加载,因为我们引入了spring-retry.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;org.springframework.retry.support.RetryTemplate&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(LoadBalancedRetryFactory.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;spring.cloud.loadbalancer.retry.enabled&quot;, havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">        matchIfMissing = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Client <span class="title">feignRetryClient</span><span class="params">(LoadBalancerClient loadBalancerClient,</span></span></span><br><span class="line"><span class="function"><span class="params">        LoadBalancedRetryFactory loadBalancedRetryFactory, LoadBalancerClientFactory loadBalancerClientFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RetryableFeignBlockingLoadBalancerClient(<span class="keyword">new</span> Client.Default(<span class="keyword">null</span>, <span class="keyword">null</span>), loadBalancerClient,</span><br><span class="line">            loadBalancedRetryFactory, loadBalancerClientFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也是为什么上面我们自己配置了自己的Client后，访问其他spring cloud服务会找不到地址，这是因为默认的client不会去通过LoadBalancer去获取服务地址。 </p>
<h3 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h3><p>期间debug的时候,还发现最终的Client的SeataFeignClient,我一看才发现某个公共包引入了Seata,但是没有使用Seata功能,然后Seata会把我们最终使用的FeignClient在给封装一次，所以后面我就把seata从项目中移除了。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>既然问题找到了,那么就好修改了，修改方式有两种，一种是创建自己的<code>RetryableFeignBlockingLoadBalancerClient</code>, 就把上面的代码拿过来抄一遍，只是自己指定SSLContext，另一种是启用httpclient</p>
<h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Client <span class="title">feignRetryClient</span><span class="params">(LoadBalancerClient loadBalancerClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                               LoadBalancedRetryFactory loadBalancedRetryFactory, LoadBalancerClientFactory loadBalancerClientFactory)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, KeyManagementException </span>&#123;</span><br><span class="line">    SSLContext ctx = SSLContext.getInstance(<span class="string">&quot;SSL&quot;</span>);</span><br><span class="line">    X509TrustManager tm = <span class="keyword">new</span> X509TrustManager() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ctx.init(<span class="keyword">null</span>, <span class="keyword">new</span> TrustManager[]&#123;tm&#125;, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RetryableFeignBlockingLoadBalancerClient(<span class="keyword">new</span> Client.Default(ctx.getSocketFactory(), (hostname, session) -&gt; <span class="keyword">true</span>), loadBalancerClient,</span><br><span class="line">            loadBalancedRetryFactory, loadBalancerClientFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>另一种方案就是启用httpclient,并且禁用ssl验证，配置如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">disable-ssl-validation:</span> <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自此这个问题解决了，当然在使用中更加倾向使用方案二，因为Feign默认的Client采用的是<code>HttpURLConnection</code>,它没有连接池,当然你也可以使用okhttp。</p>
<h3 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h3><p>这个问题看起来简单，但是排查起来还是颇费心思,很多细节隐藏到了框架之下,所以我想看源码还是有好处的，因为网上的文章别人的情况可能和你不一样，与其遨游在各个文章里面，还不如debug一把。</p>
]]></content>
      <tags>
        <tag>SpringCloud</tag>
        <tag>OpenFeign</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>让你的SpringBoot一次build,到处运行</title>
    <url>/2019/10/25/springboot-with-k8s/</url>
    <content><![CDATA[<p>开发web项目的时候，我们一般会有多个环境(dev,beta,rc,production),然后每次使用maven打包的时候都要指定profile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mven clean package -P beta</span><br></pre></td></tr></table></figure>
<p>这样就可以将application-{profile}.properties打入jar包中。这也就意味着对于不同的环境我们要打不同的包，虽然他们只有一些配置信息不同而已。</p>
<p>那么有没有办法在不同的环境中使用相同的应用程序代码呢? 当然有,<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config">springboot提供了这样的机会</a>,它允许我们通过很多种方式来决定配置文件是哪一个,当然啦本篇文章并不是介绍有哪些加载外部配置文件的方式。</p>
<a id="more"></a>

<p>就比如祸水三千，我只取一瓢。所以这次我们直接指定property文件的位置即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar myproject.jar --spring.config.location&#x3D;classpath:&#x2F;default.properties,&#x2F;myconfig&#x2F;application.properties</span><br></pre></td></tr></table></figure>

<p>道理是这么个道理,但是现在大多的项目都是部署在k8s上的,那么应该如何做呢？</p>
<p>这里我借助了k8s configMap来实现加载外部配置文件达到我们的目的。</p>
<p>首先这里生成了configMap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create configmap application-configmap --from-file&#x3D;application.properties&#x3D;..&#x2F;smcp-web&#x2F;src&#x2F;main&#x2F;resources&#x2F;application-beta.properties -o yaml -n smcp| kubectl replace -f -</span><br></pre></td></tr></table></figure>

<p>解释下上面命令的意思,每一次在打包镜像之后，都会重新生成configMap,生成的application-configmap中，key=application.properties,value则是项目中application-beta.properties的内容</p>
<blockquote>
<p>生成configmap有很多种方式，可以根据自己的需求来生成，可以查看官方文档 <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/">https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/</a><br>-n 的意思是指定namespace,如果你使用的是默认的namespace,那么可以不用指定。 -n == –namespace</p>
</blockquote>
<p>我们生成的上面的configMap可以通过<code> kubectl get configmap application-configmap -o yaml -n smcp</code>查看</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">application.properties:</span> <span class="string">|</span></span><br><span class="line">    <span class="string">logging.level.com.project.smcp=INFO</span></span><br><span class="line">    <span class="string">logging.level.org.apache.shiro=INFO</span></span><br><span class="line">    <span class="string">logging.level.okhttp3.OkHttpClient=ERROR</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="number">2019-10-24T11:41:57Z</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">application-configmap</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">smcp</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;62755048&quot;</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">48c8ab36-f653-11e9-9eab-fa163fea9021</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到其实是将application-beta.properties文件中的内容全部拷贝到了data中，然后这些所有值的key为application.properties.再来看看在我们deployment.yml文件中如何使用</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">smcp-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">smcp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">smcp-service</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">smcp-service</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">smcp-service</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">docker-registry.xxx.com/xxx/smcp-web:latest</span></span><br><span class="line">        <span class="attr">args:</span> [<span class="string">&quot;--spring.config.location=/smcp-config/application.properties&quot;</span>]</span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9000</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">application-config</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">smcp-config</span></span><br><span class="line">        <span class="attr">envFrom:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">secretRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">my-secret</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">application-config</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">application-configmap</span></span><br><span class="line">          <span class="attr">items:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">application.properties</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">application.properties</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">smcp-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">smcp</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">smcp-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targetPort:</span> <span class="number">9000</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">smcp-service</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure>

<p>经过上面的配置，现在application.properties文件就处于/smcp-config下了。看到这里可能会有人有疑问,为什么我的configMap要单独用命令生成，而不是在demployment.yaml文件中单独声明configMap类型的配置呢?<br>其实也是可以的，但是如果这样做你每次添加了环境变量你都要去demployment.yml中添加配置,你这样可能就要配置两次(application-{profile}.properties中还要配置一次)，所以我就干脆用命令生成，在开发的时候不要考虑k8s的存在。</p>
<p>还要注意上面的args参数，通过它我们指定了外部环境变量的路径。而对于生成镜像的dockerfile，其实也很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">EXPOSE 9090</span><br><span class="line">ADD target&#x2F;smcp-web.jar &#x2F;smcp-web.jar</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;,&quot;&#x2F;smcp-web.jar&quot;]</span><br></pre></td></tr></table></figure>

<p>最后当我们执行了下面的命令之后，就可以部署我们的容器到k8s中了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f deployment.yml</span><br></pre></td></tr></table></figure>

<p>最后部署后，进入Pod中，可以看到目录结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smcp-web.jar</span><br><span class="line">smcp-config</span><br><span class="line">  -- application.properties</span><br></pre></td></tr></table></figure>

<p>而启动命令也变成了下面这样，可以通过<code>ps -ef</code>查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar &#x2F;smcp-web.jar --spring.config.location&#x3D;&#x2F;smcp-config&#x2F;application.properties</span><br></pre></td></tr></table></figure>

<p>上面使用configMap的方式处理,当然还可以直接在环境变量中使用configMap(参考上面secretRef的方式)，当使用环境变量的方式注入configMap的时候，你需要使用下面这样的命令生成数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create configmap application-configmap --fron-env-file&#x3D;src&#x2F;main&#x2F;resources&#x2F;application-beta.properties</span><br></pre></td></tr></table></figure>

<p>同时yaml文件中关于configMap的修改成下面这样,使用环境变量的方式记得把volumes去掉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">envFrom:</span><br><span class="line">- configMapRef:</span><br><span class="line">  name: application-configmap</span><br></pre></td></tr></table></figure>
<p>但是使用环境变量注入的方式有一点需要注意,当你更新了configMap而不重新部署的时候,容器中的变量是不会更新的，而如果使用mountPath的方式,环境变量的值就会更新(大概10s左右)。</p>
<blockquote>
<p>如果你还使用mountPath的同时还使用了subpath同样不会更新</p>
</blockquote>
]]></content>
      <tags>
        <tag>spring</tag>
        <tag>k8s configMap</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程不得不考虑的三个问题</title>
    <url>/2020/06/02/start-of-concurrent-programming/</url>
    <content><![CDATA[<p>编写正确的程序难,编写正确的并发程序则是难上加难。既然这么难为什么还要并发,单线程执行不好吗？为了快呀,点个链接你愿意等1分钟吗?,别说等一分钟了,要是有个网页让我等超过10秒钟,我就马上要关掉了。</p>
<p>我们编写的代码在计算机中运行,那么它肯定会用到计算机中的资源,一般都逃不过cpu、内存以及I/O(文件I/O或者网络I/O等)。但是这三者速度上有极大的差异。</p>
<p>CPU的速度远远快于内存,而内存的速度又远远远快于I/O。</p>
<blockquote>
<p>比喻: CPU速度相当于 火箭,内存速度相当于 高铁,I/O速度相当于 步行。</p>
</blockquote>
<p>而我们的程序运行的快慢实际上是取决于最慢的那个操作–I/O操作,仿佛在这个时候CPU再快都没啥作用。</p>
<blockquote>
<p>我们一般都说尽可能少的查询数据库(batch的方式更好),就是为了较少I/O操作</p>
</blockquote>
<a id="more"></a>

<p>为了合理使用CPU性能,平衡这三者间的速度差。计算机体系结果、操作系统、编译程序都做出了贡献,主要体现在：</p>
<ol>
<li>CPU 增加了缓存,以均衡与内存的速度差异</li>
<li>操作系统增加了进程、线程,以分时复用 CPU,进而均衡 CPU 与 I/O 设备的速度差异</li>
<li>编译程序优化指令执行次序,使得缓存能够得到更加合理地利用</li>
</ol>
<h3 id="缓存导致的可见性问题"><a href="#缓存导致的可见性问题" class="headerlink" title="缓存导致的可见性问题"></a>缓存导致的可见性问题</h3><p>单核CPU的时候,所有线程操作的都是同一个CPU的缓存,一个线程对另缓存的写,对另一个线程来说一定是可见的。例如在下面的图中,线程 A 和线程 B 都是操作同一个 CPU 里面的缓<br>存,所以线程 A 更新了变量 V 的值,那么线程 B 之后再访问变量 V,得到的一定是 V 的最新值(线程 A 写过的值)。</p>
<p><img data-src="/images/java/access-singele-cpu-cache.png" alt="访问同一个CPU Cache"></p>
<p><strong>一个线程对共享变量的修改,另外一个线程能够立刻看到,我们称为可见性。</strong></p>
<p>但是随着多核时代的来临,每颗 CPU 都有自己的缓存,这时 CPU 缓存与内存的数据一致性就没那么容易解决了,当多个线程在不同的 CPU 上执行时,这些线程操作的是不同的 CPU 缓存。比如<br>下图中,线程 A 操作的是 CPU1 上的缓存,而线程 B 操作的是 CPU2 上的缓存,很明显,这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了</p>
<p><img data-src="/images/java/access-different-cpu-cache.png" alt="访问不同CPU Cache"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">          v += <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      Counter c = <span class="keyword">new</span> Counter();</span><br><span class="line"></span><br><span class="line">      Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          c.add();</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          c.add();</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 启动线程</span></span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 等待两个线程执行结束</span></span><br><span class="line">      t1.join();</span><br><span class="line">      t2.join();</span><br><span class="line"></span><br><span class="line">      System.out.println(c.v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比如上面的代码,每次执行的结果都不一样,执行结果也是介于10000和20000之间。</p>
<p>CPU cache中的值什么时候刷新到内存(主存)中是不确定的,所以有可能某个后启动的线程读取到的值不一定是1,而是其他值(代码所示的两个线程启动是存在时间差的)。</p>
<h3 id="线程切换带来的原子性问题"><a href="#线程切换带来的原子性问题" class="headerlink" title="线程切换带来的原子性问题"></a>线程切换带来的原子性问题</h3><p>你可知道电脑中的进程是交替运行的,你能一边听歌一边看电影都归功于这个进程切换。操作系统允许某个进程执行一小段时间,例如 50 毫秒,过了 50 毫秒操作系统就会重新选<br>择一个进程来执行(我们称为“任务切换”),这个 50 毫秒称为“时间片”。</p>
<p><img data-src="/images/java/cpu-switch.png" alt="cpu switch"></p>
<p>Java 并发程序都是基于多线程的,自然也会涉及到任务切换,也许你想不到,任务切换竟然也是并发编程里诡异 Bug 的源头之一。任务切换的时机大多数是在时间片结束的时候,<br>我们现在基本都使用高级语言编程,高级语言里一条语句往往需要多条 CPU 指令完成,例如上面代码中的v += 1,至少需要三条 CPU 指令。</p>
<ol>
<li>指令 1：首先,需要把变量 v 从内存加载到 CPU 的寄存器；</li>
<li>指令 2：之后,在寄存器中执行 +1 操作；</li>
<li>指令 3：最后,将结果写入内存(缓存机制导致可能写入的是 CPU 缓存而不是内存)。</li>
</ol>
<p>操作系统做任务切换,可以发生在任何一条CPU 指令执行完,是的,是 CPU 指令,而不是高级语言里的一条语句。对于上面的三条指令来说,我们假设 v=0,如果线程 A 在<br>指令 1 执行完后做线程切换,线程 A 和线程 B 按照下图的序列执行,那么我们会发现两个线程都执行了 v+=1 的操作,但是得到的结果不是我们期望的 2,而是 1。</p>
<h3 id="编译优化-指令重排-带来的有序性问题"><a href="#编译优化-指令重排-带来的有序性问题" class="headerlink" title="编译优化(指令重排)带来的有序性问题"></a>编译优化(指令重排)带来的有序性问题</h3><p>我们都知道编译器为了优化性能,是会调整语句顺序的。比如下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> b = <span class="number">2L</span>;</span><br></pre></td></tr></table></figure>

<p>编译器优化之后可能会变成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long b &#x3D; 2L;</span><br><span class="line">int a &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>虽然优化后不影响执行结果,不过有时候编译器以及解释器的优化会带来意想不到的结果。</p>
<p>还记得java中获取单例对象的双重检查吗?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上不能保证上面的代码有效,当我们通过返回的Singleton对象访问其成员变量,就有可能触发空指针异常。<br><code>instance = new Singleton();</code> 不是原子操作,它由分配空间,初始化对象的字段以及为instance分配地址的多条指令组成。</p>
<ol>
<li>分配一块内存 M</li>
<li>在内存 M 上初始化 Singleton 对象</li>
<li>然后 M 的地址赋值给 instance 变量。</li>
</ol>
<p>为了显示实际发生的情况,我使用一些伪代码扩展<code>instance = new Singleton();</code>并内联对象初始化代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">          pointer = allocate();</span><br><span class="line">          pointer.field1 = initField1();</span><br><span class="line">          pointer.field2 = initField2();</span><br><span class="line">          instance = pointer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为了提高整体性能,某些编译器,内存系统或处理器可能会对指令进行重新排序,例如在初始化对象的字段之前移动 instance = pointer。那么代码就会变成下面这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">          pointer = allocate();</span><br><span class="line">          instance = pointer;</span><br><span class="line">          pointer.field1 = initField1();</span><br><span class="line">          pointer.field2 = initField2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>这种重新排序是合法的,因为instance = pointer;与初始化字段的指令之间没有数据依赖性。</strong><br>但是,这种重新排序(以某些执行顺序)可能导致其他线程看到instance的非null值,但访问了该对象的未初始化字段就会出错。</p>
<p><img data-src="/images/java/broken-double-check.png" alt="重排序导致双重检查失效"></p>
<p><strong>不过如果将instance变量添加上volatile关键字就可以禁止编译优化,就不会出现我们上面所说的问题了。</strong></p>
<h3 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h3><p>只要在写代码的时候充分考虑上面说的三种情况,那么一定可以帮助你抽丝剥茧的排查多线程下遇到的问题。</p>
<p>巨人肩膀: <strong>极客时间–&lt;java并发编程实战&gt;</strong></p>
<h3 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h3><p>一个简单的程序员,如果我的写得内容对你有帮助,可以关注公众号: think123</p>
<p><img data-src="/images/gzh.png" alt="think123"></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>从OutOfMemory开始</title>
    <url>/2016/10/31/start-with-OutOfMemory/</url>
    <content><![CDATA[<p>我们来看一下下面这段异常信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">    at test.OutofMemoryTest.heapOutOfMomory(OutofMemoryTest.java:<span class="number">27</span>)</span><br></pre></td></tr></table></figure>
<p>看见上面的这段错误信息是不是很熟悉,经常我们在编写代码的过程中会遇到这样的错误,那么引起这个错误的原因有哪些呢？又有哪些类型的OutOfMemory呢？</p>
<p>我们知道JVM运行时数据区域是这样的：<br><img data-src="/images/thread-java-running-data-area.png" alt="JVM运行时区域"><br>在JVM规范的描述中,除了程序计数器之外,虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError异常的可能。</p>
<h3 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h3><p>我们看看导致以下这段导致文章开头那段异常信息的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//VM Args：-Xms10m  -Xmx10m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapOutOfMomory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Byte[] b = <span class="keyword">new</span> Byte[<span class="number">20</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码其实很简单,但是为什么会导致OutOfMemoryError呢？原因是我们设置了堆的大小为10M(通过-Xmx设置堆的最大值,-Xms设置堆的最小值),而我们在代码中却申请了20M的空间,所以会导致抛出OutOfMemoryError。此种问题一般可以通过设置-XX:+HeapDumpOnOutOfMemoryError参数让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析(当然可以通过java自带的jmap命令以及jstat命令联合查看,也可通过Eclipse Memory Analyzer进行分析)。</p>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>由于虚拟机并不区分虚拟机栈和本地方法栈,因此对于HotSpot来说,虽然-Xoss参数(设置本地方法栈大小)存在,但是实际上是无效的,栈容量只能由-Xss参数设定。关于虚拟机栈和本地方法栈,在Java虚拟机规范中描述了两种异常：</p>
<ol>
<li>如果线程请求的的栈深度大于虚拟机所允许的最大深度,将抛出StackOverflowError异常</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间,则抛出OutOfMemoryError异常。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutofMemoryTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> statckLen = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">statckLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    statckLen ++;</span><br><span class="line">    statckLeak();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    OutofMemoryTest test = <span class="keyword">new</span> OutofMemoryTest();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      test.statckLeak();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;stack length = &quot;</span> + test.statckLen);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在运行过程中设置了-Xss128K(如果这个值设置太小就会提示The stack size specified is too small, Specify at least 104k),程序抛出的异常信息为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stack length &#x3D; 990</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br><span class="line">    at test.OutofMemoryTest.statckLeak(OutofMemoryTest.java:41)</span><br></pre></td></tr></table></figure>
<p>可以看出这里并没有抛出OutOfMemoryError,很明显,在单线程情况下,无论是栈帧太大还是虚拟机容量太小,当内存无法分配的时候,虚拟机抛出的都是StackOverflowError异常。<br>如果测试不限于单线程呢？通过不断建立线程的方式倒是可以产生内存溢出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//VM Args：-Xss20M -Xmx7168M -Xms7168M -XX:MaxPermSize1024M -XX:PermSize1024M</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">statckLeakByThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这段代码极容易使得电脑卡死,需要尤其注意,在我的测试环境中抛出的异常信息如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: unable to create new native thread</span><br><span class="line">    at java.lang.Thread.start0(Native Method)</span><br><span class="line">    at java.lang.Thread.start(Unknown Source)</span><br><span class="line">    at com.think.base.OutOfMemoryTest.stackLeak(OutOfMemoryTest.java:40)</span><br></pre></td></tr></table></figure>
<p>但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系,或者可以这样说,在这种情况下,为每个线程的栈分配的内存越大,反而越容易产生内存溢出异常。其实原因很简单,因为操作系统分配给每个进程的内存是有限制的,比如32位的windows限制为2G(实际上我们在使用的时候设置-Xmx并不能设置为2G,一般只有1.5G),减去Xmx(最大堆容量),在减去MaxPermSize(最大方法区容量),程序计数器消耗内存很小,忽略不计,如果虚拟机本身耗费的内存不计算在内,那么剩下的就由虚拟机栈和本地方法栈瓜分了。因此如果是由于建立过多线程导致的内存溢出,那么可以通过减少最大堆和减少栈容量来获取更多的线程。</p>
<h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><h4 id="运行时常量池导致的内存溢出异常"><a href="#运行时常量池导致的内存溢出异常" class="headerlink" title="运行时常量池导致的内存溢出异常"></a>运行时常量池导致的内存溢出异常</h4><p>如果在JDK6的环境下写下如下的代码,那么会抛出OutOfMemoryError: PermGen space这样的错误信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用List保持着常量池引用,避免Full GC回收常量池行为</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 10MB的PermSize在integer范围内足够产生OOM了</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        list.add(String.valueOf(i++).intern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而使用JDK7就不会出现这样的问题,因为在JDK6的intern()方法会把首次遇到的字符串实例复制到永久带中,返回的也是永久带中这个字符串实例的引用。而JDK7的intern()实现不会再复制实例,只是在常量池中记录首次出现的实例引用。</p>
<h4 id="方法区出现内存溢出异常"><a href="#方法区出现内存溢出异常" class="headerlink" title="方法区出现内存溢出异常"></a>方法区出现内存溢出异常</h4><p>我们知道方法区用于存放Class的相关信息,如类名、访问修饰符、常量池、字段描述、方法描述等。如果在运行的时候大量的类填满方法区,那么也会抛出OutOfMemoryError,比如下面的这段代码就借助了CGLib(2.0版本)使得方法区出现内存溢出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="comment">//VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permGenOutOfMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果没有这个设置在JDK7中无法打印出异常信息</span></span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyHandler());</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">      enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">      enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">      enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">implements</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;异常信息为:&quot;</span> + e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">OOMObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抛出的异常信息为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">异常信息为:java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure>
<p>当然我们在平时做WEB项目的时候,如果在启动项目的时候指定-XX:MaxPermSize和-XX:PermSize的值都比较小的情况下,ClassLoader在装载较多类的时候也是会抛出这个异常的,有兴趣的读者可以试一试。</p>
<h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>DirectMemory可以通过-XX:MaxDirectMemorySize指定,如果不指定则默认与Java堆最大值(-Xmx指定)一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-Xmx10M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">    Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">    unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">int</span> _1MB = <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      unsafe.allocateMemory(_1MB);<span class="comment">//申请分配内存的方法</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>抛出的异常信息为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError</span><br><span class="line">    at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class="line">    at test.OutofMemoryTest.main(OutofMemoryTest.java:65)</span><br></pre></td></tr></table></figure>
<p>由DirectMemory导致的内存溢出,一个明显的特征是在Heap Dump文件中不会看见明显的异常,如果发现OOM之后Dump文件很小,而程序中又直接或间接使用了NIO,那就可以考虑检查一下是不是这方面的原因。</p>
<h3 id="关于OutOfMemory的排查"><a href="#关于OutOfMemory的排查" class="headerlink" title="关于OutOfMemory的排查"></a>关于OutOfMemory的排查</h3><p>大多数时候当我们遇到了OutOfMemoryError的时候,一般可以通过提示信息确定到是哪里的问题,一般都可以通过调整堆、方法区的大小来保证程序的正常运行。但是有时候内存泄露导致的问题就不是简单的通过调整堆大小可以解决的了。不过JAVA自带了许多关于排查问题的工具,特别是线上问题,通过这些命令都很有帮助。比如说jmap、jstat、jinfo、jps、jstack这样的命令工具,如果觉得不方便还可以使用jvisualvm、jconsole这样的图形化工具,当然我们常用的Eclipse也提供了Memory Analyzer这样的分析工具。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>本文中代码测试环境为JDK1.7(64位),Windows64位,Eclipse Luna Service Release 2 (4.4.2)</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《深入理解Java虚拟机第二版》</p>
]]></content>
      <categories>
        <category>java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈java线程安全</title>
    <url>/2016/09/21/talk-thread-safe/</url>
    <content><![CDATA[<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。<br>假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。<br>进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。<br>一个车间里，可以有很多工人。他们协同完成一个任务。<br>线程就好比车间里的工人。一个进程可以包括多个线程。</p>
<h3 id="JAVA中的多线程"><a href="#JAVA中的多线程" class="headerlink" title="JAVA中的多线程"></a>JAVA中的多线程</h3><p>一般来说，当运行一个应用程序的时候，就启动了一个进程，当然有些会启动多个进程。启动进程的时候，操作系统会为进程分配资源，其中最主要的资源是内存空间，因为程序是在内存中运行的。在进程中，有些程序流程块是可以乱序执行的，并且这个代码块可以同时被多次执行。实际上，这样的代码块就是线程体。线程是进程中乱序执行的代码流程。当多个线程同时运行的时候，这样的执行模式成为并发执行。<br>多线程的目的是为了最大限度的利用CPU资源。</p>
<p>Java编写程序都运行在在Java虚拟机（JVM）中，在JVM的内部，程序的多任务是通过线程来实现的。每用java命令启动一个java应用程序，就会启动一个JVM进程。在同一个JVM进程中，有且只有一个进程，就是它自己。在这个JVM环境中，所有程序代码的运行都是以线程来运行。<br>一般常见的Java应用程序都是单线程的。比如，用java命令运行一个最简单的HelloWorld的Java应用程序时，就启动了一个JVM进程，JVM找到程序程序的入口点main()，然后运行main()方法，这样就产生了一个线程，这个线程称之为主线程。当main方法结束后，主线程运行完成。JVM进程也随即退出 。</p>
<p>当我们在tomcat服务器中运行一个WEB应用程序的时候，其实就是启动了一个JAVA进程，对WEB界面的每个操作都是在一个单独的线程中执行的，对于相同的操作每个线程执行的方法体是一样的(比如说同时有多个人在淘宝查看同一个商品的详细)。</p>
<h3 id="Java中如何使用多线程"><a href="#Java中如何使用多线程" class="headerlink" title="Java中如何使用多线程"></a>Java中如何使用多线程</h3><ol>
<li>直接继承java.lang.Thread或者直接使用java.lang.Thread<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread().start();</span><br></pre></td></tr></table></figure></li>
<li>实现java.lang.Runnable接口,并将其作为参数传递给java.lang.Thread<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">     </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">     &#125;</span><br><span class="line">   &#125;).start();</span><br></pre></td></tr></table></figure>
注意，这里调用的是start方法，只有调用start方法才会启动线程，然后线程会执行run方法中的代码,如果直接调用run方法,java只是当成一个普通的方法调用，并不会启动一个线程<h3 id="多线程的使用场景"><a href="#多线程的使用场景" class="headerlink" title="多线程的使用场景"></a>多线程的使用场景</h3>刚才也说了线程是为了更好的利用CPU资源,那么我们一般在哪些场景下使用多线程呢？当然这并没有一个统一的答案，我在这里总结一下我使用多线程的场景</li>
<li>在数据库备份等比较耗时的操作中使用多线程,后台默默执行即可</li>
<li>系统需要定时做一些任务的时候，比如定时发送邮件,更新配置等</li>
<li>需要异步处理的数据的时候,比如说前台触发完成一个任务,后台线程直接执行，前台只需要轮询状态即可。</li>
</ol>
<h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><p>线程安全指的是多线程环境下,一个类在在执行某个方法的时候,对类的内部实例变量的访问是安全的。因此对于下面列出来的2类变量,并不存在任何线程安全的说法：</p>
<ol>
<li>方法签名中的任何参数对象</li>
<li>处于方法内部的局部变量</li>
</ol>
<p><strong>为什么呢？</strong><br>Java虚拟机在运行java程序的过程中会将它所管理的内存区域划分成为几个不同的区块,其将会包括以下几个运行时数据区块<br><img data-src="/images/thread-java-running-data-area.png" alt="Java运行时数据区"></p>
<p>从上图中可以看出有所有线程共享的数据库只有堆和方法区,方法区用于存取以被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据,而堆的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存。</p>
<blockquote>
<p>一个本地变量可能是原始类型，在这种情况下，它总是“呆在”线程栈上。</p>
<p>一个本地变量也可能是指向一个对象的一个引用。在这种情况下，引用（这个本地变量）存放在线程栈上，但是对象本身存放在堆上。</p>
</blockquote>
<blockquote>
<p>一个对象可能包含方法，这些方法可能包含本地变量。这些本地变量任然存放在线程栈上，即使这些方法所属的对象存放在堆上。</p>
</blockquote>
<blockquote>
<p>一个对象的成员变量可能随着这个对象自身存放在堆上。不管这个成员变量是原始类型还是引用类型。</p>
</blockquote>
<blockquote>
<p>静态成员变量跟随着类定义一起也存放在堆上。</p>
</blockquote>
<blockquote>
<p>存放在堆上的对象可以被所有持有对这个对象引用的线程访问。当一个线程可以访问一个对象时，它也可以访问这个对象的成员变量。如果两个线程同时调用同一个对象上的同一个方法，它们将会都访问这个对象的成员变量，但是每一个线程都拥有这个本地变量的私有拷贝。</p>
</blockquote>
<p>更多关于java内存模型数据可以参考<a href="http://ifeve.com/java-memory-model-6/">http://ifeve.com/java-memory-model-6/</a></p>
<h3 id="线程不安全的代码"><a href="#线程不安全的代码" class="headerlink" title="线程不安全的代码"></a>线程不安全的代码</h3><p>前面也说了,多线程是完成同一件任务的,那么必然存在对资源的竞争,那么在竞争的时候,对资源的不正当使用就会导致程序出现问题，例如下面这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> MySalary mySalary;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> value;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(MySalary mySalary,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mySalary = mySalary;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     mySalary.add(value);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    MySalary ms = <span class="keyword">new</span> MySalary();</span><br><span class="line">    MyThread t1 = <span class="keyword">new</span> MyThread(ms,<span class="number">200</span>);</span><br><span class="line">    MyThread t2 = <span class="keyword">new</span> MyThread(ms,<span class="number">300</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">//主线程睡眠1秒钟,保证两个线程运行完毕</span></span><br><span class="line">     System.out.println(Thread.currentThread().getName() + <span class="string">&quot; run over and salary = &quot;</span> + salary);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySalary</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> salary = <span class="number">1000</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">150</span>);</span><br><span class="line">      <span class="keyword">this</span>.salary = salary + value;</span><br><span class="line">      <span class="comment">//打印出当前运行的线程</span></span><br><span class="line">      System.out.println(Thread.currentThread() + <span class="string">&quot; run and salary = &quot;</span> + salary);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>预期结果应该打印的是1500,但是实际情况可能与预期结果不符,在本地多运行几次之后出现了这样的结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-0 run over and salary &#x3D; 1300</span><br><span class="line">Thread-1 run over and salary &#x3D; 1300</span><br><span class="line">main run over and salary &#x3D; 1300</span><br></pre></td></tr></table></figure>
<p>这就是多线程运行导致的线程不安全的结果!</p>
<h3 id="为什么会导致线程不安全"><a href="#为什么会导致线程不安全" class="headerlink" title="为什么会导致线程不安全"></a>为什么会导致线程不安全</h3><p>在没有同步的情况下,Java内存模型允许编译器对操作顺序进行重排序,并将数值缓存在寄存器中,此外,它还允许CPU对操作顺序进行重排序,并将数值缓存在寄存器中。所以在缺乏足够同步的多线程程序中,要想对内存的操作顺序进行判断,几乎无法得出正确的结论。</p>
<p>之前说了Java虚拟机对内存的划分,但是其和硬件是存在差异,在硬件级别上是不存在堆栈的划分的,压根没有这个概念。<br><img data-src="/images/thread-java-memory-model-4.png" alt="硬件中对于内存的划分"></p>
<p>要知道,CPU的运行速度是非常快的,CPU的运行数据是从内存(主存)来的,但是从内存中取数据对于CPU来说是非常慢的,对于一些常用的数据,CPU就做了一些缓存,所以有了CPU的缓存。而我们上面造成的多线程问题也正是由于这种”信息不对等”的情况导致的。刚才也说了硬件和JVM的运行时区并不一样,那么它们之间的关系是怎样的呢?这里同样可以用一张图来描述它们的关系<br><img data-src="/images/thread-java-memory-model-5.png" alt="JVM与硬件的交互"></p>
<p>这个时候就可以解释为什么会出现上面代码运行的结果了<br><img data-src="/images/thread-java_running_result.png" alt="线程不安全代码解析"></p>
<h3 id="synconized的作用以及使用"><a href="#synconized的作用以及使用" class="headerlink" title="synconized的作用以及使用"></a>synconized的作用以及使用</h3><p>synconized是java中的关键字,使用它可以保证线程安全,同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。<br>这就相当于寝室6个同学同时要上厕所,然后一起抢厕所，抢到厕所的那个人会把厕所门给关上,表示厕所有人,然后其他人只能在门外等着,等别人上完厕所了,其他人在接着抢。<br>那么上面线程不安全的代码可以进行部分改写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.salary = salary + value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，无论启动多少个线程都能够保证线程的安全了,synchronized不仅可以使用在代码块上还可以使用在方法声明上,但是要注意的是synconized是比较耗费系统资源的,所以要尽可能小范围的使用。</p>
<h3 id="volitale的使用"><a href="#volitale的使用" class="headerlink" title="volitale的使用"></a>volitale的使用</h3><p>volitale的作用是保证内存可见性,如果一个成员变量被valitale修饰,在A线程中修改了valitale变量的值，对其他线程来说该修改是可见的。<br>即读取valitale变量相当于进入同步代码块,写入valitale变量相当于退出同步代码块,而且读取valitaile变量的开销仅仅只比非valitale变量的开销略高一点,更远远低于synchronized.<br>值得注意的是volitale并不能保证count++这样操作的原子性,所以volitale并不能保证线程安全。</p>
<p><strong>因此synchronized和volitale的区别是:加锁机制既可以确定可见性又可以保证原子性,而volatile变量只能确保可见性。</strong></p>
<p>所以它的使用场景一般包括:确保它们自身状态的可见性,确保它们所引用状态的可见性，以及标示一些重要的程序生命周期的事件的发生(例如初始化或者关闭)。<br>一种典型的使用方式:检查某个判断标记判断是否退出循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">valitale <span class="keyword">boolean</span> isExit;</span><br><span class="line"><span class="keyword">while</span>(!isExit) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样当isExit标志被另外一个线程修改为true的时候,执行判断的线程就能够准确的读取到isExit的值，从而退出循环。</p>
<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>既然提到了Thread,就不得不说ThreadLocal了,先看下ThreadLocal内部实现机制:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//通过当前线程获取当前线程的本地变量ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取当前线程中以当前ThreadLocal实例为key的变量值</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当map不存在时,设置初始值,可以通过new ThreadLocal时覆盖initialValue方法,这也是setInitialValue主要的调用方法</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从ThreadLocal的内部实现机制分析,synchronized这种机制是提供一份变量让不同的线程排队访问,而ThreadLocal是为每个线程都提供一份变量的副本,从而实现同时访问而不受影响。<br>从这里也看出来了两者之间的应用场景不同,synchronized是为了让每个线程对变量的修改都对其他线程可见,而ThreadLocal是为了线程对象的数据不受其他线程影响,它最适合的场景应该是在同一线程的不同开发层次中共享数据。</p>
<h3 id="安全的发布对象"><a href="#安全的发布对象" class="headerlink" title="安全的发布对象"></a>安全的发布对象</h3><p>我们分析了,其实线程不安全就是因为多个线程对公共资源(存在于堆中的对象)的不正当利用,那么如何保证发布的对象线程安全呢？<br>一个正确构造的对象可以通过以下方式来安全的发布:</p>
<ol>
<li>在静态初始化函数中初始化一个对象引用(JVM在静态初始化的时候会保证线程安全)</li>
<li>将对象的引用保存到volatile类型的域或者AtomicReferance中</li>
<li>将对象的引用保存到某个正确构造对象的的final类型域中</li>
<li>将对象的引用保存到一个由锁保护的域中</li>
</ol>
<h3 id="Java中其他保证线程安全的方式"><a href="#Java中其他保证线程安全的方式" class="headerlink" title="Java中其他保证线程安全的方式"></a>Java中其他保证线程安全的方式</h3><ol>
<li>通过将一个键或者值放入HashTable、synchronizedMap或者ConcurrentMap中，可以安全的将它发布给任何从这些容器中访问它的线程(无论是直接访问还是通过迭代器访问)</li>
<li>通过将某个元素放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或者synchronizedSet中,可以将元素安全的发布到任何从这些容器中访问它的线程</li>
<li>通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中,可以将元素安全的发布到任何从这些队列中访问该元素的线程</li>
</ol>
<p>类库中的其他机制也可以实现安全发布,比如Futrue和Exchange.</p>
<h3 id="写一个线程安全的单例模式"><a href="#写一个线程安全的单例模式" class="headerlink" title="写一个线程安全的单例模式"></a>写一个线程安全的单例模式</h3><ol>
<li>饿汉式<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyFactory factory = <span class="keyword">new</span> MyFactory();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyFactory <span class="title">getFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>懒汉式<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里的volitale不可或缺</span></span><br><span class="line">    <span class="keyword">public</span> volitale <span class="keyword">static</span> MyFactory factory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyFactory <span class="title">getFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(factory == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyFactory.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(factory == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    factory = <span class="keyword">new</span> MyFactory();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>懒汉式使用了”双重检查锁”,在上锁之前多进行一次null检查就可以减少绝大多数的加锁操作。当然这种写法也不是唯一的,你可以使用静态内部类,还使用枚举(这种是Effective Java的推荐写法)。使用枚举除了线程安全和防止反射强行调用构造器之外(上面起到的其他方式均不能避免这种情况)，还提供了自动序列化机制，防止反序列化的时候创建新的对象。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>线程安全说简单也简单,说难也难,简单就简单在控制好被线程共享的资源即可,难就难在在控制的同时保证程序运行效率以及不出现线程安全问题。当然这设计到很多方面了，本文也只是作者在了解了多线程之后写下的粗浅见接，这其中也参考了很多资料,如有错误或者遗漏,请指出。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html</a></li>
<li><a href="http://ifeve.com/java-memory-model-6/">http://ifeve.com/java-memory-model-6/</a></li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>写过那么多代码,这些问题还在犯吗？？</title>
    <url>/2021/07/24/technical-debt/</url>
    <content><![CDATA[<p>当审视你现在所做的系统，下面这些技术债你遇到了多少？</p>
<ol>
<li><p>注释不规范</p>
<p> 类注释，方法注释，语句注释没有一个统一的规范，大多时候没有注释。</p>
<p> 建议在关键逻辑上写明注释，不为别人也为自己，几个月后再来看代码，看不懂了就尴尬了。</p>
</li>
<li><p>单元注释少</p>
<p> 建议在核心业务逻辑上添加单元注释</p>
</li>
<li><p>大量的sql语句在xml中</p>
<p> 建议少一些，尽量使用面向对象编程(或者面向领域驱动)</p>
</li>
<li><p>mybatis-plus queryWrapper使用不正确</p>
<p> queryWrapper.eq(“id”, id)类似这种的建议写成 queryWrapper.eq(User::getId, id),避免书写<br>错误的发生或后续数据库改动导致整个程序都要改。</p>
</li>
<li><p>一个类或者一个方法逻辑太长</p>
<p> 建议一个类300行，一个方法核心代码30行，不要超过阿里的80行。</p>
</li>
<li><p>避免循环嵌套try-catch</p>
</li>
<li><p>分支语句判断不要超过三层，for循环同理</p>
</li>
<li><p>对象锁要使用全局锁，比如private final Object lock = new Object()</p>
</li>
<li><p>能提前判断程序快速结束的，先快速结束</p>
</li>
<li><p>使用StringUtils.equals判断两个字符串是否相等</p>
</li>
<li><p>map的迭代使用entrySet方式</p>
</li>
<li><p>for循环中建议使用break而不是return</p>
</li>
<li><p>不要混淆使用Boolean和boolean</p>
</li>
<li><p>log日志输出，使用占位符而不是字符串拼接</p>
</li>
<li><p>List,Map初始化建议使用guava Lists,Maps进行初始化</p>
</li>
<li><p>不用将Map,List等缺乏领域含义的对象用做参数传递</p>
</li>
<li><p>在同一个配置类中进行线程次创建</p>
</li>
<li><p>遵循单一职责原则，将相同的业务处理放置到同一个类中</p>
</li>
<li><p>不要盲目建立索引，而是有的放矢。 索引也不是越多越好</p>
</li>
<li><p>mongodb内嵌文档不要太多，不要太大</p>
</li>
<li><p>数据库字段的逻辑删除尽量不要介入业务逻辑</p>
</li>
<li><p>不要用两个字段来表示一个状态</p>
</li>
<li><p>要在关键业务逻辑加上日志，并打印出有效信息，可以帮助排查问题</p>
</li>
<li><p>方法参数不要超过5个，尽量使用对象进行封装</p>
</li>
<li><p>apoll配置的值动态更新后，需要确定你使用到它的地方是否能够自动更新上</p>
</li>
<li><p>push代码的时候先确保本地build可以通过，同时使用阿里巴巴插件扫描下提交代码是否存在问题</p>
</li>
<li><p>对包进行合理分层</p>
</li>
<li><p>dubbo服务对外提供的api，应该只存在一些接定义以及一些参数或者常量，保持最小化</p>
</li>
<li><p>不要过度设计，保持MVP功能优先</p>
</li>
<li><p>该重构就重构，不要等</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>你有没有被ThreadLocal坑过?</title>
    <url>/2021/04/12/thread-local-problems/</url>
    <content><![CDATA[<p>上一篇文章发出去后，雄哥给我讲写得很好，但是有一些关于ThreadLocal的坑没有指出来。大佬不愧是大佬，一语中的。</p>
<p>因此这篇来看看ThreadLocal存在什么问题，又有怎样的解决方案</p>
<a id="more"></a>

<h3 id="ThreadLocal的问题"><a href="#ThreadLocal的问题" class="headerlink" title="ThreadLocal的问题"></a>ThreadLocal的问题</h3><p>ThreadLocal是线程变量，每个线程都会有一个ThreadLocal副本。每个Thread都维护着一个ThreadLocalMap,<br>ThreadLocalMap 中存在一个弱引用Entry。如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收。</p>
<p>这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链<br><code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code> 永远无法回收，造成内存泄漏。</p>
<p>虽然在调用get()、set()、remove()的时候会清除所有key为null的value,但是如果调用者不调用也没办法。关于ThreadLocalMap的分析可以参考我写的这篇<a href="https://juejin.cn/post/6844903904933576711/">开放寻址的ThreadLocalMap分析</a></p>
<p><img data-src="/images/java/thread-local.png" alt="ThreadLocal"></p>
<p>使用ThreadLocal,在子线程中我们是获取不到父线程中的ThreadLocal的值的。</p>
<p><img data-src="/images/java/test-single-thread.png" alt="test-single-thread"></p>
<p>输出结果如下</p>
<p><img data-src="/images/java/single-thread-test-result.png" alt="test-result"></p>
<h3 id="如何获取父线程中ThreadLocal的值？"><a href="#如何获取父线程中ThreadLocal的值？" class="headerlink" title="如何获取父线程中ThreadLocal的值？"></a>如何获取父线程中ThreadLocal的值？</h3><p>使用InheritableThreadLocal。InheritableThreadLocal重写了getMap与createMap方法，ThreadLocal使用的是Thread.threadLocals,而InheritableThreadLocal使用的是Thread.inheritableThreadLocals。</p>
<p><img data-src="/images/java/inherit-thread-local.png" alt="InheritableThreadLocal"></p>
<p><strong>问: InheritableThreadLocal是如何实现在子线程中获取父线程中ThreadLocal值？</strong><br>答：将父线程中的所有值Copy到子线程</p>
<p>InheritableThreadLocal在创建线程的时候做了一些工作</p>
<p><img data-src="/images/java/inherit-create.png" alt="创建"></p>
<p>若父线程inheritableThreadLocals不为null，则为当前线程创建inheritableThreadLocals，并且copy父线程inheritableThreadLocals中的内容,createInheritedMap会创建并拷贝。</p>
<p>总结:</p>
<ul>
<li>创建InheritableThreadLocal对象时，赋值给了Thread.inheritableThreadLocals变量</li>
<li>创建新的子线程会check父线程的inheritableThreadLocals是否为null, 不为null拷贝父线程inheritableThreadLocals中的内容到当前线程</li>
<li>InheritableThreadLocal重写了getMap, createMap, 使用的都是Thread.inheritableThreadLocals变量</li>
</ul>
<h3 id="InheritableThreadLocal的问题"><a href="#InheritableThreadLocal的问题" class="headerlink" title="InheritableThreadLocal的问题"></a>InheritableThreadLocal的问题</h3><p>在使用线程池的时候InheritableThreadLocal并不能解决获取父线程值得问题，因为线程池中的线程是复用的，可能在子线程中对值进行了修改，使子线程获取到的值并不正确。</p>
<p><img data-src="/images/java/test-inherit-thread.png" alt="test"></p>
<p>输出结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[main]: aaa</span><br><span class="line"></span><br><span class="line">[pool-1-thread-1]: aaa</span><br><span class="line">[pool-1-thread-1]: bbb</span><br><span class="line"></span><br><span class="line">[pool-1-thread-2]: aaa</span><br><span class="line">[pool-1-thread-1]: bbb</span><br><span class="line">[pool-1-thread-4]: aaa</span><br><span class="line">[pool-1-thread-1]: bbb</span><br><span class="line">[pool-1-thread-2]: aaa</span><br><span class="line">[pool-1-thread-3]: aaa</span><br><span class="line">[pool-1-thread-2]: aaa</span><br><span class="line">[pool-1-thread-1]: bbb</span><br><span class="line">[pool-1-thread-4]: aaa</span><br><span class="line">[pool-1-thread-3]: aaa</span><br><span class="line"></span><br><span class="line">[main]: aaa</span><br></pre></td></tr></table></figure>

<p>几个典型应用场景</p>
<ul>
<li>分布式跟踪系统</li>
<li>日志收集记录系统上下文</li>
<li>应用容器或上层框架跨应用代码给下层SDK传递信息</li>
</ul>
<p>比如我们的<a href="https://generalthink.github.io/2021/04/08/record-all-links-log/">这样记日志，再也不背锅</a> 其中的MDC就是使用的InheritableThreadLocal。</p>
<p>解决办法:</p>
<ol>
<li>线程使用完成，清空TheadLocalMap</li>
<li>submit提交新任务时，重新拷贝父线程中的所有Entry。重新为当前线程的inheritableThreadLocals赋值。</li>
</ol>
<h3 id="使用alibab-TransmittableThreadLocal"><a href="#使用alibab-TransmittableThreadLocal" class="headerlink" title="使用alibab TransmittableThreadLocal"></a>使用alibab TransmittableThreadLocal</h3><p>TransmittableThreadLocal就采用了备份的方法来解决这个问题</p>
<p><img data-src="/images/java/ttl-thread-local-test.png" alt="TTL"></p>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[main]: aaa</span><br><span class="line"></span><br><span class="line">[pool-1-thread-1]:aaa</span><br><span class="line">[pool-1-thread-1]:bbb</span><br><span class="line"></span><br><span class="line">[pool-1-thread-2]:aaa</span><br><span class="line">[pool-1-thread-1]:aaa</span><br><span class="line">[pool-1-thread-3]:aaa</span><br><span class="line">[pool-1-thread-4]:aaa</span><br><span class="line">[pool-1-thread-3]:aaa</span><br><span class="line">[pool-1-thread-1]:aaa</span><br><span class="line">[pool-1-thread-3]:aaa</span><br><span class="line">[pool-1-thread-2]:aaa</span><br><span class="line">[pool-1-thread-1]:aaa</span><br><span class="line">[pool-1-thread-4]:aaa</span><br><span class="line"></span><br><span class="line">[main]: aaa</span><br></pre></td></tr></table></figure>

<p>TransmittableThreadLocal原理很容易理解，就是在业务逻辑之前先将ThreadLocal中的内容备份，业务逻辑完成后在将内容还原。</p>
<p><img data-src="/images/java/ttl-thread-local.png" alt="TTL"></p>
<p>具体的可以参考官方这篇文档: <a href="https://github.com/alibaba/transmittable-thread-local/blob/master/docs/developer-guide.md">https://github.com/alibaba/transmittable-thread-local/blob/master/docs/developer-guide.md</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么阿里建议你不要使用Executors来创建线程池？</title>
    <url>/2020/02/06/thread-pool-analysis/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我相信大家在项目中或多或少的都使用过线程，而线程是宝贵的资源，不能频繁的创建，应当给其他任务进行复用,所以就有了我们的线程池。</p>
<h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><blockquote>
<p>你知道我们如何创建线程池吗？</p>
</blockquote>
<p>这我当然知道了,JDK主要提供了三种创建线程池的方法</p>
<ol>
<li>Executors.newFixedThreadPool(int nThreads) : 创建固定线程数量的线程池</li>
<li>Executors.newSingleThreadExecutor() : 创建单个线程的线程池</li>
<li>Executors.newCachedThreadPool() : 创建一个”无限大小”的线程池</li>
</ol>
<blockquote>
<p>线程池如何使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">threadPool.execute(() -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;执行任务&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">threadPool.shutdown();</span><br></pre></td></tr></table></figure>

<h3 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h3><blockquote>
<p>你给我讲讲线程池的原理呢?</p>
</blockquote>
<h4 id="线程池核心参数以及状态"><a href="#线程池核心参数以及状态" class="headerlink" title="线程池核心参数以及状态"></a>线程池核心参数以及状态</h4><p>上面说的创建线程池的方法实际上都是通过创建ThreadPoolExecutor这个类来实现的,所以我们直接看这个类的实现原理即可。<br>首先来看看它的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">       TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">       BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">       RejectedExecutionHandler handler)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>先说下它这几个核心参数的含义</p>
<ul>
<li>corePoolSize : 线程池核心线程数量</li>
<li>maximumPoolSize : 线程池最大线程数量</li>
<li>keepAliveTime : 非核心线程的超时时长,当系统中非核心线程闲置时间超过keepAliveTime之后，则会被回收。如果ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，则该参数也表示核心线程的超时时长</li>
<li>unit : 超时时长单位</li>
<li>workQueue : 线程池中的任务队列，该队列主要用来存储已经被提交但是尚未执行的任务</li>
<li>handler : 当线程池无法处理任务的时候的处理策略</li>
</ul>
<p>当然只是知道这几个参数也没有什么太大的作用,我们还是要着眼全局来看ThreadPoolExecutor类。</p>
<p>首先来认识下线程池中定义的状态，它们一直贯穿在整个主体</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ctl存储了两个值,一个是线程池的状态,另一个是活动线程数(workerCount)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池最多允许2^29-1个(大概5亿)线程存在,当然首先要你的系统能新建这么多个</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面的成员变量的定义我们可以知道,线程池最多允许5亿个(2^29-1)个线程活动，那么为什么不是2^31-1呢?因为设计者觉得这个值已经够大了，如果将来觉得这是一个瓶颈的话,会把这个换成Long类型。</p>
<p>同时线程池这里也存在了五个状态，它们解决着线程池的生命周期。</p>
<ol>
<li>RUNNING : 运行状态。接受新的task并且处理队列中的task</li>
<li>SHUTDOWN : 关闭状态(调用了shutdown方法)。不接受新的task,但是要处理队列中的task</li>
<li>STOP : 停止状态(调用了shutdownNow方法)。不接受新的task,也不处理队列中的task,并且要中断正在处理的task</li>
<li>TIDYING : 所有的task都已终止了,workerCount (活动终止状态，当执行 terminated() 后会更新为这个状态线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态</li>
<li>TERMINATED : 终止状态，当执行 terminated() 后会更新为这个状态</li>
</ol>
<p>状态流转图如下:<br><img data-src="/images/java/thread-pool-status.png" alt="线程池状态"></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>我们知道当我们执行一个task的时候,调用的是execute方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 1. 如果工作线程数小于核心线程数(corePoolSize),则创建一个工作线程执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 如果当前是running状态，并且任务队列能够添加任务</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 2.1 如果不处于running状态了(使用者可能调用了shutdown方法),则将刚才添加到任务队列的任务移除</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 2.2 如果当前没有工作线程,则新建一个工作线程来执行任务(任务已经被添加到了任务队列)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 队列已经满了的情况下，则新启动一个工作线程来执行任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而在addWorker方法中还存在有一些必要的判断逻辑，比如当前线程池是否是非running状态,队列是否为空等条件，当然最主要的逻辑还是判断当前工作线程数量是否大于maximumPoolSize以及启动工作线程执行任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 1. 判断当前工作线程是否满足条件</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 2. 增加工作线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建工作线程</span></span><br><span class="line">    w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">    <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">    workers.add(w);     </span><br><span class="line">    <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">        <span class="comment">// 4. 运行工作线程</span></span><br><span class="line">        t.start();</span><br><span class="line">        workerStarted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>所以，总结下线程池的<strong>工作流程</strong> 如下:</p>
<ol>
<li>提交一个任务，如果线程池中的工作线程数小于corePoolSize,则新建一个工作线程执行任务</li>
<li>如果线程池当前的工作线程已经等于了corePoolSize,则将新的任务放入到工作队列中正在执行</li>
<li>如果工作队列已经满了,并且工作线程数小于maximumPoolSize,则新建一个工作线程来执行任务</li>
<li>如果当前线程池中工作线程数已经达到了maximumPoolSize,而新的任务无法放入到任务队列中,则采用对应的策略进行相应<br>的处理(默认是拒绝策略)</li>
</ol>
<p>如果你觉得上面不好记，我给你讲个火锅店的故事你就更加明白了。</p>
<p>以前有个火锅店,叫做朱帅帅火锅，老板是个刚辞掉程序员工作出来创业的帅小伙子,火锅店不大,只能摆上10张桌子(corePoolSize),如果吃火锅的来得早就可以去店里面坐(店里有空调),来晚了,店里面坐满了,后面来的人就要排队了(workQueue)。<br>排队的人数越来越多,朱帅帅一看不是办法,就给外面摆了几张临时桌子(非核心工作线程),让客人在外面吃。如果店里面有人吃完了或者外面临时桌子吃完了就让排队的人去吃。后面时间晚了，没有排队的人了，老板就让人撤了外面的临时桌子，毕竟摆在外面也不太好，而且还怕城管来。如果生意特别好,又来了特别多的人，已经超出火锅店的服务能力了，就只能喊他们去别家了。</p>
<p>上面的故事，你要品，细细的品,最后你会发现,代码来源于生活。</p>
<p>上面一直说到工作线程,工作线程到底是个什么鬼？其实工作线程指的就是我们的Worker类,它是ThreadPoolExecutor中的私有类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行worker的线程(new Thread(this))</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 需要执行的任务</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">      <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">      <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到Woker不仅继承了AbstractQueuedSynchronizer(实现独占锁功能),还实现了Runnable接口。</p>
<p>实际上线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象</p>
<p>Worker用自己作为task构造一个线程，同时把外层任务赋值给自己的task成员变量，相当于对task做了一个包装。</p>
<p>addWorker()方法中执行了worker.thread.start(),实际上执行的就是Worker的runWorker方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 获取任务开始执行任务,如果获取不到任务,当前的worker就会被JVM回收</span></span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">       task.run();</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 判断线程池是否关闭</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断是否需要进行超时控制。</span></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；</span></span><br><span class="line">        <span class="comment">// wc &gt; corePoolSize，表示当前线程池中的工作线程数量大于核心线程数量；</span></span><br><span class="line">        <span class="comment">// 对于超过核心线程数量的这些线程，需要进行超时控制</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. wc &gt; maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；</span></span><br><span class="line">        <span class="comment">// timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. timed如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null。如果为false，则直接阻塞</span></span><br><span class="line">        Runnable r = timed ?</span><br><span class="line">            workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">            workQueue.take();</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        timedOut = <span class="keyword">true</span>;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>** 上面的代码中尤其需要注意的是getTask()中的第3点,它的目的是控制线程池有效的工作线程数量。<br>从之前的分析我们可以知道，如果当前线程池的工作线程数量超过了corePoolSize且小于maximumPoolSize，并且workQueue已满，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。**</p>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><blockquote>
<p>你刚才说到拒绝策略，都有哪些拒绝策略呀？</p>
</blockquote>
<p>主要有下面4种拒绝策略</p>
<ol>
<li>AbortPolicy : 始终抛出RejectedExecutionException</li>
<li>CallerRunsPolicy : 如果线程池未关闭,则交给调用线程池的线程执行</li>
<li>DiscardPolicy : 直接丢弃任务，啥也不做</li>
<li>DiscardOldestPolicy : 丢弃队列里最老的任务,然后将当前这个任务重新提交给线程池。</li>
</ol>
<p>如果这四种策略都不满足需求，可以自己实现自己的拒绝策略。</p>
<h3 id="通过Executors创建的线程池不同之处"><a href="#通过Executors创建的线程池不同之处" class="headerlink" title="通过Executors创建的线程池不同之处"></a>通过Executors创建的线程池不同之处</h3><blockquote>
<p>你给我说说你开头说的通过Executors创建的线程池三者有何不同吗？</p>
</blockquote>
<h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><p>固定线程数量的线程池，corePoolSize等于maximumPoolSize,采用的阻塞队列是LinkedBlockingQueue,是一个无界队列,当任务量突然很大,线程池来不及处理，就会将任务一直添加到队列中,就有可能导致内存溢出。</p>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><p>创建单个线程的线程池,corePoolSize = maximumPoolSize = 1，也采用的LinkedBlockingQueue这个无界队列，当任务量很大,线程池来不及处理,就有可能会导致内存溢出。</p>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><p>创建可缓存的线程池,corePoolSize = 1,maximumPoolSize = Interger.MAX_VALUE;但是使用的是SynousQueue,这个队列比较特殊，内部没有结构来存储任何元素，所以如果任务数很大,而创建的那个线程(corePoolSize=1)迟迟没有处理完成任务,就会一直创建线程来处理,也有OOM的可能。</p>
<p>cacheThreadPool中的cache其实指的就是SynousQueue,当往这个队列插入数据的时候，如果没有任务来取，插入这个过程会被阻塞。</p>
<blockquote>
<p>你既然说了都有可能OOM,那么应该如何创建线程池呢？</p>
</blockquote>
<p>实际使用中不建议通过Executors来创建线程池，而是通过 <code>new ThreadPoolExecutor</code>的方式来创建,而队列也不建议使用无界队列，而要使用有界队列，比如ArrayBlockingQueue。而拒绝策略这个就看你自己需求了(系统提供的如果不满足,就自己写一个)<br>同时对于核心线程数的设置也不是越大越好,只能说根据你的需求来设置这个值,一般来讲可以根据下面两点来进行合理配置</p>
<ol>
<li>对于I/O密集型任务,可以将线程数设置大一点,比如 CPU个数 * 2</li>
<li>对于计算性任务(在内存中进行大量运算),可以将线程数设置小一点, 比如就等于 CPU的个数</li>
</ol>
<p>当然啦,这个考虑是很多方面的,不仅仅和程序有关，还和硬件等资源有关，总之就是在测试的时候多多调试。</p>
<p>大家不要以为我上面说的是句废话,请你自信一点，把以为去掉。</p>
]]></content>
  </entry>
  <entry>
    <title>那些去请求锁的线程都怎么样了?</title>
    <url>/2020/11/10/threads-of-request-lock-in-synchronized/</url>
    <content><![CDATA[<p>不知道你有没有想过，那些去申请锁的线程都怎样了？有些可能申请到了锁，马上就能执行业务代码。但是如果有一个锁被很多个线程需要，那么这些线程是如何被处理的呢？</p>
<p>今天我们走进synchronized 重量级锁，看看那些没有申请到锁的线程都怎样了。</p>
<p>ps: 如果你不想看分析结果,可以拉到最后，末尾有一张总结图,一图胜千言</p>
<a id="more"></a>

<p>之前文章分析过synchroinzed中锁的优化，但是如果存在大量竞争的情况下，那么最终还是都会变成重量级锁。所以我们这里开始直接分析重量级锁的代码。</p>
<h3 id="申请锁"><a href="#申请锁" class="headerlink" title="申请锁"></a>申请锁</h3><p>在ObjectMonitor::enter函数中，有很多判断和优化执行的逻辑，但是核心还是通过EnterI函数实际进入队列将将当前线程阻塞</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectMonitor::EnterI</span><span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">  Thread * <span class="keyword">const</span> Self = THREAD;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CAS尝试将当前线程设置为持有锁的线程</span></span><br><span class="line">  <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    assert(_succ != Self, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">    assert(_owner == Self, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">    assert(_Responsible != Self, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过自旋方式调用tryLock再次尝试，操作系统认为会有一些微妙影响</span></span><br><span class="line">  <span class="keyword">if</span> (TrySpin(Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    assert(_owner == Self, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">    assert(_succ != Self, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">    assert(_Responsible != Self, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将当前线程构建成ObjectWaiter</span></span><br><span class="line">  <span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span></span>;</span><br><span class="line">  Self-&gt;_ParkEvent-&gt;reset();</span><br><span class="line">  node._prev   = (ObjectWaiter *) <span class="number">0xBAD</span>;</span><br><span class="line">  node.TState  = ObjectWaiter::TS_CXQ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ObjectWaiter * nxt;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 通过CAS方式将ObjectWaiter对象插入CXQ队列头部中</span></span><br><span class="line">    node._next = nxt = _cxq;</span><br><span class="line">    <span class="keyword">if</span> (Atomic::cmpxchg(&amp;node, &amp;_cxq, nxt) == nxt) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于cxq改变，导致CAS失败，这里进行tryLock重试</span></span><br><span class="line">    <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      assert(_succ != Self, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">      assert(_owner == Self, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">      assert(_Responsible != Self, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻塞当前线程</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (TryLock(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    assert(_owner != Self, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// park self</span></span><br><span class="line">    <span class="keyword">if</span> (_Responsible == Self) &#123;</span><br><span class="line">      Self-&gt;_ParkEvent-&gt;park((jlong) recheckInterval);</span><br><span class="line">      recheckInterval *= <span class="number">8</span>;</span><br><span class="line">      <span class="keyword">if</span> (recheckInterval &gt; MAX_RECHECK_INTERVAL) &#123;</span><br><span class="line">        recheckInterval = MAX_RECHECK_INTERVAL;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Self-&gt;_ParkEvent-&gt;park();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (TryLock(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    ++nWakeups;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TrySpin(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Self已经获取到锁了，需要将它从CXQ或者EntryList中移除</span></span><br><span class="line">  UnlinkAfterAcquire(Self, &amp;node);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在入队之前,会调用tryLock尝试通过CAS操作将_owner(当前ObjectMonitor对象锁持有的线程指针)字段设置为Self(指向当前执行的线程),如果设置成功，表示当前线程获得了锁，否则没有。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ObjectMonitor::TryLock</span><span class="params">(Thread * Self)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> * own = _owner;</span><br><span class="line">  <span class="keyword">if</span> (own != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (Atomic::replace_if_null(Self, &amp;_owner)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>如果tryLock没有成功，又会再次调用tryLock(trySpin中调用了tryLock)去尝试获取锁，因为这样可以告诉操作系统我迫切需要这个资源，希望能尽量分配给我。不过这种亲和力并不是一定能得到保证的协议，只是一种积极的操作。</p>
</li>
<li><p>通过 ObjectWaiter对象将当前线程包裹起来，入到 CXQ 队列的头部</p>
</li>
<li><p>阻塞当前线程(通过pthread_cond_wait)</p>
</li>
<li><p>当线程被唤醒而获取了锁，调用UnlinkAfterAcquire方法将ObjectWaiter从CXQ或者EntryList中移除</p>
</li>
</ol>
<h3 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h3><p>ObjectMonitor对象中保存了 sychronized 阻塞的线程的队列，以及实现了不同的队列调度策略，因此我们有必须先来认识下这个对象的一些重要属性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectMonitor</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// mark word</span></span><br><span class="line">  <span class="keyword">volatile</span> markOop _header;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向拥有线程或BasicLock的指针                 </span></span><br><span class="line">  <span class="keyword">void</span> * <span class="keyword">volatile</span> _owner; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// monitor的先前所有者的线程ID</span></span><br><span class="line">  <span class="keyword">volatile</span> jlong _previous_owner_tid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重入次数，第一次为0</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">intptr_t</span> _recursions;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下一个被唤醒的线程</span></span><br><span class="line">  Thread * <span class="keyword">volatile</span> _succ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程在进入或者重新进入时被阻塞的列表,由ObjectWaiter组成,相当于对线程的一个封装对象</span></span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _EntryList;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CXQ队列存储的是enter的时候因为锁已经被别的线程阻塞而进不来的线程</span></span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _cxq;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处于wait状态(调用了wait())的线程，会被加入到waitSet</span></span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _WaitSet;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略其他属性以及方法</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectWaiter</span> :</span> <span class="keyword">public</span> StackObj &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum</span> TStates &#123; TS_UNDEF, TS_READY, TS_RUN, TS_WAIT, TS_ENTER, TS_CXQ &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后一个节点</span></span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前一个节点</span></span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _prev;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程</span></span><br><span class="line">  Thread*       _thread;</span><br><span class="line">  <span class="comment">// 线程状态</span></span><br><span class="line">  <span class="keyword">volatile</span> TStates TState;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ObjectWaiter(Thread* thread);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到ObjectWaiter中的_next和_prev你就会明白，这是使用了双向队列实现等待队列的的，但是<strong>实际上我们上面的入队操作并没有形成双向列表，形成双向列表是在exit锁的时候。</strong></p>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><p>Java Object 类提供了一个基于 native 实现的 wait 和 notify 线程间通讯的方式,JDK中wait/notify/notifyAll全部是通过native实现的，当然到了JVM，它的实现还是在 <code>src/hotspot/share/runtime/objectMonitor.cpp</code> 中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectMonitor::wait</span><span class="params">(jlong <span class="built_in">millis</span>, <span class="keyword">bool</span> interruptible, TRAPS)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  Thread * <span class="keyword">const</span> Self = THREAD;</span><br><span class="line">  JavaThread *jt = (JavaThread *)THREAD;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果线程被中断，需要抛出异常</span></span><br><span class="line">  <span class="keyword">if</span> (interruptible &amp;&amp; Thread::is_interrupted(Self, <span class="literal">true</span>) &amp;&amp; !HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">    THROW(vmSymbols::java_lang_InterruptedException());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  jt-&gt;set_current_waiting_monitor(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造 ObjectWaiter节点</span></span><br><span class="line">  <span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span></span>;</span><br><span class="line">  node.TState = ObjectWaiter::TS_WAIT;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将ObjectWaiter加入WaitSet的尾部</span></span><br><span class="line">  AddWaiter(&amp;node);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 让出锁</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="literal">true</span>, Self);                    </span><br><span class="line"> </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调研park()，阻塞当前线程</span></span><br><span class="line">  <span class="keyword">if</span> (interruptible &amp;&amp; (Thread::is_interrupted(THREAD, <span class="literal">false</span>) || HAS_PENDING_EXCEPTION)) &#123;</span><br><span class="line">        <span class="comment">// Intentionally empty</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node._notified == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">millis</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      Self-&gt;_ParkEvent-&gt;park();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ret = Self-&gt;_ParkEvent-&gt;park(<span class="built_in">millis</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将node插入双向列表_WaitSet的尾部</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ObjectMonitor::AddWaiter</span><span class="params">(ObjectWaiter* node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_WaitSet == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    _WaitSet = node;</span><br><span class="line">    node-&gt;_prev = node;</span><br><span class="line">    node-&gt;_next = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ObjectWaiter* head = _WaitSet;</span><br><span class="line">    ObjectWaiter* tail = head-&gt;_prev;</span><br><span class="line">    tail-&gt;_next = node;</span><br><span class="line">    head-&gt;_prev = node;</span><br><span class="line">    node-&gt;_next = head;</span><br><span class="line">    node-&gt;_prev = tail;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面我把wait的主要方法逻辑列出来了，主要会执行以下步骤</p>
<ol>
<li>首先判断当前线程是否被中断，如果被中断了需要抛出InterruptedException</li>
<li>如果没有被中断，则会使用当前线程构造ObjectWaiter节点，将其插入双向链表WaitSet的尾部</li>
<li>调用exit,让出锁(让出锁的逻辑会在后面分析)</li>
<li>调用park(实际上是调用pthread_cond_wait)阻塞当前线程</li>
</ol>
<h3 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h3><p>同样的notify的逻辑也是在ObjectMonitory.cpp中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectMonitor::notify</span><span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">  CHECK_OWNER();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// waitSet为空，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (_WaitSet == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    TEVENT(Empty-Notify);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  DTRACE_MONITOR_PROBE(notify, <span class="keyword">this</span>, object(), THREAD);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 唤醒某个线程</span></span><br><span class="line">  INotify(THREAD);</span><br><span class="line"></span><br><span class="line">  OM_PERFDATA_OP(Notifications, inc(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在notify中首先会判断waitSet是否为空，如果为空，表示没有线程在等待，则直接返回。否则则调用INotify方法。</p>
<blockquote>
<p>notifyAll方法实际上是循环调用INotify</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectMonitor::INotify</span><span class="params">(Thread * Self)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// notify之前需要获取一个锁，保证并发安全</span></span><br><span class="line">  Thread::SpinAcquire(&amp;_WaitSetLock, <span class="string">&quot;WaitSet - notify&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除并返回WaitSet中的第一个元素,比如之前waitSet中是1 &lt;--&gt; 2 &lt;--&gt; 3,现在是返回1，然后waitSet变成 2&lt;--&gt;3</span></span><br><span class="line">  ObjectWaiter * iterator = DequeueWaiter();</span><br><span class="line">  <span class="keyword">if</span> (iterator != <span class="literal">NULL</span>) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// Disposition - what might we do with iterator ?</span></span><br><span class="line">    <span class="comment">// a.  add it directly to the EntryList - either tail (policy == 1)</span></span><br><span class="line">    <span class="comment">//     or head (policy == 0).</span></span><br><span class="line">    <span class="comment">// b.  push it onto the front of the _cxq (policy == 2).</span></span><br><span class="line">    <span class="comment">// For now we use (b).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程状态</span></span><br><span class="line">    iterator-&gt;TState = ObjectWaiter::TS_ENTER;</span><br><span class="line"></span><br><span class="line">    iterator-&gt;_notified = <span class="number">1</span>;</span><br><span class="line">    iterator-&gt;_notifier_tid = JFR_THREAD_ID(Self);</span><br><span class="line"></span><br><span class="line">    ObjectWaiter * <span class="built_in">list</span> = _EntryList;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      assert(<span class="built_in">list</span>-&gt;_prev == <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">      assert(<span class="built_in">list</span>-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">      assert(<span class="built_in">list</span> != iterator, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prepend to cxq</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      iterator-&gt;_next = iterator-&gt;_prev = <span class="literal">NULL</span>;</span><br><span class="line">      _EntryList = iterator;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      iterator-&gt;TState = ObjectWaiter::TS_CXQ;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 将需要唤醒的node放到CXQ的头部</span></span><br><span class="line">        ObjectWaiter * front = _cxq;</span><br><span class="line">        iterator-&gt;_next = front;</span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg(iterator, &amp;_cxq, front) == front) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iterator-&gt;wait_reenter_begin(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// notify执行完成之后释放waitSet锁,注意这里并不是释放线程持有的锁</span></span><br><span class="line">  Thread::SpinRelease(&amp;_WaitSetLock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>notify的逻辑比较简单，就是将WaitSet的头节点从队列中移除，如果EntryList为空，则将出队节点放入到EntryList中，如果EntryList不为空，则将节点插入到CXQ列表的头节点。</p>
<p>需要注意的是,<strong>notify并没有释放锁，释放锁的逻辑是在exit中</strong></p>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>当一个线程获得对象锁成功之后，就可以执行自定义的同步代码块了。执行完成之后会执行到 ObjectMonitor 的 exit 函数中，释放当前对象锁，方便下一个线程来获取这个锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectMonitor::exit</span><span class="params">(<span class="keyword">bool</span> not_suspended, TRAPS)</span> </span>&#123;</span><br><span class="line">  Thread * <span class="keyword">const</span> Self = THREAD;</span><br><span class="line">  <span class="keyword">if</span> (THREAD != _owner) &#123;</span><br><span class="line">    <span class="comment">// 锁的持有者是当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (THREAD-&gt;is_lock_owned((address) _owner)) &#123;</span><br><span class="line">      assert(_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">      _owner = THREAD;</span><br><span class="line">      _recursions = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      assert(<span class="literal">false</span>, <span class="string">&quot;Non-balanced monitor enter/exit! Likely JNI locking&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重入次数减去1</span></span><br><span class="line">  <span class="keyword">if</span> (_recursions != <span class="number">0</span>) &#123;</span><br><span class="line">    _recursions--;        <span class="comment">// this is simple recursive enter</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    w = _EntryList;</span><br><span class="line">    <span class="comment">// 如果entryList不为空，则将</span></span><br><span class="line">    <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      assert(w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">      <span class="comment">// 执行unpark,让出锁</span></span><br><span class="line">      ExitEpilog(Self, w);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w = _cxq;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    _EntryList = w;</span><br><span class="line">    ObjectWaiter * q = <span class="literal">NULL</span>;</span><br><span class="line">    ObjectWaiter * p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里将_cxq或者说_EntryList从单向链表变成了一个双向链表</span></span><br><span class="line">    <span class="keyword">for</span> (p = w; p != <span class="literal">NULL</span>; p = p-&gt;_next) &#123;</span><br><span class="line">      guarantee(p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>);</span><br><span class="line">      p-&gt;TState = ObjectWaiter::TS_ENTER;</span><br><span class="line">      p-&gt;_prev = q;</span><br><span class="line">      q = p;</span><br><span class="line">    &#125;</span><br><span class="line">    w = _EntryList;</span><br><span class="line">    <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      guarantee(w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">      <span class="comment">// 执行unpark,让出锁</span></span><br><span class="line">      ExitEpilog(Self, w);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectMonitor::ExitEpilog</span><span class="params">(Thread * Self, ObjectWaiter * Wakee)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Exit protocol:</span></span><br><span class="line">  <span class="comment">// 1. ST _succ = wakee</span></span><br><span class="line">  <span class="comment">// 2. membar #loadstore|#storestore;</span></span><br><span class="line">  <span class="comment">// 2. ST _owner = NULL</span></span><br><span class="line">  <span class="comment">// 3. unpark(wakee)</span></span><br><span class="line"></span><br><span class="line">  _succ = Wakee-&gt;_thread;</span><br><span class="line"></span><br><span class="line">  ParkEvent * Trigger = Wakee-&gt;_event;</span><br><span class="line"></span><br><span class="line">  Wakee  = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop the lock</span></span><br><span class="line">  OrderAccess::release_store(&amp;_owner, (<span class="keyword">void</span>*)<span class="literal">NULL</span>);</span><br><span class="line">  OrderAccess::fence();</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 释放锁</span></span><br><span class="line">  Trigger-&gt;unpark();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>exit的逻辑还是比较简单的</p>
<ol>
<li><p>如果当前是当前线程要让出锁，那么则查看其重入次数是否为0，不为0则将重入次数减去1，然后直接退出。</p>
</li>
<li><p>如果EntryList不为空，则将EntryList的头元素中的线程唤醒</p>
</li>
<li><p>将cxq指针赋值给EntryList，然后通过循环将cxq链表变成双向链表，然后调用ExitEpilog将CXQ链表的头结点唤醒(实际是通过pthread_cond_signal)</p>
</li>
</ol>
<p>从这里之后,EntryList和CXQ就是同一个了，因为将CXQ赋值给了EntryList了。</p>
<p><strong>需要注意的是这里唤醒的线程会继续执行文章开头的EnterI方法，此时会将ObjectWaiter从EntryList或者CXQ中移除。</strong></p>
<h3 id="实战演示"><a href="#实战演示" class="headerlink" title="实战演示"></a>实战演示</h3><p>上面的源码均是基于JDK12,JDK8中的代码关于exit和notify都还有其他策略(选择哪个线程)，而从JDK9开始就只保留了默认策略了。</p>
<p>所以下面的Java代码的运行结果无论是在jdk8还是jdk12,得到的结果都是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Thread 1 start!!!!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.wait();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Thread 1 end!!!!!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Thread 2 start!!!!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Thread 2 end!!!!!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Thread 3 start!!!!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Thread 3 end!!!!!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread t4 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Thread 4 start!!!!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.in.read();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    lock.notify();</span><br><span class="line">    lock.notify();</span><br><span class="line">    lock.notify();</span><br><span class="line">    System.out.println(<span class="string">&quot;Thread 4 end!!!!!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread t5 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Thread 5 start!!!!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Thread 5 end!!!!!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread t6 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Thread 6 start!!!!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Thread 6 end!!!!!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread t7 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Thread 7 start!!!!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Thread 7 end!!!!!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line">sleep_1_second();</span><br><span class="line"></span><br><span class="line">t2.start();</span><br><span class="line">sleep_1_second();</span><br><span class="line"></span><br><span class="line">t3.start();</span><br><span class="line">sleep_1_second();</span><br><span class="line"></span><br><span class="line">t4.start();</span><br><span class="line">sleep_1_second();</span><br><span class="line"></span><br><span class="line">t5.start();</span><br><span class="line">sleep_1_second();</span><br><span class="line"></span><br><span class="line">t6.start();</span><br><span class="line">sleep_1_second();</span><br><span class="line"></span><br><span class="line">t7.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码很简单，我们来分析一下。</p>
<p>线程1,2,3都调用了wait,所以会阻塞，然后WaitSet的链表结构如下：</p>
<p><img data-src="/images/macos-jvm/sync_waitset.png" alt="WaitSet:1--&gt;2--&gt;3"></p>
<p>线程4获取了锁，在等待一个输入</p>
<p>线程5,6,7也在等待锁，所以他们也会把阻塞，所以CXQ链表结构如下：</p>
<p><img data-src="/images/macos-jvm/sync_cxq.png" alt="CXQ:7--&gt;6--&gt;5"></p>
<p>当线程4输入任意内容，并回车结束后(调用了其中的3个notify方法，但还未释放锁)</p>
<p><img data-src="/images/macos-jvm/sync_entrylist.png" alt="EntryList:1"></p>
<p><img data-src="/images/macos-jvm/sync_cxq_2.png" alt="CXQ: 3--&gt;2--&gt;7--&gt;6--&gt;5"></p>
<p>线程4让出锁之后，由于EntryList不为空，所以会先唤醒EntryList中的线程1,然后接下来会唤醒CXQ队列中的线程(后面你可以认为CXQ就是EntryList)<br>所以最终线程执行顺序为 4 1 3 2 7 6 5,我们的输出结果也能验证我们的结论</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread 1 start!!!!!!</span><br><span class="line">Thread 2 start!!!!!!</span><br><span class="line">Thread 3 start!!!!!!</span><br><span class="line">Thread 4 start!!!!!!</span><br><span class="line">Thread 5 start!!!!!!</span><br><span class="line">Thread 6 start!!!!!!</span><br><span class="line">Thread 7 start!!!!!!</span><br><span class="line">think123</span><br><span class="line">Thread 4 end!!!!!!</span><br><span class="line">Thread 1 end!!!!!!</span><br><span class="line">Thread 3 end!!!!!!</span><br><span class="line">Thread 2 end!!!!!!</span><br><span class="line">Thread 7 end!!!!!!</span><br><span class="line">Thread 6 end!!!!!!</span><br><span class="line">Thread 5 end!!!!!!</span><br></pre></td></tr></table></figure>

<h3 id="一图胜千言"><a href="#一图胜千言" class="headerlink" title="一图胜千言"></a>一图胜千言</h3><p><img data-src="/images/macos-jvm/monitor_running.png" alt="wait/notify/monitorexit"></p>
]]></content>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>我丢,线程池原来还可以优先扩容核心线程数？</title>
    <url>/2020/08/12/tomcat-thread-pool-executor/</url>
    <content><![CDATA[<p>在之前的《为什么阿里建议你不要使用Executors来创建线程池？》文章中深入分析了一下线程池,这里重温下它的主要流程:</p>
<ol>
<li>提交一个任务，如果线程池中的工作线程数小于corePoolSize,则新建一个工作线程执行任务</li>
<li>如果线程池当前的工作线程已经等于了corePoolSize,则将新的任务放入到工作队列中正在执行</li>
<li>如果工作队列已经满了,并且工作线程数小于maximumPoolSize,则新建一个工作线程来执行任务</li>
<li>如果当前线程池中工作线程数已经达到了maximumPoolSize,而新的任务无法放入到任务队列中,则采用对应的策略进行相应的处理(默认是拒绝策略)</li>
<li>当线程数大于核心线程数时，线程等待 keepAliveTime 后还是没有任务需要处理的话，收缩线程到核心线程数。(传入 true 给 allowCoreThreadTimeOut 方法,来让线程池在空闲的时候同样回收核心线程。)</li>
</ol>
<p>在JDK自带的策略中有一个CallerRunsPolicy策略，很容易被忽视,当任务队列已经满了的时候这个任务会被调用线程池的线程执行。<br>比如我们在tomcat线程中调用了线程池，当线程池的队列满了之后,会将这个任务交给tomcat线程执行。这个时候就会影响其他同步执行的线程，甚至可能把线程池搞崩溃。</p>
<p>我们还可以通过一些手段来修改线程池的默认行为，比如回收核心线程。或者声明线程池后立即调用 prestartAllCoreThreads 方法，来启动所有核心线程。</p>
<p>我们发现核心线程数只有在工作队列满了之后才会扩容,那么能不能先扩容核心线程,等到达到最大线程数之后再加入工作队列呢？让线程池更弹性,优先开启更多线程呢？</p>
<p>当然可以，tomcat中的ThreadPoolExecutor就是就做了这样的优化。</p>
<p>tomcat的线程池在创建的时候会先启动所有的核心线程(prestartAllCoreThreads),并且会优先扩容线程数。</p>
<p>tomcat中的<code>ThreadPoolExecutor</code>继承自<code>java.util.concurrent.ThreadPoolExecutor</code>,并且任务队列使用的是<code>TaskQueue</code>(继承自<code>LinkedBlockingQueue&lt;Runnable&gt;</code>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, </span></span></span><br><span class="line"><span class="function"><span class="params">  TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);</span><br><span class="line">      <span class="comment">// 调用父类的方法,先启动所有的核心线程</span></span><br><span class="line">      prestartAllCoreThreads();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 1. 如果工作线程数小于核心线程数(corePoolSize),则创建一个工作线程执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">      <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 如果当前是running状态，并且任务队列能够添加任务</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">      <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2.1 如果不处于running状态了(使用者可能调用了shutdown方法),</span></span><br><span class="line">      <span class="comment">// 则将刚才添加到任务队列的任务移除</span></span><br><span class="line">      <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">          reject(command);</span><br><span class="line">       <span class="comment">// 2.2 如果当前没有工作线程,</span></span><br><span class="line">       <span class="comment">// 则新建一个工作线程来执行任务(任务已经被添加到了任务队列)</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">          addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 队列已经满了的情况下，则新启动一个工作线程来执行任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">      reject(command);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span> <span class="keyword">extends</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">Runnable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过setParent方法设置线程池</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadPoolExecutor parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable o)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (parent==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 线程数已经扩容到了最大线程数,此时正常加入队列</span></span><br><span class="line">    <span class="keyword">if</span> (parent.getPoolSize() == parent.getMaximumPoolSize()) <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 存在空闲线程将其加入到队列中</span></span><br><span class="line">    <span class="keyword">if</span> (parent.getSubmittedCount()&lt;=(parent.getPoolSize())) <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 核心线程数少于最大线程数,不加入队列,而是会创建一个新的工作线程</span></span><br><span class="line">    <span class="keyword">if</span> (parent.getPoolSize()&lt;parent.getMaximumPoolSize()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加入队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.offer(o);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如核心线程数设置为1,最大线程数设置为2,每个任务执行时间是5s,当第一个任务提交之后,submittedCount=1,会创建一个工作线程执行任务，poolSize变成1(查看execute方法的第一步)。</p>
<p>此时第二个任务提交了，submittedCount的值为2。不符合offer方法中第一和第二个判断,但是符合第三个判断,返回false,表示加入队列失败(表示队列已满)</p>
<p>此时在回到execute的第三个条件判断,直接启动一个新的工作线程来执行任务。</p>
<p>这样就做到了优先扩容到最大线程数。来不及处理的多余任务才会放入到队列中。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB初学者最常用的10个命令</title>
    <url>/2019/09/26/top-10-common-mongodb-commands-for-beginners/</url>
    <content><![CDATA[<h4 id="1-登录mongodb"><a href="#1-登录mongodb" class="headerlink" title="1. 登录mongodb"></a>1. 登录mongodb</h4><p>以下命令可以用于登录mongodb数据库，但是需要保证用户你声明的数据库中存在对应的用户和密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo --host &lt;hostName&gt; --port &lt;port&gt; -u &lt;username&gt; -p &lt;password&gt; --authenticationDatabase &lt;dbname&gt;</span><br><span class="line"></span><br><span class="line">mongo --host 192.168.140.11 -u test -p 123456 --authenticationDatabase test_db</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="2-列出所有的数据库"><a href="#2-列出所有的数据库" class="headerlink" title="2. 列出所有的数据库"></a>2. 列出所有的数据库</h4><p>  当你以适当角色的用户身份登录后，可以使用以下命令查看所有数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure>

<h4 id="3-选择要使用的数据库"><a href="#3-选择要使用的数据库" class="headerlink" title="3. 选择要使用的数据库"></a>3. 选择要使用的数据库</h4><p>要开始使用特定的数据库，可以用以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use &lt;databaseName&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-创建用户"><a href="#4-创建用户" class="headerlink" title="4. 创建用户"></a>4. 创建用户</h4><p>  当你想让不同的用户拥有不同的权限的时候可以使用以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use &lt;databaseName&gt;</span><br><span class="line">db.createUser(&#123; user: &#39;&lt;username&gt;&#39;, pwd: &#39;&lt;password&gt;&#39;, roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;&lt;databaseName&gt;&quot; &#125; ] &#125;);</span><br><span class="line"></span><br><span class="line">例子:</span><br><span class="line">use admin</span><br><span class="line">db.createUser(&#123; user: &#39;admin&#39;, pwd: &#39;123456&#39;, roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ] &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-列出所有的集合，用户以及角色"><a href="#5-列出所有的集合，用户以及角色" class="headerlink" title="5. 列出所有的集合，用户以及角色"></a>5. 列出所有的集合，用户以及角色</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 列出当前database下所有的集合:</span><br><span class="line">show collections;</span><br><span class="line">db.getCollectionNames();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 列出当前database下所有的用户</span><br><span class="line">show users;</span><br><span class="line">db.getUsers();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 列出当前dababase下所有角色</span><br><span class="line">show roles;</span><br></pre></td></tr></table></figure>

<p>不同的角色对应的权限，最直接之处就在于没有权限有些命令就无法执行</p>
<h4 id="6-创建集合"><a href="#6-创建集合" class="headerlink" title="6. 创建集合"></a>6. 创建集合</h4><p>  下面的命令用户创建集合，更详细命令可以查看<a href="https://docs.mongodb.com/manual/reference/method/db.createCollection/">官方文档</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.createCollection(&quot;collectionName&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="7-将文档插入到集合中"><a href="#7-将文档插入到集合中" class="headerlink" title="7. 将文档插入到集合中"></a>7. 将文档插入到集合中</h4><p>  集合一旦创建之后，下一步就是创建一个或多个文档插入到集合中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 插入单个文档</span><br><span class="line">db.&lt;collectionName&gt;.insert(&#123;field1: &quot;value&quot;, field2: &quot;value&quot;&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 插入多个文档</span><br><span class="line">db.&lt;collectionName&gt;.insert([&#123;field1: &quot;value1&quot;&#125;, &#123;field1: &quot;value2&quot;&#125;])</span><br><span class="line">db.&lt;collectionName&gt;.insertMany([&#123;field1: &quot;value1&quot;&#125;, &#123;field1: &quot;value2&quot;&#125;])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8-保存或者更新文档"><a href="#8-保存或者更新文档" class="headerlink" title="8. 保存或者更新文档"></a>8. 保存或者更新文档</h4><p>  保存命令可用于更新现有文档或根据传递给它的文档参数插入新文档。如果传递的_id与现有文档匹配，则文档将更新。否则，将创建一个新文档。在内部，保存方法使用插入或更新命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.&lt;collectionName&gt;.save(&#123;&quot;_id&quot;: new ObjectId(&quot;123456&quot;), field1: &quot;value&quot;, field2: &quot;value&quot;&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="9-显示集合记录"><a href="#9-显示集合记录" class="headerlink" title="9. 显示集合记录"></a>9. 显示集合记录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取所有记录</span><br><span class="line">db.&lt;collectionName&gt;.find();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取指定数量的记录</span><br><span class="line">db.&lt;collectionName&gt;.find().limit(10);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据id获取记录</span><br><span class="line">db.&lt;collectionName&gt;.find(&#123;&quot;_id&quot;: yourId&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回记录中特定field的值</span><br><span class="line">&#x2F;&#x2F; 类似返回select field1,field2 from table</span><br><span class="line">db.&lt;collectionName&gt;.find(&#123;&quot;_id&quot;: ObjectId(&quot;someid&quot;)&#125;, &#123;field1: 1, field2: 1&#125;);</span><br><span class="line">&#x2F;&#x2F; 不返回field1的数据</span><br><span class="line">db.&lt;collectionName&gt;.find(&#123;&quot;_id&quot;: ObjectId(&quot;someid&quot;)&#125;, &#123;field1: 0&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 文档记录数</span><br><span class="line">db.&lt;collectionName&gt;.count();</span><br></pre></td></tr></table></figure>

<h4 id="10-管理命令"><a href="#10-管理命令" class="headerlink" title="10. 管理命令"></a>10. 管理命令</h4><p>以下是一些管理命令，这些命令可能有助于查找集合详细信息，例如存储大小，总大小和总体统计信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取集合的统计信息,比如空间占用，总大小，引擎信息等</span><br><span class="line">db.&lt;collectionName&gt;.stats()</span><br><span class="line">db.printCollectionStats()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取集合的延迟统计信息,比如读写的次数,时间等等</span><br><span class="line">db.&lt;collectionName&gt;.latencyStats()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取数据和索引的集合大小</span><br><span class="line">&#x2F;&#x2F; 集合的大小</span><br><span class="line">db.&lt;collectionName&gt;.dataSize()</span><br><span class="line">&#x2F;&#x2F; 集合中存储文档的总大小</span><br><span class="line">db.&lt;collectionName&gt;.storageSize()</span><br><span class="line">&#x2F;&#x2F; 集合数据和索引的总大小(以字节为单位)</span><br><span class="line">db.&lt;collectionName&gt;.totalSize()</span><br><span class="line">&#x2F;&#x2F; 集合中所有索引的总大小</span><br><span class="line">db.&lt;collectionName&gt;.totalIndexSize()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>我是如何理解Java8 Stream</title>
    <url>/2019/03/12/understand-java-jdk8-stream/</url>
    <content><![CDATA[<p>之前看了许多介绍Java8 Stream的文章,但是初次接触真的是难以理解(我悟性比较低),没办法只能”死记硬背”,但是昨天我打王者荣耀(那一局我赢了,牛魔全场MVP)的时候,突然迸发了灵感,感觉之前没有理解透彻的一下子就理解透彻了。所以决定用简单的方式来回忆下我认为的java8 Stream.</p>
<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>lambda表达式是Stream API的基石，所以想要学会Stream API的使用，必须先要理解lambda表达式,这里对lambda做一个简单回顾。</p>
<p>我们常常会看到这样的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>&#125;, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer first, Integer second)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> first.compareTo(second);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>上面这种写法就是使用了匿名类，我们经常会使用匿名类的方式，因为我们只运行一次，不想它一直存在。虽然说lambda表达式是为了什么所谓的函数式编程，也是大家在社区千呼万唤才出来的，但是在我看来就是为了方(偷)便(懒)。</p>
<p>上面的代码写着麻烦，但是转换成下面这样的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    (first,second) -&gt; first.compareTo(second));</span><br></pre></td></tr></table></figure>
<p>这样看着多清爽，而且把一些不必要的细节都屏蔽了。对于这种只包含一个抽象方法的接口，你可以通过lambda接口来创建该接口的对象，这种接口被称为函数式接口。</p>
<p>lambda表达式引入了一个新的操作符：**-&gt;**,它把lambda表达式分为了2部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(n) -&gt; n*n</span><br></pre></td></tr></table></figure>
<p>左侧指定表达式所需的参数，如果不需要参数，也可以为空。右侧是lambda代码块,它指定lambda表达式的动作。</p>
<p>需要注意的是如果方法中只有一个返回的时候不用声明，默认会返回。如果有分支返回的时候需要都进行声明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(n) -&gt; &#123;</span><br><span class="line">    if( n &lt;&#x3D; 10) </span><br><span class="line">        return n*n;</span><br><span class="line">    return n * 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法引用以及构造器引用"><a href="#方法引用以及构造器引用" class="headerlink" title="方法引用以及构造器引用"></a>方法引用以及构造器引用</h3><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>有些时候，先要传递给其他代码的操作已经有实现的方法了。比如GUI中先要在按钮被点击时打印event对象，那么可以这样调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.setOnAction(event -&gt; System.out.println(event));</span><br></pre></td></tr></table></figure>
<p>这个时候我想偷懒，我不想写event参数，因为只有一个参数，jvm不能帮帮我吗?下面是修改好的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">button.setOnAction(System.out::println);</span><br></pre></td></tr></table></figure>
<p>表达式<code>System.out::println</code>是一个方法引用，等同于lambda表达式<code>x -&gt; System.out.println(x)</code>。**::**操作符将方法名和对象或类的名字分割开来，以下是三种主要的使用情况:</p>
<ol>
<li>对象::实例方法</li>
<li>类::静态方法</li>
<li>类::实例方法</li>
</ol>
<p>前两种情况，方法引用等同于提供方法参数的lambda表达式。比如<code>Math::pow  ====  (x,y) -&gt; Math.pow(x,y)</code>。</p>
<p>第三种情况，第一个参数会称为执行方法的对象。比如<code>String::compareToIgnoreCase ==== (x,y) -&gt; x.compareToIgnoreCase(y)</code>。</p>
<p>还有<code>this::equals ==== x -&gt; this.equals(x)</code>,<code>super::equals ==== super.equals(x)</code>。</p>
<h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strList = Arrays.asList(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream =  strList.stream().map(Integer::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码的<code>Integer::new</code>就是构造器引用，不同的是在构造器引用中方法名是new。如果存在多个构造器，编译器会从上下文推断并找出合适的那一个。</p>
<h2 id="StreamAPI"><a href="#StreamAPI" class="headerlink" title="StreamAPI"></a>StreamAPI</h2><p>Stream这个单词翻译过来就是流的意思，溪流的流，水流的流。</p>
<p><img data-src="/images/java8-stream/stream.png" alt="Stream"></p>
<p>在我看来stream就像是上面的图一样，最开始的数据就是小水滴，它经过各种”拦截器”的处理之后,有的小水滴被丢弃，有的变大了，有的加上了颜色，有的变成了三角形。最后它们都变成了带有颜色的圆。最后被我们放到结果集中。我们很多时候写的代码是这样的：遍历一个集合,然后对集合的元素进行判断或者转换，满足条件的加入到新的集合里面去,这种处理方式就和上面的图是一样的。先来看一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Map&lt;String,Integer&gt;&gt; resultMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Map&lt;String,Integer&gt; maleMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Map&lt;String,Integer&gt; femaleMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">resultMap.put(<span class="string">&quot;male&quot;</span>, maleMap);</span><br><span class="line">resultMap.put(<span class="string">&quot;female&quot;</span>,femaleMap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    Person person = list.get(i);</span><br><span class="line">    String gender = person.getGender();</span><br><span class="line">    String level = person.getLevel();</span><br><span class="line">    <span class="keyword">switch</span> (gender) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;male&quot;</span>:</span><br><span class="line">            Integer maleCount;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;gold&quot;</span>.equals(level)) &#123;</span><br><span class="line">                maleCount = maleMap.get(<span class="string">&quot;gold&quot;</span>);</span><br><span class="line">                maleMap.put(<span class="string">&quot;gold&quot;</span>, <span class="keyword">null</span> != maleCount ? maleCount + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;soliver&quot;</span>.equals(level))&#123;</span><br><span class="line">                maleCount = maleMap.get(<span class="string">&quot;soliver&quot;</span>);</span><br><span class="line">                maleMap.put(<span class="string">&quot;soliver&quot;</span>, <span class="keyword">null</span> != maleCount ? maleCount + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;female&quot;</span>:</span><br><span class="line">            Integer femaleCount;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;gold&quot;</span>.equals(level)) &#123;</span><br><span class="line">                femaleCount = femaleMap.get(<span class="string">&quot;gold&quot;</span>);</span><br><span class="line">                femaleMap.put(<span class="string">&quot;gold&quot;</span>, <span class="keyword">null</span> != femaleCount ? femaleCount + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;soliver&quot;</span>.equals(level))&#123;</span><br><span class="line">                femaleCount = femaleMap.get(<span class="string">&quot;soliver&quot;</span>);</span><br><span class="line">                femaleMap.put(<span class="string">&quot;soliver&quot;</span>, <span class="keyword">null</span> != femaleCount ? femaleCount + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码作用是统计不同性别的工程师职级的人数,在Java StreamAPI出来之前，这样类似的业务代码在系统中应该是随处可见的,手打上面的代码我大概花了两分钟,有了Stream之后，我偷了个懒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Map&lt;String,Integer&gt;&gt; result = list.stream().collect(</span><br><span class="line">    Collectors.toMap(</span><br><span class="line">        person -&gt; person.getGender(),</span><br><span class="line">        person -&gt; Collections.singletonMap(person.getLevel(), <span class="number">1</span>),</span><br><span class="line">        (existValue,newValue) -&gt; &#123;</span><br><span class="line">            HashMap&lt;String,Integer&gt; newMap = <span class="keyword">new</span> HashMap&lt;&gt;(existValue);</span><br><span class="line">            newValue.forEach((key,value) -&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(newMap.containsKey(key)) &#123;</span><br><span class="line">                    newMap.put(key, newMap.get(key) + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    newMap.put(key, value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> newMap;</span><br><span class="line">        &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者改成这样的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Map&lt;String,Integer&gt;&gt; result =  stream.collect(</span><br><span class="line">    Collectors.groupingBy(</span><br><span class="line">        Person::getGender, </span><br><span class="line">        Collectors.toMap(</span><br><span class="line">            person-&gt;person.getLevel(), </span><br><span class="line">            person -&gt; <span class="number">1</span>,</span><br><span class="line">            (existValue,newValue) -&gt; existValue + newValue</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不仅代码块减少了许多，甚至逻辑也更清晰了。真的是用stream一时爽，一直用一直爽呀。</p>
<p>Stream作为流，它可以是有限的可以是无限的，当然我们用得最多的还是有限的流(for循环就是有限的流),如上面那张图一样，我们可以对流中的元素做各种各样常见的处理。比如求和，过滤，分组，最大值，最小值等常见处理，所以现在就开始使用Stream吧</p>
<h3 id="Stream的特性"><a href="#Stream的特性" class="headerlink" title="Stream的特性"></a>Stream的特性</h3><ol>
<li>Stream自己不会存储元素,元素可能被存储在底层集合中，或者被生产出来。</li>
<li>Stream操作符不会改变源对象,相反，他们会返回一个持有新对象的stream</li>
<li>Stream操作符是延迟执行的，可能会等到需要结果的时候才去执行。</li>
</ol>
<h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>抽象方法名</th>
<th>描述</th>
<th>其他方法</th>
</tr>
</thead>
<tbody><tr>
<td>Runnable</td>
<td>无</td>
<td>void</td>
<td>run</td>
<td>执行一个没有参数和返回值的操作</td>
<td>无</td>
</tr>
<tr>
<td>Supplier&lt;T&gt;</td>
<td>无</td>
<td>T</td>
<td>get</td>
<td>提供一个T类型的值</td>
<td></td>
</tr>
<tr>
<td>Counsumer&lt;T&gt;</td>
<td>T</td>
<td>void</td>
<td>accept</td>
<td>处理一个T类型的值</td>
<td>chain</td>
</tr>
<tr>
<td>BiConsumer&lt;T,U&gt;</td>
<td>T,U</td>
<td>void</td>
<td>accept</td>
<td>处理T类型和U类型的值</td>
<td>chain</td>
</tr>
<tr>
<td>Function&lt;T,R&gt;</td>
<td>T</td>
<td>R</td>
<td>apply</td>
<td>一个参数类型为T的函数</td>
<td>compose,andThen,identity</td>
</tr>
<tr>
<td>BiFunction&lt;T,U,R&gt;</td>
<td>T,U</td>
<td>R</td>
<td>apply</td>
<td>一个参数类型为T和U的函数</td>
<td>andThen</td>
</tr>
<tr>
<td>UnaryOperator&lt;T&gt;</td>
<td>T</td>
<td>T</td>
<td>apply</td>
<td>对类型T进行的一元操作</td>
<td>compose,andThen,identity</td>
</tr>
<tr>
<td>BinaryOperator&lt;T&gt;</td>
<td>T,T</td>
<td>T</td>
<td>apply</td>
<td>对类型T进行二元操作</td>
<td>andThen</td>
</tr>
<tr>
<td>Predicate&lt;T&gt;</td>
<td>T</td>
<td>boolean</td>
<td>test</td>
<td>一个计算boolean值的函数</td>
<td>And,or,negate,isEqual</td>
</tr>
<tr>
<td>BiPredicate&lt;T,U&gt;</td>
<td>T,U</td>
<td>boolean</td>
<td>test</td>
<td>一个含有两个参数，计算boolean值的函数</td>
<td>and,or,negate</td>
</tr>
</tbody></table>
<h4 id="map-和flatMap-的区别"><a href="#map-和flatMap-的区别" class="headerlink" title="map()和flatMap()的区别"></a>map()和flatMap()的区别</h4><p>使用map方法的时候，相当于对每个元素应用一个函数，并将返回的值收集到新的Stream中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream&lt;String[]&gt;    -&gt; flatMap -&gt;    Stream&lt;String&gt;</span><br><span class="line">Stream&lt;Set&lt;String&gt;&gt;    -&gt; flatMap -&gt;    Stream&lt;String&gt;</span><br><span class="line">Stream&lt;List&lt;String&gt;&gt;    -&gt; flatMap -&gt;    Stream&lt;String&gt;</span><br><span class="line">Stream&lt;List&lt;Object&gt;&gt;    -&gt; flatMap -&gt;    Stream&lt;Object&gt;</span><br><span class="line"></span><br><span class="line">&#123;&#123;1,2&#125;, &#123;3,4&#125;, &#123;5,6&#125; &#125; -&gt; flatMap -&gt; &#123;1,2,3,4,5,6&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中间操作以及结束操作"><a href="#中间操作以及结束操作" class="headerlink" title="中间操作以及结束操作"></a>中间操作以及结束操作</h4><p>Stream上的所有操作分为两类：中间操作和结束操作，中间操作只是一种标记(调用到这类方法，并没有真正开始流的遍历。)，只有结束操作才会触发实际计算。简单的说就是API返回值仍然是Stream的就是中间操作，否则就是结束操作。</p>
<h4 id="如何debug"><a href="#如何debug" class="headerlink" title="如何debug"></a>如何debug</h4><ol>
<li>请使用代码段,比如<code>IntStream.of(1,2,3,4,5).fiter(i -&gt; &#123;return i%2 == 0;&#125;)</code>将断点打在代码段上即可。</li>
<li>引用方法也可以进行调试，在isDouble中打上断点比如<code>IntStream.of(1,2,3,4,5).fiter(MyMath::isDouble)</code></li>
</ol>
<h3 id="那些不好理解的API"><a href="#那些不好理解的API" class="headerlink" title="那些不好理解的API"></a>那些不好理解的API</h3><ol>
<li>reduce()<br>我们以前做累加是如何完成的呢？<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> value in values) &#123;</span><br><span class="line">    sum = sum + value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
现在改成stream的方式来实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">values.stream().reduce(Integer::sum);</span><br></pre></td></tr></table></figure>
<p>这个reduce()方法就是一个二元函数:从流的前两个元素开始，不断将它应用到流中的其他元素上。</p>
<h4 id="如何写好Stream代码"><a href="#如何写好Stream代码" class="headerlink" title="如何写好Stream代码"></a>如何写好Stream代码</h4><p>stream API就是为了方便而设计的,在sql层面并不方便处理的数据可以通过stream来实现分组，聚合，最大值，最小值，排序，求和等等操作。所以不要把它想得太复杂，只管写就好了。总有那么一天你熟练了就可以写出简洁得代码。或者从现在开始把你项目中的大量for循环改造成stream方式。</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>本来想写大段代码来样式到stream API的转换，但是想了想完全没有必要,github上找了hutool工具类的部分代码来完成转换示例。(可以通过这种方式来提高stream api的能力)</p>
<ol>
<li><p>计算每个元素出现的次数(请先想象下jdk7怎么实现)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">代码效果：[a,b,c,c,c]  -&gt; a:<span class="number">1</span>,b:<span class="number">1</span>,c:<span class="number">3</span></span><br><span class="line"></span><br><span class="line">Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;c&quot;</span>).stream().collect(Collectors.groupingBy(str-&gt;str, Collectors.counting()));</span><br></pre></td></tr></table></figure>
</li>
<li><p>以特定分隔符将集合转换为字符串，并添加前缀和后缀(请先想象下jdk7怎么实现)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">myList.stream().collect(Collectors.joining(<span class="string">&quot;,&quot;</span>,<span class="string">&quot;&#123;&quot;</span>,<span class="string">&quot;&#125;&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>判断列表不全为空(请先想象下jdk7怎么实现)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myList.stream().anyMatch(s -&gt; !s.isEmpty());</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的会用Java8 Optional吗？</title>
    <url>/2020/01/16/understand-java8-optional/</url>
    <content><![CDATA[<p>Java8之前我们在写代码的时候，经常会遇到返回null的情况，如果这种情况不加以判断,你就会碰到NullPointerException(NPE)。而在Java8中，Optional类型是一种更好的表示缺少返回值的形式。</p>
<p>首先来看一段代码,这可能是以前大多数人的写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getIsoCode</span><span class="params">( User user)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Address address = user.getAddress();</span><br><span class="line">    <span class="keyword">if</span> (address != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Country country = address.getCountry();</span><br><span class="line">      <span class="keyword">if</span> (country != <span class="keyword">null</span>) &#123;</span><br><span class="line">          String isocode = country.getIsocode();</span><br><span class="line">          <span class="keyword">if</span> (isocode != <span class="keyword">null</span>) &#123;</span><br><span class="line">              isocode = isocode.toUpperCase();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>而当我们有了Optional之后,上面的代码就可以缩减很大一部分，答案我会在后面给出。</p>
<p>我见过有人的写法是这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;T&gt; optionalValue = ... ;</span><br><span class="line">optionalValue.get().someMethod();</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(optionalValue.isPresent()) &#123;</span><br><span class="line">  optionalValue.get().someMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它并不比下面的方式安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">T value = ... ;</span><br><span class="line">value.someMethod();</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(value != <span class="keyword">null</span>) &#123;</span><br><span class="line">  value.someMethod();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你在你的代码中出现了上面使用Optional的片段，那么你该好好优化下了。</p>
<p>其实高效使用Optional的关键在于，使用一个 <strong>接受正确值或者返回另一个替代值</strong> 的方法。</p>
<h3 id="创建Optional"><a href="#创建Optional" class="headerlink" title="创建Optional"></a>创建Optional</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建一个空的Optional实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据传入的值创建一个非空的实例, value不能为空，否则抛出NPE</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据传入的值创建实例，value可以为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value == <span class="keyword">null</span> ? empty() : of(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的三个方法就是我们构造Optional的途径,可以看到实际上Optional是对value的封装。<br><strong>需要注意的是<code>ofNullable</code> 和 <code>of</code>的区别，推荐使用<code>ofNullable</code>方法</strong></p>
<h3 id="其他常用方法"><a href="#其他常用方法" class="headerlink" title="其他常用方法"></a>其他常用方法</h3><ol>
<li><code>boolean isPresent()</code></li>
</ol>
<p><strong>判断value是否存在</strong></p>
<ol start="2">
<li><code>Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>   </li>
</ol>
<p><strong>判断value是否满足条件</strong></p>
<ol start="3">
<li><code>Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper)</code></li>
</ol>
<p><strong>对其中的value执行一个函数，将其变成另一个值。返回的值会被Optional.ofNullable封装</strong></p>
<ol start="4">
<li><code>Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper)</code></li>
</ol>
<p><strong>也是对其中的value执行一个函数,注意和map的区别在于,执行这个函数返回的值是Optional类型，返回的值不会被封装。</strong></p>
<ol start="5">
<li><code>orElse(T other)</code></li>
</ol>
<p><strong>当value存在时,返回value，不存在时返回other</strong></p>
<ol start="6">
<li><code>orElseGet(Supplier&lt;? extends T&gt; other)</code></li>
</ol>
<p><strong>和orElse一样，只是这里的参数是通过传入的function来决定的</strong></p>
<ol start="7">
<li><code>T orElseThrow</code></li>
</ol>
<p><strong>当value存在时,返回value，不存在时抛出异常</strong></p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>开头给出的代码就可以被优化为下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String isoCode = Optional.ofNullable(user)</span><br><span class="line">   .map(User::getAddress)  <span class="comment">//Optional&lt;Address&gt;</span></span><br><span class="line">   .map(Address::getCountry)  <span class="comment">//Optional&lt;Country&gt;</span></span><br><span class="line">   .map(Country::getIsocode)  <span class="comment">// Optional&lt;String&gt;</span></span><br><span class="line">   .orElse(<span class="string">&quot;empty&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>不过有一点需要注意的是orElse和orElseGet的区别在于,无论是否满足条件orElse中的方法始终会被执行,而orElseGet中的只有当value为空时才会执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.ofNullable(user)</span><br><span class="line">    .map(User::getAddress)</span><br><span class="line">    .map(Address::getCountry)</span><br><span class="line">    .map(Country::getIsocode)</span><br><span class="line">    .orElse(getIsoCode());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你可能觉得没什么，但是如果你的业务中获取这个值要去数据库查询,那么每一次只要运行这个代码就都要去查询，这样就造成了不必要的性能损失了,还是一个很大的问题的。</p>
<h3 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h3><ol>
<li>Optional是为了更优雅的判断null而诞生的,但是并不代表有null的地方一定就要用Optional代替</li>
<li>Optional一般用于方法返回值,不用于属性(无法被序列化)</li>
<li>Optional用于多层次null判断有奇效</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>从Java字节码分析中我学到了什么</title>
    <url>/2019/03/19/understand-parameter-transfer/</url>
    <content><![CDATA[<h3 id="实参和形参"><a href="#实参和形参" class="headerlink" title="实参和形参"></a>实参和形参</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码中sum()方法中的x,y就是形参,而调用方法sum(2,3)中的2与3就是实参。形参是在方法定义阶段，而实参实在方法调用阶段。</p>
<a id="more"></a>

<h3 id="查看字节码"><a href="#查看字节码" class="headerlink" title="查看字节码"></a>查看字节码</h3><h4 id="基本类型参数调用"><a href="#基本类型参数调用" class="headerlink" title="基本类型参数调用"></a>基本类型参数调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> intStatic = <span class="number">222</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    method(intStatic);</span><br><span class="line">    System.out.println(intStatic);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> intStatic)</span> </span>&#123;</span><br><span class="line">    intStatic = <span class="number">777</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的method()方法的字节码(<code>javap -verbose XXX.class</code>)如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void method(int);</span><br><span class="line">  descriptor: (I)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">       0: sipush        777</span><br><span class="line">       3: istore_0</span><br><span class="line">       4: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 13: 0</span><br><span class="line">      line 14: 4</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0       5     0 intStatic   I</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sipush: 将一个短整形常量值推送至栈顶</p>
<blockquote>
<p>iconst 将int形式-1-5推送到栈顶<br>bipush表示将单字节的常量值(-128-127)推送至栈顶<br>sipush表示一个短整形常量值(-32768-32767)推送至栈顶</p>
</blockquote>
</blockquote>
<blockquote>
<p>istore_0: 将栈顶int型数值存入第一个本地变量。</p>
</blockquote>
<p>上面字节码的意思就是将777推送到栈顶，然后将其赋值给intStatic这个本地变量。所以我们输出的结果是222,因为method()中的赋值是对本地变量进行赋值的,并没有改变static变量的值,这也是Java的变量就近原则,当然可以使用Class.intStatic这样的方式显示声明。</p>
<h4 id="不可变对象参数调用"><a href="#不可变对象参数调用" class="headerlink" title="不可变对象参数调用"></a>不可变对象参数调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String stringStatic = <span class="string">&quot;old string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    method(stringStatic);</span><br><span class="line">    System.out.println(stringStatic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String stringStatic)</span> </span>&#123;</span><br><span class="line">    stringStatic = <span class="string">&quot;new string&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面输出的结果是<code>old string</code>,同样反编译看下字节码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">  #6 &#x3D; String     #35          &#x2F;&#x2F; new string</span><br><span class="line">  #7 &#x3D; String     #36          &#x2F;&#x2F; old string</span><br><span class="line">  #10 &#x3D; Utf8      stringStatic</span><br><span class="line">  #35 &#x3D; Utf8      new string</span><br><span class="line">  #36 &#x3D; Utf8      old string</span><br><span class="line"></span><br><span class="line">public static void method(java.lang.String);</span><br><span class="line">  descriptor: (Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">       0: ldc           #6       &#x2F;&#x2F; String new string</span><br><span class="line">       2: astore_0</span><br><span class="line">       3: return</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">        Start  Length  Slot     Name             Signature</span><br><span class="line">          0      4      0    stringStatic   Ljava&#x2F;lang&#x2F;String;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ldc: 将int、float或String型常量值从常量池中推送至栈顶。<br>astore_0: 将栈顶引用型数值存入第一个本地变量。</p>
</blockquote>
<p>字节码的意思是将#6(符号引用)的值推送至栈顶,然后将其引用型数值赋值给第一个本地变量(stringStatic)。</p>
<p>可以看到这里的#6表示是一个String类型数据，它指向常量池中一个CONSTANT_Utf8_info(缩写Utf8,Class文件中方法字段等都需要引用它来描述名称)类型，这个常量代表了类(或者接口)的全限定名称,在运行的时候，JVM会根据这个全限定名称来实例化这个类,那个时候符号引用会被转换为直接引用(就是内存中的地址)。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>上面一直在说常量池,那么常量池到底是个什么东东?</p>
<p><strong>我们都知道方法区与Java堆一样,是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。<br>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池(Constant Pool Table)，用于存放编译期产生的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。<br>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有在编译器才能产生，也就是并非预置入Class文件常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中,String.intern()方法就是典型的代表。</strong></p>
<blockquote>
<p>永久代和方法区，很多人会迷惑。方法区是JVM规范,而永久代只是实现。<br>从JDK7开始常量池已经从方法区移动到堆中</p>
</blockquote>
<p>文本字符串、声明为final的常量值都为字面量，而符号引用包含了下面三类常量<br>    1. 类和接口的全限定名<br>    2. 字段的名称和描述符<br>    3. 方法的名称和描述符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">  #1 &#x3D; Methodref    #9.#28     &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #2 &#x3D; Fieldref     #8.#29     &#x2F;&#x2F; com&#x2F;generalthink&#x2F;kafka&#x2F;ParamDemo.stringStatic:Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #3 &#x3D; Methodref    #8.#30     &#x2F;&#x2F; com&#x2F;generalthink&#x2F;kafka&#x2F;ParamDemo.method:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #8 &#x3D; Class        #37        &#x2F;&#x2F; com&#x2F;generalthink&#x2F;kafka&#x2F;ParamDemo</span><br></pre></td></tr></table></figure>
<p>所以,编译器<strong>符号引用stringStatic</strong>和<strong>字面量old string</strong>会被加入到Class文件的常量池中，然后在类加载阶段，这两个常量会进入运行时常量池。</p>
<h4 id="可变对象参数调用"><a href="#可变对象参数调用" class="headerlink" title="可变对象参数调用"></a>可变对象参数调用</h4><p>上面的参数传递的是不可变对象，这里变成可变对象我们再次分析下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> StringBuilder stringBuilderStatic = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;old stringBuilder&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    method(stringBuilderStatic);</span><br><span class="line">    System.out.println(stringBuilderStatic);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(StringBuilder stringBuilderStaticParam)</span> </span>&#123;</span><br><span class="line">    stringBuilderStaticParam.append(<span class="string">&quot; first append&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stringBuilderStaticParam = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;new stringBuilder&quot;</span>);</span><br><span class="line">    stringBuilderStaticParam.append(<span class="string">&quot; new method&#x27;s append&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看对应的关键字节码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">  #6 &#x3D; String     #41            &#x2F;&#x2F;  first append</span><br><span class="line">  #8 &#x3D; Class      #43            &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">  #9 &#x3D; String     #44            &#x2F;&#x2F; new stringBuilder</span><br><span class="line">  #11 &#x3D; String    #46            &#x2F;&#x2F; new method&#39;s append</span><br><span class="line">  #12 &#x3D; String    #47            &#x2F;&#x2F; old stringBuilder</span><br><span class="line">  #15 &#x3D; Utf8      stringBuilderStatic</span><br><span class="line">  #30 &#x3D; Utf8      stringBuilderStaticParam</span><br><span class="line">  #41 &#x3D; Utf8      first append</span><br><span class="line">  #43 &#x3D; Utf8      java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">  #44 &#x3D; Utf8      new stringBuilder</span><br><span class="line">  #46 &#x3D; Utf8      new method&#39;s append</span><br><span class="line">  #47 &#x3D; Utf8      old stringBuilder</span><br><span class="line"></span><br><span class="line">public static void method(java.lang.StringBuilder);</span><br><span class="line">  descriptor: (Ljava&#x2F;lang&#x2F;StringBuilder;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack&#x3D;3, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: ldc           #6    &#x2F;&#x2F; String  first append</span><br><span class="line">       3: invokevirtual #7    &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">       6: pop</span><br><span class="line">       7: new           #8    &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">      10: dup</span><br><span class="line">      11: ldc           #9    &#x2F;&#x2F; String new stringBuilder</span><br><span class="line">      13: invokespecial #10   &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">      16: astore_0</span><br><span class="line">      17: aload_0</span><br><span class="line">      18: ldc           #11   &#x2F;&#x2F; String new method&#39;s append</span><br><span class="line">      20: invokevirtual #7    &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">      23: pop</span><br><span class="line">      24: return</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length      Slot          Name                           Signature</span><br><span class="line">        0      25      0         stringBuilderStaticParam   Ljava&#x2F;lang&#x2F;StringBuilder;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>aload_0:将第一个引用类型本地变量推送至栈顶。<br>ldc : 将int、float或String型常量值从常量池中推送至栈顶。<br>invokevirtual：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法<br>pop: 将栈顶数值弹出(不能是long或double类型)<br>new: 创建一个对象,并将其引用值压入栈顶<br>dup：复制栈顶数值并将复制值压入栈顶<br>astore_0 : 将栈顶引用型数值存入第一个本地变量<br>return : 从当前方法返回void</p>
</blockquote>
<p>需要注意的是aload_0中的0指的是<code>LocalVariableTable</code>中slot为0的参数，这里指的是stringBuilderStaticParam。它是把静态变量的引用赋值给虚拟机栈帧中的局部变量表。</p>
<p>上面字节码的意思就是stringBuilderStaticParam推送至栈顶,然后将first append常量值推送到栈顶，调用StringBuilder.append方法得到结果,最后出栈。<br>接着new一个StringBuilder,将返回的地址复制一份压入栈顶,然后在将这个地址存入stringBuilderStaticParam。然后重新aload到操作栈顶(这里的值已经被进行了覆盖,所以后续对于stringBuilderStaticParam的append操作与类的静态变量stringBuilderStatic没有任何关系),然后接着调用append方法,最后返回void。</p>
<p>需要注意的是stringBuilderStatic仅仅只是一个指针,一个指向内存中具体地址的指针而已,它并不是这个内存地址。java spec中声明说,<strong>java中的所有东西都是值传递</strong>,从没有引用传递这个玩意儿<br>代码是检验整理的唯一标准,现在假设是引用传递,那么执行method方法之后,输出的结果就应该是<code>new stringBuilder new method&#39;s append</code>,但是输出结果并不是，所以参数传递是值传递,这个值对对象来说是指针而已。</p>
<h3 id="this是如何实现的"><a href="#this是如何实现的" class="headerlink" title="this是如何实现的"></a>this是如何实现的</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ParamDemo demo = <span class="keyword">new</span> ParamDemo();</span><br><span class="line">    System.out.println(demo.method());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在method()方法中调用了m,这里隐式的使用了this,其实是this.m。那么this式如何实现的呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int method();</span><br><span class="line">  descriptor: ()I</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      #2     &#x2F;&#x2F; Field m:I</span><br><span class="line">       4: iconst_1</span><br><span class="line">       5: iadd</span><br><span class="line">       6: ireturn</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 15: 0</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0       7     0  this   Lcom&#x2F;generalthink&#x2F;kafka&#x2F;ParamDemo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在<strong>LocalVariableTable</strong>中可以发现this成为了一个参数，它的实现就是这样简单,<strong>Javac编译器编译的时候把this关键字的访问转变为对一个普通方法参数的访问,然后在虚拟机调用实例方法时自动传入此参数。</strong></p>
<p>一说到this肯定就会想起super,其实super就是一个普通的方法调用,通过invokespecial指令实现。</p>
<h3 id="String-intern-原理"><a href="#String-intern-原理" class="headerlink" title="String.intern()原理"></a>String.intern()原理</h3><p>当使用intern()方法的时候你要想到方法作用是将字面量动态的加入运行时常量池。如果运行时常量池中已经存在了相同的字符串(equals方法决定),则返回池中的对象，否则将其加入到常量池后返回对应的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;Hello&quot;</span>).intern();</span><br><span class="line"></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>
<p>输出结果为true,编译期间”Hello”这个字面量已经加入到了常量池,运行期间,调用了intern()方法,先根据equals方法判断两个字符串相等,然后返回常量池当中Hello的引用地址,所以此时s1,s2其实指向的是同一个地址。</p>
<p>我们将代码做一点修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">String s3 = s1 + s2;</span><br><span class="line"></span><br><span class="line">String s4 = <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);</span><br><span class="line"></span><br><span class="line">System.out.println(s3.intern() == s4);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果分别为false和true。我们注意到s3和s4最多的不同就是,s3是由变量相加得到的,同样查看字节码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#2 &#x3D; String     #37     &#x2F;&#x2F; Hello</span><br><span class="line">#3 &#x3D; String     #38     &#x2F;&#x2F; World</span><br><span class="line">#4 &#x3D; Class      #39     &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">#5 &#x3D; Methodref  #4.#36  &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#6 &#x3D; Methodref  #4.#40  &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">#7 &#x3D; Methodref  #4.#41  &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">#8 &#x3D; String     #42     &#x2F;&#x2F; HelloWorld</span><br><span class="line"></span><br><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">  descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack&#x3D;3, locals&#x3D;5, args_size&#x3D;1</span><br><span class="line">      0: ldc           #2        &#x2F;&#x2F; String Hello</span><br><span class="line">      2: astore_1</span><br><span class="line">      3: ldc           #3        &#x2F;&#x2F; String World</span><br><span class="line">      5: astore_2</span><br><span class="line">      6: new           #4        &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">      9: dup</span><br><span class="line">      10: invokespecial #5        &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      13: aload_1</span><br><span class="line">      14: invokevirtual #6        &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">      17: aload_2</span><br><span class="line">      18: invokevirtual #6        &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">      21: invokevirtual #7        &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">      24: astore_3</span><br><span class="line">      25: ldc           #8        &#x2F;&#x2F; String HelloWorld</span><br><span class="line">      27: astore        4</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>
<p>从字节码可以看出来s3实际上是调用了StringBuilder.append()方法来得到的,而s4的值在编译的时候就可以直接确定,它是一个准确的值,所以此时HelloWorld在常量池中就存在了。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出git(二)——分支</title>
    <url>/2019/01/10/understanding-git-branch/</url>
    <content><![CDATA[<p>在开发软件的时候,可能很多人会同时为同一个软件开发功能或者修复bug,但是如果都在主分支来进行开发,引起冲突的概率将会大大增加,而且也不利于维护,如果你同时修改多个bug该怎么办?所幸,git的分支功能很好的帮助我们解决了这个问题,它可以帮助我们同时进行多个功能的开发和版本管理.<br>请在阅读这篇文章之前,务必先阅读<a href="http://generalthink.github.io/2019/01/09/understanding-git-data-model/">深入浅出git——数据模型</a>,这样才能更好的帮助你理解git中的分支.想知道为什么git中新建一个分支那么快,代价那么小吗?接下来我们就来揭开分支神秘的面纱.</p>
<a id="more"></a>

<p>这次我会只显示commit objects来简化它,并且为了让它更容易理解我会给他们取个别名来代替原本的检验和.所以对于提交记录,我们会得到一个像下面这样的图.<br><img data-src="/images/understanding-git/branch-graph.png" alt="commit objects"></p>
<p>熟悉图论的应该注意到了上面的是一个有向无环图(DAG),这意味着从一个节点开始沿着边的方向不会经过相同的节点.<br>在我们的例图中可以清晰的发现存在三个不同的分支,我们分别用红色(包含A,B,C,D,E),蓝色(A,B,F,G),以及绿色(A,B,H,I,J)来标记它们</p>
<p><img data-src="/images/understanding-git/branch-three-branchs.png" alt="三个分支"></p>
<p>这就是定义分支的一种方式-包含所有的提交列表.但是这不是git使用的方式,git使用更简单更便宜的方式,git只跟踪分支上的最后一次提交,而不是持有某个分支的所有列表并更新它们,只需要知道分支的最后一次提交,然后根据图的有向边就可以获取整个提交列表.例如要定义我们的蓝色分支,只需要知道蓝色分支的最后一次提交是G,如果我们需要蓝色分支包含的所有提交的列表,就从G沿着图有向边遍历即可.<br><img data-src="/images/understanding-git/branch-git-branch-list.png" alt="三个分支"></p>
<p>这就是git管理分支的方式,通过保持执行提交记录的指针即可,接下来我们会进行一个演示.<br>首先通过<code>git init</code>初始化一个空仓库,然后查看.git目录下存在的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.git</span><br><span class="line">|-- HEAD</span><br><span class="line">|-- config</span><br><span class="line">|-- description</span><br><span class="line">|-- hooks</span><br><span class="line">|   |-- applypatch-msg.sample</span><br><span class="line">|   |-- commit-msg.sample</span><br><span class="line">|   |-- fsmonitor-watchman.sample</span><br><span class="line">|   |-- post-update.sample</span><br><span class="line">|   |-- pre-applypatch.sample</span><br><span class="line">|   |-- pre-commit.sample</span><br><span class="line">|   |-- pre-push.sample</span><br><span class="line">|   |-- pre-rebase.sample</span><br><span class="line">|   |-- pre-receive.sample</span><br><span class="line">|   |-- prepare-commit-msg.sample</span><br><span class="line">|   |-- update.sample</span><br><span class="line">|-- info</span><br><span class="line">|   -- exclude</span><br><span class="line">|-- objects</span><br><span class="line">|   |-- info</span><br><span class="line">|   |-- pack</span><br><span class="line">|-- refs</span><br><span class="line">    |-- heads</span><br><span class="line">    |-- tags</span><br></pre></td></tr></table></figure>

<p>这次我们关注<code>refs</code>这个子目录,这个地方是git保留分支指针的地儿.当我们没有提交任何东西的时候,<code>refs</code>目录下只存在两个空目录,现在我们提交几个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;Hello Java&quot; &gt; helloJava.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Hello Java Commit&quot;</span><br><span class="line">echo &quot;Hello Php&quot; &gt; helloPhp.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Hello Php Commit&quot;</span><br><span class="line">echo &quot;Hello Python&quot; &gt; helloPython.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Hello Python Commit&quot;</span><br></pre></td></tr></table></figure>
<p>当我们执行<code>git branch</code>的时候我们可以看到下面这样的输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* master</span><br></pre></td></tr></table></figure>
<p>意味着我们现在处于master分支上(这个是当我们第一次提交的时候git自动给我们创建的),此时<code>refs</code>目录下是这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.git&#x2F;refs</span><br><span class="line">|-- heads</span><br><span class="line">|   &#96;-- master</span><br><span class="line">&#96;-- tags</span><br></pre></td></tr></table></figure>
<p>我们看到refs/heads子目录中有一个文件，它就像我们的分支一样被命名为master,我们使用cat命令查看下文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .git&#x2F;refs&#x2F;heads&#x2F;master</span><br><span class="line">49cd903b2bf247de040118ce60d1931ff587e801</span><br></pre></td></tr></table></figure>

<p>而使用<code>git log</code>命令我们可以看到我们的提交记录是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit 49cd903b2bf247de040118ce60d1931ff587e801 (HEAD -&gt; master)</span><br><span class="line">Author: zhu.yang &lt;zhu.yang@xxx.com&gt;</span><br><span class="line">Date:   Tue Jan 8 17:48:36 2019 +0800</span><br><span class="line">    Hello Python Commit</span><br><span class="line"></span><br><span class="line">commit dd7c1bc9c125067f5658bcc6bc35567d07bc4f35</span><br><span class="line">Author: zhu.yang &lt;zhu.yang@xxx.com&gt;</span><br><span class="line">Date:   Tue Jan 8 17:48:31 2019 +0800</span><br><span class="line">    Hello Php Commit</span><br><span class="line"></span><br><span class="line">commit c6bd5c991dbcf9c50bbab682796ab3e06672f5a7</span><br><span class="line">Author: zhu.yang &lt;zhu.yang@xxx.com&gt;</span><br><span class="line">Date:   Tue Jan 8 17:48:30 2019 +0800</span><br><span class="line">    Hello Java Commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面可以看出来一个分支仅仅只是一个文本文件,其中记录了这个分支最后一次提交的校验和.也就是指向commit的一个指针</p>
<p><img data-src="/images/understanding-git/branch-master.png" alt="master分支"><br>现在我们新建一个<code>feature</code>分支并切换到新建的这个分支上面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b feature</span><br></pre></td></tr></table></figure>
<p>使用tree命令在来看看.git/refs的样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.git&#x2F;refs</span><br><span class="line">|-- heads</span><br><span class="line">|   |-- feature</span><br><span class="line">|   |-- master</span><br><span class="line">|-- tags</span><br></pre></td></tr></table></figure>

<p>同样的我们使用cat命令查看下.git/refs/heads/feature文件的校验和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat  .git&#x2F;refs&#x2F;heads&#x2F;feature</span><br><span class="line">49cd903b2bf247de040118ce60d1931ff587e801</span><br></pre></td></tr></table></figure>
<p>我们会发现和master文件中的内容一致,现在为止我们没有往feature分支提交任何内容</p>
<p><img data-src="/images/understanding-git/branch-branch-feature.png" alt="两个分支"></p>
<p>这就是git创建一个分支那么快以及方便的原因所在,git仅仅只是创建了一个包含最近一次提交校验和的文件而已.</p>
<p>现在我们的仓库里面就有2个分支了,但是git怎么知道我们当前检出的分支是哪个分支呢?这里其实存在一个特殊的指针叫做<strong>HEAD</strong>,它之所以特殊是因为它并不指向具体的commit object,而是指向分支,git使用它来跟踪最近检出的分支.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .git&#x2F;HEAD</span><br><span class="line">ref: refs&#x2F;heads&#x2F;feature</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/understanding-git/branch-HEAD.png" alt="HEAD指针"></p>
<p>如果我们执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
<p>然后查看HEAD,会发现当前分支是master,然后HEAD会指向master</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .git&#x2F;HEAD</span><br><span class="line">ref: refs&#x2F;heads&#x2F;master</span><br></pre></td></tr></table></figure>


<p><img data-src="/images/understanding-git/branch-HEAD-to-master.png" alt="HEAD指针指向当前分支"></p>
<p>这就是git的分支模型,很简单但是很重要,了解它有助于理解在这个图上的其他操作(merge,rebase,checkout,revert…)</p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出git(一)——数据模型</title>
    <url>/2019/01/09/understanding-git-data-model/</url>
    <content><![CDATA[<p>自2005年诞生以来，git已经在开源世界中大受欢迎，我们中的许多人也在我们的工作岗位上使用它。 它是一个很棒的VCS工具，具有很多优点，但易于学习并不是其中之一。 对于git如果只会死记硬背命令那么要不了多久你就会忘记,然后一而再而三的背诵,无疑让人很受打击,在我看来，熟悉使用git甚至开始喜欢它的唯一方法是了解它如何在内部工作。 </p>
<p>git命令只是对数据存储的抽象,如果不了解git的工作原理，无论我们在笔记中记忆或存储了多少git命令或技巧我们仍然会对git的使用感到困惑.而git则是通过抽象的命令来暴露它的数据结构的使用方法.</p>
<p>所以这边文章我们更多的要关注git的内部关系-数据模型,当然这篇文章不会涉及到git的源码.</p>
<a id="more"></a>

<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h4><p>为了讲解数据模型,我们首先要在自己的工作目录下初始化一个空的git仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>git会告知我们已经在当前的目录下创建了一个.git目录,我们来看看这个.git长什么样子.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tree .git&#x2F;</span><br><span class="line">.git</span><br><span class="line">|-- HEAD</span><br><span class="line">|-- config</span><br><span class="line">|-- description</span><br><span class="line">|-- hooks</span><br><span class="line">|   |-- applypatch-msg.sample</span><br><span class="line">|   |-- commit-msg.sample</span><br><span class="line">|   |-- fsmonitor-watchman.sample</span><br><span class="line">|   |-- post-update.sample</span><br><span class="line">|   |-- pre-applypatch.sample</span><br><span class="line">|   |-- pre-commit.sample</span><br><span class="line">|   |-- pre-push.sample</span><br><span class="line">|   |-- pre-rebase.sample</span><br><span class="line">|   |-- pre-receive.sample</span><br><span class="line">|   |-- prepare-commit-msg.sample</span><br><span class="line">|   |-- update.sample</span><br><span class="line">|-- info</span><br><span class="line">|   |-- exclude</span><br><span class="line">|-- objects</span><br><span class="line">|   |-- info</span><br><span class="line">|   |-- pack</span><br><span class="line">|-- refs</span><br><span class="line">    |-- heads</span><br><span class="line">    |-- tags</span><br><span class="line"></span><br><span class="line">8 directories, 15 files</span><br></pre></td></tr></table></figure>

<p>其中一些文件和目录是不是看着有些熟悉,现在我们主要还是看<code>objects</code>这个目录,现在它是空的,但是一会儿我们就会改变它.</p>
<h4 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h4><p>首先我们创建一个<code>Main.java</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch Main.java</span><br></pre></td></tr></table></figure>
<p>然后输入一部分内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后以同样的方式在准备一个README.md文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch README.md</span><br></pre></td></tr></table></figure>

<p>向文件中输入以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is my first java project!</span><br></pre></td></tr></table></figure>

<p>现在add并且commit他们到仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &#39;Initial Commit&#39;</span><br></pre></td></tr></table></figure>

<h3 id="模型的创建"><a href="#模型的创建" class="headerlink" title="模型的创建"></a>模型的创建</h3><p>现在看上去没啥特殊的,现在我们回过头来在看看<code>.git/objects</code>目录下已经存在了一些子文件夹以及文件了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.git&#x2F;objects</span><br><span class="line">|-- 84</span><br><span class="line">|   -- 705622ee44f2afbb21087ca7d81fda01fccded</span><br><span class="line">|-- 95</span><br><span class="line">|   -- fc1236534b6f73930367f02895467040f47d4a</span><br><span class="line">|-- b0</span><br><span class="line">|   -- 81e51f448387e72a3e3551ba8610eedc172e60</span><br><span class="line">|-- f1</span><br><span class="line">|   -- a8b89f50a2fd8287578daa2b0374adf3cad8aa</span><br><span class="line">|-- info</span><br><span class="line">|-- pack</span><br><span class="line">6 directories, 4 files</span><br></pre></td></tr></table></figure>
<p>需要注意的是在你的电脑上目录和文件名称和我这里是不一样的.</p>
<h4 id="blob-object的创建"><a href="#blob-object的创建" class="headerlink" title="blob object的创建"></a>blob object的创建</h4><p>在<code>.git/objects</code>下我们注意到每个目录的名称只有2个字符长度,Git为每个对象生成一个40个字符的校验和（SHA-1）哈希，该校验和的前两个字符用作目录名，另外38个字符用作文件（对象）名。<br>当我们提交一些文件时,git创建的第一类对象是<strong>blob object</strong>,在我们的例子中是两个,每一个<strong>blob object</strong>对应我们提交的每一个文件:</p>
<p><img data-src="/images/understanding-git/data-model-blob-object.png" alt="blob object"></p>
<p>blob object包含文件的快照以及拥有文件校验和.</p>
<h4 id="tree-object的创建"><a href="#tree-object的创建" class="headerlink" title="tree object的创建"></a>tree object的创建</h4><p>git创建的另外一种对象是<code>tree object</code>,在我们的例子中只有一个,它包含我们项目中所有文件的列表,其中包含分配给它们的blob object的指针(这就是git如何将文件与blob object相关联)</p>
<p><img data-src="/images/understanding-git/data-model-tree-object.png" alt="tree object"></p>
<h4 id="commit-object的创建"><a href="#commit-object的创建" class="headerlink" title="commit object的创建"></a>commit object的创建</h4><p>最后git还创建了一个commit object,该对象具有指向它的tree object的指针(以及一些其他信息)</p>
<p><img data-src="/images/understanding-git/data-model-commit-object.png" alt="commit object"></p>
<p>这个时候在来看以下objects目录下的结构就清晰多了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.git&#x2F;objects</span><br><span class="line">|-- 84</span><br><span class="line">|   -- 705622ee44f2afbb21087ca7d81fda01fccded</span><br><span class="line">|-- 95</span><br><span class="line">|   -- fc1236534b6f73930367f02895467040f47d4a</span><br><span class="line">|-- b0</span><br><span class="line">|   -- 81e51f448387e72a3e3551ba8610eedc172e60</span><br><span class="line">|-- f1</span><br><span class="line">|   -- a8b89f50a2fd8287578daa2b0374adf3cad8aa</span><br><span class="line">|-- info</span><br><span class="line">|-- pack</span><br></pre></td></tr></table></figure>

<h3 id="验证模型的准确性"><a href="#验证模型的准确性" class="headerlink" title="验证模型的准确性"></a>验证模型的准确性</h3><p>上面画出了模型图,但是你以为我这个模型是自己猜的吗?我又是如何确定哪个是blob object?哪个是tree object?哪个是commit object的呢?接下来就是见证奇迹的时刻了.</p>
<p>使用<code>git log</code>命令我们可以查看我们的提交历史</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commit f1a8b89f50a2fd8287578daa2b0374adf3cad8aa (HEAD -&gt; master)</span><br><span class="line">Author: zhu.yang &lt;zhu.yang@xxx.com&gt;</span><br><span class="line">Date:   Tue Jan 8 10:12:06 2019 +0800</span><br><span class="line">    Initial Commit</span><br></pre></td></tr></table></figure>

<p>根据我们前面说的命名约定,我们可以在objects中发现<code>f1a8b89f50a2fd8287578daa2b0374adf3cad8aa</code>这个对象.<br>想要查看文件内容我们不能简单的使用<code>cat</code>命令,因为这些不是纯文本文件,但是好在git给我们提供了一个cat-file命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git cat-file commit f1a8b89f50a2fd8287578daa2b0374adf3cad8aa</span><br></pre></td></tr></table></figure>
<p>可以通过它获取到commit object中的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tree 95fc1236534b6f73930367f02895467040f47d4a</span><br><span class="line">author zhu.yang &lt;zhu.yang@xxx.com&gt; 1546913526 +0800</span><br><span class="line">committer zhu.yang &lt;zhu.yang@xxx.com&gt; 1546913526 +0800</span><br><span class="line">Initial Commit</span><br></pre></td></tr></table></figure>

<p>从上面可以看到commit指向tree object并且我们可以使用<code>git ls-tree</code>命令来检查下其中的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git ls-tree 95fc1236534b6f73930367f02895467040f47d4a</span><br></pre></td></tr></table></figure>
<p>正如我们说预料的一样,其中包含了指向blob object的文件列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100644 blob 84705622ee44f2afbb21087ca7d81fda01fccded    Main.java</span><br><span class="line">100644 blob b081e51f448387e72a3e3551ba8610eedc172e60    README.md</span><br></pre></td></tr></table></figure>

<p>如果想要查看Main.java中的内容则使用<code>cat-file</code>命令即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git cat-file blob 84705622ee44f2afbb21087ca7d81fda01fccded</span><br></pre></td></tr></table></figure>
<p>我们可以看到其中返回了Main.java文件的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">                System.out.println(&quot;Hello World&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是当我们创建并提交了一些文件的时候就会发生的事情.同时也验证了我们模型的准确性.</p>
<h4 id="修改文件时模型的改变"><a href="#修改文件时模型的改变" class="headerlink" title="修改文件时模型的改变"></a>修改文件时模型的改变</h4><p>现在我们修改一下main.java然后重新提交一下</p>
<p><img data-src="/images/understanding-git/data-model-when-create-new-blob.png" alt="新增blob object"></p>
<p>正如我们看到的一样,git以快照的方式为<code>Main.java</code>新建了一个blob object,由于<code>README.md</code>没有被修改,因此不会为其创建新的blob object.而且<strong>git会重用现有的blob object.</strong></p>
<p>现在，当git创建一个tree object时，分配给<code>Main.java</code>的blob指针会被更新，并且分配给<code>README.md</code>的blob指针将保持与前一个提交树中的相同。</p>
<p><img data-src="/images/understanding-git/data-model-when-create-new-tree.png" alt="新增tree object"></p>
<p>在最后,git创建一个commit object并指向它的tree object.同时还有一个指向它的父提交对象的指针(每个提交除了第一个提交至少还有一个父提交)<br><img data-src="/images/understanding-git/data-model-when-create-new-commit.png" alt="新增commit object"></p>
<p>到现在为止我们已经知道了git是如何处理文件的新增以及编辑的,唯一还遗留的就是如何处理删除了,我们先删除Main.java:</p>
<p><img data-src="/images/understanding-git/data-model-when-delete.png" alt="删除文件"></p>
<p>请注意上图中红色的连线,我们发现删除同样也是非常简单,只需要删除tree object指向blob object的指针即可.在这种情况下我们在新的提交中删除了Main.java,因此我们的提交的树对象不再具有指向表示Main.java的blob object的指针.</p>
<h4 id="模型对文件夹的处理"><a href="#模型对文件夹的处理" class="headerlink" title="模型对文件夹的处理"></a>模型对文件夹的处理</h4><p>我们提供的这个数据模型还有一个附加功能-tree object是可以被嵌套的(它们可以指向其他树对象),你可以这样想:每个blob object代表一个文件,每个树对象代表一个目录,所以如果我们有嵌套目录,我们就有嵌套的tree object.</p>
<p>由于上面的图已经是提交多次结果画出来的了,再在上面的基础上画结构就不是那么清晰了,这次我重新初始化一个仓库来演示,现在该仓库下存在存在的数据如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|-- README.md</span><br><span class="line">&#96;-- app</span><br><span class="line">    &#96;-- user.json</span><br></pre></td></tr></table></figure>
<p>然后提交,最后可以看到如下的数据模型</p>
<p><img data-src="/images/understanding-git/data-model-dir.png" alt="tree object嵌套"></p>
<p>Git使用blob object以及tree object来重现项目的文件夹结构.到这里我相信你肯定对git的数据模型有了较为深入的了解,它真的是很简单,我相信基于它再去学习Git一定会是事半功倍.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>创建一个提交的时候git会新增blob object,tree object,commit object并会形成链路图</li>
<li>嵌套的tree object用来表示文件夹</li>
<li>git从复用blob object</li>
<li>除了第一个提交之外,每一个提交都有一个父提交</li>
</ol>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>深入简出git(三)——索引</title>
    <url>/2019/01/21/understanding-git-index/</url>
    <content><![CDATA[<h3 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h3><p>从git的角度来看,文件的修改涉及到以下三个区域:工作目录,stage区(暂存区)以及本地仓库.<br><img data-src="/images/understanding-git/git-area-when-update.png" alt="git区域"></p>
<p>当我们对我们的项目做了一些修改(新增文件,删除文件,修改文件等),我们处理的就是我们的工作目录.这个目录是存在于我们电脑的文件系统上的.所有的修改都会保留在工作目录直到我们把它们加入到暂存区(通过git add命令).</p>
<a id="more"></a>

<p>暂存区这是对下一次提交最好的表示方式,当我们执行<code>git commit</code>,git会获取暂存区中的修改,并将这些修改作为下一次的提交内容.暂存区的一个实际作用就是允许你调整你的提交,你可以向暂存区新增和删除修改直到你对你下一次的提交满意,这个时候你就可以用<code>git commit</code>提交你的内容了.</p>
<p>在提交修改后,它们就会进入<code>.git/objects</code>目录,在其中被保存为commit,blob以及tree objects(参考<a href="https://generalthink.github.io/2019/01/09/understanding-git-data-model/">数据模型</a>那一篇文章)</p>
<p>把暂存区认为是一个存储修改的真实区域并不准确,git没有专门的stage目录来存放这些文件的修改(blobs),git有一个名为index的文件来跟踪这三个区域的修改:工作目录,暂存区以及本地仓库</p>
<p>当我们添加修改到暂存区的时候,git会更新index文件中的信息,并且创建一个新的blob object,然后将它们放到与之前提交的记录所产生的其他blob相同的.git/objects目录中.</p>
<h3 id="index的变化"><a href="#index的变化" class="headerlink" title="index的变化"></a>index的变化</h3><p>接下来我们就通过一个正常的git流程来演示下git如何使用的index</p>
<p>首先在我们的仓库里面有master以及feature两个分支,如果我们执行下面的命令,会有三件事情发生</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br></pre></td></tr></table></figure>

<p>第一,git会移动HEAD指针来指向feature分支,为了更加便于理解,我们只显示功能分支的最后一次提交</p>
<p><img data-src="/images/understanding-git/index-object.png" alt="HEAD指向feature"></p>
<p>第二,git将获取feautre分支指向的提交内容并将其添加到索引中</p>
<p><img data-src="/images/understanding-git/index-when-checkout.png" alt="添加到索引"></p>
<p>我们注意到index是一个文件而不是目录,所以git是没有往其中存储内容的,git只是存储我们仓库中每个文件的信息而已,类似于上面这样</p>
<ul>
<li>mtime : 上次更新时间</li>
<li>file : 文件名称</li>
<li>wdir : 工作目录中文件版本</li>
<li>stage : index中文件版本</li>
<li>repo : 仓库中的文件版本</li>
</ul>
<p>文件版本以校验和来标识,如果两个文件有相同的校验和,那么它们就有一样的内容以及版本.</p>
<p>最后,git会将你的工作目录和HEAD指向的内容相匹配(它将使用树和blob对象重新创建项目目录的内容)</p>
<p><img data-src="/images/understanding-git/index-data-workspace.png" alt="索引和工作目录"></p>
<p>所以,当你使用checkout的时候,工作目录,暂存区以及仓库都是相同的版本<br>我们来看看当我们编辑Main.java的时候会发生什么?</p>
<p><img data-src="/images/understanding-git/index-when-workspace-change.png" alt="工作目录变化"></p>
<p>现在仅仅只影响了我们的工作目录,但是我们运行下面的命令的时候</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>git 首先会更新index文件中Main.java的工作目录的版本</p>
<p><img data-src="/images/understanding-git/index-find-workspace-change.png" alt="index中变化"></p>
<p>然后我们看到Main.java在工作目录和暂存区有不同的版本</p>
<p><img data-src="/images/understanding-git/index-find-stage-change.png" alt="index中变化"></p>
<p>然后git会提示我们</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">On branch feature</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">modified:   Main.java</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就表明工作目录的修改不在暂存区中(那么下一次的提交就不会包含Main.java的修改).</p>
<p>所以,执行以下命令将Main.java加入到暂存区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add Main.java</span><br></pre></td></tr></table></figure>

<p>执行了上面这条命令,就又会发生两件事儿,第一,git会为Main.java创建一个blob object然后存储在.git/objects目录下,第二,会再次更新index文件</p>
<p><img data-src="/images/understanding-git/index-sync-stage.png" alt="执行git add命令之后"></p>
<p>这个时候我们再次执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>git会发现Main.java的暂存区的版本和工作目录版本一致,但是和仓库的版本不一致</p>
<p><img data-src="/images/understanding-git/index-find-respo-change.png" alt="index中变化"></p>
<p>所以git就告知我们</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">On branch feature</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">modified:   Main.java</span><br></pre></td></tr></table></figure>
<p>证明Main.java已经在暂存区,但是还没有提交到仓库.现在我们就可以提交我们的修改了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;add some code to Main.java&quot;</span><br></pre></td></tr></table></figure>
<p>git会做下面几件事儿:<br>    1. 新增commit object和tree object,并把它们和执行git add时创建的blob object连接起来<br>    2. 移动feature的指针到新的commit object<br>    3. 更新index</p>
<p><img data-src="/images/understanding-git/index-create-object.png" alt="创建commit object"></p>
<p>好啦,现在我们的Main.java在所有区域都有相同的版本了.</p>
<p>无论执行 <code>git add</code>还是<code>git commit</code>index文件都会变更,这也更好的证明了我们上述模型,当然index文件中的内容肯定没有那么清晰,它是一个二进制文件,如果想要查看它的内容就需要借助其他工具来实现</p>
<p>上面就是关于git index的原理了,现在回过头来看发现其实并不复杂,但是对于我们理解在一些在index上操作的命令(add,checkout,revert,commit,add…)却是至关重要的</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.youtube.com/watch?v=xbLVvrb2-fY">https://www.youtube.com/watch?v=xbLVvrb2-fY</a></p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出git(四)——merge和rebase</title>
    <url>/2019/01/23/understanding-git-merge-and-rebase/</url>
    <content><![CDATA[<p>经过前面理论的学习,相信对git的模型已经有了一个比较深入的认识,在讲解常用开发命令之前,先看下git整体操作流程</p>
<p><img data-src="/images/understanding-git/merge-and-rebase/git-process.png" alt="git流程"></p>
<p>我们按照一个正常的开发流程来学习,我们现在要开始开发了,首先我们需要把远程仓库同步到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;generalthink&#x2F;git_learn.git</span><br></pre></td></tr></table></figure>
<p>运行完上面的命令,在我们的当前工作目录就会有一个git_learn的文件夹,其中存在.git目录(git维护仓库的基本)以及和远程仓库一样的文件,现在我们的代码环境就和远程仓库一致了,我们就可以开始我们的开发流程了。</p>
<a id="more"></a>

<h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><p>一般来说，无论是开发新功能(feature)还是修改bug(issue)我们都不会直接在主干上进行开发，而是会在分支上进行开发，然后验证无误之后在同步到master。<br>现在突然有了一个bug我们要新开一个分支来解决这个bug,那么我们应该怎么做呢?</p>
<p>首先，新建一个bugFix分支,并切换到这个分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch bugFix</span><br><span class="line">git checkout bugFix</span><br><span class="line">或者</span><br><span class="line">git checkout -b bugFix</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/understanding-git/merge-and-rebase/git-checkout.png" alt="git checkout"></p>
<p>新建一个分支,只是多了一个指针指向当前最新的提交而已,后面所有的提交都基于当前的分支,星号代表当前分支。</p>
<p>然后，找到bug的原因，修改对应的文件，现在我们修改了几个文件,需要提交将它加入到我们本地仓库,同步到远程仓库会在后面的文章讲解。</p>
<ol>
<li>加入修改的文件到暂存区</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add *.java</span><br></pre></td></tr></table></figure>
<p>上面的操作实际上是使文件工作目录和暂存区的版本一致,但是现在和仓库的版本还不一致.想要查看具体存在哪些文件需要提交可以使用<code>git status</code>查看。</p>
<ol start="2">
<li>提交文件到本地仓库</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;fix bug&quot;</span><br></pre></td></tr></table></figure>
<p><code>commit</code>命令实际上是让index中文件在暂存区和仓库的版本保持一致,经过这个步骤,工作目录,暂存区以及仓库的版本都是一致了，下面的图是提交前后commit objects(可以查看数据模型那篇文章)的变化。</p>
<p><img data-src="/images/understanding-git/merge-and-rebase/git-commit.png" alt="git commit"></p>
<p>你在修改bug的同时,其他人已经往主干分支上提交了其他功能的代码或者你本地本来就存在两个不同的分支,所以修复了这个bug之后,我们的仓库看上去是这样的</p>
<p><img data-src="/images/understanding-git/merge-and-rebase/git-two-branch.png" alt="结构图"></p>
<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>这个bug修复后,被测试验证通过了,然后接下来想要把这个分支的代码合并到主干分支(或者合并两个不同的分支),常用的合并方式有2种</p>
<h4 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h4><p>将bugFix合并到master分支上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;切换到master分支</span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line">git merge bugFix</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/understanding-git/merge-and-rebase/git-merge-bugFix.png" alt="git-merge-bugFix"></p>
<p>看到了没有,master指向了一个拥有两个父节点的提交记录,如果从master开始沿着箭头向上看,在到达起点的路上会经过所有的提交记录,这意味着 master 包含了对代码库的所有修改。</p>
<p>这个时候如果你还想把master分支合并到bugFix分支也是可以的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout bugFix</span><br><span class="line">git merge master</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/understanding-git/merge-and-rebase/git-merge-master.png" alt="git-merge-master"></p>
<p>因为 master 继承自 bugFix，Git 什么都不用做，只是简单地把 bugFix 移动到 master 所指向的那个提交记录。<br>现在所有提交记录的颜色都一样了，这表明每一个分支都包含了代码库的所有修改！</p>
<h4 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h4><p>第二种合并分支的方法是 git rebase。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。<br>Rebase 的优势就是可以创造更线性的提交历史.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase master</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/understanding-git/merge-and-rebase/git-rebase-bugFix.png" alt="git-rebase-bugFix"></p>
<p>现在 bugFix 分支上的工作在 master 的最顶端，同时我们也得到了一个更线性的提交序列。<br>注意，提交记录 C3 依然存在（树上那个虚线节点），而 C3’ 是我们 Rebase 到 master 分支上的 C3 的副本。<br>现在唯一的问题就是 master 还没有更新，下面咱们就来更新它吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git rebase bugFix</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/understanding-git/merge-and-rebase/git-rebase-master.png" alt="git-rebase-master"></p>
<p>由于 bugFix 继承自 master，所以 Git 只是简单的把 master 分支的引用向前移动了一下而已</p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出git(五)——自由的修改提交记录</title>
    <url>/2019/01/25/understanding-git-move-node/</url>
    <content><![CDATA[<p><a href="https://generalthink.github.io/2019/01/23/understanding-git-merge-and-rebase/">上篇文章</a>讲了merge和rebase,我们已经可以在commit object构成的图(当然我更愿意把它看成一棵树)上面进行分支的合并了,在图上我们可以新增节点(git commit),合并节点(merge或者rebase),这篇我们就来讲解下移动和删除节点。</p>
<p>在讲移动和删除之前，我们先来认识下HEAD的分离。</p>
<h3 id="分离的HEAD"><a href="#分离的HEAD" class="headerlink" title="分离的HEAD"></a>分离的HEAD</h3><p>我们都知道,HEAD是指向当前分支的,而分离的HEAD就是让其指向了某个具体的提交记录而不是分支名。</p>
<p>现在我本地的提交记录是这样的</p>
<p><img data-src="/images/understanding-git/move-and-delete/git-log-status.gif" alt="git log"></p>
<p>当我们执行<code>git checkout  062704b1c3a814dfd95695aba3684c22e3f3fa85</code>之后HEAD就处于分离状态。</p>
<p><img data-src="/images/understanding-git/move-and-delete/git-detached-head.gif" alt="分离HEAD"></p>
<p><img data-src="/images/understanding-git/move-and-delete/git-detached-head-structure.gif" alt="分离HEAD"></p>
<a id="more"></a>

<h3 id="移动节点"><a href="#移动节点" class="headerlink" title="移动节点"></a>移动节点</h3><p>我们可以通过指定提交记录hash的方式移动指针的位置(无论是分支还是HEAD),然而实际中并没有那么直观的图给我们看，就不得不使用<code>git log</code>来查看提交记录的hash，然而hash又比较长，幸好git对hash的处理比较智能，我们只需要提供唯一标识提交记录的前几个字符就可以了，因此我们可以只输入<code>git checkout 0627</code>就可以检出提交记录了。</p>
<p>通过hash值来移动节点显然并不方便，所以git提供了相对引用，这样我们就可以从一个易于记忆的地方(比如bugFix分支或者HEAD)开始计算。</p>
<h4 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h4><p>相对引用很给力，常用的两种用法</p>
<ol>
<li>使用<code>^</code>向上移动1个提交记录</li>
<li>使用<code>~num</code>向上移动多个提交记录</li>
</ol>
<p><img data-src="/images/understanding-git/move-and-delete/git-move-one.gif" alt="移动一个节点"><br><img data-src="/images/understanding-git/move-and-delete/git-move-multi.gif" alt="移动多个节点"></p>
<p>当我们执行<code>git checkout master^</code>的时候，我们的HEAD就指向了上一个提交记录(当前记录的是一个记录)，注意这里移动的是提交记录(commit object)，同理移动多个记录也是一样的。</p>
<p>使用相对引用最多的就是移动分支，我们可以命令直接让分支指向另外一个提交。</p>
<p><img data-src="/images/understanding-git/move-and-delete/git-move-branch.gif" alt="移动分支到指定节点"></p>
<p>现在master分支就指向了第一个提交，需要注意的是不能在当前分支操作当前分支的移动，否则你会有这样的错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: Cannot force update the current branch.</span><br></pre></td></tr></table></figure>
<p>完成移动之后并不会切换分支，仍然处于之前的分支。</p>
<h4 id="任意移动"><a href="#任意移动" class="headerlink" title="任意移动"></a>任意移动</h4><p>如何能将提交树的commit object任意的移动?让我们的修改可以更加的随意，<code>git cherry-pick</code>就能做到。<br>现在我们想把bugFix分支上C2,C4的提交记录移动到master分支上，只需要执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git cherry-pick C2 C4</span><br></pre></td></tr></table></figure>
<p>这个命令可以”复制”提交节点并在当前分支做一次完全一样的新提交</p>
<p><img data-src="/images/understanding-git/move-and-delete/git-cherry-pick.gif" alt="git cherry-pick"></p>
<h3 id="回退代码"><a href="#回退代码" class="headerlink" title="回退代码"></a>回退代码</h3><p>有的时候我们的代码提交错了，但是已经提交到git上去了，我想要回退怎么办？还好git提供了两种方法用来撤销变更—-<code>git reset</code>以及<code>git revert</code>。</p>
<h4 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h4><p><code>git reset</code>通过把分支记录回退几个提交记录来实现撤销 改动，其实就是移动在图上的指针。</p>
<p><img data-src="/images/understanding-git/move-and-delete/git-reset.gif" alt="git reset"></p>
<h4 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h4><p><img data-src="/images/understanding-git/move-and-delete/git-revert.gif" alt="git revert"></p>
<p>我们本来是要撤销C2提交的，但是为什么还多了一个C2’提交呢？这是因为新提交记录C2’引入了更改–这个更改又是用来撤销C2这个提交的，也就是说C2’的状态于C1是相同的。<br>revert之后就可以把更改push到远程仓库与别人分享了。</p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出git(六)——远端命令</title>
    <url>/2019/01/29/understanding-git-remote-cmd/</url>
    <content><![CDATA[<p>前面的文章讲的命令都是操作本地仓库的,我相信可以应付大部分的开发状况,提交代码到本地仓库已经不是问题了,那么这次我们就来看看如何和远程仓库进行对接。</p>
<h3 id="git-clone-—-克隆远端代码到本地"><a href="#git-clone-—-克隆远端代码到本地" class="headerlink" title="git clone — 克隆远端代码到本地"></a>git clone — 克隆远端代码到本地</h3><p>当我们进行开发的时候，开发流程是这样的：首先将远程仓库(中央仓库)的代码clone到本地，在本地进行开发，开发完成之后将代码提交到远程仓库。</p>
<p>远程仓库并不复杂,实际上它们只是你的仓库在另外一台计算机上的拷贝,我们可以通过网络和这台计算机通信–也就是增加或是获取提交记录。我们先通过命令将远端仓库clone到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;generalthink&#x2F;git_learn.git</span><br></pre></td></tr></table></figure>
<p>执行命令之后git仓库就从远端clone到本地了,此时本地和远端的代码一致。执行了这个命令之后我们本地有什么变化呢？<br>先查看我们现在存在哪些分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes&#x2F;origin&#x2F;HEAD -&gt; origin&#x2F;master</span><br><span class="line">  remotes&#x2F;origin&#x2F;master</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>当我们执行<code>git clone</code>的时候， Git 会为远程仓库中的每个分支在本地仓库中创建一个远程分支（比如 origin/master）。然后再<strong>创建一个跟踪远程仓库中活动分支的本地分支</strong>，默认情况下这个本地分支会被命名为 master。</p>
<p>你可能注意到了我们除了本地的master分支,还多了origin/master的分支,这种类型的分支就叫远程分支,它反映了远程仓库在你上次和它通信的状态。还记得index那篇文章吗?index文件中记录了工作目录,暂存区,本地仓库的版本用于跟踪文件状态,那么远程仓库的状态由谁来维护呢?没错就是这个origin/master分支。</p>
<p>需要注意的是远程分支有一个特别的属性,当我们检出时,自动进入分离HEAD状态(此种状态下提交并不能影响origin/master分支).git这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作。<br><img data-src="/images/understanding-git/remote-cmd/detached-origin-head.gif" alt="分离HEAD"></p>
<p>远程分支的命令规范是这样的:<code>&lt;remote name&gt;/&lt;branch name&gt;</code>,当我们使用git clone某个仓库的时候,git已经帮我们把远程仓库的名称设置为origin了。</p>
<p>可以使用下面的命令来查看远程库对应的简短名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https:&#x2F;&#x2F;github.com&#x2F;generalthink&#x2F;git_learn.git (fetch)</span><br><span class="line">origin  https:&#x2F;&#x2F;github.com&#x2F;generalthink&#x2F;git_learn.git (push)</span><br></pre></td></tr></table></figure>

<p>上面我们把远端仓库同步到了本地,远端和本地的代码就是一致的了(本地仓库中两个分支都指向的最新的提交记录)。</p>
<h3 id="分支跟踪"><a href="#分支跟踪" class="headerlink" title="分支跟踪"></a>分支跟踪</h3><p>当我们将本地master分支的代码push到远程的master分支(同时会更新远程分支origin/master)的时候，我们只需要执行<code>git push</code>就可以了，就好像git知道我们它们是关联起来的！</p>
<p>其实master和origin/master的关联关系是由分支的”remote tracking”属性决定的，master被设定为跟踪origin/master – 表示master指定了推送的目的地以及拉取后合并的目标。</p>
<p>可以让任意分支跟踪 origin/master, 然后该分支会像 master 分支一样得到隐含的 push 目的地以及 merge 的目标。 这意味着你可以在分支 bugFix上执行 git push，将工作推送到远程仓库的 master 分支上。我们可以通过下面的两种方法创建一个bugFix的分支，它跟踪远程分支origin/master</p>
<ul>
<li><p><code>git checkout</code></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b bugFix origin&#x2F;master</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>git branch</code> </p>
<p>  需要保证bugFix分支已经存在</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -u origin&#x2F;master bugFix</span><br><span class="line"></span><br><span class="line">如果当前就在bugFix分支上，命令可以优化成为</span><br><span class="line"></span><br><span class="line">git branch -u origin&#x2F;master</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这样bugFix就会跟踪origin/master了,当我们推送代码到远端的时候就可以不用指定目的地了，直接执行<code>git push</code>就可以将bugFix分支的代码推送到远端的master分支了。</p>
<p>通过<code>git branch -vv</code>命令可以查看本地分支关联的远程分支的对应关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line">* bugFix     215d0ff [origin&#x2F;master] add bugFix.md</span><br><span class="line">  foo        e2240d6 [origin&#x2F;master: behind 2] add foo.md</span><br><span class="line">  master     7b7adf6 [origin&#x2F;master: behind 5] Revert &quot;bugFix&quot;</span><br><span class="line">  newFeature 3136c72 [origin&#x2F;master: behind 3] add test2.md</span><br></pre></td></tr></table></figure>

<p>当你通过上面的命令设置了跟踪关系之后执行<code>git pull</code>的时候你可能会有这样的报错信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fatal: The upstream branch of your current branch does not match</span><br><span class="line">the name of your current branch.  To push to the upstream branch</span><br><span class="line">on the remote, use</span><br><span class="line">    git push origin HEAD:master</span><br><span class="line">To push to the branch of the same name on the remote, use</span><br><span class="line">    git push origin newFeature</span><br><span class="line">To choose either option permanently, see push.default in &#39;git help config&#39;.</span><br></pre></td></tr></table></figure>

<p>这全是因为<code>git config push.default</code>设置，默认是simple(从git 2.0开始)，这表示当本地分支和远端分支的名称不一样的时候git会拒绝提交。为了让其允许push到它跟踪的分支，需要重新设置这个参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global push.default upstream</span><br></pre></td></tr></table></figure>
<p><code>--global</code>只改变当前git仓库的配置。关于push.default有哪些值可以通过<code>git help config</code>命令查看。</p>
<p>设置完成之后，在执行<code>git push</code>命令就可以直接将bugFix分支的内容提交到master分支上了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push</span><br><span class="line">Enumerating objects: 4, done.</span><br><span class="line">Counting objects: 100% (4&#x2F;4), done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (2&#x2F;2), done.</span><br><span class="line">Writing objects: 100% (2&#x2F;2), 327 bytes | 327.00 KiB&#x2F;s, done.</span><br><span class="line">Total 2 (delta 1), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (1&#x2F;1), completed with 1 local object.</span><br><span class="line">To https:&#x2F;&#x2F;github.com&#x2F;generalthink&#x2F;git_learn.git</span><br><span class="line">   e2240d6..215d0ff  bugFix -&gt; master</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><p>上面我们的仓库已经和远端一致之后，我们就可以开发了，现在我们要修改一个bug,做法就是本地新建一个bugFix(命名规范各个公司是不一样的，一般配合bts工具)分支，<br>然后在这个分支上面修改，修改完成之后将修改提交到线上服务器，然后线上jekins会自动跑一些脚本，验证你提交的代码，或者检测冲突，有冲突就需要合并。等到一切没有问题之后就可以合并master去了，当然我们自己开发是没有这么复杂的，因此我们就通过直接将bugFix分支的代码推送到远端master分支就可以了</p>
<h3 id="提交代码到远程仓库"><a href="#提交代码到远程仓库" class="headerlink" title="提交代码到远程仓库"></a>提交代码到远程仓库</h3><p><code>git push</code>命令负责将我们的变更上传到指定的远程仓库，现在直接将我们的代码推送到远程分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin bugFix:master</span><br><span class="line">To https:&#x2F;&#x2F;github.com&#x2F;generalthink&#x2F;git_learn.git</span><br><span class="line">! [rejected]        bugFix -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &#39;https:&#x2F;&#x2F;github.com&#x2F;generalthink&#x2F;git_learn.git&#39;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally。 This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref。 You may want to first integrate the remote changes</span><br><span class="line">hint: (e。g。, &#39;git pull 。。。&#39;) before pushing again。</span><br><span class="line">hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details。</span><br></pre></td></tr></table></figure>
<p>执行命令发现报错了，为什么会这样呢？是因为你在开发的过程中，你的同事也在开发，并且他开发的代码已经合并到了主干上，这个时候你本地的代码就不是最新的了,这个时候如果你往远端push代码,那么git就会给你抛出这个错误提示。</p>
<p>此时，远端和本地分支的情况是这样的。<br><img data-src="/images/understanding-git/remote-cmd/git-rep-compare.gif" alt="远端和本地分支对比"></p>
<p>可以看到远端master节点和本地的origin/master指向的并不是同一个commit object,而我们执行的git push命令显然不能智能的帮助我们合并。此时我们应该先同步远端更改到本地，合并这些修改，然后在push到主干。</p>
<h4 id="git-fetch-–-同步代码到本地"><a href="#git-fetch-–-同步代码到本地" class="headerlink" title="git fetch – 同步代码到本地"></a>git fetch – 同步代码到本地</h4><p>下面的命令用来和远端进行通信,把远端的代码先同步到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch origin master</span><br></pre></td></tr></table></figure>
<p><img data-src="/images/understanding-git/remote-cmd/get-fetch.gif" alt="get fetch"></p>
<p>git fetch完成了仅有的但是特别重要的两步<br>    1. 从远程仓库下载本地仓库中缺失的提交记录<br>    2. 更新远程分支指针(如 origin/master)</p>
<p>现在本地仓库的远程分支更新成了远程仓库相应分支最新的状态。它通常通过互联网(http://或者git://协议)与远程仓库通信。<br>需要注意的是<strong>git fetch 并不会改变你本地仓库的状态。它不会更新你的 master 分支，也不会修改你磁盘上的文件。</strong></p>
<h4 id="合并代码"><a href="#合并代码" class="headerlink" title="合并代码"></a>合并代码</h4><p>现在我们已经获取到了远程的数据,只需要将这些变化更新到我们的工作目录中就可以了,我们只需要像合并本地分支那样来合并远程分支就可以了,我们可以通过以下三种方式来完成合并<br>    1. git cherry-pick origin/master<br>    2. git rebase origin/master<br>    3. git merge origin/master</p>
<p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git 提供了一个专门的命令来完成这两个操作。它就是我们的 git pull。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; git fetch;  git merge origin&#x2F;master</span><br><span class="line"></span><br><span class="line">git pull --rebase &#x3D;&#x3D; git fetch;git rebase origin&#x2F;master</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在本地的远程分支和远程仓库的代码保持了一致,我们终于可以使用服务器<code>git push origin bugFix:master</code>提交我们的代码了。</p>
<p>看着还挺不错,现在我们可以开心的使用git工作了,但是需要记住的是git push之前一定要保证要本地的远程指针一定要和远端一致,要不然你就只有等着报错吧。</p>
<h3 id="远程命令语法"><a href="#远程命令语法" class="headerlink" title="远程命令语法"></a>远程命令语法</h3><p>上面我们看到了和远程仓库交互的命令主要有git fetch/pull/push这个三个,有人经常使用的可能就只有get pull,git push这样的，可能第一次看到<code>git push orgin bugFix:master</code>这样的命令很惊奇，所以这里对这几个命令的语法做一些简介，如果有了解过的就可以不用看下面的文章了。</p>
<h4 id="git-push语法"><a href="#git-push语法" class="headerlink" title="git push语法"></a>git push语法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;localPlace:remotePlace&gt;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master:master</span><br></pre></td></tr></table></figure>
<p>表示切换到本地的master分支，获取所有提交，再到远程仓库”origin”中找到”master”分支(如果没有会新建一个)，将远程仓库中没有的提交记录添加上去。<br>通过”localPlace”参数来告诉git提交记录来自master，在推送到远程仓库中的master,后面的两个参数实际上是要同步的两个仓库的位置。<br>当只指定localPlace的时候remotePlace的值默认是我们跟踪的分支名称(需要注意push.default参数的值),如果当前分支就是你想要提交的分支，那么你可以直接写成<code>git push</code></p>
<p>这里的localPlace和remotePlace按照官方说明是一个refspec，“refspec” 是一个自造的词，意思是 git 能识别的位置（比如分支 bugFix或者 HEAD~1）。</p>
<h4 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h4><p>git fetch和git push的参数及其类似，它们概念相同，只是方向相反(因为你现在是下载，而非上传)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch &lt;remote&gt; &lt;remotePlace:localPlace&gt;</span><br></pre></td></tr></table></figure>
<p>举个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch origin master</span><br></pre></td></tr></table></figure>
<p>git会到远程仓库的master分支上，然后获取所有本地不存在的提交，放到本地的origin/master上，注意fetch并不会更新本地的非远程分支，而是下载提交记录。</p>
<p>如果想要直接更新本地master分支也不是不可以，运行下面的命令即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch origin master:master</span><br></pre></td></tr></table></figure>
<p><strong>理论上是可以的，但是强烈建议不要那么做。</strong></p>
<p>当我们只执行<code>git fetch</code>不带任何参数的时候，它就会下载所有的提交记录到各个远程分支。</p>
<h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><p>学会了git fetch，那么git pull就很简单了,git pull唯一关注的是提交最终合并到哪里。之前说过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull &#x3D;&#x3D; git fetch;git merge</span><br></pre></td></tr></table></figure>
<p>那么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull origin bugFix &#x3D;&#x3D;&#x3D;&#x3D;  git fetch orign master; git merge origin&#x2F;bugFix</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/understanding-git/remote-cmd/git-pull-structure.gif" alt="get pull"></p>
<p>上图可以看到当前分支是bugFix，执行pull命令之后origin/master的指向改变了，bugFix分支的内容和远端master分支的内容进行了合并，把这条命令拆解为2条来记忆我相信更容易让人理解。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>git系列写到现在已经结束了，总共写了6篇文章，三篇理论，三篇实际运用。理论是实战的基础，弄明白了理论理解起来更加容易，git将再也不难，当然我也不可能将每个命令都进行细致的讲解，<br>但是2-8理论在git中同样适用,如果想看更加详细的命令，我相信官方文档才是最好的。</p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>图说https协议</title>
    <url>/2019/03/26/understanding-https/</url>
    <content><![CDATA[<p>故事还要从月月给她老公亮亮发了一条消息说起。</p>
<p><img data-src="/images/Https/https_message_1.png"></p>
<a id="more"></a>
<p>晚上亮亮下班回到家,刚一进门<br>“给我跪下”,<br>“咋了,媳妇儿?”,嘴上这样问着,可是亮亮的身体还是很诚实。<br>“你不是给我发消息说今晚不回家吗?”说着月月掏出了手机<br>“天地良心我没这么说过,我今天收到了你的消息还是你骂我呢”,亮亮也掏出了自己的手机</p>
<p>“好神奇,我们收到的消息和发出去的消息不一样耶,难道是我们被黑客截取了信息”</p>
<p>亮亮起身拍了拍膝盖上的灰说到:“肯定是呀，不要让我看见他，不然我打得他妈都不认识他”</p>
<p>入夜了,小两口在床上躺着想到今天发生的事儿还是苦笑不得,决定想个办法来解决通信不安全的问题,不然这日子没法过了。</p>
<p>“亮亮，你说咋办呢?你是程序员，你说有什么办法即使是黑客截取到了我们的信息也没有办法知道是什么内容，就跟谍战片里面一样”<br>“可以呀,你发送消息给我的时候用密钥加密，然后我收到消息用同样的算法,同样的密钥解密就行了,这有个专业术语叫做对称加密”<br><img data-src="/images/Https/https_message_2.png"></p>
<p>“听上去不错,可是你这个有问题呀,和你一个人通信这样倒是可以,但是和其他人通信怎么办呢?我和他们怎么协商密钥呢?”<br><img data-src="/images/Https/https_message_3.png"></p>
<p>“没事儿，这难不倒我，我们还可以使用非对称加密算法,它有两个密钥，一个叫公钥，一个叫私钥,公钥加密的数据只能被私钥解密,同样的,私钥加密的数据只能被公钥解密，私钥只能由你持有,公钥就由我持有(可以网络分发),以后你想和我聊天就把密钥用私钥加密,我这边用公钥解密得到密钥，然后我们还像之前讲的那样用密钥加密消息进行通信。别人想和你聊天,你就把公钥给他就行了”<br><img data-src="/images/Https/https_message_4.png"></p>
<p>“为什么我们不直接使用非对称加密算法来通信呢？”</p>
<p>“非对称加密不仅速度慢而且只支持少量数据的加密,说多了你也不懂”</p>
<p>“还存在一个问题耶,这个公钥就这样暴露出去了,黑客就可以将其替换成他的公钥，这样别人给我发送消息就相当于给这个黑客发送消息了”</p>
<p>“这个可以让第三方进行担保,让它给我保证公钥是正确的。这个第三方结构我们称它为CA”<br>“它如何保证呀?”<br>“CA其实也是使用了非对称加密算法，首先使用CA的私钥对我们的公钥加密,然后它会给你返回一个证书,里面包含了加密之后的公钥,然后你本地使用CA公钥解密这个证书就可以获取到我们的公钥了。你老公我是不是很聪明呀？”<br><img data-src="/images/Https/https_message_5.png"><br>“聪明?呵呵。我告诉你你还是太天真了,CA可以给你颁发证书也可以给黑客证书,你如何保证证书没有被掉包,我收到的证书不是黑客所持有的？”<br>亮亮嘀咕到:”一天想东想西的,黑客哪有那么多时间，天天守着你”<br>“你说什么?”<br>“我说,我们可以在本地通过证书的编号来验证证书是否是真实的呀?我们让证书根据一系列信息生成一个消息摘要，然后将这个消息摘要使用CA的密钥加密形成数字签名放到证书里面,然后我们本地根据同样的规则来生成消息摘要,然后将证书中的数字签名解密,它们两个进行两两对比就行呀。”</p>
<blockquote>
<p>一系列代指签发者，证书用途，我们需要传输的公钥,加密算法，HASH算法，到期时间等,对于网站来说还有域名的信息</p>
</blockquote>
<p><img data-src="/images/Https/https_message_6.png"></p>
<p>“听上去不错，可是这一切的前提是CA的公钥可信呀,万一内置在游览器和操作系统的证书不可信了怎么办呢?”<br>“如果这两个都被攻破了,那就万事皆休了,而且世界上哪有绝对的安全呀，你要是在意信息泄露，那你就别上网好了”<br>“算了,还是别想那么多了,睡觉吧，都2点钟,明天我肯定又有黑眼圈了，都怪你。”</p>
<blockquote>
<p>NetScape相继开发了SSL1.0,SSL2.0,SSL3.0，由ISOC组织接手后，发布了TLS 1.0(和SSL3.0几乎没有差异,可以向下降级),TLS1.0也被称为SSL3.1,然后经过TLS1.1,TLS1.2,现在最新的是TLS1.3。大部分游览器基本都支持TLS1.2。<br>我们访问网络常用的协议是HTTP协议,但是它的通信过程并不安全,很容易被拦截,监听，篡改。而SSL/TLS可以保证信息安全,所以它们合并在一起就组成了我们今天要说的主角HTTPS(HTTPS=HTTP &gt;+ SSL/TLS)。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Https,Http</tag>
      </tags>
  </entry>
  <entry>
    <title>老大喊我用AOP记录下日志</title>
    <url>/2019/08/22/use-aop-record-log/</url>
    <content><![CDATA[<p>老大喊我记录下API的操作日志,免得前端甩锅,主要记录新增,修改,删除等操作。我想了下就决定用AOP来实现这个功能。</p>
<p>由于使用的是SpringBoot，所以首先应该在依赖中引入AOP包。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一般引入了AOP之后，一般不用做其他特殊配置,也不用加上@EnableAspectJAutoProxy注解。但是它仍有两个属性需要我们注意</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 相当于@EnableAspectJAutoProxy</span><br><span class="line">spring.aop.auto&#x3D;true</span><br><span class="line"></span><br><span class="line"># 默认使用jdk来实现AOP,如果想要使用CGLIB的话，这里要改成true</span><br><span class="line">spring.aop.proxy-target-class&#x3D;false</span><br></pre></td></tr></table></figure>

<h3 id="实现日志记录功能"><a href="#实现日志记录功能" class="headerlink" title="实现日志记录功能"></a>实现日志记录功能</h3><p>我想要记录某个API对模块进行了什么操作，操作的key,对于修改，删除来说我们记录id,对于新增来说，最开始没有id,我们记录name即可(也可以是其他属性),所以OpLog注解是这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OpLog &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模块</span></span><br><span class="line">  <span class="function">String <span class="title">module</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 类型</span></span><br><span class="line">  <span class="function">String <span class="title">opType</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 级别，默认一般</span></span><br><span class="line">  <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> OpLevel.COMMON</span>;</span><br><span class="line">  <span class="comment">// 需要记录的key</span></span><br><span class="line">  <span class="function">String <span class="title">key</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让这个功能更加易用,所以我要求其他开发者必须在Controller上加上注解@OpLog,为什么是Controller呢?因为API是在Controller上,我并不关心具体业务，我只要记录对应的操作即可。在Controller层你只需要这要做就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CpGroupController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意这里的userParam和@RequestBody的userParam名字必需要要一致</span></span><br><span class="line">  <span class="meta">@OpLog(module = &quot;用户管理&quot;, opType = &quot;新增&quot;, key = &quot;userParam.name&quot;)</span></span><br><span class="line">  <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BaseResponse&lt;Boolean&gt; <span class="title">add</span><span class="params">(<span class="meta">@RequestBody</span> UserParam userParam)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> ResponseUtil.success(userService.add(userParam));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是切面代码的编写了，其中我们要记录访问的url以及必要的操作信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpLogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> OperateLogService operateLogService;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> paramNameIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> propertyIndexFrom = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Pointcut(&quot;execution(public * com.generalthink.springboot.web.controller..*.*(..))&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">webLogPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Around(value = &quot;webLogPointcut() &amp;&amp; @annotation(opLog)&quot;, argNames = &quot;joinPoint,opLog&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint, OpLog opLog)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object objReturn = joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        OperateLog operationLog = generateOperateLog(joinPoint, opLog);</span><br><span class="line"></span><br><span class="line">        operateLogService.save(operationLog);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;operateLog record error&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> objReturn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> OperateLog <span class="title">generateOperateLog</span><span class="params">(ProceedingJoinPoint joinPoint, OpLog opLog)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String requestUrl = extractRequestUrl();</span><br><span class="line"></span><br><span class="line">    Object recordKey = getOpLogRecordKey(joinPoint, opLog);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OperateLog.builder()</span><br><span class="line">            .<span class="keyword">module</span>(opLog.<span class="keyword">module</span>())</span><br><span class="line">            .opType(opLog.opType())</span><br><span class="line">            .level(opLog.level())</span><br><span class="line">            .operateTimeUnix(CommonUtils.getNowTimeUnix())</span><br><span class="line">            .recordKey(recordKey != <span class="keyword">null</span> ? recordKey.toString() : <span class="keyword">null</span>)</span><br><span class="line">            .url(requestUrl)</span><br><span class="line">            .operator(getCurrentUser())</span><br><span class="line">            .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前用户</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getCurrentUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Subject subject = SecurityUtils.getSubject();</span><br><span class="line">    <span class="keyword">return</span> (String) subject.getPrincipal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取想要记录的key</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">getOpLogRecordKey</span><span class="params">(ProceedingJoinPoint joinPoint, OpLog opLog)</span> </span>&#123;</span><br><span class="line">    String key = opLog.key();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] keys = key.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入参  value</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line"></span><br><span class="line">    CodeSignature codeSignature = (CodeSignature) joinPoint.getSignature();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Controller方法上的参数名称</span></span><br><span class="line">    String[] paramNames = codeSignature.getParameterNames();</span><br><span class="line"></span><br><span class="line">    Object paramArg = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paramNames.length; i++) &#123;</span><br><span class="line">        String paramName = paramNames[i];</span><br><span class="line">        <span class="keyword">if</span> (paramName.equals(keys[paramNameIndex])) &#123;</span><br><span class="line">            paramArg = args[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(keys.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> paramArg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取参数的值</span></span><br><span class="line">    Object paramValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != paramArg) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            paramValue = getParamValue(paramArg, keys, propertyIndexFrom);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;parse field error&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> paramValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getParamValue</span><span class="params">(Object param, String[] keys, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">    Optional&lt;Field&gt; fieldOptional = getAllFields(<span class="keyword">new</span> ArrayList&lt;&gt;(), param.getClass())</span><br><span class="line">            .stream()</span><br><span class="line">            .filter(field -&gt; field.getName().equalsIgnoreCase(keys[idx]))</span><br><span class="line">            .findFirst();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!fieldOptional.isPresent()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置属性可访问,因为bean当中属性一般都是private</span></span><br><span class="line">    Field field = fieldOptional.get();</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(idx + <span class="number">1</span> == keys.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> field.get(param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getParamValue(field.get(param), keys, idx + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归获取所有Field</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Field&gt; <span class="title">getAllFields</span><span class="params">(List&lt;Field&gt; fieldList, Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前类的所有Field</span></span><br><span class="line">    fieldList.addAll(Arrays.asList(type.getDeclaredFields()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取父类的所有Field</span></span><br><span class="line">    Class&lt;?&gt; superClass = type.getSuperclass();</span><br><span class="line">    <span class="keyword">if</span>(superClass != <span class="keyword">null</span> &amp;&amp; superClass != Object.class) &#123;</span><br><span class="line">        getAllFields(fieldList,superClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fieldList;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取访问URL</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">extractRequestUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder</span><br><span class="line">            .getRequestAttributes();</span><br><span class="line">    HttpServletRequest request = attributes.getRequest();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> request.getRequestURL().toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主要就是记录了操作了什么模块,操作内容等等,对于修改和删除操作我们可以记录id,但是对于save操作,我们没有办法记录id,只能记录其他属性,比如说name,就可以记录保存的数据了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: &quot;zhangsan&quot;,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于上面的数据就会把”zhangsan”这个值保存下来,后面就可以通过查询日志表知道是谁操作的,修改和删除也是同样的.</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>AOP</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>在git-ops中使用git-crypt保护敏感数据</title>
    <url>/2020/03/01/use-git-crypt/</url>
    <content><![CDATA[<h3 id="为什么要避免将敏感信息存储在git中？"><a href="#为什么要避免将敏感信息存储在git中？" class="headerlink" title="为什么要避免将敏感信息存储在git中？"></a>为什么要避免将敏感信息存储在git中？</h3><p>不要在git仓库中存储任何敏感信息，并且要不惜一切代价这样做，即使仓库是私有的，也不应该将其视为存储敏感信息的安全场所，首先让我们了解为什么它存储敏感信息不安全。</p>
<p>git上如果你将你的仓库声明为public的,那么任何一个人都可以访问你仓库的内容，不仅如此，还可以游览仓库中的所有代码，甚至可以运行它。如果你将你的API秘钥存储在仓库中，那么任何人都可以拿到。</p>
<p>即使是存储在私有仓库，也会面临风险。当你与第三方程序集成的时候，你可能正在向第三方应用打开私有仓库。这些应用程序时可以访问你的私有仓库并阅读其中包含的信息。攻击者就有可能伪装成这些第三方应用来获取你的机密数据(API key,数据库密码等等)。</p>
<a id="more"></a>

<h3 id="使用git-crypt来加密你的敏感数据"><a href="#使用git-crypt来加密你的敏感数据" class="headerlink" title="使用git-crypt来加密你的敏感数据"></a>使用git-crypt来加密你的敏感数据</h3><p>git-crypt(<a href="https://github.com/AGWA/git-crypt)%E5%8F%AF%E4%BB%A5%E5%9C%A8git%E4%BB%93%E5%BA%93%E4%B8%AD%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E9%80%8F%E6%98%8E%E7%9A%84%E5%8A%A0%E8%A7%A3%E5%AF%86%E3%80%82%E4%BD%A0%E9%80%89%E6%8B%A9%E4%BF%9D%E6%8A%A4%E7%9A%84%E6%96%87%E4%BB%B6%E5%9C%A8%E6%8F%90%E4%BA%A4%E6%97%B6%E4%BC%9A%E5%8A%A0%E5%AF%86%EF%BC%8C%E8%80%8C%E5%9C%A8%E6%A3%80%E5%87%BA%E6%97%B6%E4%BC%9A%E8%A7%A3%E5%AF%86%E3%80%82git-crypt%E4%BD%BF%E5%BC%80%E5%8F%91%E8%80%85%E5%8F%AF%E4%BB%A5%E8%87%AA%E7%94%B1%E5%85%B1%E4%BA%AB%E5%8C%85%E5%90%AB%E5%85%AC%E5%85%B1%E5%92%8C%E7%A7%81%E6%9C%89%E5%86%85%E5%AE%B9%E6%B7%B7%E5%90%88%E7%9A%84%E5%AD%98%E5%82%A8%E5%BA%93%E3%80%82">https://github.com/AGWA/git-crypt)可以在git仓库中对数据进行透明的加解密。你选择保护的文件在提交时会加密，而在检出时会解密。git-crypt使开发者可以自由共享包含公共和私有内容混合的存储库。</a><br>git-crypt会正常降级，因此没有密钥的开发人员仍然可以克隆并提交到包含加密文件的存储库。这样一来，就可以将机密资料（例如密钥或密码）与代码存储在同一存储库中，而无需锁定整个仓库。</p>
<p>接下来我会演示如下如何使用git-crypt保护我的重要数据。</p>
<h4 id="安装git-crypt"><a href="#安装git-crypt" class="headerlink" title="安装git-crypt"></a>安装git-crypt</h4><p>mac和linux上安装git-crypt都比较简单，windows上比较麻烦，不过有人已经把安装包搞定了，大家可以去这里<a href="https://gitee.com/pharaoh/git-crypt-win">下载 </a>,当然我后面的仓库中也有。下载下来的是一个exe文件，放到环境变量中即可。</p>
<h4 id="首先clone一个需要使用git-crypt的仓库-我的仓库中有2个文件-其中secret-properties是存放敏感数据的文件"><a href="#首先clone一个需要使用git-crypt的仓库-我的仓库中有2个文件-其中secret-properties是存放敏感数据的文件" class="headerlink" title="首先clone一个需要使用git-crypt的仓库,我的仓库中有2个文件,其中secret.properties是存放敏感数据的文件"></a>首先clone一个需要使用git-crypt的仓库,我的仓库中有2个文件,其中secret.properties是存放敏感数据的文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">|-- DbInfo</span><br><span class="line">|   &#96;-- secret.properties</span><br><span class="line">&#96;-- index.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>仓库地址是: <a href="https://github.com/generalthink/git-crypt-test">https://github.com/generalthink/git-crypt-test</a></p>
<p>DbInfo目录中secret.properties内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat DbInfo&#x2F;secret.properties</span><br><span class="line">mysql.ip&#x3D;locahost</span><br><span class="line">mysql.port&#x3D;3306</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="然后初始化你的存储库以便于使用git-crypt-它将生成一个密钥并使得当前的Git存储库可以使用git-crypt"><a href="#然后初始化你的存储库以便于使用git-crypt-它将生成一个密钥并使得当前的Git存储库可以使用git-crypt" class="headerlink" title="然后初始化你的存储库以便于使用git-crypt,它将生成一个密钥并使得当前的Git存储库可以使用git-crypt"></a>然后初始化你的存储库以便于使用git-crypt,它将生成一个密钥并使得当前的Git存储库可以使用git-crypt</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git-crypt init</span><br></pre></td></tr></table></figure>
<h4 id="检查文件状态"><a href="#检查文件状态" class="headerlink" title="检查文件状态"></a>检查文件状态</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git-crypt status</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/git-crypt/status.png" alt="查看状态"></p>
<p>你可以看到所有的文件都没有被加密</p>
<h4 id="通过创建gitattributes文件来指定要“加密”的文件。你要为每个要加密的文件分配“-filter-git-crypt-diff-git-crypt”属性"><a href="#通过创建gitattributes文件来指定要“加密”的文件。你要为每个要加密的文件分配“-filter-git-crypt-diff-git-crypt”属性" class="headerlink" title="通过创建gitattributes文件来指定要“加密”的文件。你要为每个要加密的文件分配“ filter = git-crypt diff = git-crypt”属性"></a>通过创建gitattributes文件来指定要“加密”的文件。你要为每个要加密的文件分配“ filter = git-crypt diff = git-crypt”属性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;file-name-to-encrypt&gt; filter&#x3D;git-crypt diff&#x3D;git-crypt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，在执行第5步(即将.gitattributes添加到您的存储库)之前，请确保将“敏感文件”移出存储库并提交更改，然后添加.gitattributes文件，然后将“敏感文件”移回存储库。<br>就像下图这样，首先将敏感文件（在mycase中为secret.properties）移出存储库并提交更改，然后在仓库的根目录中添加.gitattributes，然后将我的“ secret.properties”文件再次添加至仓库。不然,你会收到git抛出的警告错误。</p>
</blockquote>
<p><img data-src="/images/git-crypt/encrypted.png" alt="加密"></p>
<p><strong>经过上面的步骤之后你的secret.properties已经被加密了,当然在你本地的git仓库你看到的是解密后的数据。 将它推送到git仓库就可以看到这是加密的数据了</strong></p>
<p><img data-src="/images/git-crypt/secret-in-github.png" alt="github上的显示"></p>
<h4 id="导出秘钥和你的协作者共享"><a href="#导出秘钥和你的协作者共享" class="headerlink" title="导出秘钥和你的协作者共享"></a>导出秘钥和你的协作者共享</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git-crypt export-key &lt;key-to-unlock&gt;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/git-crypt/export-key.png" alt="导出秘钥"></p>
<p>通过上面的命令，你就可以看到会生成一个git-crypt.key文件，将这个文件分发给你的协作者，当他们checkout这个仓库之后就可以用这个秘钥解密了。</p>
<blockquote>
<p>别忘了在gitingore文件中忽略 git-crypt.key,以防止意外地将此文件提交到git repo。同时，从这里开始，无论克隆存储库的人是什么，除非他们有解锁它的钥匙，否则他们将无法看到“secret.properties”文件的内容！</p>
</blockquote>
<h3 id="如何解密仓库中的加密文件"><a href="#如何解密仓库中的加密文件" class="headerlink" title="如何解密仓库中的加密文件"></a>如何解密仓库中的加密文件</h3><p>现在，如果你尝试克隆仓库，将无法在仓库中看到加密文件。就像我克隆了测试仓库(我在我本地电脑的另一个目录中clone的)并尝试打开“ secret.properties（加密文件）”一样，这就是我所看到的！</p>
<p><img data-src="/images/git-crypt/after-encryption.png" alt="加密后"></p>
<p>你还记得吗？解密前我们是可以看到真正内容的。</p>
<p>现在要解密此文件,你必须具有密钥！请要求管理员为你提供密钥。之后，你必须跳入克隆的仓库中执行下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git-crypt unlock &#x2F;path&#x2F;to&#x2F;key</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/git-crypt/unlock.png" alt="解密"></p>
<h3 id="多说两句"><a href="#多说两句" class="headerlink" title="多说两句"></a>多说两句</h3><p>看到这里可能有人会有疑问,开发的时候好使了，那打包的时候咋整呢？这个加密了，在服务器打包之后肯定跑不起来呀,其实解决办法很简单,只需要在打包之前解密就行了。</p>
<p>当然了关于对配置文件加密的方法，还是有很多种的，比如sealed-secrets或者公司内部的加解密服务。</p>
<p>为了便于大家测试我会在将我生成的key提交到git仓库中。</p>
]]></content>
      <tags>
        <tag>git-crypt</tag>
      </tags>
  </entry>
  <entry>
    <title>拥抱Kubernetes,再见了,SpringBoot cronjob</title>
    <url>/2020/10/27/use-kubernetes-cron-job/</url>
    <content><![CDATA[<p>项目开发中总是需要执行一些定时任务，比如定时处理数据之后发送邮件，定时更新缓存等等。</p>
<h3 id="Java定时任务"><a href="#Java定时任务" class="headerlink" title="Java定时任务"></a>Java定时任务</h3><ol>
<li>基于 java.util.Timer 定时器，实现类似闹钟的定时任务</li>
<li>使用 Quartz、elastic-job、xxl-job 等开源第三方定时任务框架，适合分布式项目应用</li>
<li>使用 Spring 提供的一个注解： @Scheduled</li>
</ol>
<p>项目框架使用的是SpringBoot,所以之前定时任务使用的是SpringBoot中的@Scheduled。可是这种方式并不适合我们现在的cloud环境，为了更加cloud native一点,我删除了使用SpringBoot写的37个定时任务，改为使用Kubernetes cronjob的方式。</p>
<a id="more"></a>

<h3 id="定时任务代码编写"><a href="#定时任务代码编写" class="headerlink" title="定时任务代码编写"></a>定时任务代码编写</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遵循Unix约定，如果命令执行正常，则返回0；否则为非0。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">(String... args)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先定义一个接口，所有具体的定时任务都必须实现该接口。接下来是具体的某一个定时任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProjectCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Map&lt;String, Command&gt; commandMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> SendEmailCommand sendEmailCommand;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    commandMap.put(<span class="string">&quot;sendEmail&quot;</span>, sendEmailCommand);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!commandMap.containsKey(args[<span class="number">0</span>])) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;&#x27;&#123;&#125;&#x27; command not found&quot;</span>, args[<span class="number">0</span>]);</span><br><span class="line">        System.exit(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Command command = commandMap.get(args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    String[] arguments = Arrays.copyOfRange(args, <span class="number">1</span>, args.length);</span><br><span class="line"></span><br><span class="line">    System.exit(command.execute(arguments));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendEmailCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">execute</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 省略业务逻辑代码</span></span><br><span class="line"></span><br><span class="line">      log.info(<span class="string">&quot;send email success&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      log.error(<span class="string">&quot;send email error&quot;</span>, e);</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码我们采用了策略模式，后面即使新增其他定时任务也只是会改动很少的代码。</p>
<h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><p>cronjob不用打包成单独的镜像，它直接和我们的web应用公用同一个镜像,本地调试的时候也是极为方便的,只需要我们启动SpringBoot Application时指定参数即可</p>
<p><img data-src="/images/java/debug-cronjob-in-idea.png" alt="调试定时任务"></p>
<p>对应的定时任务执行完成之后就会，application就会退出。</p>
<h3 id="cronjob-yaml"><a href="#cronjob-yaml" class="headerlink" title="cronjob yaml"></a>cronjob yaml</h3><p>一个基本的cronjob yaml如下所示</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">send-email-job</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">failedJobsHistoryLimit:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">successfulJobsHistoryLimit:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">startingDeadlineSeconds:</span> <span class="number">180</span></span><br><span class="line">  <span class="attr">concurrencyPolicy:</span> <span class="string">Forbid</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;0 4 * * 1-5&quot;</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">send-email-job</span></span><br><span class="line">              <span class="attr">image:</span> <span class="string">harbor.xxx.com/think123/project</span></span><br><span class="line">              <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">              <span class="attr">command:</span> [<span class="string">&quot;java&quot;</span>]</span><br><span class="line">              <span class="attr">args:</span> [<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app/target/think123-task.jar&quot;</span>,<span class="string">&quot;sendEmail&quot;</span>]</span><br><span class="line">              <span class="attr">envFrom:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">configMapRef:</span></span><br><span class="line">                    <span class="attr">name:</span> <span class="string">smcp-config</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">secretRef:</span></span><br><span class="line">                    <span class="attr">name:</span> <span class="string">smcp-service-secret</span></span><br><span class="line">              <span class="attr">resources:</span></span><br><span class="line">                <span class="attr">requests:</span></span><br><span class="line">                  <span class="attr">cpu:</span> <span class="string">&quot;250m&quot;</span></span><br><span class="line">                  <span class="attr">memory:</span> <span class="string">1024Mi</span></span><br><span class="line">                <span class="attr">limits:</span></span><br><span class="line">                  <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">                  <span class="attr">memory:</span> <span class="string">1024Mi</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在定时任务中,可能某个job还没有执行完，另外一个job就产生了。这个时候我们可以通过spec.concurrencyPolicy字段来定义具体的处理策略。</p>
<ol>
<li>concurrencyPolicy=Allow，这也是默认情况，这意味着这些Job可以同时存在；</li>
<li>concurrencyPolicy=Forbid，这意味着不会创建新的Pod，该创建周期被跳过；</li>
<li>concurrencyPolicy=Replace，这意味着新产生的Job会替换旧的、没有执行完的Job</li>
</ol>
<p>几个关键参数解释如下:</p>
<ol>
<li>schedule : Unix Cron格式的表达式，cron表达式中的五个部分分别代表：分钟、小时、日、月、星期。</li>
<li>startingDeadlineSeconds ： 表示在过去的多少秒(这里设置的180)里，如果job创建失败的数据达到了100次，那么这个job就不会被创建执行了。</li>
<li>restartPolicy: 重启策略(有Never和OnFailure两个选项)。当job正常结束之后是否需要重启<blockquote>
<p>restartPolicy在Job对象里只允许被设置为Never和OnFailure；而在Deployment对象里，restartPolicy则只允许被设置为Always。</p>
</blockquote>
</li>
</ol>
<p>实际上在<code>jobTemplate.spec.template</code>中可以像pod中那样，指定volume,指定nodeSelector，都是可以的。这个template实际上就是指的pod的template</p>
<h3 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h3><p>上面的yaml虽然可以直接使用，但是我们用不着每个job都去写一份同样的模板，实际中我们会使用Kustomize控制模板来生成job。比如我们有一个新的任务，是计算热点文章并更新redis</p>
<p>对于这个任务而言，变化的主要有两个地方，第一个是定时任务的时间不同，第二个是指定的参数不同。所以我们的每个任务只需要更新这两个参数就行了</p>
<p>关于kustomize的使用可以参考我之前<a href="https://juejin.im/post/6844904039017086990">的kustomize的介绍</a>,打包的话可以看看<a href="https://juejin.im/post/6844903981966360583">springboot build的文章</a></p>
<p>对于模板设定，我们形成了下面的目录结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">|-- base</span><br><span class="line">|   |-- cronjob.yaml</span><br><span class="line">|   &#96;-- kustomization.yaml</span><br><span class="line">&#96;-- overlay</span><br><span class="line">    &#96;-- beta</span><br><span class="line">        |-- kustomization.yaml</span><br><span class="line">        &#96;-- send-email-patch-args.yaml</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cronjob.yaml作为所有job的模板,而send-emial-patch-args.yaml则是针对具体的job的一个替换。涉及到的yaml文件内容如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># base/kustomization.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kustomize.config.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Kustomization</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">cronjob.yaml</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># base/cronjob.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">think123-</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">failedJobsHistoryLimit:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">successfulJobsHistoryLimit:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">startingDeadlineSeconds:</span> <span class="number">180</span></span><br><span class="line">  <span class="attr">concurrencyPolicy:</span> <span class="string">Forbid</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;0 0 1 * *&quot;</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cron-job</span></span><br><span class="line">              <span class="attr">image:</span> <span class="string">harbor.xxx.com/think123/my-task</span></span><br><span class="line">              <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">              <span class="attr">args:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">&quot;help&quot;</span></span><br><span class="line">              <span class="attr">envFrom:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">configMapRef:</span></span><br><span class="line">                    <span class="attr">name:</span> <span class="string">smcp-config</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">secretRef:</span></span><br><span class="line">                    <span class="attr">name:</span> <span class="string">smcp-service-secret</span></span><br><span class="line">              <span class="attr">resources:</span></span><br><span class="line">                <span class="attr">requests:</span></span><br><span class="line">                  <span class="attr">cpu:</span> <span class="string">&quot;250m&quot;</span></span><br><span class="line">                  <span class="attr">memory:</span> <span class="string">1024Mi</span></span><br><span class="line">                <span class="attr">limits:</span></span><br><span class="line">                  <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">                  <span class="attr">memory:</span> <span class="string">1024Mi</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># overlay/beta/kustomization.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kustomize.config.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Kustomization</span></span><br><span class="line"></span><br><span class="line"><span class="attr">nameSuffix:</span> <span class="string">send-email-job</span></span><br><span class="line"></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">../../base/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">patchesStrategicMerge:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">send-email-patch-args.yaml</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># overlay/beta/send-email-patch-args.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">think123-</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;0 4 * * 1-5&quot;</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">send-email-job</span></span><br><span class="line">              <span class="attr">args:</span> [<span class="string">&quot;sendEmail&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你可以使用<code>kustomize build beta &gt; send-email-cron-job.yaml</code>命令,然后查看send-email-cron-job.yaml文件，就可以看到生成的具体的cronjob的详细。</p>
<p>kustomize的文档可以参考: <a href="https://kubernetes-sigs.github.io/kustomize/api-reference/">https://kubernetes-sigs.github.io/kustomize/api-reference/</a></p>
<h3 id="为什么要用Kubernetes-Cron-Job"><a href="#为什么要用Kubernetes-Cron-Job" class="headerlink" title="为什么要用Kubernetes Cron Job"></a>为什么要用Kubernetes Cron Job</h3><p>使用SpringBoot的定时任务不香吗？为什么要还要引入新的东西。再想这个问题的时候，想想为什么你在SpringBoot中不写Servlet,不是一样可以吗？</p>
<p>其实想想还是有原因的，首先我们的服务是分布式的，我们的定时任务应该只需要运行一次，而不是每个实例都运行一次，如果用SpringBoot的task那么我们需要用代码来保证这个行为。</p>
<p>如果引入分布式任务框架，又是引入了一堆其他新的东西，比如注册中心等等，而且还要去学习一项新的技术。</p>
<p>而我们的服务由于是通过Kubernetes部署的，我们的job再使用Kubernetes来，更是相得益彰。</p>
]]></content>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>使用kustomize来管理Kubernetes yaml应用</title>
    <url>/2020/01/03/use-kustomize/</url>
    <content><![CDATA[<p>Kustomize是为了解决k8s yaml应用管理问题而生的一个工具，在1.14版本之后kubectl就集成了kustomize,而在这之前，我们则只能自己安装。<br>可以在github上下载对应操作系统的包进行安装(<a href="https://github.com/kubernetes-sigs/kustomize/releases)%E3%80%82">https://github.com/kubernetes-sigs/kustomize/releases)。</a></p>
<p>windows下它就是一个exe文件，我们把它放到某一个目录后,加入环境变量，即可在命令行中进行使用了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kustomize version</span><br><span class="line">&#123;Version:kustomize&#x2F;v3.5.2 GitCommit:79a891f4881cfc780e77789a1d240d8f4bfa2598 BuildDate:2019-12-17T03:48:17Z GoOs:windows GoArch:amd64&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>好了，重新回到k8s,当我们部署的时候，是不是会使用很多kubernetes 对象来描述我们的服务。比如deployment,ingress,service,configMap,secret等等。这些我们都是使用yaml文件来进行配置的。比如一个典型的deployment.yaml文件长这样子</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">smcp-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">smcp-dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">smcp-service</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">smcp-service</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">smcp-service</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">harbor.xxx.com/example/smcp-web:1.0</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/api/anon/health</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">80</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">20</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/api/anon/health</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">90</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9000</span></span><br><span class="line">          <span class="attr">envFrom:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">configMapRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">smcp-config</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">secretRef:</span></span><br><span class="line">                <span class="attr">name:</span> <span class="string">smcp-service-secret</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比如上面这个springboot应用,我们部署到dev环境，可以看到namespace是smcp-dev,但是当我们部署到其他环境,比如beta,staging,production环境，意味着我们要把上面所说的这些文件都抄一遍，然后修改其中的微小变量(namespace,replica,image等)。</p>
<p>而且当我们环境变量的内容如果被更新了，这个deployment也不会滚动更新,因为它们的name没有变化(smcp-config,smcp-service-secret)。</p>
<blockquote>
<p>我们将application.properties文件的内容通过configMap放到环境变量中了。</p>
</blockquote>
<p>而kustomize应运而生，它可以解决我们的问题。它将公共的部分提出来作为base,即基础层,然后在overlays上对base中的内容进行覆盖,有点类似docker image layer的概念。而base对overlays是无感知的。最终形成的目录结构是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">|-- base</span><br><span class="line">|   |-- deployment.yaml</span><br><span class="line">|   |-- ingress.yaml</span><br><span class="line">|   |-- kustomization.yaml</span><br><span class="line">|   &#96;-- service.yaml</span><br><span class="line">&#96;-- overlays</span><br><span class="line">    |-- devlopment</span><br><span class="line">    |   |-- cert</span><br><span class="line">    |   |   |-- tls.crt</span><br><span class="line">    |   |   &#96;-- tls.key</span><br><span class="line">    |   |-- config.properties</span><br><span class="line">    |   |-- ingress-patch.yaml</span><br><span class="line">    |   |-- kustomization.yaml</span><br><span class="line">    |   &#96;-- secret.properties</span><br><span class="line">    &#96;-- production</span><br><span class="line">        |-- cert</span><br><span class="line">        |   |-- tls.crt</span><br><span class="line">        |   &#96;-- tls.key</span><br><span class="line">        |-- config.properties</span><br><span class="line">        |-- ingress-patch.yaml</span><br><span class="line">        |-- kustomization.yaml</span><br><span class="line">        &#96;-- secret.properties</span><br><span class="line"></span><br><span class="line">6 directories, 16 files</span><br></pre></td></tr></table></figure>
<p>而base/kustomization.yaml文件中只是引入了其他几个文件,它的yaml文件内容如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">deployment.yaml</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">ingress.yaml</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">service.yaml</span></span><br></pre></td></tr></table></figure>

<p>base中比如ingress.yaml或者service.yaml文件只是定义了deployment对象以及service对象，对于某些需要根据不同的环境来设定的参数，比如namespace,replicas等，你可以先设置一个默认值，然后在overlays中修改就行了。</p>
<blockquote>
<p>kustomize create可以生成kustomization.yaml文件</p>
</blockquote>
<p>而在overlays可以看到我们在overlays文件夹下放置了两个环境的配置,分别存储的是这两个环境中独有的配置(config.properties,secret.properteis),而kustomizatiion.yaml文件中这是我们对模板文件(base)内容的一些修改,我们来看看development环境下的配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">../../base</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置namespace</span></span><br><span class="line"><span class="attr">namespace:</span> <span class="string">smcp-example-dev</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">replicas:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">smcp-service</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置configMap</span></span><br><span class="line"><span class="attr">configMapGenerator:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">smcp-config</span></span><br><span class="line">  <span class="attr">files:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">config.properties</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置secret</span></span><br><span class="line"><span class="attr">secretGenerator:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">smcp-service-secret</span></span><br><span class="line">  <span class="attr">envs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">secret.properties</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">smcp-service-cert</span></span><br><span class="line">  <span class="attr">files:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cert/tls.crt</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cert/tls.key</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">kubernetes.io/tls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的group/version的值等于ingress.yaml文件中apiVersion的值</span></span><br><span class="line"><span class="attr">patchesJson6902:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">target:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">extensions</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1beta1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">smcp-service-ingress</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">ingress-patch.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置镜像版本</span></span><br><span class="line"><span class="attr">images:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">harbor.xxx.com/example/smcp-web</span></span><br><span class="line">  <span class="attr">newTag:</span> <span class="number">0.10</span><span class="number">.0</span><span class="string">-test</span></span><br></pre></td></tr></table></figure>

<p>而ingress-patch.yaml文件中内容如下,实际上是修改ingress中关于域名的配置,将原有的域名修改为​dev环境特有的。​</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">op:</span> <span class="string">replace</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/spec/tls/0/hosts/0</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">test.example.com</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">op:</span> <span class="string">replace</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/spec/rules/0/host</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">test.example.com</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>kustomize的文档地址: <a href="https://github.com/kubernetes-sigs/kustomize/tree/master/docs">https://github.com/kubernetes-sigs/kustomize/tree/master/docs</a></p>
</blockquote>
<p>最后当我们执行<code>kustomize build overlays/devlopment</code>的时候新生成的api对象(deployment,ingress等),就会按照我们设置的那样将模板中的值进行替换。</p>
<p>新生成的Deployment对象如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">smcp-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">smcp-example-dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">smcp-service</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">smcp-service</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">envFrom:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">configMapRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">smcp-config-f5thmfmkb6</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">secretRef:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">smcp-service-secret-66m2658btb</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">harbor.xxx.com/example/smcp-web:0.10.0-test</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/api/anon/health</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">20</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">smcp-service</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9000</span></span><br><span class="line">        <span class="attr">readinessProbe:</span></span><br><span class="line">          <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/api/anon/health</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">90</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>可以看到相比较于base中的deployment.yaml,<br>replicas变成了2,namespace变成了smcp-example-dev,configMap和secret的生成规则这是<code>$&#123;name&#125;-hash</code>,一切都是按照kustomization.yaml文件的配置来进行修改的。</p>
<p>而且现在只要我们更新了configMap和secret,也就能触发滚动更新了(<strong>deployment中只有spec.spec中的内容更新了才会触发滚动更新</strong>)。</p>
<blockquote>
<p>可以配合kubectl命令使用: kustomize build overlays/devlopment | kubectl apply -f -</p>
</blockquote>
<p>至此，我们就完成了kustomization的使用了，有了它，我们可以很快部署一套系统到其他环境，同时修改基础配置，也只用修改一次，而不是在不同的环境都需要修改了。</p>
]]></content>
      <tags>
        <tag>Kubernetes</tag>
        <tag>Kustomize</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中如何为HTTP请求设置代理?</title>
    <url>/2020/02/20/use-proxy-in-java/</url>
    <content><![CDATA[<h3 id="什么是代理服务器"><a href="#什么是代理服务器" class="headerlink" title="什么是代理服务器"></a>什么是代理服务器</h3><p>代理服务器充当你和Internet之间的网关，就像一个中间人。它实际上是一个中间服务器，可以将用户与它们游览的网站区分开。</p>
<p>如果你使用了代理服务器，那么网络流量会通过代理服务器流向你请求的地址。然后该请求通过同一台代理服务器返回,然后代理服务器将从网站接收到的数据转发给你。</p>
<p>当然如果仅仅是这样，也没什么必要使用代理服务器，我们直接访问网站岂不更美？</p>
<p>现在代理服务器的功能远不只是转发Web请求，而这一切都是为了保证数据安全和网络性能。代理服务器充当防火墙和Web筛选器，提供共享的网络连接，并缓存数据以加快常见请求的速度。<br>而且还可以保护用户和内部网络以免收到外部Internet的不良影响。</p>
<a id="more"></a>

<h3 id="Java如何使用代理服务器"><a href="#Java如何使用代理服务器" class="headerlink" title="Java如何使用代理服务器"></a>Java如何使用代理服务器</h3><p>java 有两种方式可以设置代理服务器</p>
<h4 id="如何设置"><a href="#如何设置" class="headerlink" title="如何设置"></a>如何设置</h4><ol>
<li>通过命令行选项进行设置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -Dhttp.proxyHost&#x3D;webcache.example.com -Dhttp.proxyPort&#x3D;8080 -Dhttp.nonProxyHosts&#x3D;&quot;localhost|host.example.com&quot; test.jar </span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>所有http连接都将通过webcache.example.com上的代理服务器在端口8080上监听(如果不指定端口默认是80),此外，连接到localhost或host.example.com时将不使用代理。</p>
<ol start="2">
<li>通过System.setProperty(String，String)方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置代理</span></span><br><span class="line">System.setProperty(<span class="string">&quot;http.proxyHost&quot;</span>, <span class="string">&quot;webcache.example.com&quot;</span>);</span><br><span class="line">System.setProperty(<span class="string">&quot;http.proxyPort&quot;</span>, <span class="string">&quot;8080&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一个连接将会使用代理</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://java.example.org/&quot;</span>);</span><br><span class="line">InputStream in = url.openStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除代理</span></span><br><span class="line">System.clearProperty(<span class="string">&quot;http.proxyHost&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从现在开始，http连接将直接完成而不再使用代理</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ol>
<li>http.proxyHost : 代理服务器主机名</li>
<li>http.proxyPort : 端口号,默认是80</li>
<li>https.proxyHost : https代理服务器主机名</li>
<li>https.proxyPort: 代理端口号,默认是443</li>
<li>http.nonProxyHosts : 指定绕过代理的主机列表，使用 | 分割的模式列表,可以以通配符 * 开头或者结尾,任何匹配这些模式之一的主机都将通过直接连接而不是通过代理访问。该设置对http,https通用</li>
</ol>
<blockquote>
<p>其他比如ftp,socket等设置可以参考官方文档: <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/net/proxies.html">https://docs.oracle.com/javase/8/docs/technotes/guides/net/proxies.html</a></p>
</blockquote>
<h3 id="使用代理服务器"><a href="#使用代理服务器" class="headerlink" title="使用代理服务器"></a>使用代理服务器</h3><p>我刚才有讲过,一般情况只是只是转发请求，我们是用不到代理服务器的，但是刚好我遇到了不一般的情况。<br>我们的服务部署在Kubernetes中,但是有些请求需要走内网访问内部服务,有些请求需要走外网下载文件。而且不能同时给它设置内网ip和public ip(同时设置,访问其他服务时，其他服务会认为是外网在访问)。</p>
<p>因此解决方案是将我们的服务部署在拥有内网访问的worker中,而将代理服务器部署在具有public ip的worker中,当某些访问需要访问外网的时候,走代理服务器即可。<br>代理服务器我们选择了squid这个老牌产品。</p>
<h4 id="squid"><a href="#squid" class="headerlink" title="squid"></a>squid</h4><p>首先部署squid的service</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">squid</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">squid</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">squid</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">node.vks/internet-access:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">proxy-config</span></span><br><span class="line">          <span class="attr">configMap:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">proxy-configmap</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">squid</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">sameersbn/squid:3.5.27-2</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">          <span class="comment"># 将squid的配置文件挂载到/etc/squid中</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">proxy-config</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/etc/squid</span></span><br><span class="line">              <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">proxy-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">squid</span></span><br></pre></td></tr></table></figure>

<p>而proxy.conf的配置实际是默认的，你可以使用默认的，也可以使用这个我优化了的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http_port 80</span><br><span class="line"># Example rule allowing access from your local networks.</span><br><span class="line"># Adapt to list your (internal) IP networks from where browsing</span><br><span class="line"># should be allowed</span><br><span class="line">acl localnet src 10.0.0.0&#x2F;8 # RFC1918 possible internal network</span><br><span class="line">acl localnet src 172.16.0.0&#x2F;12  # RFC1918 possible internal network</span><br><span class="line">acl localnet src 192.168.0.0&#x2F;16 # RFC1918 possible internal network</span><br><span class="line">acl SSL_ports port 443</span><br><span class="line">acl Safe_ports port 80    # http</span><br><span class="line">acl Safe_ports port 21    # ftp</span><br><span class="line">acl Safe_ports port 443   # https</span><br><span class="line">acl Safe_ports port 70    # gopher</span><br><span class="line">acl Safe_ports port 210   # wais</span><br><span class="line">acl Safe_ports port 1025-65535  # unregistered ports</span><br><span class="line">acl Safe_ports port 280   # http-mgmt</span><br><span class="line">acl Safe_ports port 488   # gss-http</span><br><span class="line">acl Safe_ports port 591   # filemaker</span><br><span class="line">acl Safe_ports port 777   # multiling http</span><br><span class="line">acl CONNECT method CONNECT</span><br><span class="line">http_access deny CONNECT !SSL_ports</span><br><span class="line">http_access allow localhost manager</span><br><span class="line">http_access allow localnet</span><br><span class="line">http_access deny manager</span><br><span class="line">http_access allow all</span><br><span class="line"># disable caching</span><br><span class="line">cache deny all</span><br><span class="line">cache_mem 8 MB</span><br><span class="line">cache_dir null &#x2F;tmp</span><br><span class="line"># disable unnecessary logs</span><br><span class="line">cache_log &#x2F; dev&#x2F;null</span><br><span class="line"># To make it anonymous</span><br><span class="line">forwarded_for off</span><br><span class="line">request_header_access Allow allow all</span><br><span class="line">request_header_access Authorization allow all</span><br><span class="line">request_header_access WWW-Authenticate allow all</span><br><span class="line">request_header_access Proxy-Authorization allow all</span><br><span class="line">request_header_access Proxy-Authenticate allow all</span><br><span class="line">request_header_access Cache-Control allow all</span><br><span class="line">request_header_access Content-Encoding allow all</span><br><span class="line">request_header_access Content-Length allow all</span><br><span class="line">request_header_access Content-Type allow all</span><br><span class="line">request_header_access Date allow all</span><br><span class="line">request_header_access Expires allow all</span><br><span class="line">request_header_access Host allow all</span><br><span class="line">request_header_access If-Modified-Since allow all</span><br><span class="line">request_header_access Last-Modified allow all</span><br><span class="line">request_header_access Location allow all</span><br><span class="line">request_header_access Pragma allow all</span><br><span class="line">request_header_access Accept allow all</span><br><span class="line">request_header_access Accept-Charset allow all</span><br><span class="line">request_header_access Accept-Encoding allow all</span><br><span class="line">request_header_access Accept-Language allow all</span><br><span class="line">request_header_access Content-Language allow all</span><br><span class="line">request_header_access Mime-Version allow all</span><br><span class="line">request_header_access Retry-After allow all</span><br><span class="line">request_header_access Title allow all</span><br><span class="line">request_header_access Connection allow all</span><br><span class="line">request_header_access Proxy-Connection allow all</span><br><span class="line">request_header_access User-Agent allow all</span><br><span class="line">request_header_access Cookie allow all</span><br><span class="line">request_header_access All deny all</span><br></pre></td></tr></table></figure>

<p>需要注意的是<code>node.vks/internet-access: &quot;true&quot;</code>,squid部署在了具有公网访问权限的worker中。</p>
<blockquote>
<p>如果想要验证proxy是否可用，可以通过curl的方式(自行设定proxy)</p>
</blockquote>
<h4 id="设定Java运行参数"><a href="#设定Java运行参数" class="headerlink" title="设定Java运行参数"></a>设定Java运行参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: helloworld</span><br><span class="line">spec:</span><br><span class="line">  replicas: <span class="number">1</span></span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      run: helloworld</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        run: helloworld</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        node.vks/intranet: <span class="string">&quot;true&quot;</span></span><br><span class="line">      containers:</span><br><span class="line">        - name: helloworld</span><br><span class="line">          image: docker-registry.xxx.com/hello_proxy</span><br><span class="line">          imagePullPolicy: Always</span><br><span class="line">          ports:</span><br><span class="line">            - containerPort: <span class="number">8080</span></span><br><span class="line">          command: [<span class="string">&quot;java&quot;</span>]</span><br><span class="line">          args: [<span class="string">&quot;-Dhttp.proxyHost=proxy-service&quot;</span>, <span class="string">&quot;-Dhttp.proxyPort=80&quot;</span>, <span class="string">&quot;-Dhttps.proxyHost=proxy-service&quot;</span>, <span class="string">&quot;-Dhttps.proxyPort=80&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;target/app.jar&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>这里我们将我们的服务通过<code>node.vks/intranet-ip: &quot;true&quot;</code>部署到了内网中。而hello_proxy的代码其实很简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;http.ProxyHost=&quot;</span> + System.getProperty(<span class="string">&quot;http.proxyHost&quot;</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;http.ProxyPort=&quot;</span> + System.getProperty(<span class="string">&quot;http.proxyPort&quot;</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;https.ProxyHost=&quot;</span> + System.getProperty(<span class="string">&quot;https.proxyHost&quot;</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;https.ProxyPort=&quot;</span> + System.getProperty(<span class="string">&quot;https.proxyPort&quot;</span>));</span><br><span class="line">      hostname = InetAddress.getLocalHost().getHostName();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">      hostname = <span class="string">&quot;unknown host&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然你可以自己写一个从外网下载文件的controller或者请求内网服务的controller来验证。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>kubernetes</tag>
        <tag>squid proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中对象在JVM中如何表示？</title>
    <url>/2021/04/27/view-class-in-jvm-with-HSDB/</url>
    <content><![CDATA[<p>我们写代码的时候，前端传递参数给后端，后端都会有一个对象来负责参数接收，同样的JVM内部也有一个模型来表示Java对象，而这个就是oop-Klass模型。</p>
<p>Hotspot虚拟机在内部使用两组类来表示Java的类和对象</p>
<ol>
<li>oop(ordinary object pointer)用来描述对象实例信息</li>
<li>kclass用来描述Java类，是虚拟机内部Java类型结构的对等体</li>
</ol>
<p><img data-src="/images/java/class-in-jvm.png" alt="class-in-jvm"></p>
<a id="more"></a>

<p>JVM内部基于OOP-Klass模型描述一个Java类，将一个Java类一拆为二，第一个是oop,第二个是klass.</p>
<p>oop是ordinary object pointer(普通对象指针), 它用来表示对象的实例信息(Java类实例对象中各个属性在运行期的值)。看起来像是一个指针，而实际上对象实例数据都藏在指针所指向的内存首地址后面的一篇内存区域中。</p>
<p><img data-src="/images/java/oopDesc.png" alt="oopDesc"></p>
<blockquote>
<p>以上代码在<a href="https://github.com/openjdk/jdk/blob/jdk8-b29/hotspot/src/share/vm/oops/oop.hpp">https://github.com/openjdk/jdk/blob/jdk8-b29/hotspot/src/share/vm/oops/oop.hpp</a></p>
</blockquote>
<p>从注释中我们可以知道oopDesc是对象类的顶级基础类，{name}Desc用来描述Java对象格式，从而可以在C++中访问到它。<br>Java中万物皆为对象，所以C++中将方法，常量，数组等都抽象成为了对象，可以用oop来表示</p>
<p><img data-src="/images/java/other-oops.png"></p>
<p>而klass则包含元数据和方法信息，用来描述Java类或者JVM内部自带的C++类型信息。比如Java类的继承信息、成员变量、静态变量、成员方法、构造函数等信息都在klass中保存，JVM根据这个<br>可以在运行期反射出Java类的全部结构信息。JVM根据这个就能在运行期反射出Java类的全部结构信息。</p>
<p>同样的和oop一样，klass也是成体系的，它也有很多子类，这里我就不列举出来了，我们可以看一个instanceKlass的定义</p>
<p><img data-src="/images/java/instanceKlass-layout.png" alt="layout"></p>
<p>由于mirror也是一个instanceKlass，所以它包含了instanceKlass所包含的一切字段</p>
<p>执行 <code>new A()</code> 的时候，JVM native 层里发生了什么。首先，如果这个类没有被加载过，JVM 就会进行类的加载，并在 JVM 内部创建一个 instanceKlass 对象表示这个类的运行时元数据（相当于 Java 层的 Class 对象）。到初始化的时候（执行 invokespecial A::<init>），JVM 就会创建一个 instanceOopDesc 对象表示这个对象的实例，然后进行 Mark Word 的填充，将元数据指针指向 Klass 对象，并填充实例变量。</p>
<p>根据对 JVM 的理解，我们可以想到，元数据—— instanceKlass 对象会存在元空间（方法区），而对象实例—— instanceOopDesc 会存在 Java 堆。Java 虚拟机栈中会存有这个对象实例的引用。</p>
<h3 id="handle体系"><a href="#handle体系" class="headerlink" title="handle体系"></a>handle体系</h3><p>JVM内部访问对象并不是直接通过oop，而是通过handle,handle封装了oop,handle是对普通对象的一种间接引用，那JVM内部为什么要什么这种间接引用呢？</p>
<p>这完全是为GC考虑。</p>
<ol>
<li>通过handle，能够让GC知道其内部代码有哪些地方持有GC管理对象的引用，只需要扫描handle对应的table,这样JVM无须关注其内部哪些地方持有对普通对象的引用。</li>
<li>GC过程中，如果发生了对象移动(比如从新生代移动到老年代),那么JVM内部引用无须跟着更改为被移动对象的新地址，JVM只需要更改handle table里面对应的指针即可。</li>
</ol>
<p>在JVM中为了方便回收oop和klass(oop在堆中,klass处于metaspace),会将这两个对象封装成 oop</p>
<p><img data-src="/images/java/handle.png"></p>
<blockquote>
<p><a href="https://github.com/openjdk/jdk/blob/jdk8-b29/hotspot/src/share/vm/runtime/handles.hpp">https://github.com/openjdk/jdk/blob/jdk8-b29/hotspot/src/share/vm/runtime/handles.hpp</a></p>
</blockquote>
<p>在handles.hpp被编译后，会分别出现oop和klass对应的handle,</p>
<p>比如 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 类实例handle</span><br><span class="line">instanceHandle</span><br><span class="line"></span><br><span class="line"># 方法实例handle</span><br><span class="line">methodHandle</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"># 类元结构handle</span><br><span class="line">instanceKlassHandle</span><br><span class="line"></span><br><span class="line"># 方法元结构handle</span><br><span class="line">methodKlassHandle</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>jvm在具体描述一个类型时，会使用oop(其实这里是oopDesc)去存储这个类型的实例数据，使用klass去存储这个类型的元数据和虚方法表。当一个类型完成其生命周期后，需要将这两部分都回收<br>，因此将 oop封装成oop,klass也封装成oop。</p>
<p>可能有点绕，换个说法。</p>
<p>比如我们将JVM内部描述类信息模型叫做data-meta模型，将jvm内部的oop体系的类名全部改成Data结尾，比如instanceData, methodData。 klass体系的类改成以Meta结尾，比如 methodMeta, instanceMeta, JVM再进行GC时，即要回收Data类实例，也要回收Meta类实例，为了让GC方便回收，因此对于每一个Meta和Data类，JVM在内部将其封装成了oop模型。</p>
<p>对于Data类，内存布局前面是oop对象头，后面紧跟实例数据；对于Meta类，其内存布局是前面是oop对象头，后面紧跟实例数据和方发表。 封装成oop之后，再进一步使用handle来封装，于是有利于GC内存回收。</p>
<h3 id="查看Java对象在内存中的样子"><a href="#查看Java对象在内存中的样子" class="headerlink" title="查看Java对象在内存中的样子"></a>查看Java对象在内存中的样子</h3><p>为了让梦想照进现实，我们使用HSDB来查看JAVA对象在JVM中长什么样子,我们使用下面的代码来进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;think123&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String staticString = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> String desc = <span class="string">&quot;heheda&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">                      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    MyClassTest test = <span class="keyword">new</span> MyClassTest();</span><br><span class="line">    hello(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">hello</span><span class="params">(String otherName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name + <span class="string">&quot; : &quot;</span> + otherName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的java是安装在 C:\Program Files\Java\jdk1.8.0_172\lib，所以在这个目录下执行以下命令启动HSDB</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp sa-jdi.jar sun.jvm.hotspot.HSDB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后启动我们的程序(启动时最好关闭指针压缩：-XX:-UseCompressedOops)， 使用<code>jps -l </code>命令查看java进程id, 然后选择 <code>File --&gt; Attach to Hotspot Process</code>,输入java进程id</p>
<p><img data-src="/images/java/hsdb-attach.gif" alt="attach"><br><img data-src="/images/java/hsdb-threads.png"></p>
<h4 id="查看OOP"><a href="#查看OOP" class="headerlink" title="查看OOP"></a>查看OOP</h4><p>此时我们可以查看main线程的oop以及线程堆栈，在堆栈中可以看到我们的MyClassTest对象分配到了年轻代，也可以看到对应的内存地址，然后把这个地址复制下来，我们可以通过</p>
<p>Tools–&gt; Inspector查看对应的oop对象。</p>
<p><img data-src="/images/java/show-thread-info.gif"></p>
<p>不过这种方式比较麻烦，我们可以使用<code>Tools --&gt; Object Histogram</code>的方式来查看<br><img data-src="/images/java/hsdb-object.png" alt="查找对象"></p>
<p>找到对应的对象后，双击打开，然后点击Inspect</p>
<p><img data-src="/images/java/hsdb-object-type.png"></p>
<p><img data-src="/images/java/hsdb-oop.png"></p>
<h4 id="查看Klass"><a href="#查看Klass" class="headerlink" title="查看Klass"></a>查看Klass</h4><p><img data-src="/images/java/hsdb-class-browser.png"></p>
<p><img data-src="/images/java/hsdb-klass.png"></p>
<p>而在Method中我们则可以看到方法对应的字节码<br><img data-src="/images/java/hsdb-method-bytecode.png"></p>
<p>常量池中这是MyClass中的常量(比如引用类全限定名，方法名，常量，LocalNumberTable,LocalVariableTable等)</p>
<p>通过刚才查看到的地址，我们还可以看看Klass的数据结构是怎样的</p>
<p><img data-src="/images/java/hsdb-klass-structure.png"></p>
<blockquote>
<p>klass中的Method的定义: <a href="https://github.com/openjdk/jdk/blob/61bb6eca3e34b3f8382614edccd167f7ecefba65/src/hotspot/share/oops/method.hpp">https://github.com/openjdk/jdk/blob/61bb6eca3e34b3f8382614edccd167f7ecefba65/src/hotspot/share/oops/method.hpp</a></p>
</blockquote>
<p>可以看到，它的结构和我们最开始列出来的instanceKlass layout是一样的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们需要记住的是在JVM内部实例对象和Class是分别使用不同的数据结构来表示的(oop,Klass),我们可以借助HSDB工具来查看它们在JVM中的数据结构。</p>
<p>而我们常用到的反射，只所以能拿到那些字段，方法，接口等这些参数全是因为借助了Klass来实现的。</p>
<p>同时我们还可以借助它来查看常量池，比如困扰大家的intern问题，就可以结合HSDB来分析。</p>
<h3 id="think123"><a href="#think123" class="headerlink" title="think123"></a>think123</h3><p>以前最开始看小说的时候，那会儿异界修仙流比较出名，过程倒是记不住了，但是各个等级还是印象颇深。</p>
<p>炼气  筑基  金丹  元婴  离合  渡劫  大乘</p>
<p>如果程序员也有这种级别认定的话，那或许也是一件不错的事儿,每次升级都大吼一声</p>
<p>“键来!”</p>
<h3 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h3><p>《揭秘Java虚拟机-JVM设计原理与实现》</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章讲懂Java内存模型</title>
    <url>/2018/08/12/what-is-java-memory-model/</url>
    <content><![CDATA[<h3 id="Java运行时数据区域"><a href="#Java运行时数据区域" class="headerlink" title="Java运行时数据区域"></a>Java运行时数据区域</h3><p>在Java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享（本文使用“共享变量”这个术语代指实例域，静态域和数组元素）。局部变量（Local variables），方法定义参数（Java语言规范称之为formal method parameters）和异常处理器参数（exception handler parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响<br><img data-src="/images/thread-java-running-data-area.png" alt="Java运行时数据区"></p>
<h3 id="多线程下编码问题"><a href="#多线程下编码问题" class="headerlink" title="多线程下编码问题"></a>多线程下编码问题</h3><p>在Java多线程编程中，线程之间的通信机制是通过读写共享内存(堆内存)中的公共数据来隐式进行通信的，而同步是指程序用于控制不同线程之间操作发生相对顺序的机制，同步是显式进行的，需要程序员 显式指定某个方法或某段代码需要在线程之间互斥执行。由于线程之间的通信是隐式的，所以不了解这之间的通信机制，那么可能会遇到各种奇怪的内存可见性问题，导致在多线程编码中得到很多你不想要的结果。</p>
<p>在处理器级别，由于现在计算机基本上都是多CPU的,存储器模型也定义了一定的条件，用于知道当前处理器对其他处理器的存储器写入是可见的。某些处理器表现出强大的内存模型，其中所有处理器始终看到任何给定内存位置的完全相同的值。其他处理器表现出较弱的内存模型，其中需要特殊指令（称为内存屏障，memory barriers，intel称之为memory fence）来刷新或使本地处理器高速缓存无效，以便查看其他处理器进行的写入或使该处理器的写入对其他处理器可见。但是即使在一些最强大的内存模型上，通常也需要内存屏障。处理器大多数使用较弱的内存模型，因为这样可以容许更大的扩展性。</p>
<p>编译器重新排序代码时，写入对另一个线程可见的问题更加复杂。例如，编译器可能会决定稍后在程序中移动写操作更有效;只要此代码动作不会改变程序的语义，就可以自由地执行此操作。如果编译器推迟操作，则另一个线程在执行之前不会看到它;这反映了缓存的效果。</p>
<p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型</p>
<ol>
<li><p>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>
</li>
<li><p>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p>
</li>
<li><p>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p>
</li>
</ol>
<p>java代码到最终执行的指令会分别经历下面三种排序<br><img data-src="/images/code_sort_in_jmm.jpg" alt="指令重排序"></p>
<h3 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h3><p>Java虚拟机规范中试图定义一种Java内存模型(JMM,Java Memory Model)来屏蔽各种硬件和操作系统的内存访问差异，以实现Java程序在各种平台下都能达到一致的访问效果。</p>
<p>上述的编译器重排序，处理器重排序(包括指令集重排序和内存系统重排序)这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。<br>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<p>上面这么多问题都影响我们多线程编码，因此Java为了保证一次编译到处运行，让线程之间的通信由Java内存模型控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。<br><img data-src="/images/jmm_for_memory.jpg" alt="Java线程工作内存和主存通信"></p>
<h4 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h4><p>as-if-serial语义指的是不管怎么重排序(编译器和处理器为了提高并行度)，单线程的执行结果不能被改变。编译器，runtime和处理器都必须准守as-if-serial语义。为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。</p>
<p>数据依赖关系分为以下几种:<br>|  名称 |代码示例   | 说明  |<br>|—|—|—|<br>|   写后读 |  a = 1;b = a;  |  写一个变量之后，再读这个位置。  |<br>|  写后写  | a = 1;a = 2;   |   写一个变量之后，再写这个变量。 |<br>|   读后写 |   a = b;b = 1; |   读一个变量之后，再写这个变量 |</p>
<p>编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。 仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
<h4 id="处理器排序与内存屏障指令"><a href="#处理器排序与内存屏障指令" class="headerlink" title="处理器排序与内存屏障指令"></a>处理器排序与内存屏障指令</h4><p>现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！<br>由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操做重排序。<br>为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad Barriers</td>
<td>Load1; LoadLoad; Load2</td>
<td>Load2确保Load1数据的装载，之前于Load2及所有后续装载指令的装载。</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1; StoreStore; Store2</td>
<td>确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1; LoadStore; Store2</td>
<td>确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1; StoreLoad; Load2</td>
<td>确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</td>
</tr>
</tbody></table>
<h4 id="原子性、可见性、与有序性"><a href="#原子性、可见性、与有序性" class="headerlink" title="原子性、可见性、与有序性"></a>原子性、可见性、与有序性</h4><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这三个特征来建立的，我们现在看看这三个特性。</p>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>通俗的将就是一个操作不能被其他操作打断，要么成功，要么失败。Java中基本数据类型的访问读写是具备原子性的(例外就是long和double的非原子性协定，但是几乎不会发生)</p>
<h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>可见性是指当一个线程修改了共享变量的值,其他线程能够立即得知这个修改。</p>
<h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>有序性指的是代码在本线程内部观察都是有序；如果在另一个线程中观察一个线程，所有的操作都是无序的。<br>前半句指的是as-if-serial语义，后半句指的是”指令重排序”现象和”本地内存和主内存同步延迟”现象。</p>
<p>如果每一次多线程编程都要去考虑重排序，那么是非常辛苦的，而且也违背了java的初衷，因为考虑系统底层的实现总是非常辛苦的。从jdk5开始java使用新的jsr-133内存模型，其中通过happen-before(先行发生)的概念来阐述操作之间的内存可见性。 如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。这就意味着如果说操作A先行发生于操作B,其实就是说在发生操作B之前,从操作A产生的影响能被B观察到,”影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<h4 id="Java中天然的happen-before-先行发生-原则"><a href="#Java中天然的happen-before-先行发生-原则" class="headerlink" title="Java中天然的happen-before(先行发生)原则"></a>Java中天然的happen-before(先行发生)原则</h4><ul>
<li>在一个线程内，按照控制流顺序，书写在前面的操作happen-before书写在后面的操作</li>
<li>对同一个monitor的unlock操作都happens-before同一个monitor的lock</li>
<li>对volatile变量的写操作都happens-before同一个变量的读操作</li>
<li>线程的start()都happens-before线程的任何一个操作</li>
<li>线程中的所有操作happens-before任何其他线程从该线程上的join()成功返回。</li>
<li>线程interrrupt()方法的调用happends-before被中断线程的代码检测到中断事件的发生</li>
<li>如果A happens-before B,且B happens-before C，那么A happens-before C.</li>
</ul>
<h4 id="Java中线程同步的关键字"><a href="#Java中线程同步的关键字" class="headerlink" title="Java中线程同步的关键字"></a>Java中线程同步的关键字</h4><h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。<br>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p>
<p>前文我们提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。下面是JMM针对编译器制定的volatile重排序规则表：<br><img data-src="/images/volatile_in_jmm.png" alt="volatile排序规则"><br>从上表我们可以看出：举例来说，第三行最后一个单元格的意思是：在程序顺序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。</p>
<p>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</p>
<p>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</p>
<p>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</p>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：</p>
<ol>
<li><p>在每个volatile写操作的前面插入一个StoreStore屏障。</p>
</li>
<li><p>在每个volatile写操作的后面插入一个StoreLoad屏障。</p>
</li>
<li><p>在每个volatile读操作的后面插入一个LoadLoad屏障。</p>
</li>
<li><p>在每个volatile读操作的后面插入一个LoadStore屏障。</p>
</li>
</ol>
<p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。因为volatile可以保证可见性以及重排序优化。</p>
<h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><p>只有一个线程能持有监视器，这代表只有一个线程可以进入同步代码块，其他线程只有在这个线程退出了同步代码块之后才能进入，同时在退出同步代码块的时候JMM会把该线程对应的本地内存中的共享变量刷新到主内存中，所以这个线程的写操作对其他线程是可见的。当我们进入同步代码块的时候，我们需要获取监视器，在获取监视器的同时会使得当前处理器本地的缓存无效，而是会从主存中同步数据，然后我们就可以看到前一个线程的所有写入了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">new</span> Object()) &#123;</span><br><span class="line">    dosomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用这段代码来设置内存屏障是不起作用的，因为编译器知道不会有其他线程来获取同一个而监视器,所以编译器会完全给你移除<br>需要注意的是两个监视器在同一个监视器锁上同步才能触发happens-before，如果线程A在对象X上同步时可见的所有内容在对象Y上同步后不一定就对线程B可见。所以获取和释放必须匹配。</p>
<p>synchronized关键字可以保证原子性、可见性、与有序性，因为它如此强大的功能，许多人将它大量用在线程同步中，通常会伴随着越大的性能影响。</p>
<h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><ol>
<li><p>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p>
</li>
<li><p>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</p>
</li>
</ol>
<p>也就是说使用final字段可以保证初始化安全性，它允许在不同步的情况下自由访问和共享不可变对象。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>多线程编码中影响多线程安全的主要有内存、处理器重排序、编译器重排序等硬件和软件方面问题，而JMM则屏蔽了底层细节，对其进行了抽象处理，保证了单线程的as-if-serial语义以及多线程下合理使用Java提供的关键字或者开发包来保证线程安全。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://www.infoq.com/cn/articles/java-memory-model-1">http://www.infoq.com/cn/articles/java-memory-model-1</a></p>
<p>&lt;&lt;深入理解Java虚拟机&gt;&gt;</p>
]]></content>
      <categories>
        <category>jvm</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>why-mongodb-use-b-tree</title>
    <url>/2020/04/16/why-mongodb-use-b-tree/</url>
    <content><![CDATA[<p>除了 B+ 树，你可能还听说过 B 树、 B- 树，实际上， B- 树就是 B 树，英文翻译都是 B-Tree ，这里的 “-” 并不是相对 B+ 树中的 “+” ，而只是一个连接符。而 B 树实际上是低级版的B+ 树，或者说 B+ 树是 B 树的改进版。 </p>
<h3 id="B-tree"><a href="#B-tree" class="headerlink" title="B+ tree"></a>B+ tree</h3><p>B+ tree 实际上是一颗m叉平衡查找树(不是二叉树)</p>
<blockquote>
<p>平衡查找树定义：树中任意一个节点的左右子树的高度相差不能大于 1 </p>
</blockquote>
<p><img data-src="/images/java/BPlusTree.png" alt="B+ tree"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是B+树非叶子节点的定义。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 假设keywords=[3, 5, 8, 10]</span></span><br><span class="line"><span class="comment">* 4个键值将数据分为5个区间：(-INF,3), [3,5), [5,8), [8,10), [10,INF)</span></span><br><span class="line"><span class="comment">* 5个区间分别对应：children[0]...children[4]</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* m值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：</span></span><br><span class="line"><span class="comment">* PAGE_SIZE = (m-1)*4[keywordss大小]+m*8[children大小]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BPlusTreeNode</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 5叉树</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 键值，用来划分数据区间</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] keywords = <span class="keyword">new</span> <span class="keyword">int</span>[m-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存子节点指针</span></span><br><span class="line">  <span class="keyword">public</span> BPlusTreeNode[] children = <span class="keyword">new</span> BPlusTreeNode[m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这是B+树中叶子节点的定义。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* B+树中的叶子节点跟内部结点是不一样的,</span></span><br><span class="line"><span class="comment">* 叶子节点存储的是值，而非区间。</span></span><br><span class="line"><span class="comment">* 这个定义里，每个叶子节点存储3个数据行的键值及地址信息。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* k值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：</span></span><br><span class="line"><span class="comment">* PAGE_SIZE = k*4[keyw..大小]+k*8[dataAd..大小]+8[prev大小]+8[next大小]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BPlusTreeLeafNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据的键值</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] keywords = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据地址</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">long</span>[] dataAddress = <span class="keyword">new</span> <span class="keyword">long</span>[k];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个结点在链表中的前驱结点</span></span><br><span class="line">  <span class="keyword">public</span> BPlusTreeLeafNode prev;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个结点在链表中的后继结点 </span></span><br><span class="line">  <span class="keyword">public</span> BPlusTreeLeafNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在B+ 树中，树中的节点并不存储数据本身，而是只是作为索引。除此之外，所有记录的节点按大小顺序存储在同一层的叶节点中，并且每个叶节点通过指针连接。</p>
<p>总结下,B+树有以下特点</p>
<ol>
<li><p>B +树的每个节点可以包含更多节点，其原因有两个，其一是降低树的高度(索引不会全部存储在内存中,内存中可能撑不住,所以一般都是将索引树存储在磁盘中，只是将根节点放到内存中，这样对每个节点的访问,实际上就是访问磁盘,树的高度就等于每次查询数据时磁盘 IO 操作的次数),另一种是将数据范围更改为多个间隔。间隔越大，数据检索越快(可以想象跳表)</p>
</li>
<li><p>每个节点不在是存储一个key,而是存储多个key</p>
</li>
<li><p>叶节点来存储数据，而其他节点用于索引</p>
</li>
<li><p>叶子节点通过两个指针相互链接，顺序查询性能更高。</p>
</li>
</ol>
<p>这样设计还有以下优点：</p>
<ol>
<li><p>B +树的非叶子节点仅存储键，占用很小的空间，因此节点的每一层可以索引的数据范围要宽得多。换句话说，可以为每个IO操作搜索更多数据</p>
</li>
<li><p>叶子节点成对连接，符合磁盘的预读特性。例如，叶节点存储50和55，它们具有指向叶节点60和62的指针。当我们从磁盘读取对应于50和55的数据时，由于磁盘的预读特性，我们将顺便提一下60和62。读出相应的数据。这次是顺序读取，而不是磁盘搜索，加快了速度。</p>
</li>
<li><p>支持范围查询，局部范围查询非常高效，每个节点都可以索引更大，更准确的范围，这意味着B +树单磁盘IO信息大于B树，并且I / O效率更高</p>
</li>
<li><p>由于数据存储在叶节点层中，并且有指向其他叶节点的指针，因此范围查询仅需要遍历叶节点层，而无需遍历整个树。</p>
</li>
</ol>
<p>由于磁盘访问速度和内存之间存在差距，为了提高效率，应将磁盘I / O最小化。磁盘通常不是严格按需读取的，而是每次都被预读。磁盘读取所需的数据后，它将向后读取内存中的一定长度的数据。这样做的理论基础是计算机科学中众所周知的本地原理：</p>
<blockquote>
<p>关于MySQL数据索引是如何实现的，可以参考这篇文章：<a href="https://time.geekbang.org/column/article/77830">https://time.geekbang.org/column/article/77830</a></p>
</blockquote>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>B-Tree实际上也是一颗m叉平衡查找树</p>
<p><img data-src="/images/java/B-Tree.png" alt="B-Tree"></p>
<ol>
<li>所有的key值分布在整个树中</li>
<li>所有的key值出现在一个节点中</li>
<li>搜索可以在非叶子节点处结束</li>
<li>在完整的关键字搜索过程中，性能接近二分搜索。</li>
</ol>
<h3 id="B树和B-树之间的区别"><a href="#B树和B-树之间的区别" class="headerlink" title="B树和B+树之间的区别"></a>B树和B+树之间的区别</h3><ol>
<li><p>B +树中的非叶子节点不存储数据，并且存储在叶节点中的所有数据使得查询时间复杂度固定为log n。</p>
</li>
<li><p>B树查询时间的复杂度不是固定的，它与键在树中的位置有关，最好是O（1）。</p>
</li>
<li><p>由于B+树的叶子节点是通过双向链表链接的，所以支持范围查询，且效率比B树高</p>
</li>
<li><p>B树每个节点的键和数据是一起的</p>
</li>
</ol>
<h3 id="为什么MongoDB使用B-Tree-Mysql使用B-Tree"><a href="#为什么MongoDB使用B-Tree-Mysql使用B-Tree" class="headerlink" title="为什么MongoDB使用B-Tree,Mysql使用B+Tree ?"></a>为什么MongoDB使用B-Tree,Mysql使用B+Tree ?</h3><p>B +树中的非叶子节点不存储数据，并且存储在叶节点中的所有数据使得查询时间复杂度固定为log n。B树查询时间复杂度不是固定的，它与键在树中的位置有关，最好是O(1)。</p>
<p><strong>我们已经说过，尽可能少的磁盘IO是提高性能的有效方法。MongoDB是一个聚合数据库，而B树恰好是键域和数据域的集群。</strong></p>
<p>至于为什么MongoDB使用B树而不是B +树，可以从其设计的角度考虑它。<br>MongoDB不是传统的关系数据库，而是以BSON格式(可以认为是JSON)存储的nosql。目的是高性能，高可用性和易于扩展。</p>
<p>Mysql是关系型数据库，最常用的是数据遍历操作(join)，而MongoDB它的数据更多的是聚合过的数据，不像Mysql那样表之间的关系那么强烈,因此MongoDB更多的是单个查询。</p>
<p>由于Mysql使用B+树，数据在叶节点上,叶子节点之间又通过双向链表连接,更加有利于数据遍历，而MongoDB使用B树,所有节点都有一个数据字段。只要找到指定的索引，就可以对其进行访问。毫无疑问，单个查询MongoDB平均查询速度比Mysql快。</p>
<h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><p>简而言之，哈希索引使用某种哈希算法将键值转换为新的哈希值。不需要像B +树那样从根节点到叶节点逐步搜索。只需要一种哈希算法,就可以立即找到对应的位置，速度非常快。(此处可以想想Java中的HashMap)。</p>
<h4 id="B-树索引和Hash索引的区别"><a href="#B-树索引和Hash索引的区别" class="headerlink" title="B+树索引和Hash索引的区别"></a>B+树索引和Hash索引的区别</h4><ol>
<li><p>如果是等价查询，则哈希索引显然具有绝对优势，因为只需一种算法即可找到相应的键值；当然，前提是键值是唯一的,如果存在hash冲突就必须链表遍历了。</p>
</li>
<li><p>哈希索引不支持范围查询(不过改造之后可以,Java中的LinkedHashMap通过链表保存了节点的插入顺序,那么也可以使用链表将数据的大小顺序保存起来)</p>
<blockquote>
<p>这样做虽然支持了范围查询但是时间复杂度是O(n),效率比跳表和B+Tree差</p>
</blockquote>
</li>
<li><p>哈希索引无法使用索引排序以及模糊匹配</p>
</li>
<li><p>哈希索引也不支持多列联合索引的最左边匹配规则。</p>
</li>
<li><p>键值大量冲突的情况下,Hash索引效率极低</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要有复合索引?</title>
    <url>/2019/06/19/why-need-compound-index/</url>
    <content><![CDATA[<h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><p>要理解索引,你需要在脑中有个画面,这里建议想象一本食谱,不是普通食谱，而是5000页的厚重食谱，包含各种场合、菜肴和季节的食谱。虽然这个食谱很全,但是它有个缺点就是它是乱序的，第一页可能是鱼香茄子，第3000页是红烧茄子。</p>
<p>这还不是很要紧,关键问题是这本食谱没有索引！</p>
<p>下面是你要问自己的第一个问题：如果没有索引如何在食谱中找到糖醋排骨?唯一的选择是一页一页翻过去，如果它在3892页，你得要翻多少页呀，最坏的情况是它在最后一页，你就得把整本书都翻一遍。</p>
<p>解决办法就是构建一个索引。</p>
<a id="more"></a>

<p>我们可以想到多种查找方法，其中食谱名称可以作为一个起点。如果建立一个按食谱名称排列列表，随后是其所在页码，那么就是按食谱名称对书建立索引了。其中的条目可能是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">红烧排骨 : 45</span><br><span class="line">猪肉饺子 : 320</span><br><span class="line">酱萝卜 : 199</span><br></pre></td></tr></table></figure>

<p>现在只要知道食谱的名称就能通过该索引快速找到书中的任意食谱了,如果你只希望通过这种方式来检索食谱，那就已经完事儿了。</p>
<p>但这是不现实的，比方说,你还会希望根据你冰箱里面的食材查找食谱，或者是根据菜肴来进行查找。针对这种情况，你需要更多的索引。</p>
<p>这就产生了第二个问题，只有一个基于<code>食谱名称</code>的索引，如何能找到所有的排骨相关的食谱呢？缺少合适的索引，你仍然需要翻阅整本食谱–5000页。在根据食材或者菜肴进行检索时都是如此。</p>
<p>为此我们需要构建另一个索引，这次是对食材进行索引，在这个索引里面按照字母顺序排列食材，每个食材都指向所有包含它的食谱所在的页码。最基本的<code>食材索引</code>是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">牛肉 : 301, 342, 785, 2310, 2456, 4310 ...</span><br><span class="line">山药 : 8, 20, 45, 78, 287, 1295, 4587 ...</span><br><span class="line">猪肉 : 12, 124, 320, 890, 3719, ...</span><br></pre></td></tr></table></figure>

<p>这是你希望的索引吗？是不是很有用？</p>
<p>如果只是需要知道指定食材的食谱清单，这个索引就够用了，但如果还希望在查找时包含任何任意其他与与食谱相关的信息，还是需要进行“扫描”–一旦知道牛肉的页码，你要翻到每一页找到食谱的名字以及确定菜肴类型，虽然这比我们翻阅整本书要好，但是还远远不够。</p>
<p>例如，一周前，你无意间在这本食谱里面发现了一个很棒的鸡肉料理食谱，但是却忘了它的名字，你很想找到它然后做给你心仪的漂亮小姐姐吃。目前为止，有两个索引，一个时食谱名称的索引，另一个是食材的索引。是否能将两者结合起来，找到遗忘的鸡肉食谱呢？</p>
<p>实际上，这是不可能的。如果从食谱名称索引入手，但是却不记得名字，检索这个索引只比翻阅全书好一点点。从食材入手，则要检查一系列页码，但是这些页码无法插入基于食谱名称的索引。因此这种情况下只能使用一个索引，本例中食材的索引要更有用一点。</p>
<blockquote>
<p>通常认为一个查询里面要查找两个字段，可以针对它们分离索引。有一个现成的算法：查找每个索引里匹配项的页码，针对同时匹配两个索引的名单扫面它们页码的交集。这样可以减少扫描的总数。一些数据库实现了这个算法，但MongoDB中没有。就算它实现了，使用复合索引来查找两个字段总是会比我刚才描述的算法效率高。请记住每个查询中数据库只会使用一个索引，如果要对多个字段进行查询，请确保有这些字段的符合索引。</p>
</blockquote>
<p>那该怎么办？幸好我们有复合索引。</p>
<h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p><strong>目前为止你建立的都是单键索引：它们只是对食谱的一个键进行索引。现在要为整本食谱构建一个新的索引，不同之处这次是要使用两个键。类似的使用多个键的索引成为复合索引(compound index)。</strong></p>
<p>该复合索引依次使用了食材和食谱名称，可以这样来标记它: 材料-食谱，其中的部分内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">猪肉：</span><br><span class="line">  猪肉白菜炖粉条： 320</span><br><span class="line">  猪肉蛋卷： 3719</span><br><span class="line">  猪肉脯： 890</span><br><span class="line"></span><br><span class="line">鸡腿：</span><br><span class="line">  红烧鸡腿： 82</span><br><span class="line">  可乐鸡腿： 3710</span><br><span class="line">  土豆焖鸡腿： 2578</span><br><span class="line"></span><br><span class="line">西红柿</span><br><span class="line">  西红柿炒鸡蛋： 4827</span><br><span class="line">  西红柿鸡蛋汤： 2478</span><br><span class="line">  西红柿牛腩： 489</span><br></pre></td></tr></table></figure>

<p>这个索引的值对人是显而易见的，现在可以根据食材进行查找，大致定位要找的食谱，哪怕只是记得名称的开头部分。对机器而言同样很有价值，不用扫描该食材的全部食谱名称了。</p>
<p>需要注意的是复合索引的的顺序是很有讲究的，假设将上述索引翻转为 食谱-材料，它能替代我们之前的索引吗？</p>
<p>明显不能!使用新索引，只要知道名称，搜索就一定会定位到一个食谱，书中的一页。如果是要查找含有香蕉食材的猪肉食谱，那就可以确定不存在这个食谱。如果进行翻转之后，我们就必须要知道食谱的名称，在去找食材，但是现实情况往往是我们知道食材却不知道食谱名称。</p>
<p>现在整本食谱有三个索引： <code>食谱</code>、<code>食材</code>和<code>食材-食谱</code>，也就是说我们可以安全地去掉食材这个索引了。为什么呢？<br>因为对某一食材的索引可以使用食材-食谱索引，如果你知道食材，可以便利该复合索引，获得包含它的食谱的页码列表。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文只是为更进一步认识索引提供一个隐喻，从中可以认识到一些简单的经验法则，如下：</p>
<ol>
<li>索引能够显著减少获取文档所需的工作量。没有合适的索引，实现查询的唯一途径就是线性扫描整个文档，直到满足查询条件为止。这通常就是扫描整个集合。</li>
<li>解析查询时只会使用一个单键索引(or是例外),对于包含多个键(比如食材和食谱)的查询，包含这些键的复合索引能更好地解析查询。<blockquote>
<p>比如student表,对age和name都建立了索引，如果你查询name=”zhangsan” and age = 20,也只是会使用其中一个索引</p>
</blockquote>
</li>
<li>如果有食材-菜谱索引,可以去掉食材索引，也应该这么做。更抽象一点，如果有一个a-b的复合索引，那么仅针对a的索引就是冗余的。但是如果b本身就是一个复合索引(b=c-d),那么同时拥有a-b和a还是很有意义的。</li>
<li>符合索引里键的顺序也是很重要的。</li>
</ol>
]]></content>
      <tags>
        <tag>MongoDB</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么获取请求IP这么麻烦？</title>
    <url>/2020/05/06/why-so-diffcult-to-get-ip/</url>
    <content><![CDATA[<p>web开发中，经常会获取请求端IP地址,熟悉的同学可能第一时间就想到了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String ip = httpServletRequest.getRemoteAddr();</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>如果你的客户端和你的服务器是直连的，中间没有经过任何的代理这样是没有问题，如果你是通过了代理服务器访问了后端服务，那么获取到的ip其实是代理服务器的ip。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">直连: client --&gt; Server</span><br><span class="line">代理: client --&gt; Nginx --&gt; Server</span><br></pre></td></tr></table></figure>

<p>所以经常会在项目中看到如下获取ip地址的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIpAddress</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    String xIp = request.getHeader(<span class="string">&quot;X-Real-IP&quot;</span>);</span><br><span class="line">    String xFor = request.getHeader(<span class="string">&quot;X-Forwarded-For&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotEmpty(xFor) &amp;&amp; !<span class="string">&quot;unKnown&quot;</span>.equalsIgnoreCase(xFor)) &#123;</span><br><span class="line">      <span class="comment">// 多次反向代理后会有多个ip值，第一个ip才是真实ip</span></span><br><span class="line">      <span class="keyword">int</span> index = xFor.indexOf(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> xFor.substring(<span class="number">0</span>, index);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> xFor;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xFor = xIp;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotEmpty(xFor) &amp;&amp; !<span class="string">&quot;unKnown&quot;</span>.equalsIgnoreCase(xFor)) &#123;</span><br><span class="line">        <span class="keyword">return</span> xFor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(xFor) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(xFor)) &#123;</span><br><span class="line">        xFor = request.getHeader(<span class="string">&quot;Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(xFor) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(xFor)) &#123;</span><br><span class="line">        xFor = request.getHeader(<span class="string">&quot;WL-Proxy-Client-IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(xFor) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(xFor)) &#123;</span><br><span class="line">        xFor = request.getHeader(<span class="string">&quot;HTTP_CLIENT_IP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(xFor) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(xFor)) &#123;</span><br><span class="line">        xFor = request.getHeader(<span class="string">&quot;HTTP_X_FORWARDED_FOR&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(xFor) || <span class="string">&quot;unknown&quot;</span>.equalsIgnoreCase(xFor)) &#123;</span><br><span class="line">        xFor = request.getRemoteAddr();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xFor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会发现仅仅只是获取一个ip而已，竟然如此复杂。莫急，且听我细细道来。</p>
<p>接下来我们分析下为什么经过了代理之后获取真实ip变得如此复杂了。</p>
<h3 id="X-Forwarded-For"><a href="#X-Forwarded-For" class="headerlink" title="X-Forwarded-For"></a>X-Forwarded-For</h3><p>X-Forwarded-For(XFF) 是一个 HTTP 扩展头部。HTTP/1.1(RFC 2616)协议并没有对它的定义，它最开始是由 Squid 这个缓存代理软件(关于squid的使用，可以参考我这篇文章)引入，用来表示 HTTP 请求端真实 IP。如今它已经成为事实上的标准，被各大 HTTP 代理、负载均衡等转发服务广泛使用，并被写入 <a href="https://tools.ietf.org/html/rfc7239">RFC 7239</a> (Forwarded HTTP Extension)标准之中。</p>
<p>比如我们一般在nginx中会这样配置</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 指定上游服务器(可以指定多个，还可以指定权重等)，并取名为local</span></span><br><span class="line">    <span class="attribute">upstream</span> local &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">127.0.0.1:8001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">      <span class="attribute">listen</span>       <span class="number">8002</span>;</span><br><span class="line">      <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 由于有了反向代理，A--&gt;B--&gt;C这样的请求链，所以为了让C拿到A的信息就进行如下的配置，这些特性可以在http-proxy-module中看到</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将请求代理到上游服务器</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://local;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>X-Forwarded-For 请求头格式非常简单，就这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For: client, proxy1, proxy2</span><br></pre></td></tr></table></figure>

<p>XFF的格式非常简单,它的内容由 “英文逗号 + 空格” 隔开的多个部分组成，最开始的是离服务端最远的设备 IP(client ip)，然后是每一级代理设备的 IP。</p>
<blockquote>
<p>所以上面代码中从XFF中获取IP时,会获取逗号分隔后的第一个值</p>
</blockquote>
<p>比如我们有这样的请求链条: client –&gt; proxy1 –&gt; proxy2 –&gt; proxy3 –&gt; server。请求经过了proxy1, proxy2, proxy3三个代理,其ip分别是proxy1IP, proxy2IP, proxy3IP,而客户端真实ip为clientIP,那么根据XFF标准,server最终会收到以下信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For: clientIP, proxy1IP, proxy2IP</span><br></pre></td></tr></table></figure>

<p>proxy3直连server,它会给XFF追加proxy2IP,表示它是在帮proxy2转发请求，而proxy3IP没有出现在XFF中,它可以在服务端通过 Remote Address 字段获得。我们知道 HTTP 连接基于 TCP 连接，HTTP 协议中没有 IP 的概念，Remote Address 来自 TCP 连接，表示与服务端建立 TCP 连接的设备 IP，在这个例子里就是 proxy3IP。</p>
<p>Remote Address 无法伪造，因为建立 TCP 连接需要三次握手，如果伪造了源 IP，无法建立 TCP 连接，更不会有后面的 HTTP 请求。不同语言获取 Remote Address 的方式不一样，例如 php 是 <code>$_SERVER[&quot;REMOTE_ADDR&quot;]</code>，java 中 是 <code>request.getRemoteAddr()</code>，但原理都一样。</p>
<p>我们还知道上面的代码中总是出现了一个词 unknown ? 为什么总是使用它来判断呢？</p>
<p>这是因为squid.conf的配置文件中如果将 forwarded设置为 <code>forwarded_for off</code>,那么XFF的值就是unknown</p>
<h3 id="Proxy-Client-IP和WL-Proxy-Client-IP"><a href="#Proxy-Client-IP和WL-Proxy-Client-IP" class="headerlink" title="Proxy-Client-IP和WL-Proxy-Client-IP"></a>Proxy-Client-IP和WL-Proxy-Client-IP</h3><p>Proxy-Client-IP 字段和 WL-Proxy-Client-IP 字段只在 Apache（Weblogic Plug-In Enable）+ WebLogic 搭配下出现，这里的WL就是WebLogic的缩写。</p>
<h3 id="X-Real-IP-HTTP-CLIENT-IP-HTTP-X-FORWARDED-FOR"><a href="#X-Real-IP-HTTP-CLIENT-IP-HTTP-X-FORWARDED-FOR" class="headerlink" title="X-Real-IP, HTTP_CLIENT_IP, HTTP_X_FORWARDED_FOR"></a>X-Real-IP, HTTP_CLIENT_IP, HTTP_X_FORWARDED_FOR</h3><p>这些都是代理服务器自定义的header,比如X-Real-IP一般nginx会加上, HTTP_X_FORWARDED_FOR 可以认为就是 X_FORWARDED_FOR。 比如我nginx配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">include</span>       mime.types;</span><br><span class="line">  <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">  <span class="attribute">underscores_in_headers</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">  <span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">127.0.0.1:8001</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line">   </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&#x27;clintIp=<span class="variable">$http_client_ip</span>,xff=<span class="variable">$HTTP_X_FORWARDED_FOR</span>&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当你这样访问nginx服务时:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl  127.0.0.1:8001/ -H <span class="string">&#x27;x-forwarded-for: 1.2.2.2&#x27;</span> -H <span class="string">&#x27;client-ip: 1.1.1.1&#x27;</span></span></span><br><span class="line"></span><br><span class="line">  clintIp=1.1.1.1,xff=1.2.2.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面用到的<code>$http_client_ip</code>,<code>$HTTP_X_FORWARDED_FOR</code>(不区分大小写),这种是nginx中获取用户自定义的header的写法(header名称均为小写,且以http开头,以下划线连接)。而我们在访问服务器的时候，是可以传递任何header的。这也就意味着你获取到的header值不是完全可信的。</p>
<p>所以，如果我们的Web应用是直接对外提供服务的，那么在进行安全相关的操作时，只能通过Remote Address获取IP,不能相信任何请求头</p>
<p>如果我们的Web应用是通过Nginx等Web Server进行反向代理后对外提供服务的，想要获取client ip需要使用X-Forwarded-For第一节或X-Real-IP来获取IP(此时Remote Address 获取的是Nginx 所在服务器的IP,当然第一节很容易被伪造,如果拿后面部分的地址,拿到的实际是Nginx所在服务器的IP,不过这样一定可以知道是从Nginx转发过来的),同时还应该禁止Web服务应用直接对外提供服务。</p>
]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>我为什么要选择traefik2做网关？</title>
    <url>/2020/03/13/why-we-need-gateway/</url>
    <content><![CDATA[<h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><p>下图简单展示了单体架构的工作流程</p>
<p><img data-src="/images/gateway/single-server.png" alt="单体架构"></p>
<p>单体架构是把所有的模块和功能集中到一起，部署到一台服务器中，这种一把梭的方式,赢了还好，输了就下海干活。如果请求过大,一台机器撑不住,也只能通过添加机器的方式来进行横向扩展。</p>
<a id="more"></a>

<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务架构中我们的应用往往是拆分成不同的模块，取而代之的是多个不同的Service独立部署。他们之间的通信通过http或者rpc等方式，这样每个模块我们就可以独立开发，互不影响。</p>
<p><img data-src="/images/gateway/micro-service.png" alt="微服务架构"></p>
<p>可以看到之前的单体系统提供的功能被我们拆分成了很多个模块，分别部署成不同的服务。</p>
<p>手机端用户直接通过Nginx访问不同的后端服务，但是在手机端需要完成聚合功能。比如首页需要显示的数据需要在不同的服务中获取数据，就需要将数据请求回来组合之后才能进行显示，所以一般我们会在手机客户端和微服务之间增加一层。</p>
<p><img data-src="/images/gateway/micro-service-bff.png" alt="BFF"></p>
<p>这一层主要做什么呢？聚合数据之后返回统一格式的数据,还可以根据不同设备类型进行裁剪(比如平板和手机显示就不一样),由于增加了BFF(backend for frontend，为前端开发的后端),APP和后端API就解除了强耦合的关系，两边是可以独立变化的,不会受到另一方影响。</p>
<blockquote>
<p>有的服务返回的数据可能是xml格式，有的有可能是json格式</p>
</blockquote>
<p>微服务看起来很棒，但是也存在一些挑战，在微服务架构之下，服务被拆的非常零散，降低了耦合度的同时也给服务的统一管理增加了难度。<br>在旧的服务治理体系之下，鉴权，限流，日志，监控等通用功能需要在每个服务中单独实现，这使得系统维护者没有一个全局的视图来统一管理这些功能。而计算机的问题都可以通过增加一层来解决这个问题，所以我们可以增加一层API网关来容纳这些通用的功能，在此基础上提供系统可扩展性。</p>
<p><img data-src="/images/gateway/micro-service-gateway.png" alt="gateway"></p>
<p>可以看到这里又提出来了一层gateway，而对于BFF,有些公司可能将其和gateway合并了，具体怎么处理，得看实际情况是怎样的了。</p>
<p>API 网关模式意味着你要把API 网关放到你的微服务们的最前端，并且要让API 网关变成由应用所发起的每个请求的入口。这样就可以明显的简化客户端实现和微服务应用程序之间的沟通方式。</p>
<p>没有网关之前,客户端将商品加入购物车不得不去请求用户服务，然后再到商品服务，然后是购物车服务。客户端需要去知道怎么去一起来消费这三个不同的service。使用API网关，我们可以抽象所有这些复杂性，并创建客户端们可以使用的优化后的端点，并向那些模块们发出请求。</p>
<p>你还可以通过API网关中心化中间件的能力。当你开始创建越来越多的服务时，你会发现自己面临了一个新的问题 – 就是你发现你需要对一些服务进行身份验证和流量控制。</p>
<p>有的服务是public的；有的是private的；有的则是合作伙伴的API，这些你只能提供给一些特定的用户。迟早你会发现自己在实现每个微服务时总是一次次的重复编写一些相同的代码，这些代码其实都是可以抽象为中间件的。</p>
<p>这显然不是每个微服务应该去关注的事情。API网关才应该把这件事情揽下，也就是说微服务只负责接收进来的request-然后返回一个类似JSON格式的response即可。然后API网关就把这些例如身份验证、日志（logging）以及流量控制都归于麾下。</p>
<blockquote>
<p>微服务并不都是优点,它同样有一长串需要考虑的问题，比如日志、监控、异常处理、容错、回滚、通信、消息格式、容器、服务发现、备份、测试、报警、跟踪、工具、文档、扩展、时区、API版本、网络延迟、健康检查、负载均衡等等问题,一个新的方式解决问题的同时也会面临新的问题，所以不要觉得微服务就一定好，每个阶段面临的问题不一样,我们处理问题，看待问题的方式也不一样。</p>
</blockquote>
<p>微服务要关心的事情太多，所以如果你的公司准备转成微服务就一定要有具备这些解决微服务面临问题的能力。</p>
<h3 id="云原生服务"><a href="#云原生服务" class="headerlink" title="云原生服务"></a>云原生服务</h3><p>微服务之后,又兴起了云原生服务,什么是云原生服务呢？</p>
<p>云原生应用定义: 基于微服务原理而开发的应用，以容器方式打包。在运行时，容器由运行于云基础设施之上的平台(比如kubernetes)进行调度。应用开发采用持续交付和DevOps实践。</p>
<p>云原生服务还是离不开微服务，只是它是运行在具备云原生基础的平台中的，而且采用的是持续交付和DevOps实践。这个云原生平台有什么作用呢？用过Kubernetes的都知道它不用担心扩展、服务发现、负载均衡、容错、回滚、更新等等问题，并且对于gateway,监控等等都有配套的成熟解决方案。真的是谁用谁知道。</p>
<blockquote>
<p>这里就不展开说了，感兴趣的可以去了解下Kubernetes</p>
</blockquote>
<h3 id="API-Gateway选择"><a href="#API-Gateway选择" class="headerlink" title="API Gateway选择"></a>API Gateway选择</h3><h4 id="网关需要考虑哪些内容"><a href="#网关需要考虑哪些内容" class="headerlink" title="网关需要考虑哪些内容"></a>网关需要考虑哪些内容</h4><ul>
<li>限流熔断</li>
<li>动态路由和负载均衡</li>
<li>基于path的路由,比如 example.com/user 访问问用户服务, example.com/shopping 访问购物服务</li>
<li>截获器链</li>
<li>日志采集和Metrics埋点</li>
<li>响应流优化</li>
<li>可编程API</li>
<li>Header头重写</li>
</ul>
<h4 id="各大网关对比"><a href="#各大网关对比" class="headerlink" title="各大网关对比"></a>各大网关对比</h4><table>
<thead>
<tr>
<th></th>
<th>支持公司</th>
<th>实现语言</th>
<th>亮点</th>
<th>不足</th>
</tr>
</thead>
<tbody><tr>
<td>Nginx(2004)</td>
<td>Nginx Inc</td>
<td>C/Lua</td>
<td>高性能，成熟稳定</td>
<td>门槛高,偏运维,可编程弱</td>
</tr>
<tr>
<td>Zuul1(2012)</td>
<td>Netflix/Pivotal</td>
<td>Java</td>
<td>成熟,简单门槛低</td>
<td>性能一般,可编程一般</td>
</tr>
<tr>
<td>Spring Cloud Gateway(2016)</td>
<td>Pivotal</td>
<td>Java</td>
<td>异步,配置灵活</td>
<td>早期产品</td>
</tr>
<tr>
<td>Envoy(2016)</td>
<td>Lyft</td>
<td>C++</td>
<td>高性能,可编程API/ServiceMesh集成</td>
<td>门槛较高</td>
</tr>
<tr>
<td>Kong(2014)</td>
<td>Kong Inc</td>
<td>OpenResty/Lua</td>
<td>高性能,可编程API</td>
<td>门槛较高</td>
</tr>
<tr>
<td>Traefik(2015)</td>
<td>Containous</td>
<td>Golang</td>
<td>云原生,可编程API/对接各种服务发现</td>
<td>生产案例不太多</td>
</tr>
</tbody></table>
<p>实际中我们使用的是云原生服务,而Zuul和Spring Cloud Gateway结合Spring Cloud全家桶结合使用效果较好，所以它不太适合我们现在的选择。</p>
<p>我们将目光集中在Kong和traefik中,经过对比发现,我们最终还是选择了traefik,相比较于Kong,traefic的优势如下:</p>
<p><strong>1. traefik较为轻量，非常易于使用和设置</strong><br><strong>2. traefic通过Kubernetes存储状态(Kong要使用Postgres或者Cassandra来存储状态)，并利用Ingress通过https将所有流量路由到对应的服务</strong><br><strong>3. 已在全球范围内用户生产环境，并经过了严格的测试和基准测试，在我司其他项目中有运用</strong><br><strong>4. Kong仪表板，它是单独开发的，与最新版本的Kong兼容需要花点时间。Traefik带有自己的仪表板，它始终与最新的Traefik版本兼容,Traefik的用户界面也比Kong的用户界面好看。</strong></p>
<blockquote>
<p>traefik的Middlewares真心好用,traefik建议升级到traefik2</p>
</blockquote>
<p>并且traefik还可以作为Kubernetes ingress controller,可以完全替代我们之前说过的nginx controller</p>
<h4 id="如何使用traefick作为网关进行用户验证"><a href="#如何使用traefick作为网关进行用户验证" class="headerlink" title="如何使用traefick作为网关进行用户验证"></a>如何使用traefick作为网关进行用户验证</h4><p><img data-src="/images/gateway/traefic-forwardauth.png" alt="权限验证"></p>
<p>ingress route的配置：</p>
<p><img data-src="/images/gateway/traefik-middleware-auth.png" alt="ingressRoute"></p>
<p>代码:<br><img data-src="/images/gateway/auth-service.png" alt="auth-service"></p>
<p>通过上面的配置之后，当我们想要访问/api/orders这个api的时候就会先去/api/auth中进行授权验证用户是否登录，如果登录后则会将携带对应的http header到对应的后端服务，后端服务在根据这个header进行验证</p>
<p><img data-src="/images/gateway/auth-processing.png" alt="流程图"></p>
]]></content>
      <tags>
        <tag>traefik</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写出高效率的正则表达式</title>
    <url>/2018/04/08/write-high-performance-regular-expressions/</url>
    <content><![CDATA[<h3 id="正则表达式引擎-DFA-NFA"><a href="#正则表达式引擎-DFA-NFA" class="headerlink" title="正则表达式引擎(DFA/NFA)"></a>正则表达式引擎(DFA/NFA)</h3><p>NFA 是不确定的有限自动机，也就是说在状态的迁移过程中，下一个状态可能有好几种可能，而对于 DFA 确定有限自动机而言，下一个状态只有一种可能。<br>DFA引擎因为不需要回溯，所以匹配快速，但不支持捕获组，所以也就不支持反向引用和$number这种引用方式，目前使用DFA引擎的语言和工具主要有awk、egrep 和 lex。<br>而NFA又基本上可以分为传统型NFA和POSIX NFA，<br>POSIX NFA主要指符合POSIX标准的NFA引擎，它的特点主要是提供longest-leftmost匹配，也就是在找到最左侧最长匹配之前，它将继续回溯。同DFA一样，非贪婪模式或者说忽略优先量词对于POSIX NFA同样是没有意义的。</p>
<p><strong>Java使用的是传统型NFA引擎</strong>,所以我们接下来讨论的内容也是基于传统型NFA引擎的</p>
<h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>因为 DFA 在匹配过程中是跟正则表达式无关的，所以接下来效率提升方面的讨论只针对 NFA。<br>匹配失败发生回朔的次数是一个指标，而为什么会发生回朔呢?<br>因为基本的元字符是贪婪的 (*, +)，因为有选择性的匹配 (|), 于是在匹配过程中每一次这样的选择，都会记录一个回朔点，在匹配失败时，就会回朔到之前一个回朔点，继续匹配，也就是类似于栈的机制，后进先出。</p>
<h3 id="学会使用工具"><a href="#学会使用工具" class="headerlink" title="学会使用工具"></a>学会使用工具</h3><p>在这里安利一个RegexBuddy工具，使用它可以很简单的在各种语言环境下测试、使用、debug正则表达式，不要使用网页版本的正则表达式匹配工具，那些大多数是匹配js的，有些甚至连js都匹配不准确。</p>
<h3 id="开始优化正则表达式"><a href="#开始优化正则表达式" class="headerlink" title="开始优化正则表达式"></a>开始优化正则表达式</h3><h4 id="使用字符组代替分支条件"><a href="#使用字符组代替分支条件" class="headerlink" title="使用字符组代替分支条件"></a>使用字符组代替分支条件</h4><p>匹配abcd字符请使用[a-d]而不是使用a|b|c|d,前者匹配一次即可匹配需要的字符，而后者需要进行匹配四次(因为需要进行回溯)</p>
<h4 id="尽量使用锚点优化-或者"><a href="#尽量使用锚点优化-或者" class="headerlink" title="尽量使用锚点优化(^或者$)"></a>尽量使用锚点优化(^或者$)</h4><p>如果知道一个字符串开头是什么，尽量使用^,如果知道结尾是什么尽量使用$,它可以从字符串末尾倒数如干个字符开始进行匹配，比如regex$只可能从字符串默认倒数的第五个字符开始匹配，这样可以略过很多字符，达到优化的效果。</p>
<h4 id="尽量使用长度优化"><a href="#尽量使用长度优化" class="headerlink" title="尽量使用长度优化"></a>尽量使用长度优化</h4><p>如果你知道一个字符串的长度不超过多少，或者这个字符串是定长的，那么请一定加上长度匹配，比如\d{11}匹配11位的数字，\d{4,8}匹配4到8位的数字，在匹配的时候就不会匹配小于4位的数字。</p>
<h4 id="使用占有优先量词和固化分组"><a href="#使用占有优先量词和固化分组" class="headerlink" title="使用占有优先量词和固化分组"></a>使用占有优先量词和固化分组</h4><p><strong>占有优先量词：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?+     *+     ++     &#123;m,n&#125;+</span><br></pre></td></tr></table></figure>
<p>占有优先量词与匹配优先量词很相似,只是它们从来不会交还已经匹配的字符。<br><strong>固化分组：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(?&gt;...)       ...是指具体内容</span><br></pre></td></tr></table></figure>
<p>固化分组的内容与正常的匹配并无区别，只是当匹配完括号中的内容后，括号中的备用状态会全部舍去。</p>
<h4 id="是否使用非捕获型括号"><a href="#是否使用非捕获型括号" class="headerlink" title="是否使用非捕获型括号"></a>是否使用非捕获型括号</h4><p>在上一篇文章正则表达式的基本使用中指出了使用非捕获型括号有利于性能提升，因为你不在需要捕获文本的开销,但是这也不是必然的，比如(000|999)$使用了非捕获型括号之后反而比之前还变慢了，那是因为非捕获型括号不会使用$这个锚结尾优化，但是大多数时候非捕获型括号都是有益的，所以这个使用就需要自己权衡。</p>
<h4 id="尽可能少的编译"><a href="#尽可能少的编译" class="headerlink" title="尽可能少的编译"></a>尽可能少的编译</h4><p>正则表达式的编辑也是需要耗费时间的，不要每次在循环内重新编辑正则表达式</p>
<h4 id="不要滥用括号"><a href="#不要滥用括号" class="headerlink" title="不要滥用括号"></a>不要滥用括号</h4><p>只有在需要的时候才使用括号，要不然括号会阻止某些优化措施，比如.<em>请不要用成(.)\</em></p>
<h4 id="不要滥用字符组"><a href="#不要滥用字符组" class="headerlink" title="不要滥用字符组"></a>不要滥用字符组</h4><p>字符组使用时有好处，但是不要滥用呀,并不需要用到字符组提供的多字符匹配功能的时候请不要使用字符组</p>
<h4 id="像写代码一样优化"><a href="#像写代码一样优化" class="headerlink" title="像写代码一样优化"></a>像写代码一样优化</h4><p>这个是什么意思？其实就是尽量将常量字符串提取出来,将共同的部分提取出来</p>
<h4 id="别写太长的正则表达式"><a href="#别写太长的正则表达式" class="headerlink" title="别写太长的正则表达式"></a>别写太长的正则表达式</h4><p>太长的正则表达式效率不一定高，而且后期不好维护，所以尽量不要写太长的表达式，就算有长的也尽量拆分成比较短的正则表达式，能用字符串处理解决的就尽量不用正则表达式。</p>
<h4 id="使用环视模拟开头符识别"><a href="#使用环视模拟开头符识别" class="headerlink" title="使用环视模拟开头符识别"></a>使用环视模拟开头符识别</h4><p>如果正则表达式为 Jan|Feb|Dec， 对应的就是(?=[JFMASOND])(?:Jan|Feb|Dec)。<br>开头的[JFMASOND]代表了英文中月份单词可能的开始字母。</p>
<h4 id="将尽可能多的多选分支放在前面"><a href="#将尽可能多的多选分支放在前面" class="headerlink" title="将尽可能多的多选分支放在前面"></a>将尽可能多的多选分支放在前面</h4><p>多选分支下尽可能将出现概率比较大的表达式放在前面，比如匹配主机名的表达式中(?:aero|biz|com|cooph|…)的效率没有(?:com|net|edu|org|…)的效率高</p>
<h3 id="消除循环"><a href="#消除循环" class="headerlink" title="消除循环"></a>消除循环</h3><p>如果你写了一个较复杂的表达式,可以使用消除循环来提高效率,消除循环的常用解法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opening normal* (special normal\*)* closing</span><br></pre></td></tr></table></figure>
<p>需要注意的几点<br>** 1. special 部分和normal部分匹配的开头不能重合 **<br>** 2. normal 部分必须匹配至少一个字符 **<br>** 3. special部分必须是固话的,部分匹配的文本不能由该部分的多次迭代完成,比如(abc*)<em>重要比.\</em>好一些。**</p>
<h3 id="是否必须使用正则表达式"><a href="#是否必须使用正则表达式" class="headerlink" title="是否必须使用正则表达式?"></a>是否必须使用正则表达式?</h3><p>有时候正则表达式确实能为我们带来便捷，但是滥用正则表达式的后果同样是非常严重的,可能会导致死循环，让你程序的效率显著的下降，所以如果能用字符串解决的问题尽量不使用正则表达式，如果使用正则表达式请尽量多测试，写出高水平的正则表达式。</p>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>从mysql到mongodb你应该快速了解的内容</title>
    <url>/2018/08/05/you-should-know-from-mysql-to-mongodb/</url>
    <content><![CDATA[<p>从mysql转战mongodb，应该快速的了解上手，以下的内容就是个人对其基本使用的一个总结。</p>
<h3 id="下载安装查看官方文档"><a href="#下载安装查看官方文档" class="headerlink" title="下载安装查看官方文档"></a>下载安装查看官方文档</h3><p>当然第一步肯定是要安装上了，安装步骤按照官网的来就可以了  <a href="https://docs.mongodb.com/manual/mongo/">https://docs.mongodb.com/manual/mongo/</a>,安装之后可以使用自带的mongoshell来测试也可以用Robo 3T这样的工具来进行测试</p>
<h3 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h3><p>MongoDB以BSON格式的文档（Documents）形式存储。Databases中包含集合（Collections），集合（Collections）中存储文档（Documents）。</p>
<p><a href="https://docs.mongodb.com/manual/reference/bson-types/">BSON</a>是一个二进制形式的JSON文档，它比JSON包含更多的数据类型。</p>
<table>
<thead>
<tr>
<th>SQL术语/概念</th>
<th>MongoDB术语/概念</th>
<th>解释/说明</th>
</tr>
</thead>
<tbody><tr>
<td>database</td>
<td>database</td>
<td>数据库</td>
</tr>
<tr>
<td>table</td>
<td>collection</td>
<td>数据库表/集合</td>
</tr>
<tr>
<td>row</td>
<td>document</td>
<td>数据记录行/文档</td>
</tr>
<tr>
<td>column</td>
<td>field</td>
<td>数据字段/域</td>
</tr>
<tr>
<td>index</td>
<td>index</td>
<td>索引</td>
</tr>
<tr>
<td>table joins</td>
<td></td>
<td>table joins</td>
</tr>
<tr>
<td>primary key</td>
<td>primary key</td>
<td>主键,MongoDB自动将_id字段设置为主键</td>
</tr>
</tbody></table>
<p>上面说了MongoDB中保存的数据是bson格式的数据,所以数据库中的数据看上去是这样的</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;_id&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;zipcode&quot;</span> : <span class="string">&quot;63109&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;students&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;john&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;age&quot;</span> : <span class="number">10</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;jess&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;age&quot;</span> : <span class="number">11</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;jeff&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;age&quot;</span> : <span class="number">15</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="熟悉语法"><a href="#熟悉语法" class="headerlink" title="熟悉语法"></a>熟悉语法</h3><h4 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo host:port&#x2F;databaseName -u user -p password</span><br><span class="line"></span><br><span class="line">#连接本地的local库</span><br><span class="line">mongo 127.0.0.1&#x2F;local</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use myNewDB</span><br><span class="line"></span><br><span class="line">#也可以调用insertMany同时插入多条数据,插入的数据是一个&#x2F;多个json对象</span><br><span class="line">db.myNewCollection1.insert( &#123;name:&quot;Kit&quot;&#125; )</span><br><span class="line"></span><br><span class="line"># 也以使用getCollection的方式</span><br><span class="line">db.getCollection(&quot;myNewCollection1&quot;).insertOne(&#123;name:&quot;Kit&quot;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>insert()操作会创建名为myNewDB的database和名为myNewCollection1的collection（如果他们不存在的话）。</p>
<h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collectionName.find(query,projection);</span><br><span class="line"></span><br><span class="line">query ：可选，使用查询操作符指定查询条件</span><br><span class="line">projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="query的使用"><a href="#query的使用" class="headerlink" title="query的使用"></a>query的使用</h5><p>下面给出几个对比查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># select * from user where name &#x3D; &quot;张三&quot; and age &#x3D; 20;</span><br><span class="line">db.user.find(&#123;</span><br><span class="line">    name:&quot;张三&quot;,</span><br><span class="line">    age:20</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># select * from user where name &#x3D; &quot;张三&quot; and age &gt; 20;</span><br><span class="line">db.user.find(&#123;</span><br><span class="line">    name:&quot;张三&quot;,</span><br><span class="line">    age:&#123;</span><br><span class="line">        $gt:20</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># select * from user where name &#x3D; &quot;张三&quot; or age &#x3D; 20;</span><br><span class="line">db.user.find(&#123;</span><br><span class="line">    $or: [</span><br><span class="line">        &#123;name:&quot;张三&quot;&#125;,</span><br><span class="line">        &#123;age:20&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>基本mysql支持的查询，mongodb都可以做到，它支持的操作符在这里(<a href="https://docs.mongodb.com/manual/reference/operator/query/">https://docs.mongodb.com/manual/reference/operator/query/</a>)可以看到.</p>
<p>从上面的对比基本可以总结出来，mongodb的查询基本是按照JSON对象的语法来进行的,所以想要查询数据就按照JSON对象的方式来，所以你能怎么访问就能怎么查询，比如对嵌套对象或者数据对象的数据。</p>
<p><strong>对内嵌对象的查询</strong></p>
<p>如果存在这样的数据:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">db.user.insert(</span><br><span class="line">&#123;</span><br><span class="line">    name:&quot;张三&quot;,</span><br><span class="line">    age:20,</span><br><span class="line">    sex:&quot;男&quot;,</span><br><span class="line">    sale_books:[</span><br><span class="line">        &#123;</span><br><span class="line">            name:&quot;钢铁怎么练成的&quot;,</span><br><span class="line">            price:69</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name:&quot;Spring揭秘&quot;,</span><br><span class="line">            price:87</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name:&quot;MongoDb实战&quot;,</span><br><span class="line">            price:54</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">     address: &#123;</span><br><span class="line">         zipCode: 632185,</span><br><span class="line">         name: &quot;腾讯大学287号&quot;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我现在想要查询MongoDb实战这本书的信息，怎么查？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.user.find(&#123;</span><br><span class="line">    &quot;sale_books.name&quot; : &quot;MongoDb实战&quot;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是运行这条sql语句会返回sale_books数据中其他的数据，如何只返回MongoDb实战的数据呢？这个时候可以考虑使用projection的方式,那么下面这种就可以满足需求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">db.user.find(</span><br><span class="line">&#123;</span><br><span class="line">    &quot;sale_books.name&quot; : &quot;MongoDb实战&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    # $用于遍历数组的下标</span><br><span class="line">    &quot;sale_books.$&quot;:1</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">或者这样</span><br><span class="line"></span><br><span class="line">db.user.find(</span><br><span class="line">sale_books: &#123;</span><br><span class="line">  $elemMatch: &#123;</span><br><span class="line">   name: &quot;MongoDb实战&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;sale_books.$&quot;:1</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>看上去和访问json对象的方式是一样的，没错这就是mongodb的查询方式。</p>
<p>更多的关于数据对象的增删改查可以参考这篇文章(<a href="https://blog.csdn.net/leshami/article/details/55192965">https://blog.csdn.net/leshami/article/details/55192965</a>).</p>
<p>关于query的用法基本可以总结为以下三种:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. equal的查询语法: &#123; &lt;field1&gt;: &lt;value1&gt;, ... &#125;,比如db.inventory.find( &#123; status: &quot;D&quot; &#125; )</span><br><span class="line"></span><br><span class="line">2. 使用查询操作符的查询语法: &#123; &lt;field1&gt;: &#123; &lt;operator1&gt;: &lt;value1&gt; &#125;, ... &#125;,比如db.inventory.find( &#123; status: &#123; $in: [ &quot;A&quot;, &quot;D&quot; ] &#125; &#125; )</span><br><span class="line"></span><br><span class="line">3. &#123;&lt;operator1&gt; : &#123; &lt;field1&gt;: &#123; &lt;operator1&gt;: &lt;value1&gt; &#125;&#125;&#125;,比如or的用法</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="projection的用法"><a href="#projection的用法" class="headerlink" title="projection的用法"></a>projection的用法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># inclusion模式 指定返回的键，不返回其他键</span><br><span class="line">db.collection.find(query, &#123;name: 1, age: 1&#125;)</span><br><span class="line"></span><br><span class="line"># exclusion模式 指定不返回的键,返回其他键,默认会返回_id,如果不想返回需要手动指定</span><br><span class="line">db.collection.find(query, &#123;name: 0, age: 0&#125;)</span><br><span class="line"></span><br><span class="line"># 两种模式不可混用（因为这样的话无法推断其他键是否应返回）</span><br><span class="line"># 错误</span><br><span class="line">db.collection.find(query, &#123;title: 1, by: 0&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 相当于select name from user where age &#x3D; 20;</span><br><span class="line">db.user.find(&#123;age:20&#125;,&#123;name:1&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><p>常用语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.update(&lt;filter&gt;, &lt;update&gt;, &lt;options&gt;)</span><br><span class="line">db.collection.updateOne(&lt;filter&gt;, &lt;update&gt;, &lt;options&gt;)</span><br><span class="line">db.collection.updateMany(&lt;filter&gt;, &lt;update&gt;, &lt;options&gt;)</span><br><span class="line">db.collection.replaceOne(&lt;filter&gt;, &lt;update&gt;, &lt;options&gt;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到关于update的操作主要有三个参数，第一个是查询条件，第二个是需要更新的内容，第三个是一些特殊选项，update的语法也是json格式(记住所有的语法都是json格式)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &lt;update operator&gt;: &#123; &lt;field1&gt;: &lt;value1&gt;, ... &#125;,</span><br><span class="line">  &lt;update operator&gt;: &#123; &lt;field2&gt;: &lt;value2&gt;, ... &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>演示一个例子，如果我想要实现这样的sql语句,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update user set age &#x3D; age + 1 where name &#x3D; &#39;张三&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么对应的mongo查询可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.getCollection(&#39;user&#39;).updateOne(</span><br><span class="line">&#123;</span><br><span class="line">    name:&quot;张三&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    $inc:</span><br><span class="line">        &#123;</span><br><span class="line">            age:1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第三个参数有时候也可能用到，他们的参数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入update指定的对象,true为插入，默认是false，不插入。</span><br><span class="line">multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</span><br><span class="line">writeConcern :可选，抛出异常的级别。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果想要给一条记录新增一个sex的对象，那么可以这样写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.user.update(&#123;name:&quot;张三&quot;&#125;,&#123;$set:&#123;sex:&quot;male&quot;&#125;&#125;,&#123;upsert:true&#125;)</span><br></pre></td></tr></table></figure>

<p>update支持的操作符在这里可以看到(<a href="https://docs.mongodb.com/manual/reference/operator/update-field/">https://docs.mongodb.com/manual/reference/operator/update-field/</a>)</p>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>删除数据的方法主要有2个,它们的语法格式也很简单，是按照query的语法来进行的，所以删除数据的语法可以参考查询数据那一节。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.deleteMany()</span><br><span class="line">db.collection.deleteOne()</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="备份数据"><a href="#备份数据" class="headerlink" title="备份数据"></a>备份数据</h4><p>导出只能在本地命令行执行而不是mongo shell中执行，所以不用用mongo先进入到命令行界面，如果时导出本地数据则不用添加-h参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongoexport -h host:port -u username -p password -d databaseName -c collectionName -o exportFilePath --type json&#x2F;csv -f field</span><br><span class="line"></span><br><span class="line">参数说明:</span><br><span class="line">    -h : 主机地址</span><br><span class="line">    -u : 用户名</span><br><span class="line">    -p ：密码</span><br><span class="line">    -d ：数据库名</span><br><span class="line">    -c ：collection名</span><br><span class="line">    -o ：输出的文件名</span><br><span class="line">    --type ： 输出的格式，默认为json，可选为CSV</span><br><span class="line">    -f ：输出的字段，如果-type为csv，则需要加上-f &quot;字段名&quot;</span><br><span class="line"></span><br><span class="line">mongoexport -h localhost:27017</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongoimport -h host:port -u username -p password  -d dbname -c collectionname --file filename --headerline --type json&#x2F;csv -f field</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">    -h : 主机地址</span><br><span class="line">    -d ：数据库名</span><br><span class="line">    -c ：collection名</span><br><span class="line">    --type ：导入的格式默认json</span><br><span class="line">    -f ：导入的字段名</span><br><span class="line">    --headerline ：如果导入的格式是csv，则可以使用第一行的标题作为导入的字段</span><br><span class="line">    --file ：要导入的文件</span><br><span class="line"></span><br><span class="line">mongoimport -h localhost:27017 -d local-test -c userSetting --file E:&#x2F;userSetting.json --type json</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h4><p>在mysql里面我可以用mysql命令直接运行脚本，在mongo里面我们同样可以，只是mongo里面的脚本就是js,这里面你可以用上面用到的任何一个方法，insert,find,update,delete之类的，这个脚本里面就是js语法，js的一些特性也是可以使用的。比如我想向不同国家的user中插入一条数据</p>
<p>user.js文件内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertUser</span>(<span class="params">country</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> collectionName = <span class="string">&quot;user_info&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> userData = db.getCollection(collectionName).find(&#123;<span class="string">&quot;country&quot;</span>:country&#125;);</span><br><span class="line">    <span class="keyword">var</span> desc = <span class="string">&quot;Hello, my country is &quot;</span> + country;</span><br><span class="line">    db.getCollection(collectionName).insert(&#123;<span class="string">&quot;conuntry&quot;</span>:country,<span class="string">&quot;desc&quot;</span>:desc&#125;);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="string">&quot;CN&quot;</span>,<span class="string">&quot;UK&quot;</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;insertUser(c)&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在命令行执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo host:port&#x2F;databaseName filePath.js</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>即可,或者在mongo shell中采用load的方式执行即可，需要注意的是如果语法有错误可能会说报file doesn’t exist的问题。这个时候可以加上–quiet的方式会有一些错误提示。如果想查看更多的参数使用mongo –help的方式查看</p>
]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>StampedLock--比读写锁更快的锁</title>
    <url>/2020/12/25/StampedLock-analysis/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ReentrantReadWriteLock支持读写锁，StampedLock支持写锁、悲观锁读和乐观读(无锁)。其中写锁、悲观读锁的语义和ReentrantReadWriteLock中的写锁、读锁语义一样，都是允许多个线程同时获取悲观锁读，但是只允许一个线程获取写锁，写锁和悲观读锁是互斥的。</p>
<p>不同的是：StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp。</p>
<a id="more"></a>


<p>以下为官方使用例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> stamp = sl.writeLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      x += deltaX;</span><br><span class="line">      y += deltaY;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      sl.unlockWrite(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> stamp = sl.tryOptimisticRead();</span><br><span class="line">    <span class="keyword">double</span> currentX = x, currentY = y;</span><br><span class="line">    <span class="keyword">if</span> (!sl.validate(stamp)) &#123;</span><br><span class="line">        stamp = sl.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          currentX = x;</span><br><span class="line">          currentY = y;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          sl.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果处理业务需要保持互斥，那么就用互斥锁，如果不需要保持互斥才可以</span></span><br><span class="line">    <span class="comment">// 用读写锁。一般来讲缓存是不需要保持互斥性的，能接受瞬间的不一致</span></span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// StampedLock 支持锁的降级（通过 tryConvertToReadLock() 方法）和升级（通过tryConvertToWriteLock() 方法）</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> stamp = sl.readLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp);</span><br><span class="line">        <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123;</span><br><span class="line">          stamp = ws;</span><br><span class="line">          x = newX;</span><br><span class="line">          y = newY;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          sl.unlockRead(stamp);</span><br><span class="line">          stamp = sl.writeLock();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      sl.unlock(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主要数据结构"><a href="#主要数据结构" class="headerlink" title="主要数据结构"></a>主要数据结构</h3><p>虽然StampedLock没有使用AQS，不过它的数据结构中还是用到了CLH队列。</p>
<p>WNode是CLH队列的节点，其源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WNode</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 前驱节点</span></span><br><span class="line">  <span class="keyword">volatile</span> WNode prev;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后继节点</span></span><br><span class="line">  <span class="keyword">volatile</span> WNode next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取读锁的列表</span></span><br><span class="line">  <span class="keyword">volatile</span> WNode cowait;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程</span></span><br><span class="line">  <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 节点状态。0, WAITING, or CANCELLED</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> status;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 读模式或者写模式。RMODE or WMODE</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> mode;  </span><br><span class="line">  WNode(<span class="keyword">int</span> m, WNode p) &#123; mode = m; prev = p; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>StampedLock中其中重要属性如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CLH队列头结点</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode whead;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// CLH队列尾节点</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode wtail;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 锁状态</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 读锁次数的额外计数器</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> readerOverflow;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 读锁的位数</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LG_READERS = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 计算state值常量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RUNIT = <span class="number">1L</span>;</span><br><span class="line"> <span class="comment">// 写锁标志位，十进制：128 二进制：1000 0000</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WBIT  = <span class="number">1L</span> &lt;&lt; LG_READERS;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 读状态标志位。 十进制:127  二进制: 0111 1111</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RBITS = WBIT - <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// state状态中记录读锁快满了的值,126</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RFULL = RBITS - <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 用来获取读写状态。 十进制：255 二进制：1111 1111</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABITS = RBITS | WBIT;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// -128 (1....1 1000 0000)</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SBITS = ~RBITS;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 状态state的初始值 256 二进制： 00001 0000 0000</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ORIGIN = WBIT &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 锁的状态。使用state来控制当前是读锁，还是写锁</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 额外的读锁计数器</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> readerOverflow;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// state初始值为256</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">StampedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     state = ORIGIN;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>看过我之前分析AQS源码的应该对这个CLH很熟悉了。同样的StampedLock也是通过这个stae变量来进行读写锁判断的。这个state承载了三个部分的内容</p>
<p><img data-src="/images/java/stampedlock-state.png" alt="状态位"></p>
<p>StampedLock中state是long类型，占64位，它被划为了三个部分来使用。低7位作为读锁标志位，可以由多个线程共享，每有一个线程申请读锁成功，低7位就加1。第8位是写锁位，由线程独占。<br>其余位是stamp位，用来记录写锁状态的变化(版本号)，每使用一次写锁，stamp位就会加1。</p>
<p>同时如果读锁数量超过了126之后，超出的次数使用readerOverflow来进行计数。</p>
<p>当出现并发的情况的时候，CLH队列的排队情况是怎样的呢？</p>
<p>比如，线程w1获取了写锁，一直未释放。此时有4个线程分别获取读锁(获取顺序是R0–&gt;R1–&gt;R2–&gt;R3),又有线程W2获取写锁，最后还有R4,R5,R6三个线程获取读锁,那么此时队列的排队情况如下</p>
<p><img data-src="/images/java/stamped-lock-clh.png" alt="CLH"></p>
<p>因为读锁是可以被多个线程获取的，如果同一时间有多个线程来获取读锁却获取不到时，这个时候第一个获取读锁的线程会被加入到链表中，而后面的的读线程会被加入到cowait栈中,<br>可以认为cowait是一条副链。</p>
<p>这里的cowait可以理解为协同等待，表示将这些获取读锁的线程作为一个整体来获取锁。</p>
<h3 id="获取乐观读锁"><a href="#获取乐观读锁" class="headerlink" title="获取乐观读锁"></a>获取乐观读锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryOptimisticRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s;</span><br><span class="line">    <span class="keyword">return</span> (((s = state) &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乐观读锁逻辑比较简单，就是判断写锁是否被占用(判断state第8位的值是否为1)，如果写锁被占用则返回0，否则返回stamp位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">state初始值为256(1 0000 0000)</span><br><span class="line"></span><br><span class="line">  01000 0000(WBIT)</span><br><span class="line">&amp; 10000 0000(state)</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">  00000 0000</span><br><span class="line"></span><br><span class="line"> 1 0000 0000(state)</span><br><span class="line"> 1 1000 0000(SBITS)</span><br><span class="line"> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> 1 0000 0000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="检测乐观读锁"><a href="#检测乐观读锁" class="headerlink" title="检测乐观读锁"></a>检测乐观读锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过UNSafe插入内存屏障，禁止重排序</span></span><br><span class="line">  U.loadFence();</span><br><span class="line">  <span class="keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回true: 表示期间没有写锁，不关心读锁。</p>
<p>返回false: 表示期间有写锁发生</p>
<p>SBITS为-128，用二进制表示是：<code>1111 1111 1111 1000 0000</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x xxxx xxxx(stamp)</span><br><span class="line">1 1000 0000</span><br><span class="line"></span><br><span class="line">1 yyyy yyyy(state)</span><br><span class="line">1 1000 0000</span><br></pre></td></tr></table></figure>
<p>SBITS后7位都是0，也就是不关心读锁，我们只关心stamp位和写位。</p>
<p>当我们获取乐观读时，如果此时已经有了写锁，那么返回stamp值为0，此时进行验证肯定为false。</p>
<h3 id="获取普通读锁"><a href="#获取普通读锁" class="headerlink" title="获取普通读锁"></a>获取普通读锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> s = state, next;</span><br><span class="line">  <span class="comment">// whead == wtail时，队列为空，表示当前没有线程在排队</span></span><br><span class="line">  <span class="keyword">return</span> ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;</span><br><span class="line">           U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + RUNIT)) ?</span><br><span class="line">           <span class="comment">// acquireRead的第一个参数为false，标识不处理线程中断</span></span><br><span class="line">          next : acquireRead(<span class="keyword">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当获取读锁成功时，会将state值加1。当条件不满足时(队列不为空,CAS失败，或者读锁的个数已经大于等于126),都会进入到<code>acquireRead()</code>方法，这个方法主要分为两个大的for循环，代码比较长我就不贴出来了。</p>
<p>它的主要逻辑如下：</p>
<ol>
<li>如果当前队列没有排队的线程，该线程是第一个准备排队的元素，就有很大机会获取到锁，所以会先自旋尝试获取到锁(自旋次数为64)，如果获取到了将state值加1，如果读锁次数已经超出了126，则使用readerOverflow记录超出的读锁数目。如果未获取到锁，则进入第2步</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">tryIncReaderOverflow</span><span class="params">(<span class="keyword">long</span> s)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 如果读锁的记录数等于126,</span></span><br><span class="line">  <span class="keyword">if</span> ((s &amp; ABITS) == RFULL) &#123;</span><br><span class="line">      <span class="comment">// 将state的值加1</span></span><br><span class="line">      <span class="comment">// CAS之后state的后七位的值是127，state的整个值是383(1 0111 1111)。</span></span><br><span class="line">      <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s | RBITS)) &#123;</span><br><span class="line">          <span class="comment">// 将readOverflow的值加1</span></span><br><span class="line">          ++readerOverflow;</span><br><span class="line">          state = s;</span><br><span class="line">          <span class="keyword">return</span> s;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((LockSupport.nextSecondarySeed() &amp;</span><br><span class="line">            OVERFLOW_YIELD_RATE) == <span class="number">0</span>)</span><br><span class="line">      Thread.yield();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>初始化入队排队节点，形成链表关系。和AQS一样的是head节点被当成哨兵节点或者正持有锁正在运行的线程(虚拟)。所以head节点的thread为null,mode的值为WMODE。这样会形成<br><code>head --&gt; node &lt;-- tail</code>这样的节点关系</p>
</li>
<li><p>如果又有新的线程获取读锁失败，会将新的线程加入到cowait栈中</p>
</li>
<li><p>对于不是第一个获取读锁的线程，它会先加入到cowait这个栈中，然后再通过CAS获取锁，如果获取失败就被阻塞,等待被唤醒或者由于超时中断被取消。</p>
</li>
<li><p>会对第一个获取读锁的线程进行优待，因为它前面没有在排队的线程，所以这一层还是在自旋获取锁，只是自旋次数再增加，首先会自旋1024次获得锁，如果还未获取到，在自旋2048次。<br>如果还未等到锁释放，就阻塞当前线程，等待被唤醒，直到获得锁或者超时中断被取消。</p>
</li>
</ol>
<p>第1-4步属于一个大的循环，第5步骤属于另外一个大的循环。</p>
<p>同时当获取读锁线程被唤醒获取到锁后，它同时也会唤醒挂在它身上的cowait栈中的线程。</p>
<p>从分析中可以看到StampedLock中通过大量的自旋操作可以一定程度避免线程阻塞，只要线程执行操作够快，释放锁比较及时，可以说几乎不会存在阻塞。</p>
<h3 id="释放读锁"><a href="#释放读锁" class="headerlink" title="释放读锁"></a>释放读锁</h3><p>释放读锁的代码比较简单，主要操作如下</p>
<ol>
<li>首先判断stamp是否合法，如果不合法则抛出<code>IllegalMonitorStateException</code>异常</li>
<li>如果读锁个数小于126，则通过CAS将state值减去1,如果释放的是最后一个读锁，则需要唤醒队列中的节点。</li>
<li>如果读锁个数已经溢出了，则将readerOverflow减去1</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockRead</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> s, m; WNode h;</span><br><span class="line">  <span class="comment">// 自旋</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 判断stamp是否合法</span></span><br><span class="line">      <span class="keyword">if</span> (((s = state) &amp; SBITS) != (stamp &amp; SBITS) ||</span><br><span class="line">          (stamp &amp; ABITS) == <span class="number">0L</span> || (m = s &amp; ABITS) == <span class="number">0L</span> || m == WBIT)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">      <span class="comment">// 读锁个数小于126</span></span><br><span class="line">      <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">          <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s - RUNIT)) &#123;</span><br><span class="line">              <span class="comment">// 释放最后一个读锁时，需要唤醒下一个节点</span></span><br><span class="line">              <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                  release(h);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 读锁个数饱和溢出，需要减少readerOverflow</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (tryDecReaderOverflow(s) != <span class="number">0L</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取写锁"><a href="#获取写锁" class="headerlink" title="获取写锁"></a>获取写锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">writeLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> s, next;</span><br><span class="line">  <span class="keyword">return</span> ((((s = state) &amp; ABITS) == <span class="number">0L</span> &amp;&amp;</span><br><span class="line">           U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + WBIT)) ?</span><br><span class="line">          next : acquireWrite(<span class="keyword">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果state中的第8位等于0并且CAS设置state值成功，则获取锁成功，否则进入到<code>acquireWrite</code>方法。</p>
<p>acquireWrite的逻辑也分为两部分，分别是两个for循环。</p>
<p>第一个for循环逻辑如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> spins = -<span class="number">1</span>;;) &#123; <span class="comment">// spin while enqueuing</span></span><br><span class="line">    <span class="keyword">long</span> m, s, ns;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前写锁标志位仍然为0，即没有其他线程获取到写锁</span></span><br><span class="line">    <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) == <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="comment">// CAS将state的值加128，实质是将写锁状态位加1</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, ns = s + WBIT))</span><br><span class="line">            <span class="keyword">return</span> ns;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他线程获取到了写锁，则设定自旋次数为64次</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">        spins = (m == WBIT &amp;&amp; wtail == whead) ? SPINS : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 随机减少自旋次数</span></span><br><span class="line">        <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span>)</span><br><span class="line">            --spins;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自旋仍未获取到写锁则执行下面的逻辑</span></span><br><span class="line">    <span class="comment">// 初始化CLH队列(主要是whead,wtail节点)</span></span><br><span class="line">    <span class="comment">// p指向了wtail节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((p = wtail) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        WNode hd = <span class="keyword">new</span> WNode(WMODE, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WHEAD, <span class="keyword">null</span>, hd))</span><br><span class="line">            wtail = hd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        node = <span class="keyword">new</span> WNode(WMODE, p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终形成 whead --&gt; node &lt;-- wtail</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node.prev != p)</span><br><span class="line">        node.prev = p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WTAIL, p, node)) &#123;</span><br><span class="line">        p.next = node;</span><br><span class="line">        <span class="comment">// 形成链表关系之后自旋结束</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个for循环代码也比较长，我就不贴出来了。它的核心逻辑如下</p>
<ol>
<li><p>如果仍然只有当前线程在等待锁，则会先自旋1024次去获取写锁，如果获取失败，则在自旋2048次再次去获取。如果都获取失败，则进入第二步。</p>
</li>
<li><p>阻塞当前线程等待被唤醒</p>
</li>
</ol>
<h3 id="释放写锁"><a href="#释放写锁" class="headerlink" title="释放写锁"></a>释放写锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">  WNode h;</span><br><span class="line">  <span class="comment">// 验证stamp是否合法</span></span><br><span class="line">  <span class="keyword">if</span> (state != stamp || (stamp &amp; WBIT) == <span class="number">0L</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放写锁，stamp位(版本号)加1</span></span><br><span class="line">  <span class="comment">// stamp+WBIT会将state的第8位置为0，就相当于释放了写锁</span></span><br><span class="line">  state = (stamp += WBIT) == <span class="number">0L</span> ? ORIGIN : stamp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果头结点不为空，并且状态不为0,,则调用release方法唤醒下一个节点</span></span><br><span class="line">  <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">      release(h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(WNode h)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">    WNode q; Thread w;</span><br><span class="line">    U.compareAndSwapInt(h, WSTATUS, WAITING, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果头结点的下一个节点为空或者其状态为已取消</span></span><br><span class="line">    <span class="keyword">if</span> ((q = h.next) == <span class="keyword">null</span> || q.status == CANCELLED) &#123;</span><br><span class="line">        <span class="comment">// 从尾结点向前遍历找到可用节点</span></span><br><span class="line">      <span class="keyword">for</span> (WNode t = wtail; t != <span class="keyword">null</span> &amp;&amp; t != h; t = t.prev)</span><br><span class="line">        <span class="keyword">if</span> (t.status &lt;= <span class="number">0</span>)</span><br><span class="line">          q = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒q节点所在的线程</span></span><br><span class="line">    <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; (w = q.thread) != <span class="keyword">null</span>)</span><br><span class="line">        U.unpark(w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>释放写锁过程总结如下</p>
<ol>
<li>将state的第8位置为0(释放写锁)，并将stamp位(version)加1</li>
<li>唤醒下一个节点</li>
</ol>
<h3 id="锁的降级-tryConvertToReadLock"><a href="#锁的降级-tryConvertToReadLock" class="headerlink" title="锁的降级(tryConvertToReadLock)"></a>锁的降级(tryConvertToReadLock)</h3><p>tryConvertToReadLock方法可以用于锁的降级。不过并不是只有再获取读锁时才能调用该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryConvertToReadLock</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// a为锁标识，m则是最新的锁标识</span></span><br><span class="line">  <span class="keyword">long</span> a = stamp &amp; ABITS, m, s, next; WNode h;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// state的写锁标志位和版本号一致(有可能写锁标志位是0，即可能是读锁)</span></span><br><span class="line">  <span class="keyword">while</span> (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还未添加任何锁标识</span></span><br><span class="line">    <span class="keyword">if</span> ((m = s &amp; ABITS) == <span class="number">0L</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a != <span class="number">0L</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// 读锁次数小于126</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">        <span class="comment">// 将state的值加1</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + RUNIT))</span><br><span class="line">          <span class="keyword">return</span> next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 读锁次数已经超出了，使用额外字段记录</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ((next = tryIncReaderOverflow(s)) != <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前是写锁状态</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m == WBIT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a != m)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 将读锁次数加1，写锁标志置为0，stamp位加1。即加129</span></span><br><span class="line">        state = next = s + (WBIT + RUNIT);</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">          release(h);</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经是读锁了直接返回</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a != <span class="number">0L</span> &amp;&amp; a &lt; WBIT)</span><br><span class="line">        <span class="keyword">return</span> stamp;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 转换失败</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的主要逻辑如下，如果当前线程还未加任何锁，则加上写锁并返回最新的stamp值。如果当前线程已经是写锁，则释放写锁，并更新state的值(读锁加1,写锁状态为置为0，version加1)。<br>如果当前线程是读锁则直接返回stamp值。如果上面条件都不满足，则转换失败。</p>
<h3 id="锁的升级-tryConvertToWriteLock"><a href="#锁的升级-tryConvertToWriteLock" class="headerlink" title="锁的升级(tryConvertToWriteLock)"></a>锁的升级(tryConvertToWriteLock)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryConvertToWriteLock</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> a = stamp &amp; ABITS, m, s, next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// state的写锁标志位和版本号一致(有可能写锁标志位是0，即可能是读锁)</span></span><br><span class="line">  <span class="keyword">while</span> (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 还未添加任何锁标识</span></span><br><span class="line">      <span class="keyword">if</span> ((m = s &amp; ABITS) == <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 将写锁状态位置为0</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + WBIT))</span><br><span class="line">          <span class="keyword">return</span> next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果当前已经是写锁状态，则直接返回</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (m == WBIT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a != m)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">return</span> stamp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果当前是唯一读锁，则转换为写锁</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (m == RUNIT &amp;&amp; a != <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s,</span><br><span class="line">              next = s - RUNIT + WBIT))</span><br><span class="line">          <span class="keyword">return</span> next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁的升级和锁的降级的逻辑类似，这里就不再读过介绍了。</p>
<h3 id="总结以及注意"><a href="#总结以及注意" class="headerlink" title="总结以及注意"></a>总结以及注意</h3><ul>
<li><p>StampedLock没有使用AQS，而是依靠自己实现的同步状态(long state占64位)和变异的CLH队列</p>
</li>
<li><p>StampedLock使用state的低7位标识读锁数量(超出126的使用readerOverflow字段记录)，第8位标识写锁，高56位记录锁的版本，每次释放/获取写锁版本号都会加1</p>
</li>
<li><p>StampedLock中读锁和读锁不阻塞，读锁写锁相互阻塞，写锁和写锁也相互阻塞</p>
</li>
<li><p>StampedLock的连续多个读锁线程，只有第一个是在CLH队列中，后面的会挂在第一个线程的cowait栈中</p>
</li>
<li><p>StampedLock唤醒第一个读线程后，读线程会唤醒它cowait栈的所有读线程(acquireRead()方法中)</p>
</li>
<li><p>StampedLock不支持公平锁，也不支持Condition</p>
</li>
<li><p>StampedLock支持锁的降级和锁的升级</p>
</li>
<li><p>StampedLock中的乐观读操作是无锁的</p>
</li>
<li><p>StampedLock中使用了大量的自旋+CAS操作，适合持有锁时间比较短的任务，持有锁时间长的话不仅会浪费CPU而且仍然会阻塞自己。</p>
</li>
<li><p>线程阻塞在 StampedLock 的 readLock() 或者 writeLock() 上时，此时调用该阻塞线程的 interrupt() 方法，会导致 CPU 飙升。所以，使用 StampedLock 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly() 和写锁 writeLockInterruptibly()</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出HBase</title>
    <url>/2018/11/24/hbase-basic/</url>
    <content><![CDATA[<p>本文全文转载自:<a href="https://www.ibm.com/developerworks/cn/analytics/library/ba-cn-bigdata-hbase/index.html">https://www.ibm.com/developerworks/cn/analytics/library/ba-cn-bigdata-hbase/index.html</a><br>原文中有关于Phoenix的部分使用，个人觉得HBase的内容是最好的，所以只转载了关于HBase部分的，如果下想要看Phoenix,<br>可以查看原文。</p>
<p>提到大数据的存储，大多数人首先联想到的是 Hadoop 和 Hadoop 中的 HDFS 模块。大家熟知的 Spark、以及 Hadoop 的 MapReduce，可以理解为一种计算框架。而 HDFS，我们可以认为是为计算框架服务的存储层。因此不管是 Spark 还是 MapReduce，都需要使用 HDFS 作为默认的持久化存储层。</p>
<p>那么 HBase 又是什么，可以用在哪里，解决什么样的问题？</p>
<p>简单地，我们可以认为 HBase 是一种类似于数据库的存储层，也就是说 HBase 适用于结构化的存储。并且 HBase 是一种列式的分布式数据库，是由当年的 Google 公布的 BigTable 的论文而生。不过这里也要注意 HBase 底层依旧依赖 HDFS 来作为其物理存储，这点类似于 Hive。</p>
<p>可能有的读者会好奇 HBase 于 Hive 的区别，我们简单的梳理一下 Hive 和 HBase 的应用场景：<br>Hive 适合用来对一段时间内的数据进行分析查询，例如，用来计算趋势或者网站的日志。Hive 不应该用来进行实时的查询（Hive 的设计目的，也不是支持实时的查询）。因为它需要很长时间才可以返回结果；HBase 则非常适合用来进行大数据的实时查询，例如 Facebook 用 HBase 进行消息和实时的分析。</p>
<p>对于 Hive 和 HBase 的部署来说，也有一些区别，Hive 一般只要有 Hadoop 便可以工作。而 HBase 则还需要 Zookeeper 的帮助（Zookeeper，是一个用来进行分布式协调的服务，这些服务包括配置服务，维护元信息和命名空间服务）。再而，HBase 本身只提供了 Java 的 API 接口，并不直接支持 SQL 的语句查询，而 Hive 则可以直接使用 HQL（一种类 SQL 语言）。如果想要在 HBase 上使用 SQL，则需要联合使用 Apache Phonenix，或者联合使用 Hive 和 HBase。</p>
<p>但是和上面提到的一样，如果集成使用 Hive 查询 HBase 的数据，则无法绕过 MapReduce，那么实时性还是有一定的损失。Phoenix 加 HBase 的组合则不经过 MapReduce 的框架，因此当使用 Phoneix 加 HBase 的组成，实时性上会优于 Hive 加 HBase 的组合，我们后续也会示例性介绍如何使用两者。最后我们再提下 Hive 和 HBase 所使用的存储层，默认情况下 Hive 和 HBase 的存储层都是 HDFS。但是 HBase 在一些特殊的情况下也可以直接使用本机的文件系统。例如 Ambari 中的 AMS 服务直接在本地文件系统上运行 HBase。</p>
<h3 id="HBase-与传统关系数据库的区别"><a href="#HBase-与传统关系数据库的区别" class="headerlink" title="HBase 与传统关系数据库的区别"></a>HBase 与传统关系数据库的区别</h3><p>首先让我们了解下什么是 ACID。ACID 是指数据库事务正确执行的四个基本要素的缩写，其包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）以及持久性（Durability）。对于一个支持事务（Transaction）的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction Processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求。下面，我们就简单的介绍下这 4 个特性的含义。</p>
<ul>
<li><p>原子性(Atomicity)是指一个事务要么全部执行,要么全部不执行。换句话说，一个事务不可能只执行了一半就停止了。比如一个事情分为两步完成才可以完成，那么这两步必须同时完成，要么一步也不执行，绝不会停留在某一个中间状态。如果事物执行过程中，发生错误，系统会将事物的状态回滚到最开始的状态。</p>
</li>
<li><p>一致性(Consistency)是指事务的运行并不改变数据库中数据的一致性。也就是说，无论并发事务有多少个，但是必须保证数据从一个一致性的状态转换到另一个一致性的状态。例如有 a、b 两个账户，分别都是 10。当 a 增加 5 时，b 也会随着改变，总值 20 是不会改变的。</p>
</li>
<li><p>隔离性（Isolation）是指两个以上的事务不会出现交错执行的状态。因为这样可能会导致数据不一致。如果有多个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。</p>
</li>
<li><p>持久性(Durability)指事务执行成功以后,该事务对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚。</p>
</li>
</ul>
<p>在具体的介绍 HBase 之前，我们先简单对比下 HBase 与传统关系数据库的（RDBMS，全称为 Relational Database Management System）区别。如表 1 所示。</p>
<p>表 1. HBase 与 RDBMS 的区别</p>
<table>
<thead>
<tr>
<th></th>
<th>HBase</th>
<th>RDBMS</th>
</tr>
</thead>
<tbody><tr>
<td>硬件架构</td>
<td>类似于 Hadoop 的分布式集群，硬件成本低廉</td>
<td>传统的多核系统，硬件成本昂贵</td>
</tr>
<tr>
<td>容错性</td>
<td>由软件架构实现，由于由多个节点组成，所以不担心一点或几点宕机</td>
<td>一般需要额外硬件设备实现 HA 机制</td>
</tr>
<tr>
<td>数据库大小</td>
<td>PB</td>
<td>GB、TB</td>
</tr>
<tr>
<td>数据排布方式</td>
<td>稀疏的、分布的多维的 Map</td>
<td>以行和列组织</td>
</tr>
<tr>
<td>数据类型</td>
<td>Bytes</td>
<td>丰富的数据类型</td>
</tr>
<tr>
<td>事物支持</td>
<td>ACID 只支持单个 Row 级别</td>
<td>全面的 ACID 支持，对 Row 和表</td>
</tr>
<tr>
<td>查询语言</td>
<td>只支持 Java API （除非与其他框架一起使用，如 Phoenix、Hive）</td>
<td>SQL</td>
</tr>
<tr>
<td>索引</td>
<td>只支持 Row-key，除非与其他技术一起应用，如 Phoenix、Hive</td>
<td>支持</td>
</tr>
<tr>
<td>吞吐量</td>
<td>百万查询/每秒</td>
<td>数千查询/每秒</td>
</tr>
</tbody></table>
<p>理解了上面的表格之后，我们在看看数据是如何在 HBase 以及 RDBMS 中排布的。首先，数据在 RDBMS 的排布大致如表 2。</p>
<p>表 2. 数据在 RDBMS 中的排布示例</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>姓</th>
<th>名</th>
<th>密码</th>
<th>时间戳</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>张</td>
<td>三</td>
<td>111</td>
<td>20160719</td>
</tr>
<tr>
<td>2</td>
<td>李</td>
<td>四</td>
<td>222</td>
<td>20160720</td>
</tr>
</tbody></table>
<p>那么数据在 HBase 中的排布会是什么样子呢？如表 3 所示（这只是逻辑上的排布）。</p>
<table>
<thead>
<tr>
<th>Row-Key</th>
<th>Value（CF、Qualifier、Version）</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>info{‘姓’: ‘张’，’名’:’三’} pwd{‘密码’: ‘111’}</td>
</tr>
<tr>
<td>2</td>
<td>Info{‘姓’: ‘李’，’名’:’四’} pwd{‘密码’: ‘222’}</td>
</tr>
</tbody></table>
<p>从上面示例表中，我们可以看出，在 HBase 中首先会有 Column Family 的概念，简称为 CF。CF 一般用于将相关的列（Column）组合起来。在物理上 HBase 其实是按 CF 存储的，只是按照 Row-key 将相关 CF 中的列关联起来。物理上的数据排布大致可以如表 4 所示。</p>
<table>
<thead>
<tr>
<th>Row-Key</th>
<th>CF:Column-Key</th>
<th>时间戳</th>
<th>Cell Value</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>info:fn</td>
<td>123456789</td>
<td>三</td>
</tr>
<tr>
<td>1</td>
<td>info:ln</td>
<td>123456789</td>
<td>张</td>
</tr>
<tr>
<td>2</td>
<td>info:fn</td>
<td>123456789</td>
<td>四</td>
</tr>
<tr>
<td>2</td>
<td>info:ln</td>
<td>123456789</td>
<td>李</td>
</tr>
</tbody></table>
<p>我们已经提到 HBase 是按照 CF 来存储数据的。在表 3 中，我们看到了两个 CF，分别是 info 和 pwd。info 存储着姓名相关列的数据，而 pwd 则是密码相关的数据。上表便是 info 这个 CF 存储在 Hbase 中的数据排布。Pwd 的数据排布是类似的。上表中的 fn 和 ln 称之为 Column-key 或者 Qulifimer。在 Hbase 中，Row-key 加上 CF 加上 Qulifier 再加上一个时间戳才可以定位到一个单元格数据（Hbase 中每个单元格默认有 3 个时间戳的版本数据）。初学者，在一开始接触这些概念是很容易混淆。其实不管是 CF 还是 Qulifier 都是客户定义出来的。也就是说在 HBase 中创建表格时，就需要指定表格的 CF、Row-key 以及 Qulifier。我们会在后续的介绍中，尝试指定这些相关的概念，以便加深理解。这里我们先通过下图理解下 HBase 中，逻辑上的数据排布与物理上的数据排布之间的关系。</p>
<p>图 1. Hbase 中逻辑上数据的排布与物理上排布的关联</p>
<p><img data-src="/images/hbase-logic-data.png" alt="Hbase数据分布"></p>
<p>从上图我们看到 Row1 到 Row5 的数据分布在两个 CF 中，并且每个 CF 对应一个 HFile。并且逻辑上每一行中的一个单元格数据，对应于 HFile 中的一行，然后当用户按照 Row-key 查询数据的时候，HBase 会遍历两个 HFile，通过相同的 Row-Key 标识，将相关的单元格组织成行返回，这样便有了逻辑上的行数据。讲解到这，我们就大致了解 HBase 中的数据排布格式，以及与 RDBMS 的一些区别。</p>
<p>对于 RDBMS 来说，一般都是以 SQL 作为为主要的访问方式。而 HBase 是一种”NoSQL”数据库。”NoSQL”是一个通用词表示该数据库并不是 RDBMS 。现在的市面上有许多种 NoSQL 数据库，如 BerkeleyDB 是本地 NoSQL 数据库的例子, HBase 则为大型分布式 NoSql 数据库。从技术上来说，Hbase 更像是”数据存储”而非”数据库”（HBase 和 HDFS 都属于大数据的存储层）。因此，HBase 缺少很多 RDBMS 特性，如列类型，二级索引，触发器和高级查询语言等。然而, HBase 也具有许多其他特征同时支持线性化和模块化扩充。最明显的方式，我们可以通过增加 Region Server 的数量扩展 HBase。并且 HBase 可以放在普通的服务器中，例如将集群从 5 个扩充到 10 个 Region Server 时，存储空间和处理容量都可以同时翻倍。当然 RDBMS 也能很好的扩充，但仅对一个点，尤其是对一个单独数据库服务器而言，为了更好的性能，往往需要特殊的硬件和存储设备（往往价格也非常昂贵）。</p>
<h3 id="HBase-相关的模块以及-HBase-表格的特性"><a href="#HBase-相关的模块以及-HBase-表格的特性" class="headerlink" title="HBase 相关的模块以及 HBase 表格的特性"></a>HBase 相关的模块以及 HBase 表格的特性</h3><p>在这里，让我们了解下 HBase 都有哪些模块，以及大致的工作流程。前面我们提到过 HBase 也是构建于 HDFS 之上，这是正确的，但也不是完全正确。HBase 其实也支持直接在本地文件系统之上运行，不过这样的 HBase 只能运行在一台机器上，那么对于分布式大数据的环境是没有意义的（这也是所谓的 HBase 的单机模式）。一般只用于测试或者验证某一个 HBase 的功能，后面我们在详细的介绍 HBase 的几种运行模式。这里我们只要记得在分布式的生产环境中，HBase 需要运行在 HDFS 之上，以 HDFS 作为其基础的存储设施。HBase 上层提供了访问的数据的 Java API 层，供应用访问存储在 HBase 的数据。在 HBase 的集群中主要由 Master 和 Region Server 组成，以及 Zookeeper，具体模块如下图所示。</p>
<p><img data-src="/images/hbase-module.png" alt="组成Hbase模块"></p>
<p>接下来，我们简单的一一介绍下 HBase 中相关模块的作用。</p>
<ol>
<li><p>Master</p>
<p> HBase Master 用于协调多个 Region Server，侦测各个 Region Server 之间的状态，并平衡 Region Server 之间的负载。HBase Master 还有一个职责就是负责分配 Region 给 Region Server。HBase 允许多个 Master 节点共存，但是这需要 Zookeeper 的帮助。不过当多个 Master 节点共存时，只有一个 Master 是提供服务的，其他的 Master 节点处于待命的状态。当正在工作的 Master 节点宕机时，其他的 Master 则会接管 HBase 的集群。</p>
</li>
<li><p>Region Server</p>
<p> 对于一个 Region Server 而言，其包括了多个 Region。Region Server 的作用只是管理表格，以及实现读写操作。Client 直接连接 Region Server，并通信获取 HBase 中的数据。对于 Region 而言，则是真实存放 HBase 数据的地方，也就说 Region 是 HBase 可用性和分布式的基本单位。如果当一个表格很大，并由多个 CF 组成时，那么表的数据将存放在多个 Region 之间，并且在每个 Region 中会关联多个存储的单元（Store）。</p>
</li>
<li><p>Zookeeper</p>
<p> 对于 HBase 而言，Zookeeper 的作用是至关重要的。首先 Zookeeper 是作为 HBase Master 的 HA 解决方案。也就是说，是 Zookeeper 保证了至少有一个 HBase Master 处于运行状态。并且 Zookeeper 负责 Region 和 Region Server 的注册。其实 Zookeeper 发展到目前为止，已经成为了分布式大数据框架中容错性的标准框架。不光是 HBase，几乎所有的分布式大数据相关的开源框架，都依赖于 Zookeeper 实现 HA。</p>
</li>
</ol>
<p>一个完整分布式的 HBase 的工作原理示意图如下：<br><img data-src="/images/hbase-work-process.png" alt="Hbase工作原理图"></p>
<p>在上面的图中，我们需要注意几个我们之前没有提到的概念：Store、MemStore、StoreFile 以及 HFile。带着这几个新的概念，我们完整的梳理下整个 HBase 的工作流程。</p>
<p>首先我们需要知道 HBase 的集群是通过 Zookeeper 来进行机器之前的协调，也就是说 HBase Master 与 Region Server 之间的关系是依赖 Zookeeper 来维护。当一个 Client 需要访问 HBase 集群时，Client 需要先和 Zookeeper 来通信，然后才会找到对应的 Region Server。每一个 Region Server 管理着很多个 Region。对于 HBase 来说，Region 是 HBase 并行化的基本单元。因此，数据也都存储在 Region 中。这里我们需要特别注意，每一个 Region 都只存储一个 Column Family 的数据，并且是该 CF 中的一段（按 Row 的区间分成多个 Region）。Region 所能存储的数据大小是有上限的，当达到该上限时（Threshold），Region 会进行分裂，数据也会分裂到多个 Region 中，这样便可以提高数据的并行化，以及提高数据的容量。每个 Region 包含着多个 Store 对象。每个 Store 包含一个 MemStore，和一个或多个 HFile。MemStore 便是数据在内存中的实体，并且一般都是有序的。当数据向 Region 写入的时候，会先写入 MemStore。当 MemStore 中的数据需要向底层文件系统倾倒（Dump）时（例如 MemStore 中的数据体积到达 MemStore 配置的最大值），Store 便会创建 StoreFile，而 StoreFile 就是对 HFile 一层封装。所以 MemStore 中的数据会最终写入到 HFile 中，也就是磁盘 IO。由于 HBase 底层依靠 HDFS，因此 HFile 都存储在 HDFS 之中。这便是整个 HBase 工作的原理简述。</p>
<p>我们了解了 HBase 大致的工作原理，那么在 HBase 的工作过程中，如何保证数据的可靠性呢？带着这个问题，我们理解下 HLog 的作用。HBase 中的 HLog 机制是 WAL 的一种实现，而 WAL（一般翻译为预写日志）是事务机制中常见的一致性的实现方式。每个 Region Server 中都会有一个 HLog 的实例，Region Server 会将更新操作（如 Put，Delete）先记录到 WAL（也就是 HLog）中，然后将其写入到 Store 的 MemStore，最终 MemStore 会将数据写入到持久化的 HFile 中（MemStore 到达配置的内存阀值）。这样就保证了 HBase 的写的可靠性。如果没有 WAL，当 Region Server 宕掉的时候，MemStore 还没有写入到 HFile，或者 StoreFile 还没有保存，数据就会丢失。或许有的读者会担心 HFile 本身会不会丢失，这是由 HDFS 来保证的。在 HDFS 中的数据默认会有 3 份。因此这里并不考虑 HFile 本身的可靠性。</p>
<p>前面，我们很多次提到了 HFile，也就是 HBase 持久化的存储文件。也许有的读者还不能完全理解 HFile，这里我们便详细的看看 HFile 的结构，如下图。</p>
<p><img data-src="/images/hbase-hfile.png" alt="HFile结构图"></p>
<p>从图中我们可以看到 HFile 由很多个数据块（Block）组成，并且有一个固定的结尾块。其中的数据块是由一个 Header 和多个 Key-Value 的键值对组成。在结尾的数据块中包含了数据相关的索引信息，系统也是通过结尾的索引信息找到 HFile 中的数据。HFile 中的数据块大小默认为 64KB。如果访问 HBase 数据库的场景多为有序的访问，那么建议将该值设置的大一些。如果场景多为随机访问，那么建议将该值设置的小一些。一般情况下，通过调整该值可以提高 HBase 的性能。</p>
<p>如果要用很短的一句话总结 HBase，我们可以认为 HBase 就是一个有序的多维 Map，其中每一个 Row-key 映射了许多数据，这些数据存储在 CF 中的 Column。我们可以用下图来表示这句话。</p>
<p><img data-src="/images/hbase-data-reflect.png" alt="Hbase数据映射"></p>
<h3 id="HBase-的使用建议"><a href="#HBase-的使用建议" class="headerlink" title="HBase 的使用建议"></a>HBase 的使用建议</h3><p>之前我介绍了很多 HBase 与 RDBMS 的区别，以及一些优势的地方。那么什么时候最需要 HBase，或者说 HBase 是否可以替代原有的 RDBMS？对于这个问题，我们必须时刻谨记——HBase 并不适合所有问题，其设计目标并不是替代 RDBMS，而是对 RDBMS 的一个重要补充，尤其是对大数据的场景。当需要考量 HBase 作为一个备选项时，我们需要进行如下的调研工作。</p>
<p>首先，要确信有足够多数据，如果有上亿或上千亿行数据，HBase 才会是一个很好的备选。其次，需要确信业务上可以不依赖 RDBMS 的额外特性，例如，列数据类型, 二级索引，SQL 查询语言等。再而，需要确保有足够硬件。且不说 HBase，一般情况下当 HDFS 的集群小于 5 个数据节点时，也干不好什么事情 (HDFS 默认会将每一个 Block 数据备份 3 分)，还要加上一个 NameNode。</p>
<p>以下我给了一些使用 HBase 时候对表格设计的一些建议，读者也可以理解背后的含义。不过我并不希望这些建议成为使用 HBase 的教条，毕竟也有不尽合理的地方。首先，一个 HBase 数据库是否高效，很大程度会和 Row-Key 的设计有关。因此，如何设计 Row-key 是使用 HBase 时，一个非常重要的话题。随着数据访问方式的不同，Row-Key 的设计也会有所不同。不过概括起来的宗旨只有一个，那就是尽可能选择一个 Row-Key，可以使你的数据均匀的分布在集群中。这也很容易理解，因为 HBase 是一个分布式环境，Client 会访问不同 Region Server 获取数据。如果数据排布均匀在不同的多个节点，那么在批量的 Client 便可以从不同的 Region Server 上获取数据，而不是瓶颈在某一个节点，性能自然会有所提升。对于具体的建议我们一般有几条：</p>
<ol>
<li>当客户端需要频繁的写一张表，随机的 RowKey 会获得更好的性能。</li>
<li>当客户端需要频繁的读一张表，有序的 RowKey 则会获得更好的性能。</li>
<li>对于时间连续的数据（例如 log），有序的 RowKey 会很方便查询一段时间的数据（Scan 操作）。</li>
</ol>
<p>上面我们谈及了对 Row-Key 的设计，接着我们需要想想是否 Column Family 也会在不同的场景需要不同的设计方案呢。答案是肯定的，不过 CF 跟 Row-key 比较的话，确实也简单一些，但这并不意味着 CF 的设计就是一个琐碎的话题。在 RDBMS（传统关系数据库）系统中，我们知道如果当用户的信息分散在不同的表中，便需要根据一个 Key 进行 Join 操作。而在 HBase 中，我们需要设计 CF 来聚合用户所有相关信息。简单来说，就是需要将数据按类别（或者一个特性）聚合在一个或多个 CF 中。这样，便可以根据 CF 获取这类信息。上面，我们讲解过一个 Region 对应于一个 CF。那么设想，如果在一个表中定义了多个 CF 时，就必然会有多个 Region。当 Client 查询数据时，就不得不查询多个 Region。这样性能自然会有所下降，尤其当 Region 夸机器的时候。因此在大多数的情况下，一个表格不会超过 2 到 3 个 CF，而且很多情况下都是 1 个 CF 就足够了。</p>
]]></content>
      <categories>
        <category>HBase</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka consumer如何加入consumer group</title>
    <url>/2019/05/15/how-to-join-kafka-consumer-group/</url>
    <content><![CDATA[<p>consumer比producer要复杂许多,producer没有组的概念，也不需要关注offset,而consumer不一样,它有组织(consumer group)，有纪律(offset)。这些对consumer的要求就会很高，这篇文章就先从consumer如何加入consumer group说起。</p>
<p>GroupCoordinator是运行在服务器上的一个服务,负责consumer以及offset的管理。消费者客户端的ConsumerCoordinator负责与GroupCoordinator进行通信。Broker在启动的时候，都会启动一个GroupCoordinator服务。</p>
<h3 id="如何找到对应的GroupCoordinator节点？"><a href="#如何找到对应的GroupCoordinator节点？" class="headerlink" title="如何找到对应的GroupCoordinator节点？"></a>如何找到对应的GroupCoordinator节点？</h3><p>对于 consumer group 而言，是根据其 group.id 进行 hash 并通过一定的计算得到其具对应的 partition 值(计算方式如下)，该 partition leader 所在 Broker 即为该 Group 所对应的 GroupCoordinator，GroupCoordinator 会存储与该 group 相关的所有的 Meta 信息。</p>
<blockquote>
<p>__consumer_offsets 这个topic 是 Kafka 内部使用的一个 topic，专门用来存储 group 消费的情况，默认情况下有50个 partition，每个 partition 默认三个副本。<br>partition计算方式：abs(GroupId.hashCode()) % NumPartitions(其中，NumPartitions 是 __consumer_offsets 的 partition 数，默认是50个)。<br>比如，现在通过计算abs(GroupId.hashCode()) % NumPartitions的值为35,那么就找第35个partition的leader在哪个broker(假设在192.168.1.12),那么GroupCoordinator节点就在这个broker。</p>
</blockquote>
<p>同时这个消费者所提交的消费位移信息也会发送给这个partition leader所对应的broker节点，因此这个节点不仅是GroupCoordinator而且还保存分区分配方案和组内消费者位移。</p>
<a id="more"></a>

<h3 id="消息消费流程"><a href="#消息消费流程" class="headerlink" title="消息消费流程"></a>消息消费流程</h3><p>先来回顾下消费消息的流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建消费者</span></span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅主题</span></span><br><span class="line">consumer.subscribe(Collections.singletonList(<span class="string">&quot;consumerCodeTopic&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从服务端拉取数据</span></span><br><span class="line">ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码就是消费消息的主体流程,在创建KafkaConsumer的时候会先创建ConsumerCoordinator,由它来负责和GroupCoordinator通信</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.coordinator = <span class="keyword">new</span> ConsumerCoordinator(...);</span><br></pre></td></tr></table></figure>

<p>接着就开始订阅主题，订阅的方式有好几种，我在上一篇文章有提到过。订阅的时候会设置当前订阅类型为SubscriptionType.AUTO_TOPICS,默认存在五种类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriptionState</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">enum</span> SubscriptionType &#123;</span><br><span class="line">    <span class="comment">// 默认</span></span><br><span class="line">    NONE,</span><br><span class="line">    <span class="comment">// subscribe方式 </span></span><br><span class="line">    AUTO_TOPICS, </span><br><span class="line">    <span class="comment">// pattern方式订阅</span></span><br><span class="line">    AUTO_PATTERN,</span><br><span class="line">    <span class="comment">// assign方式</span></span><br><span class="line">    USER_ASSIGNED</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>订阅完成后，就可以从服务器拉取数据了，consumer没有后台线程默默的拉取数据，它的所有行为都集中在poll()方法中，KafkaConsumer也是线程不安全的，同时只能允许一个线程运行。<br>因此在poll的时候会进行判定，如果有多个线程同时使用一个KafkaConsumer则会抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">  <span class="keyword">if</span> (threadId != currentThread.get() &amp;&amp; !currentThread.compareAndSet(NO_CURRENT_THREAD, threadId))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException(<span class="string">&quot;KafkaConsumer is not safe for multi-threaded access&quot;</span>);</span><br><span class="line">  refcount.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="和GroupCoordinator取得联系"><a href="#和GroupCoordinator取得联系" class="headerlink" title="和GroupCoordinator取得联系"></a>和GroupCoordinator取得联系</h3><p>一个 Consumer 实例消费数据的前提是能够加入一个 group 成功，并获取其要订阅的 tp（topic-partition）列表，因此首先要做的就是和GroupCoordinator建立连接，加入组织，因此我们先把目光集中在ConsumerCoordinator。poll()方法中首先会去更新metadata信息(获取 GroupCoordinator 的ip以及接口,并连接、 join-Group、sync-group, 期间 group 会进行 rebalance )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeoutMs, <span class="keyword">final</span> <span class="keyword">boolean</span> includeMetadataInTimeout)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">    client.maybeTriggerWakeup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> metadataEnd;</span><br><span class="line">    <span class="keyword">if</span> (includeMetadataInTimeout) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!updateAssignmentMetadataIfNeeded(remainingTimeAtLeastZero(timeoutMs, elapsedTime))) &#123;</span><br><span class="line">            <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">        &#125;</span><br><span class="line">       ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!updateAssignmentMetadataIfNeeded(Long.MAX_VALUE)) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Still waiting for metadata&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        metadataEnd = time.milliseconds();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = pollForFetches(remainingTimeAtLeastZero(timeoutMs, elapsedTime));</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">while</span> (elapsedTime &lt; timeoutMs);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateAssignmentMetadataIfNeeded</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeoutMs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> startMs = time.milliseconds();</span><br><span class="line">  <span class="keyword">if</span> (!coordinator.poll(timeoutMs)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> updateFetchPositions(remainingTimeAtLeastZero(timeoutMs, time.milliseconds() - startMs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于对ConsumerCoordinator的处理都集中在coordinator.poll()方法中。其主要逻辑如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">poll</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeoutMs)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是subscribe方式订阅的</span></span><br><span class="line">  <span class="keyword">if</span> (subscriptions.partitionsAutoAssigned()) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查心跳线程运行是否正常，如果心跳线程失败则抛出异常，反之则更新poll调用时间</span></span><br><span class="line">   pollHeartbeat(currentTime);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (coordinatorUnknown()) &#123;</span><br><span class="line">        <span class="comment">// 确保ConsumeCoordinator创建完成，如果没有则向服务器发送请求开始创建一个</span></span><br><span class="line">        <span class="keyword">if</span> (!ensureCoordinatorReady(remainingTimeAtLeastZero(timeoutMs, elapsed))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是需要重新加入group,如果订阅的partition变化或者分配的partition变化</span></span><br><span class="line">    <span class="keyword">if</span> (rejoinNeededOrPending()) &#123;</span><br><span class="line">        <span class="comment">//确保group是active，加入group，分配订阅的partition</span></span><br><span class="line">        <span class="keyword">if</span> (!ensureActiveGroup(remainingTimeAtLeastZero(timeoutMs, elapsed))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果设置的是自动commit,如果定时达到则自动commit</span></span><br><span class="line">  maybeAutoCommitOffsetsAsync(currentTime);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>poll方法中，具体实现可以分为四个步骤</p>
<ol>
<li><p>检测心跳线程运行是否正常(需要定时向GroupCoordinator发送心跳,在建立连接之后,建立连接之前不会做任何事情)</p>
</li>
<li><p>通过subscribe()方法订阅topic,如果 coordinator 未知，就初始化 Consumer Coordinator(在 ensureCoordinatorReady() 中实现，主要的作用是发送 FindCoordinatorRequest 请求，并建立连接）</p>
</li>
<li><p>判断是否需要重新加入group,如果订阅的partition变化或者分配的partition变化时，需要rejoin,通过ensureActiveGroup()发送join-group、sync-group请求，加入group并获取其assign的TopicPartition list。</p>
</li>
<li><p>如果设置的是自动commit,并且达到了发送时限则自动commit offset</p>
</li>
</ol>
<p>关于rejoin,下列几种情况会触发再均衡(reblance)操作</p>
<ul>
<li>新的消费者加入消费组(第一次进行消费也属于这种情况)</li>
<li>消费者宕机下线(长时间未发送心跳包)</li>
<li>消费者主动退出消费组，比如调用unsubscrible()方法取消对主题的订阅</li>
<li>消费组对应的GroupCoorinator节点发生了变化</li>
<li>消费组内所订阅的任一主题或者主题的分区数量发生了变化</li>
</ul>
<blockquote>
<p>取消topic订阅，consumer心跳线程超时以及在Server端给定的时间未收到心跳请求，这三个都是触发的LEAVE_GROUP请求</p>
</blockquote>
<p>这其中我会重点介绍下第二步中的ensureCoordinatorReady()方法和第三步中的ensureActiveGroup()方法。</p>
<h4 id="ensureCoordinatorReady"><a href="#ensureCoordinatorReady" class="headerlink" title="ensureCoordinatorReady"></a>ensureCoordinatorReady</h4><p>这个方法主要作用就是选择一个连接数最少的broker(还未响应请求最少的broker)，<strong>发送FindCoordinator请求，并建立对应的TCP连接。</strong></p>
<ul>
<li>方法调用流程是ensureCoordinatorReady() –&gt; lookupCoordinator() –&gt; sendGroupCoordinatorRequest()。</li>
<li>如果client收到response,那么就与GroupCoordinator建立连接</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">ensureCoordinatorReady</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeoutMs)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (coordinatorUnknown()) &#123;</span><br><span class="line">      <span class="comment">// 找到GroupCoordinator，并建立连接</span></span><br><span class="line">      <span class="keyword">final</span> RequestFuture&lt;Void&gt; future = lookupCoordinator();</span><br><span class="line">      client.poll(future, remainingTimeAtLeastZero(timeoutMs, elapsedTime));</span><br><span class="line">     ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !coordinatorUnknown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到coordinator</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> RequestFuture&lt;Void&gt; <span class="title">lookupCoordinator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (findCoordinatorFuture == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 找一个最少连接的节点,</span></span><br><span class="line">      Node node = <span class="keyword">this</span>.client.leastLoadedNode();</span><br><span class="line">      <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">          log.debug(<span class="string">&quot;No broker available to send FindCoordinator request&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span> RequestFuture.noBrokersAvailable();</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">          <span class="comment">// 发送FindCoordinator request请求</span></span><br><span class="line">          findCoordinatorFuture = sendFindCoordinatorRequest(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> findCoordinatorFuture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送FindCoordinator请求</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestFuture&lt;Void&gt; <span class="title">sendFindCoordinatorRequest</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;Sending FindCoordinator request to broker &#123;&#125;&quot;</span>, node);</span><br><span class="line">    FindCoordinatorRequest.Builder requestBuilder =</span><br><span class="line">            <span class="keyword">new</span> FindCoordinatorRequest.Builder(FindCoordinatorRequest.CoordinatorType.GROUP, <span class="keyword">this</span>.groupId);</span><br><span class="line">    <span class="comment">// 发送请求，并将response转换为RequestFuture</span></span><br><span class="line">    <span class="keyword">return</span> client.send(node, requestBuilder)</span><br><span class="line">                 .compose(<span class="keyword">new</span> FindCoordinatorResponseHandler());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据response返回的ip以及端口和GroupCoordinator建立连接</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FindCoordinatorResponseHandler</span> <span class="keyword">extends</span> <span class="title">RequestFutureAdapter</span>&lt;<span class="title">ClientResponse</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ClientResponse resp, RequestFuture&lt;Void&gt; future)</span> </span>&#123;</span><br><span class="line">      log.debug(<span class="string">&quot;Received FindCoordinator response &#123;&#125;&quot;</span>, resp);</span><br><span class="line"></span><br><span class="line">      FindCoordinatorResponse findCoordinatorResponse = (FindCoordinatorResponse) resp.responseBody();</span><br><span class="line">      Errors error = findCoordinatorResponse.error();</span><br><span class="line">      <span class="keyword">if</span> (error == Errors.NONE) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">              <span class="keyword">int</span> coordinatorConnectionId = Integer.MAX_VALUE - findCoordinatorResponse.node().id();</span><br><span class="line">              AbstractCoordinator.<span class="keyword">this</span>.coordinator = <span class="keyword">new</span> Node(</span><br><span class="line">                      coordinatorConnectionId,</span><br><span class="line">                      findCoordinatorResponse.node().host(),</span><br><span class="line">                      findCoordinatorResponse.node().port());</span><br><span class="line">              <span class="comment">// 初始化连接</span></span><br><span class="line">              client.tryConnect(coordinator);</span><br><span class="line">              <span class="comment">// 更新心跳时间</span></span><br><span class="line">              heartbeat.resetTimeouts(time.milliseconds());</span><br><span class="line">          &#125;</span><br><span class="line">          future.complete(<span class="keyword">null</span>);</span><br><span class="line">      &#125; </span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码主要作用就是往一个负载最小的节点发起FindCoordinator请求(client.send()方法底层使用的是java NIO,在上一篇文章中分析过),Kafka在走到这个请求后会根据group_id查找对应的GroupCoordinator节点，如果找到对应的则会返回其对应的node_id,host和port信息</p>
<blockquote>
<p>这里的GroupCoordinator节点的确定在文章开头提到过,是通过group.id和partitionCount来确定的</p>
</blockquote>
<p>上面的代码我把一些无关紧要的精简过了,你可以更多的关注注释，我在关键代码上都添加了对应的注释,对于理解主要流程挺有帮助。</p>
<h4 id="ensureActiveGroup"><a href="#ensureActiveGroup" class="headerlink" title="ensureActiveGroup()"></a>ensureActiveGroup()</h4><p>现在已经知道了GroupCoordinator节点,并建立了连接。ensureActiveGroup()这个方法的主要作用是<strong>向GroupCoordinator发送join-group、sync-group请求，获取assign的TopicPartition list。</strong></p>
<ol>
<li>调用过程是ensureActiveGroup() -&gt; ensureCoordinatorReady() -&gt; startHeartbeatThreadIfNeeded() -&gt; joinGroupIfNeeded()</li>
<li>joinGroupIfNeeded()方法中最重要的方法是initiateJoinGroup(),它的的调用流程是 disableHeartbeatThread() -&gt; sendJoinGroupRequest() -&gt; JoinGroupResponseHandler::handle()</li>
</ol>
<p>-&gt; onJoinLeader(),onJoinFollower() -&gt; sendSyncGroupRequest()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">ensureActiveGroup</span><span class="params">(<span class="keyword">long</span> timeoutMs, <span class="keyword">long</span> startMs)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span> (!ensureCoordinatorReady(timeoutMs)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动心跳线程</span></span><br><span class="line">  startHeartbeatThreadIfNeeded();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> joinStartMs = time.milliseconds();</span><br><span class="line">  <span class="keyword">long</span> joinTimeoutMs = remainingTimeAtLeastZero(timeoutMs, joinStartMs - startMs);</span><br><span class="line">  <span class="keyword">return</span> joinGroupIfNeeded(joinTimeoutMs, joinStartMs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>心跳线程就是在这里启动的，但是并不一定马上发送心跳包，会在满足条件之后才会开始发送。后面最主要的逻辑就集中在joinGroupIfNeeded()方法，它的核心代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">joinGroupIfNeeded</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> timeoutMs, <span class="keyword">final</span> <span class="keyword">long</span> startTimeMs)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> (rejoinNeededOrPending()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ensureCoordinatorReady(remainingTimeAtLeastZero(timeoutMs, elapsedTime))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needsJoinPrepare) &#123;</span><br><span class="line">        <span class="comment">// 如果是自动提交,则要开始提交offset以及在joingroup之前回调reblanceListener接口</span></span><br><span class="line">        onJoinPrepare(generation.generationId, generation.memberId);</span><br><span class="line">        needsJoinPrepare = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送join group请求</span></span><br><span class="line">    <span class="keyword">final</span> RequestFuture&lt;ByteBuffer&gt; future = initiateJoinGroup();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (future.succeeded()) &#123;</span><br><span class="line">        </span><br><span class="line">        ByteBuffer memberAssignment = future.value().duplicate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送完成</span></span><br><span class="line">        onJoinComplete(generation.generationId, generation.memberId, generation.protocol, memberAssignment);</span><br><span class="line"></span><br><span class="line">        resetJoinGroupFuture();</span><br><span class="line">        needsJoinPrepare = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>initiateJoinGroup()的核心代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> RequestFuture&lt;ByteBuffer&gt; <span class="title">initiateJoinGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">  <span class="keyword">if</span> (joinFuture == <span class="keyword">null</span>) &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 禁止心跳线程运行</span></span><br><span class="line">    disableHeartbeatThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前状态为rebalance</span></span><br><span class="line">    state = MemberState.REBALANCING;</span><br><span class="line">    <span class="comment">// 发送joinGroup请求</span></span><br><span class="line">    joinFuture = sendJoinGroupRequest();</span><br><span class="line">    joinFuture.addListener(<span class="keyword">new</span> RequestFutureListener&lt;ByteBuffer&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ByteBuffer value)</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置状态为stable状态    </span></span><br><span class="line">            state = MemberState.STABLE;</span><br><span class="line">            rejoinNeeded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (heartbeatThread != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 允许心跳线程继续运行</span></span><br><span class="line">                heartbeatThread.enable();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e)</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">              <span class="comment">// 如果joinGroup失败，设置状态为unjoined</span></span><br><span class="line">              state = MemberState.UNJOINED;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> joinFuture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到在joinGroup之前会让心跳线程暂时停下来，此时会将ConsumerCoordinator的状态设置为rebalance状态，当joinGroup成功之后会将状态设置为stable状态，同时让之前停下来的心跳继续运行。</p>
<p>在发送joinGroupRequest之后,收到服务器的响应，会针对这个响应在做一些重要的事情</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinGroupResponseHandler</span> <span class="keyword">extends</span> <span class="title">CoordinatorResponseHandler</span>&lt;<span class="title">JoinGroupResponse</span>, <span class="title">ByteBuffer</span>&gt; </span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(JoinGroupResponse joinResponse, RequestFuture&lt;ByteBuffer&gt; future)</span> </span>&#123;</span><br><span class="line">   Errors error = joinResponse.error();</span><br><span class="line">   <span class="keyword">if</span> (error == Errors.NONE) &#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (AbstractCoordinator.<span class="keyword">this</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (state != MemberState.REBALANCING) &#123;</span><br><span class="line">           future.raise(<span class="keyword">new</span> UnjoinedGroupException());</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           AbstractCoordinator.<span class="keyword">this</span>.generation = <span class="keyword">new</span> Generation(joinResponse.generationId(),</span><br><span class="line">                   joinResponse.memberId(), joinResponse.groupProtocol());</span><br><span class="line">           <span class="comment">// 如果当前consumer是leader</span></span><br><span class="line">           <span class="keyword">if</span> (joinResponse.isLeader()) &#123;</span><br><span class="line">               onJoinLeader(joinResponse).chain(future);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 是follower</span></span><br><span class="line">               onJoinFollower().chain(future);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>当 GroupCoordinator 接收到 consumer 的 join-group 请求后，由于此时这个 group 的 member 列表还是空(group 是新建的，每个 consumer 实例被称为这个 group 的一个 member)，第一个加入的 member 将被选为 leader，也就是说，对于一个新的 consumer group 而言，当第一个 consumer 实例加入后将会被选为 leader。如果后面leader挂了，会从其他member里面随机选择一个menmber成为新的leader</p>
</li>
<li><p>如果GroupCoordinator接收到consumer发送join-group请求，会将所有menber列表以及分区策略返回其response</p>
</li>
<li><p>consumer在收到GroupCoordinator的response后，如果这个consumer是group的leader,那么这个consumer会负责为整个group 分配分区(默认是range策略,分区策略会在后续文章进行讲解),然后leader会发送SyncGroup(sendSyncGroupRequest()方法)请求，将分配信息发送给GroupCoordinator,作为follower的consumer则只是发送一个空列表。</p>
</li>
<li><p>GroupCoordinator 在接收到leader发送来的请求后，会将assign的结果返回给所有已经发送sync-group请求的consumer实例。并且group的状态会转变为stable.如果后续再收到 sync-group 请求，由于 group 的状态已经是 Stable，将会直接返回其分配结果。</p>
</li>
</ol>
<p>sync-group发送请求核心代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//根据返回的assignmenet strategy name来决定采用何种策略进行分区分配</span></span><br><span class="line">Map&lt;String, ByteBuffer&gt; groupAssignment = performAssignment(joinResponse.leaderId(), joinResponse.groupProtocol(),</span><br><span class="line">        joinResponse.members());</span><br><span class="line">SyncGroupRequest.Builder requestBuilder =</span><br><span class="line">        <span class="keyword">new</span> SyncGroupRequest.Builder(groupId, generation.generationId, generation.memberId, groupAssignment);</span><br><span class="line">log.debug(<span class="string">&quot;Sending leader SyncGroup to coordinator &#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">this</span>.coordinator, requestBuilder);</span><br><span class="line"><span class="keyword">return</span> sendSyncGroupRequest(requestBuilder);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个阶段主要是讲分区分配方案同步给各个消费者，这个同步仍然是通过GroupCoordinator来转发的。</p>
<blockquote>
<p>分区策略并非由leader消费者来决定，而是各个消费者投票决定的,谁的票多就采用什么分区策略。这里的分区策略是通过partition.assignment.strategy参数设置的，可以设置多个。如果选举除了消费者不支持的策略，那么就会抛出异常IllegalArgumentException: Member does not support protocol</p>
</blockquote>
<p>经过上面的步骤，一个consumer实例就已经加入group成功了，加入group成功后，将会触发ConsumerCoordinator 的 onJoinComplete() 方法，其作用就是：更新订阅的 tp 列表、更新其对应的 metadata 及触发注册的 listener。</p>
<p>然后消费者就进入正常工作状态,同时消费者也通过向GroupCoordinator发送心跳来维持它们与消费者的从属关系，已经它们对分区的所有权关系。只要以正常的间隔发送心跳，就被认为是活跃的，但是如果GroupCoordinator没有响应，那么就会发送LeaveGroup请求退出消费组。</p>
]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>万字长文:操作系统如何解决并发问题?</title>
    <url>/2020/07/02/how-to-resolve-concurrency-issue-in-os/</url>
    <content><![CDATA[<p>在之前的文章中我们讲到过引起多线程bug的三大源头问题(可见性,原子性,有序性问题),java的内存模型(Java Memory Model)可以解决可见性和有序性问题,但是原子性问题如何解决呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add10K</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Counter counter = <span class="keyword">new</span> Counter();</span><br><span class="line"></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; counter.add10K());</span><br><span class="line"></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; counter.add10K());</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    System.out.println(counter.count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>上面的代码我们的期望结果是20000,可以运行结果却是小于20000的。是因为count这个共享变量同时被两个线程在修改,而count++这条语句在cpu中实际对应三条指令</p>
<ol>
<li>读取count的值</li>
<li>count + 1</li>
<li>将count+1的值重新复制给count</li>
</ol>
<p>而线程切换就可能发生在执行完任意一个指令的时候,比如 现在count的值为100, 线程1读取到了之后加1完成,但是还没有将新的值赋值给count,此时让出cpu,然后线程2执行,线程2读取到的值也为100,执行后count++之后,才让出cpu,此时线程1获取到执行资格,将count设置为101。</p>
<p>类似上面的情况,<strong>两个或多个线程读写某些共享数据,而最后的结果取决于线程运行的精准时序,称为竞争条件。</strong><br>那么如何避免竞争条件呢？实际上凡是涉及共享内存、共享文件以及共享任何资源的情况都会引发与前面类似的错误,要避免这种错误,关键是要找出某种途径来阻止多个线程同时读写共享的数据。</p>
<p>换言之,我们需要的是<strong>互斥,即以某种手段确保当一个进程在使用另一个共享变量或文件时,其他进程不能做同样的操作。</strong></p>
<p>上面例子的症结在于,线程1对共享变量的使用未结束之前线程2就使用它了。</p>
<p>线程的存在的问题,进程也同样存在。所以我们接下来看看操作系统是如何处理的。</p>
<p>一个进程的一部分时间做内部计算或另外一些不会引发竞争条件的操作。在某些时候进程可能需要访问共享内存或文件,或执行另外一些会导致竞争的操作。</p>
<p>我们把对共享内存进行访问的程序片段称作临界区域或临界区。如果我们能够使得两个进程不同时处于临界区中,就能避免竞争。</p>
<p>为了保证使用共享数据的并发进程能够正确和高效地进行写作,一个好的解决方案需要满足以下4个条件。</p>
<ol>
<li>任何两个进程不能同时处于其临界区</li>
<li>不应对CPU的速度和数量做任何假设</li>
<li>临界区以外运行的进程不得阻塞其他进程</li>
<li>不得使进程无限期等待进入临界区</li>
</ol>
<p><img data-src="/images/java/critical-region.png" alt="临界区"></p>
<p>比较期望的进程行为如上图所示。进程A在T1时刻进入临界区。稍后,在T2时刻进程B试图进入临界区,但是失败了,因为另一个进程已经在临界区内,而一个时刻只允许一个进程在临界区内。所以B被暂时挂起知道T3时刻A离开临界区为止,从而允许B立即进入。最后,在B离开(在时刻T4),回到了在临界区中没有进程的原始状态。</p>
<h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><p>为了保证同一时刻只能有一个进程进入临界区,我们需要让进程在临界区保持互斥,这样当一个进程在临界区更新共享内存时,其他进程将不会进入临界区,以免带来不可预见的问题。</p>
<p>接下来会讨论下关于互斥的几种方案。</p>
<h4 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h4><p>单处理器系统中比较简单的做法就是在进入临界区之后立即屏蔽所有中断,并在要离开之前在打开中断。屏蔽中断后,时钟中断也被屏蔽,由于cpu只有发生时钟中断或其他中断时才会进行进程切换,这样在屏蔽中断后CPU不会被切换到其他进程,检查和修改共享内存的时候就不用担心其他进程介入。</p>
<blockquote>
<p>中断信号导致CPU停止当前正在做的工作并且开始做其他的事情</p>
</blockquote>
<p>可是如果把屏蔽中断的能力交给进程,如果某个进程屏蔽之后不再打开中断怎么办？<br>整个系统可能会因此终止。多核CPU可能要好点,可能只有其中一个cpu收到影响,其他cpu仍然能正常工作。</p>
<h4 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h4><p>锁变量实际是一种软件解决方案,设想存在一个共享锁变量,初始值为0,当进程想要进入临界区的时候,会执行下面代码类似的判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">if( lock &#x3D;&#x3D; 0) &#123;</span><br><span class="line">  lock &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 临界区</span><br><span class="line">  critical_region();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   wait lock &#x3D;&#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看上去很好,可是会出现和文章开头演示代码同样的问题。进程A读取锁变量lock的值发现为0,而在恰好设置为1之前,另一个进程被调度运行,将锁变量设置为1。<br>当第一个进程再次运行时,同样也将该锁设置为1,则此时同时有两个进程进入临界区中。</p>
<p>同样的即使在改变值之前再检查一次也是无济于事,如果第二个进程恰好在第一个进程完成第二次检查之后修改了锁变量的值,则同样会发生竞争条件。</p>
<h4 id="严格轮换法"><a href="#严格轮换法" class="headerlink" title="严格轮换法"></a>严格轮换法</h4><p>这种方法设计到两个线程执行不同的方法</p>
<p>线程1:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(turn != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 空等</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 临界区</span></span><br><span class="line">  critical_region();</span><br><span class="line">  </span><br><span class="line">  turn = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 非临界区</span></span><br><span class="line">  noncritical_region();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程2:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(turn != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 空等</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 临界区</span></span><br><span class="line">  critical_region();</span><br><span class="line">  </span><br><span class="line">  turn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  noncritical_region();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>turn初始值为0,用于记录轮到哪个线程进入临界区。</p>
<p>开始时,进程1检查turn,发现其值为0,于是进入临界区。进程2也发现值为0,于是一直在一个等待循环中不停的测试turn的值。</p>
<p><strong>连续测试一个变量直到某个值出现为止,称为忙等待。由于这种方式浪费CPU时间,所以通常应该避免。只有在有理由认为等待时间是非常短的情况下,才使用忙等待。用于忙等待的锁,称为自旋锁。</strong></p>
<p>看上去是不是很完美,其实不然。</p>
<p>当进程2执行得比较慢还在执行非临界区代码,此时turn = 1,而进程1又回到了循环的开始,但是它不能进入临界区,它只能在while循环中一直忙等待。</p>
<p>这种情况违反了前面叙述的条件3：进程不能被一个临界区外的进程阻塞。这也说明了在一个进程比另一个慢了许多的情况下,轮流进入临界区并不是一个好办法。</p>
<h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h4><p>1981年发明的互斥算法其基本原理如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> turn;</span><br><span class="line"><span class="keyword">boolean</span>[] interested = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程号是0或者1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enterRegion</span><span class="params">(<span class="keyword">int</span> process)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 其他进程</span></span><br><span class="line">  <span class="keyword">int</span> other = <span class="number">1</span> - process;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录哪个进程有兴趣进入临界区</span></span><br><span class="line">  interested[process] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置标志</span></span><br><span class="line">  turn = process;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果不满足进入条件,则空等待</span></span><br><span class="line">  <span class="keyword">while</span>(turn == process &amp;&amp; interested[other] == <span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leaveRegion</span><span class="params">(<span class="keyword">int</span> process)</span> </span>&#123;</span><br><span class="line">  interested[process] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当进程想要进入临界区的时候就会调用enterRegion方法,该方法在需要时将使得进程等待,在完成对共享变量的操作后,就会调用leaveRegion离开临界区。</p>
<p>这种算法虽然不会严格要求进程的执行顺序,但是仍然会造成忙等待。</p>
<h3 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h3><p>忙等待的缺点如何克服呢？</p>
<blockquote>
<p>忙等待的本质是由于当一个进程想要进入临界区时,先检查是否允许进入,如不允许,则该进程在原地一直等待,知道允许为止</p>
</blockquote>
<p>是否存在一个命令当无法进入临界区的时候就阻塞,而不是忙等待呢？</p>
<p>进程通信有两个原语sleep和wakeup就满足这个需求,sleep是一个将引起调用进程阻塞的系统调用,它会使得进程被挂起直到另外一个进程将其唤醒。</p>
<p>而wakeup有一个参数,即被需要唤醒的线程。这里我们来考虑一个生产者消费者的例子。</p>
<p>生产者往缓冲区中写入数据,消费者从缓冲区中取出数据。但是这里有两个隐藏的条件,当缓冲区为空的时候消费者不能取出数据,<br>当缓冲区满了的时候生产者不能生产数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> MAX = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    iterm = produce_item();</span><br><span class="line">    <span class="comment">// 队列满了就要睡眠</span></span><br><span class="line">    <span class="keyword">if</span>(count == MAX) &#123;</span><br><span class="line">      sleep();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    insert_item(item);</span><br><span class="line"></span><br><span class="line">    count = count + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">1</span>) &#123;</span><br><span class="line">      wakeup(consumer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> item;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">      sleep();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    item = remove_item();</span><br><span class="line"></span><br><span class="line">    count = count -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列不满,则唤醒producer</span></span><br><span class="line">    <span class="keyword">if</span>(count == N -<span class="number">1</span>) &#123;</span><br><span class="line">      wakeup(producer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consume_item(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>乍看之下没有问题,其实还是存在问题的,那就是对count(队列当前数据个数)的访问未加限制。</p>
<p>队列为空,当consumer在执行到if(count == 0)的时候,如果刚好发生了进程切换,producer执行,此时插入一个数据,然后发现count == 1,就会唤醒consumer(但是实际上consumer并没有睡眠),consumer接着刚才的代码执行会发现count = 0,于是睡眠。生产者迟早会填满整个队列,从而使得两个进程都陷入睡眠状态。</p>
<p>快速的弥补方法就是加一个唤醒等待位,当一个wakeup信号发送给一个清醒的进程时,将该标志位置为1,随后,当该进程要睡眠时,如果唤醒等待位为1,则将该标志位清除,同时进程保持为清醒状态。</p>
<p>但是这个办法还是治标不治本,如果有三个进程甚至更多的进程那么就会需要更多的标志位。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是E.W.Dijkstra在1965年提出的一种方法,它使用一个整型变量来累计唤醒次数,供以后使用。<br>在他的建议中引入了一个新的变量类型,称作信号量(semaphore),一个信号量的取值可以为0(表示没有唤醒操作)或者为正值(表示有一个或多个唤醒操作)。<br>Dijkstra建议设立两种操作:down和up(分别为一般化后的sleep和wakeup)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(semaphore &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      semaphore = semaphore -<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sleep();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>检査数值、修改变量值以及可能发生的睡眠操作均作为一个单一的、不可分割的原子操作完成,保证一旦一个信号量操作开始,则在该操作完成或阻塞之前,其他进程均不允许访问该信号量。</strong></p>
<blockquote>
<p>所谓原子操作,是指一组相关联的操作要么都不间断地执行,要么都不执行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  semaphore = semaphore + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  wakeup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>up操作对信号量的操作增加1,同样信号量的值增加1和唤醒一个进程同样是不可分割的一个操作。</p>
<p>那么是如何保证down()和up()的操作是原子性的呢？实际上是通过硬件提供的TSL或XCHG指令来完成的。</p>
<blockquote>
<p>执行TSL或者XCHG指令的CPU将锁住内存总线,以禁止其他CPU在本指令结束之前访问内存。</p>
</blockquote>
<p>来看看如何使用信号量的方式来解决生产者消费者问题。</p>
<p>在下面的实现方案中使用了3个信号量</p>
<ol>
<li>full: 记录充满的缓冲槽数目</li>
<li>empty: 记录空的缓冲槽数目</li>
<li>mutex: 供两个或多个进程使用的信号量,初始值为1,表示只有一个进程可以进入临界区</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100  <span class="comment">// 缓冲区中槽数目</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore; <span class="comment">// 信号量是一种特殊的整型数据</span></span><br><span class="line"></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// 控制对临界区的访问</span></span><br><span class="line">semaphore empty = N; <span class="comment">//缓冲区的空槽数目</span></span><br><span class="line">semaphore full = <span class="number">0</span>; <span class="comment">// 缓冲区的满槽数目</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> item;</span><br><span class="line">  <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 产生放在缓冲区中的一些数据</span></span><br><span class="line">    item = produce_item();</span><br><span class="line">    <span class="comment">// 将空槽数目減1</span></span><br><span class="line">    down(&amp;empty);</span><br><span class="line">    <span class="comment">// 进入临界区</span></span><br><span class="line">    down(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新数据项放到缓冲区中</span></span><br><span class="line">    insert_item(item);</span><br><span class="line">    <span class="comment">// 离开临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将满槽的数目加1</span></span><br><span class="line">    up(&amp;full);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> item;</span><br><span class="line">  <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">    <span class="comment">// 将满槽数目減1</span></span><br><span class="line">    down(&amp;full);</span><br><span class="line">    <span class="comment">// 进入临界区</span></span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 从缓冲区中取出数据项</span></span><br><span class="line">    item = remove_item();</span><br><span class="line">    <span class="comment">// 离开临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">    <span class="comment">// 将空槽数目加1</span></span><br><span class="line">    up(&amp;empty);</span><br><span class="line">    <span class="comment">// 处理数据项</span></span><br><span class="line">    consume_item(item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>empty这个信号量保证了缓冲区满(empty=0)的时候生产者停止运行,full这个信号量保证了缓冲区空的时候消费者停止运行。</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>互斥量是信号量的简化版本,互斥量仅仅适用于管理共享资源或一小段代码,由于互斥量在实现时即容易又有效,这使得互斥量在实现用户空间线程包时非常有用。</p>
<p>互斥量是一个可以处于两态之一的变量:解锁和加锁。这样,只需要一个二进制位表示它,不过实际上,常常使用一个整型量,0表示解锁,而其他所有的值则表示加锁。</p>
<p>当一个线程(或进程)需要访问临界区时,它调用mutex_lock,如果该互斥量当前是解锁的(即临界区可用),此调用成功,调用线程可以自由进入该临界区。</p>
<p>另一方面,如果该互斥量已经加锁,调用线程被阻塞,直到在临界区中的线程完成并调用mutex_unlock。如果多个线程被阻塞在该互斥量上,将随机选择一个线程并允许它获得锁。<br>由于互斥量非常简单,所以如果有可用的TSL或XCHG指令,就可以很容易地在用户空间中实现它们。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mutex_lock:</span><br><span class="line">  &#x2F;&#x2F; 将互斥信号量复制到寄存器,并且将互斥信号量置为 1</span><br><span class="line">  TSL REGISTER,MUTEX</span><br><span class="line">  &#x2F;&#x2F; 互斥信号是0吗</span><br><span class="line">  CMP REGISTER,#O</span><br><span class="line">  &#x2F;&#x2F; 如果互斥信号量为0,它被解锁,所以返回</span><br><span class="line">  JZE ok</span><br><span class="line">  &#x2F;&#x2F; 互斥信号量忙,调度另一个线程 </span><br><span class="line">  CALL thread_yield</span><br><span class="line">  &#x2F;&#x2F; 稍后再试 </span><br><span class="line">  JMP mutex_lock</span><br><span class="line">ok: RET  &#x2F;&#x2F; 返回调用者,进入临界区</span><br><span class="line"></span><br><span class="line">mutex_unlock:</span><br><span class="line">  &#x2F;&#x2F; 将mutex置为0 </span><br><span class="line">  MOVE MUTEX,#0</span><br><span class="line">  &#x2F;&#x2F; 返回调用者</span><br><span class="line">  RET 1</span><br></pre></td></tr></table></figure>

<p>mutex_lock的方法和enter_region的方法有点类似,但是有一个很关键的区别,enter_region进入临界区失败,会忙等待(实际上由于CPU时钟超时,会调度其他进程运行)。</p>
<p>由于thread_yield只是在用户空间中对线程调度程序的一个调用,所以它的运行非常快。这样,mutex_lock及mutex_unlock都不需要任何内核调用。</p>
<h4 id="线程中的互斥"><a href="#线程中的互斥" class="headerlink" title="线程中的互斥"></a>线程中的互斥</h4><p>为实现可移植的线程程序,IEEE标准1003.1c中定义了线程的标准,它定义的线程包叫做Pthread,大部分UNIX系统都支持这个标准。</p>
<p>Pthread提供许多可以用来同步线程的函数。其基本机制是使用一个可以被锁定和解锁的互斥量来保护每个临界区。</p>
<p>与互斥量相关的主要函数调用如下所示：</p>
<table>
<thead>
<tr>
<th>线程调用</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>pthread_mutex_init</td>
<td>创建一个互斥量</td>
</tr>
<tr>
<td>pthread_mutex destroy</td>
<td>撤销一个已存在的互斥量</td>
</tr>
<tr>
<td>pthread_mutex_lock</td>
<td>获得一个锁或阻塞</td>
</tr>
<tr>
<td>pthread_mutex_trylock</td>
<td>尝试获得一个锁或失败</td>
</tr>
<tr>
<td>pthread_mutex_unlock</td>
<td>释放一个锁</td>
</tr>
</tbody></table>
<p>除互斥量之外,pthread提供了另一种同步机制:条件变量。</p>
<p><strong>互斥量在允许或阻塞对临界区的访问上是很有用的,条件变量则允许线程由于一些未达到的条件而阻塞,绝大都分情況下这两种方法是一起使用的。</strong>现在让我们进一步地研究线程、互斥量、条件变量之间的关联。</p>
<p>再考虑一下生产者一消费者问题:一个线程将产品放在一个缓冲区内,而另一个线程将它们取出。如果生产者发现缓冲区中没有空槽可以使用了,它不得不阻塞起来直到有一个空槽可以使用。生产者使用互斥量可以进行原子性检查,而不受其他线程干扰。但是当发现缓存区已经满了以后,生产者需要一种方法来阻塞自己并在以后被唤醒,这便是条件变量做的事了.</p>
<p>与条件变量相关的pthread调用如下:</p>
<table>
<thead>
<tr>
<th>线程调用</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>pthread_condinit</td>
<td>创建一个条件变量</td>
</tr>
<tr>
<td>pthread_cond_destroy</td>
<td>撤销一个条件变量</td>
</tr>
<tr>
<td>pthread_cond_wait</td>
<td>阻塞以等待一个信号</td>
</tr>
<tr>
<td>pthread_cond_signal</td>
<td>向另一个线程发信号来唤醒它</td>
</tr>
<tr>
<td>pthread_cond_broadcast</td>
<td>向多个线程发信号来让它们全部唤醒</td>
</tr>
</tbody></table>
<p>与条件变量相关的最重要的两个操作是pthread_cond_wait 和 pthread_cond_signal,前者阻塞调用线程直到其他线程给它发信号(pthread_cond_signal通知其他进程)。当有多个线程被阻塞在同一个信号时,可以使用pthread_cond_broadcast 调用。</p>
<p><strong>条件变量与互斥量经常一起使用,这种模式用于让一个线程锁住一个互斥量,然后当它不能获得它期待的结果时等待一个条件变量。最后另一个线程会向它发信号,使它可以继续执行。<br>pthread_cond_wait原子性地调用并解锁它持有的互斥量,由于这个原因,互斥量是参数之一。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000000000</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> the_mutex;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> condc, condp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓冲区</span></span><br><span class="line"><span class="keyword">int</span> buffer = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i =<span class="number">1</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">    <span class="comment">// 互斥使用缓冲区</span></span><br><span class="line">    pthread_mutex_lock(&amp;the_mutex);</span><br><span class="line">    <span class="keyword">while</span> (buffer != <span class="number">0</span>) &#123;</span><br><span class="line">      pthread_cond_wait(&amp;condp, &amp;the_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数据放入缓冲区</span></span><br><span class="line">    buffer = i;</span><br><span class="line">    <span class="comment">// 唤醒消费者</span></span><br><span class="line">    pthread_cond_signal(&amp;condc);</span><br><span class="line">    <span class="comment">// 释放缓冲区</span></span><br><span class="line">    pthread_mutex_unlock(&amp;the_mutex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pthread _exit(O);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= MAX; i++) &#123;</span><br><span class="line">    <span class="comment">// 互斥使用缓冲区</span></span><br><span class="line">    pthread_mutex_lock(&amp;the_mutex);</span><br><span class="line">    <span class="keyword">while</span> (buffer == <span class="number">0</span>) &#123;</span><br><span class="line">       pthread_cond_wait(&amp;condc, &amp;the_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从缓冲区中取出数据</span></span><br><span class="line">    buffer = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 唤醒生产者</span></span><br><span class="line">    pthread_cond_signal(&amp;condp);</span><br><span class="line">    <span class="comment">// 释放缓冲区</span></span><br><span class="line">    pthread_.mutex_unlock(&amp;the_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_exit(O);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="keyword">pthread_t</span> pro, con;</span><br><span class="line">  pthread_mutex_init(&amp;the_mutex, <span class="number">0</span>);</span><br><span class="line">  pthread_cond _init(&amp;condc, <span class="number">0</span>);</span><br><span class="line">  pthread_cond_init(&amp;condp, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建一个线程(pthread提供的方法)</span></span><br><span class="line">  pthread_create(&amp;con, <span class="number">0</span>, consumer, <span class="number">0</span>);</span><br><span class="line">  pthread_create(&amp;pro, <span class="number">0</span>, producer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待线程执行完成</span></span><br><span class="line">  pthread_join(pro, <span class="number">0</span>);</span><br><span class="line">  pthread_join(con, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  pthread_cond_destroy(&amp;condc);</span><br><span class="line">  pthread_cond_destroy(&amp;condp);</span><br><span class="line">  pthread_mutex_destroy(&amp;the_mutex); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子虽然简单,但是却说明了基本的机制。<br><strong>同时使一个线程睡眠的语句应该总要检查这个条件,以保证线程在继续执行前满足条件,因为线程可能已经因为一个UNIX信号或其他原因被唤醒。</strong></p>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>有了信号量和互斥量之后,进程间通信看起来就容易了,是这样吗？</p>
<p>当然不是,可以再看看信号量中的producer(),如果将代码中的两个down操作交换下次序,这使得mutex的值在empty之前减1,如果缓冲区完全满了,生产者将阻塞,此时mutex为0,</p>
<p>当消费者下一次访问缓冲区时,消费者也就被阻塞,这种情况叫做死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> item;</span><br><span class="line">  <span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 产生放在缓冲区中的一些数据</span></span><br><span class="line">    item = produce_item();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的代码交换了顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入临界区</span></span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 将空槽数目減1</span></span><br><span class="line">    down(&amp;empty);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 将新数据项放到缓冲区中</span></span><br><span class="line">    insert_item(item);</span><br><span class="line">    <span class="comment">// 离开临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将满槽的数目加1</span></span><br><span class="line">    up(&amp;full);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题告诉我们使用信号量要很小心。</p>
<p>为了更易于编写正确的程序,Brinch Hansen(1973)和Hoare(1974)提出了一种高级同步原语,称为管程(monitor)。<br>在下面的介绍中我们会发现,他们两人提出的方案略有不同。</p>
<p><strong>一个管程是一个由过程、变量及数据结构等组成的一个集合,它们组成一个特殊的模块或软件包。</strong></p>
<p>下面的代码是类Pascal语法,procedure你可以认为是一个函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">monitor example:</span><br><span class="line"> interger i;</span><br><span class="line"> condition c;</span><br><span class="line"> procedure producer();</span><br><span class="line"> begin</span><br><span class="line"> ...</span><br><span class="line"> end;</span><br><span class="line"></span><br><span class="line"> procedure consumer();</span><br><span class="line"> begin</span><br><span class="line"> ...</span><br><span class="line"> end;</span><br><span class="line">end monitor;</span><br></pre></td></tr></table></figure>
<p>管程有一个很重要的特性,即任一时刻管程中只能有一个活跃进程,这一特性使管程能有效地完成互斥。</p>
<blockquote>
<p>管程是一个语言概念</p>
</blockquote>
<p>管程是编程语言的组成部分,编译器知道它们的特殊性,因此可以采用与其他过程调用不同的方法来处理对管程的调用。</p>
<p><strong>当一个进程调用管程过程时,该过程中的前几条指令将检査在管程中是否有其他的活跃进程。如果有,调用进程将被挂起,直到另一个进程离开管程将其唤醒。如果没有活跃进程在使用管程,则该调用进程可以进入。</strong></p>
<p>进入管程时的互斥由编译器负责,但通常的做法是用一个互斥量或信号量。因为是由编译器而非程序员来安排互斥,所以出错的可能性要小得多。在任一时刻,写管程的人无须关心编译器是如何实现互斥的。他只需知道将所有的临界区转换成管程过程即可,决不会有两个进程同时执行临界区中的代码。</p>
<p><strong>管程仍然需要一种方法使得进程在无法继续运行时被阻塞,其解决办法就是条件变量,以及相关的两个操作:wait和signal.</strong></p>
<p>当一个管程发现他无法运行时(比如生产者无法缓冲区满了),它会在某个条件变量执行wait操作,该操作导致调用进程自身阻塞,并且还将另一个以前在管程外的进程调入管程,另一个进程比如消费者可以唤醒生产者,通过对生产者正在等待的条件变量执行signal。</p>
<h4 id="signal唤醒策略"><a href="#signal唤醒策略" class="headerlink" title="signal唤醒策略"></a>signal唤醒策略</h4><p>为了避免管程中同时有两个活跃进程,我们需要一个规则来通过在signal之后怎么做。</p>
<p>Hoare 建议让唤起的新线程执行,而挂起另一个线程。</p>
<p>Brinch Hansen则建议执行signal的进程必须立即退出管程,即signal语句只能作为一个管程过程的最后一个语句。</p>
<p>第三种方法是让发信号者继续运行,并且只有在发信号者退出管程后,才允许等待的进程开始运行。而java使用的就是该种方案。</p>
<p>需要注意的是无论是信号量还是管程在分布式系统中都是不起作用的,至于为什么我相信大家心里肯定有了答案。</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM日志分析</title>
    <url>/2018/11/13/jvm-log-analysis/</url>
    <content><![CDATA[<p>今天这篇文章主要是对生产环境中（Java7）常用的两种垃圾收集器（ParNew：年轻代，CMS：老年代）从日志信息上进行分析，做一下总结，这样当我们在排查相应的问题时，看到 GC 的日志信息，不会再那么陌生，能清楚地知道这些日志是什么意思，GC 线程当前处在哪个阶段，正在做什么事情等。</p>
<p>我们的应用程序一般是运行在tomcat中,通过在tomcat中配置对应的参数可以可以生产gc日志信息:</p>
<ul>
<li>-verbose.gc开关可显示GC的操作内容。打开它，可以显示最忙和最空闲收集行为发生的时间、收集前后的内存大小、收集需要的时间等。</li>
<li>打开-xx:+printGCdetails开关，可以详细了解GC中的变化。</li>
<li>打开-XX:+PrintGCTimeStamps开关，可以了解这些垃圾收集发生的时间，自JVM启动以后以秒计量。</li>
<li>最后，通过-xx:+PrintHeapAtGC开关了解堆的更详细的信息。</li>
<li>为了了解新域的情况，可以通过-XX:+PrintTenuringDistribution开关了解获得使用期的对象权。</li>
<li>-Xloggc:$CATALINA_BASE/logs/gc.log gc日志产生的路径</li>
<li>-XX:+PrintGCApplicationStoppedTime 输出GC造成应用暂停的时间</li>
<li>-XX:+PrintGCDateStamps GC发生的时间信息</li>
</ul>
<p>还可以通过笨神的JVM平台来根据需求生成和解析JVM参数<a href="http://xxfox.perfma.com/jvm/generate">http://xxfox.perfma.com/jvm/generate</a></p>
<h3 id="GC日志格式"><a href="#GC日志格式" class="headerlink" title="GC日志格式"></a>GC日志格式</h3><p><img data-src="/images/jvm-log-gc.png" alt="GC日志格式总览"></p>
<h3 id="ParNew收集器日志分析"><a href="#ParNew收集器日志分析" class="headerlink" title="ParNew收集器日志分析"></a>ParNew收集器日志分析</h3><p>ParNew 收集器是年轻代常用的垃圾收集器，它采用的是复制算法，youngGC 时一个典型的日志信息如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-04-12T13:48:26.134+0800: 15578.050: [GC2018-04-12T13:48:26.135+0800: 15578.050: [ParNew: 3412467K-&gt;59681K(3774912K), 0.0971990 secs] 9702786K-&gt;6354533K(24746432K), 0.0974940 secs][Times: user&#x3D;0.95 sys&#x3D;0.00, real&#x3D;0.09 secs]</span><br></pre></td></tr></table></figure>
<p>GC日志开头的”[GC”和“[Full GC”说明了这次垃圾收集的停顿类型。”[DefNew”、”[Tenured”、“[Perm”表示GC发生的区域，和GC收集器密切相关。比如使用Serial收集器中的新生代名为”Default New Generation”,所以显示为“[DefNew”.如果是ParNew收集器，新生代名称会变为”[ParaNew”,意思是Parallel New Generation.如果采用Parallel Scavenge收集器，那它配套的新生代名称为“[PSYoungGen”,老年代和永久代同理。</p>
<p>依次分析一下上面日志信息的含义：</p>
<ul>
<li>2018-04-12T13:48:26.134+0800： Mirror GC 发生的时间</li>
<li>15578.050：GC 开始时，相对 JVM 启动的相对时间，单位时秒，这里是4h+；</li>
<li>ParNew：收集器名称，这里是 ParNew 收集器，它使用的是并行的 mark-copy 算法，GC 过程也会 Stop the World；</li>
<li>3412467K-&gt;59681K：收集前后年轻代的使用情况，这里是 3.25G-&gt;58.28M；</li>
<li>3774912K：整个年轻代的容量，这里是 3.6G；</li>
<li>0.0971990 secs：Duration for the collection w/o final cleanup.</li>
<li>9702786K-&gt;6354533K：收集前后整个堆的使用情况，这里是 9.25G-&gt;6.06G;</li>
<li>24746432K：整个堆的容量，这里是 23.6G；</li>
<li>0.0974940 secs：ParNew 收集器标记和复制年轻代活着的对象所花费的时间（包括和老年代通信的开销、对象晋升到老年代开销、垃圾收集周期结束一些最后的清理对象等的花销）；</li>
</ul>
<p>更全一点的参数说明:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC [&lt;collector&gt;: &lt;starting occupancy1&gt; -&gt; &lt;ending occupancy1&gt;, &lt;pause time1&gt; secs] &lt;starting occupancy3&gt; -&gt; &lt;ending occupancy3&gt;, &lt;pause time3&gt; secs]</span><br><span class="line"> </span><br><span class="line">&lt;collector&gt;              GC收集器的名称</span><br><span class="line">&lt;starting occupancy1&gt;    新生代在GC前占用的内存</span><br><span class="line">&lt;ending occupancy1&gt;      新生代在GC后占用的内存</span><br><span class="line">&lt;pause time1&gt;            新生代局部收集时jvm暂停处理的时间</span><br><span class="line">&lt;starting occupancy3&gt;    JVM Heap 在GC前占用的内存</span><br><span class="line">&lt;ending occupancy3&gt;      JVM Heap 在GC后占用的内存</span><br><span class="line">&lt;pause time3&gt;            GC过程中jvm暂停处理的总时间</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于 [Times: user=0.95 sys=0.00, real=0.09 secs]，这里面涉及到三种时间类型，含义如下：</p>
<ul>
<li>user：GC 线程在垃圾收集期间所使用的 CPU 总时间；</li>
<li>sys：系统调用或者等待系统事件花费的时间；</li>
<li>real：应用被暂停的时钟时间，由于 GC 线程是多线程的，导致了 real 小于 (user+real)，如果是 gc 线程是单线程的话，real 是接近于 (user+real) 时间。</li>
</ul>
<h3 id="CMS收集器日志分析"><a href="#CMS收集器日志分析" class="headerlink" title="CMS收集器日志分析"></a>CMS收集器日志分析</h3><p>CMS 收集器是老年代经常使用的收集器，它采用的是标记-清楚算法，应用程序在发生一次 Full GC 时，典型的 GC 日志信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-04-12T13:48:26.233+0800: 15578.148: [GC [1 CMS-initial-mark: 6294851K(20971520K)] 6354687K(24746432K), 0.0466580 secs] [Times: user&#x3D;0.04 sys&#x3D;0.00, real&#x3D;0.04 secs]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:26.280+0800: 15578.195: [CMS-concurrent-mark-start]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:26.418+0800: 15578.333: [CMS-concurrent-mark: 0.138&#x2F;0.138 secs] [Times: user&#x3D;1.01 sys&#x3D;0.21, real&#x3D;0.14 secs]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:26.418+0800: 15578.334: [CMS-concurrent-preclean-start]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:26.476+0800: 15578.391: [CMS-concurrent-preclean: 0.056&#x2F;0.057 secs] [Times: user&#x3D;0.20 sys&#x3D;0.12, real&#x3D;0.06 secs]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:26.476+0800: 15578.391: [CMS-concurrent-abortable-preclean-start]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:29.989+0800: 15581.905: [CMS-concurrent-abortable-preclean: 3.506&#x2F;3.514 secs] [Times: user&#x3D;11.93 sys&#x3D;6.77, real&#x3D;3.51 secs]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:29.991+0800: 15581.906: [GC[YG occupancy: 1805641 K (3774912 K)]2018-04-12T13:48:29.991+0800: 15581.906: [GC2018-04-12T13:48:29.991+0800: 15581.906: [ParNew: 1805641K-&gt;48395K(3774912K), 0.0826620 secs] 8100493K-&gt;6348225K(24746432K), 0.0829480 secs] [Times: user&#x3D;0.81 sys&#x3D;0.00, real&#x3D;0.09 secs]2018-04-12T13:48:30.074+0800: 15581.989: [Rescan (parallel) , 0.0429390 secs]2018-04-12T13:48:30.117+0800: 15582.032: [weak refs processing, 0.0027800 secs]2018-04-12T13:48:30.119+0800: 15582.035: [class unloading, 0.0033120 secs]2018-04-12T13:48:30.123+0800: 15582.038: [scrub symbol table, 0.0016780 secs]2018-04-12T13:48:30.124+0800: 15582.040: [scrub string table, 0.0004780 secs] [1 CMS-remark: 6299829K(20971520K)] 6348225K(24746432K), 0.1365130 secs] [Times: user&#x3D;1.24 sys&#x3D;0.00, real&#x3D;0.14 secs]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:30.128+0800: 15582.043: [CMS-concurrent-sweep-start]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:36.638+0800: 15588.553: [GC2018-04-12T13:48:36.638+0800: 15588.554: [ParNew: 3403915K-&gt;52142K(3774912K), 0.0874610 secs] 4836483K-&gt;1489601K(24746432K), 0.0877490 secs] [Times: user&#x3D;0.84 sys&#x3D;0.00, real&#x3D;0.09 secs]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:38.412+0800: 15590.327: [CMS-concurrent-sweep: 8.193&#x2F;8.284 secs] [Times: user&#x3D;30.34 sys&#x3D;16.44, real&#x3D;8.28 secs]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:38.419+0800: 15590.334: [CMS-concurrent-reset-start]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:38.462+0800: 15590.377: [CMS-concurrent-reset: 0.044&#x2F;0.044 secs] [Times: user&#x3D;0.15 sys&#x3D;0.10, real&#x3D;0.04 secs]</span><br></pre></td></tr></table></figure>

<p>CMS Full GC 拆分开来，涉及的阶段比较多，下面分别来介绍各个阶段的情况。</p>
<h4 id="阶段1：Initial-Mark"><a href="#阶段1：Initial-Mark" class="headerlink" title="阶段1：Initial Mark"></a>阶段1：Initial Mark</h4><p>这个是 CMS 两次 stop-the-wolrd 事件的其中一次，这个阶段的目标是：标记那些直接被 GC root 引用或者被年轻代存活对象所引用的所有对象，标记后示例如下所示（插图来自：GC Algorithms：Implementations —— Concurrent Mark and Sweep —— Full GC）：</p>
<p><img data-src="/images/jvm-log-cms-init.png" alt="CMS初始标记阶段"></p>
<p>上述例子对应的日志信息为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-04-12T13:48:26.233+0800: 15578.148: [GC [1 CMS-initial-mark: 6294851K(20971520K)] 6354687K(24746432K), 0.0466580 secs] [Times: user&#x3D;0.04 sys&#x3D;0.00, real&#x3D;0.04 secs]</span><br></pre></td></tr></table></figure>

<p>逐行介绍上面日志的含义：</p>
<ol>
<li>2018-04-12T13:48:26.233+0800: 15578.148：GC 开始的时间，以及相对于 JVM 启动的相对时间（单位是秒，这里大概是4.33h），与前面 ParNew 类似，下面的分析中就直接跳过这个了；</li>
<li>CMS-initial-mark：初始标记阶段，它会收集所有 GC Roots 以及其直接引用的对象；</li>
<li>6294851K：当前老年代使用的容量，这里是 6G；</li>
<li>(20971520K)：老年代可用的最大容量，这里是 20G；</li>
<li>6354687K：整个堆目前使用的容量，这里是 6.06G；</li>
<li>(24746432K)：堆可用的容量，这里是 23.6G；</li>
<li>0.0466580 secs：这个阶段的持续时间；</li>
<li>[Times: user=0.04 sys=0.00, real=0.04 secs]：与前面的类似，这里是相应 user、system and real 的时间统计。</li>
</ol>
<h4 id="阶段2"><a href="#阶段2" class="headerlink" title="阶段2"></a>阶段2</h4><p>并发标记在这个阶段 Garbage Collector 会遍历老年代，然后标记所有存活的对象，它会根据上个阶段找到的 GC Roots 遍历查找。并发标记阶段，它会与用户的应用程序并发运行。并不是老年代所有的存活对象都会被标记，因为在标记期间用户的程序可能会改变一些引用，如下图所示（插图来自：GC Algorithms：Implementations —— Concurrent Mark and Sweep —— Full GC）：</p>
<p><img data-src="/images/jvm-log-cms-mark-sweep.png" alt="CMS并发标记阶段"></p>
<p>在上面的图中，与阶段1的图进行对比，就会发现有一个对象的引用已经发生了变化，这个阶段相应的日志信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-04-12T13:48:26.280+0800: 15578.195: [CMS-concurrent-mark-start]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:26.418+0800: 15578.333: [CMS-concurrent-mark: 0.138&#x2F;0.138 secs] [Times: user&#x3D;1.01 sys&#x3D;0.21, real&#x3D;0.14 secs]</span><br></pre></td></tr></table></figure>

<p>这里详细对上面的日志解释，如下所示：</p>
<ol>
<li>CMS-concurrent-mark：并发收集阶段，这个阶段会遍历老年代，并标记所有存活的对象；</li>
<li>0.138/0.138 secs：这个阶段的持续时间与时钟时间；</li>
<li>[Times: user=1.01 sys=0.21, real=0.14 secs]：如前面所示，但是这部的时间，其实意义不大，因为它是从并发标记的开始时间开始计算，这期间因为是并发进行，不仅仅包含 GC 线程的工作。</li>
</ol>
<h4 id="阶段3：Concurrent-Preclean"><a href="#阶段3：Concurrent-Preclean" class="headerlink" title="阶段3：Concurrent Preclean"></a>阶段3：Concurrent Preclean</h4><p>Concurrent Preclean：这也是一个并发阶段，与应用的线程并发运行，并不会 stop 应用的线程。在并发运行的过程中，一些对象的引用可能会发生变化，但是这种情况发生时，JVM 会将包含这个对象的区域（Card）标记为 Dirty，这也就是 Card Marking。如下图所示（插图来自：GC Algorithms：Implementations —— Concurrent Mark and Sweep —— Full GC：</p>
<p><img data-src="/images/jvm-log-cms-concurrent-clean.png" alt="Concurrent preclean 1"></p>
<p>在pre-clean阶段，那些能够从 Dirty 对象到达的对象也会被标记，这个标记做完之后，dirty card 标记就会被清除了，如下（插图来自：GC Algorithms：Implementations —— Concurrent Mark and Sweep —— Full GC)</p>
<p><img data-src="/images/jvm-log-cms-concurrent-clean2.png" alt="Concurrent preclean 2"></p>
<p>这个阶段相应的日志信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-04-12T13:48:26.418+0800: 15578.334: [CMS-concurrent-preclean-start]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:26.476+0800: 15578.391: [CMS-concurrent-preclean: 0.056&#x2F;0.057 secs] [Times: user&#x3D;0.20 sys&#x3D;0.12, real&#x3D;0.06 secs]</span><br></pre></td></tr></table></figure>

<p>其含义为：</p>
<ol>
<li>CMS-concurrent-preclean：Concurrent Preclean 阶段，对在前面并发标记阶段中引用发生变化的对象进行标记；</li>
<li>0.056/0.057 secs：这个阶段的持续时间与时钟时间；</li>
<li>[Times: user=0.20 sys=0.12, real=0.06 secs]：同并发标记阶段中的含义。</li>
</ol>
<h4 id="阶段4：Concurrent-Abortable-Preclean"><a href="#阶段4：Concurrent-Abortable-Preclean" class="headerlink" title="阶段4：Concurrent Abortable Preclean"></a>阶段4：Concurrent Abortable Preclean</h4><p>这也是一个并发阶段，但是同样不会影响影响用户的应用线程，这个阶段是为了尽量承担 STW（stop-the-world）中最终标记阶段的工作。这个阶段持续时间依赖于很多的因素，由于这个阶段是在重复做很多相同的工作，直接满足一些条件（比如：重复迭代的次数、完成的工作量或者时钟时间等）。这个阶段的日志信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-04-12T13:48:26.476+0800: 15578.391: [CMS-concurrent-abortable-preclean-start]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:29.989+0800: 15581.905: [CMS-concurrent-abortable-preclean: 3.506&#x2F;3.514 secs] [Times: user&#x3D;11.93 sys&#x3D;6.77, real&#x3D;3.51 secs]</span><br></pre></td></tr></table></figure>

<ol>
<li>CMS-concurrent-abortable-preclean：Concurrent Abortable Preclean 阶段；</li>
<li>3.506/3.514 secs：这个阶段的持续时间与时钟时间，本质上，这里的 gc 线程会在 STW 之前做更多的工作，通常会持续 5s 左右；</li>
<li>[Times: user=11.93 sys=6.77, real=3.51 secs]：同前面。</li>
</ol>
<h4 id="阶段5：Final-Remark"><a href="#阶段5：Final-Remark" class="headerlink" title="阶段5：Final Remark"></a>阶段5：Final Remark</h4><p>这是第二个STW阶段，也是CMS中的最后一个，这个阶段的目标是标记所有老年代所有的存活对象，由于之前的阶段是并发执行的，gc 线程可能跟不上应用程序的变化，为了完成标记老年代所有存活对象的目标，STW 就非常有必要了。通常 CMS 的 Final Remark 阶段会在年轻代尽可能干净的时候运行，目的是为了减少连续 STW 发生的可能性（年轻代存活对象过多的话，也会导致老年代涉及的存活对象会很多）。这个阶段会比前面的几个阶段更复杂一些，相关日志如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-04-12T13:48:29.991+0800: 15581.906: [GC[YG occupancy: 1805641 K (3774912 K)]2018-04-12T13:48:29.991+0800: 15581.906: [GC2018-04-12T13:48:29.991+0800: 15581.906:</span><br><span class="line">[ParNew: 1805641K-&gt;48395K(3774912K), 0.0826620 secs] 8100493K-&gt;6348225K(24746432K), 0.0829480 secs]</span><br><span class="line">[Times: user&#x3D;0.81 sys&#x3D;0.00, real&#x3D;0.09 secs]2018-04-12T13:48:30.074+0800: 15581.989: [Rescan (parallel) , 0.0429390 secs]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:30.117+0800: 15582.032: [weak refs processing, 0.0027800 secs]2018-04-12T13:48:30.119+0800: 15582.035: [class unloading, 0.0033120 secs]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:30.123+0800: 15582.038: [scrub symbol table, 0.0016780 secs]2018-04-12T13:48:30.124+0800: 15582.040: [scrub string table, 0.0004780 secs]</span><br><span class="line">[1 CMS-remark: 6299829K(20971520K)] 6348225K(24746432K), 0.1365130 secs] [Times: user&#x3D;1.24 sys&#x3D;0.00, real&#x3D;0.14 secs]</span><br></pre></td></tr></table></figure>

<p>对上面的日志进行分析：</p>
<ol>
<li>YG occupancy: 1805641 K (3774912 K)：年轻代当前占用量及容量，这里分别是 1.71G 和 3.6G；</li>
<li>ParNew:…：触发了一次 young GC，这里触发的原因是为了减少年轻代的存活对象，尽量使年轻代更干净一些；</li>
<li>[Rescan (parallel) , 0.0429390 secs]：这个 Rescan 是当应用暂停的情况下完成对所有存活对象的标记，这个阶段是并行处理的，这里花费了 0.0429390s；</li>
<li>[weak refs processing, 0.0027800 secs]：第一个子阶段，它的工作是处理弱引用；</li>
<li>[class unloading, 0.0033120 secs]：第二个子阶段，它的工作是：unloading the unused classes；</li>
<li>[scrub symbol table, 0.0016780 secs] … [scrub string table, 0.0004780 secs]：最后一个子阶段，它的目的是：cleaning up symbol and string tables which hold class-level metadata and internalized string respectively，时钟的暂停也包含在这里；</li>
<li>6299829K(20971520K)：这个阶段之后，老年代的使用量与总量，这里分别是 6G 和 20G；</li>
<li>6348225K(24746432K)：这个阶段之后，堆的使用量与总量（包括年轻代，年轻代在前面发生过 GC），这里分别是 6.05G 和 23.6G；</li>
<li>0.1365130 secs：这个阶段的持续时间；</li>
<li>[Times: user=1.24 sys=0.00, real=0.14 secs]：对应的时间信息。</li>
</ol>
<p>经历过这五个阶段之后，老年代所有存活的对象都被标记过了，现在可以通过清除算法去清理那些老年代不再使用的对象。</p>
<h4 id="阶段6：Concurrent-Sweep"><a href="#阶段6：Concurrent-Sweep" class="headerlink" title="阶段6：Concurrent Sweep"></a>阶段6：Concurrent Sweep</h4><p>这里不需要 STW，它是与用户的应用程序并发运行，这个阶段是：清除那些不再使用的对象，回收它们的占用空间为将来使用。如下图所示（插图来自：GC Algorithms：Implementations —— Concurrent Mark and Sweep —— Full GC)</p>
<p><img data-src="/images/jvm-log-cms-concurrent-clean.png" alt="CMS Concurrent Sweep阶段"></p>
<p>这个阶段对应的日志信息如下（这中间又发生了一次 Young GC）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-04-12T13:48:30.128+0800: 15582.043: [CMS-concurrent-sweep-start]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:36.638+0800: 15588.553: [GC2018-04-12T13:48:36.638+0800: 15588.554: [ParNew: 3403915K-&gt;52142K(3774912K), 0.0874610 secs] 4836483K-&gt;1489601K(24746432K), 0.0877490 secs] [Times: user&#x3D;0.84 sys&#x3D;0.00, real&#x3D;0.09 secs]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:38.412+0800: 15590.327: [CMS-concurrent-sweep: 8.193&#x2F;8.284 secs] [Times: user&#x3D;30.34 sys&#x3D;16.44, real&#x3D;8.28 secs]</span><br></pre></td></tr></table></figure>

<p>分别介绍一下：</p>
<ol>
<li>CMS-concurrent-sweep：这个阶段主要是清除那些没有被标记的对象，回收它们的占用空间；</li>
<li>8.193/8.284 secs：这个阶段的持续时间与时钟时间；</li>
<li>[Times: user=30.34 sys=16.44, real=8.28 secs]：同前面；</li>
</ol>
<h4 id="阶段7：Concurrent-Reset"><a href="#阶段7：Concurrent-Reset" class="headerlink" title="阶段7：Concurrent Reset"></a>阶段7：Concurrent Reset</h4><p>这个阶段也是并发执行的，它会重设 CMS 内部的数据结构，为下次的 GC 做准备，对应的日志信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-04-12T13:48:38.419+0800: 15590.334: [CMS-concurrent-reset-start]</span><br><span class="line"></span><br><span class="line">2018-04-12T13:48:38.462+0800: 15590.377: [CMS-concurrent-reset: 0.044&#x2F;0.044 secs] [Times: user&#x3D;0.15 sys&#x3D;0.10, real&#x3D;0.04 secs]</span><br></pre></td></tr></table></figure>

<p>日志详情分别如下：</p>
<ol>
<li>CMS-concurrent-reset：这个阶段的开始，目的如前面所述；</li>
<li>0.044/0.044 secs：这个阶段的持续时间与时钟时间；</li>
<li>[Times: user=0.15 sys=0.10, real=0.04 secs]：同前面。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CMS 通过将大量工作分散到并发处理阶段来在减少 STW 时间，在这块做得非常优秀，但是 CMS 也有一些其他的问题：</p>
<ol>
<li>CMS 收集器无法处理浮动垃圾（ Floating Garbage），可能出现 “Concurrnet Mode Failure” 失败而导致另一次 Full GC 的产生，可能引发串行 Full GC；</li>
<li>空间碎片，导致无法分配大对象，CMS 收集器提供了一个 -XX:+UseCMSCompactAtFullCollection 开关参数（默认就是开启的），用于在 CMS 收集器顶不住要进行 Full GC 时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长；</li>
<li>对于堆比较大的应用上，GC 的时间难以预估。</li>
</ol>
<p>CMS 的一些缺陷也是 G1 收集器兴起的原因。关于G1收集器的日志可以查看这里<a href="https://tech.meituan.com/g1.html">https://tech.meituan.com/g1.html</a></p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol>
<li><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#concurrent-mark-and-sweep">https://plumbr.io/handbook/garbage-collection-algorithms-implementations#concurrent-mark-and-sweep</a></li>
<li><a href="http://matt33.com/2018/07/28/jvm-cms/">http://matt33.com/2018/07/28/jvm-cms/</a></li>
</ol>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>请别再问我Jdk8 HashMap了，好吗？</title>
    <url>/2019/07/29/jdk8-hashmap-sourcecode/</url>
    <content><![CDATA[<p>上一篇文章中提到了ThreadLocalMap是使用开放地址法来解决冲突问题的，而我们今天的主角HashMap是采用了链表法来处理冲突的,什么是链表法呢?</p>
<p><img data-src="/images/java/hashmap-structure.png" alt="jdk8链表法"></p>
<p>在散列表中，每个 “ 桶(bucket)” 或者 “ 槽(slot)” 会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p>
<p>jdk8和jdk7不一样，jdk7中没有红黑树,数组中只挂载链表。而jdk8中在桶容量大于等于64且链表节点数大于等于8的时候转换为红黑树。当红黑树节点数量小于6时又会转换为链表。</p>
<a id="more"></a>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>但插入的时候,我们只需要通过散列函数计算出对应的槽位,将其插入到对应链表或者红黑树即可。如果此时元素数量超过了一定值则会进行扩容，同时进行rehash.</p>
<h3 id="查找或者删除"><a href="#查找或者删除" class="headerlink" title="查找或者删除"></a>查找或者删除</h3><p>通过散列函数计算出对应的槽，然后遍历链表或者删除</p>
<h3 id="链表为什么会转为红黑树"><a href="#链表为什么会转为红黑树" class="headerlink" title="链表为什么会转为红黑树?"></a>链表为什么会转为红黑树?</h3><p>上一篇文章有提到过通过装载因子来判定空闲槽位还有多少，如果超过装载因子的值就会动态扩容,HashMap会扩容为原来的两倍大小(初始容量为16,即槽(数组)的大小为16)。但是无论负载因子和散列函数设得再合理，也避免不了链表过长的情况，一旦链表过长查找和删除元素就比较耗时，影响HashMap性能,所以JDK8中对其进行了优化，当链表长度大于等于8的时候将链表转换为红黑树，利用红黑树的特点(查找、插入、删除的时间复杂度最坏为O(logn))，可以提高HashMap的性能。当节点个数少于6个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维持平衡，比起链表来，性能上的优势并不明显，而且编码难度比链表要大上不少。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="构造方法以及重要属性"><a href="#构造方法以及重要属性" class="headerlink" title="构造方法以及重要属性"></a>构造方法以及重要属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>HashMap的构造方法中可以分别指定初始化容量(bucket大小)以及负载因子，如果不指定默认值分别是16和0.75.它几个重要属性如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化容量，必须要2的n次幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子默认值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要从链表转换为红黑树时,链表节点的最小长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为红黑树时数组的最小容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resize操作时,红黑树节点个数小于6则转换为链表。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap阈值，用于判断是否需要扩容(threshold = 容量*loadFactor)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存数据的数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">  TreeNode&lt;K,V&gt; left;</span><br><span class="line">  TreeNode&lt;K,V&gt; right;</span><br><span class="line">  TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">  <span class="keyword">boolean</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的table就是存储数据的数组(可以叫做桶或者槽),数组挂载的是链表或者红黑树。值得一提的是构造HashMap的时候并没有初始化数组容量，而是在第一次put元素的时候才进行初始化的。</p>
<h3 id="hash函数的设计"><a href="#hash函数的设计" class="headerlink" title="hash函数的设计"></a>hash函数的设计</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>从上面可以看出,key为null是时候放到数组中的第一个位置的,我们一般定位key应当存放在数组哪个位置的时候一般是这样做的 <code>key.hashCode() % tab.length</code>。但是当tab.length是2的n次幂的时候，就可以转换为 <code>A % B = A &amp; (B-1)</code>;所以 <code>index = hash &amp; (tab.length-1)</code>就可以理解了。</p>
<blockquote>
<p>这里是使用了除留余数法的理念来设计的,可以可能减少hash冲突<br>除留余数法 : 用关键字K除以某个不大于hash表长度m的数p,将所得余数作为hash表地址<br>比如x/8=x&gt;&gt;3,即把x右移3位，得到了x/8的商，被移掉的部分(后三位)，则是x%8，也就是余数。</p>
</blockquote>
<p>而对于hash值的运算为什么是<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>呢？也就是为什么要向右移16位呢?直接使用 <code>key.hashCode() &amp; (tab.length -1)</code>不好吗？<br>如果这样做，由于tab.length肯定是远远小于hash值的,所以位运算的时候只有低位才参与运算，而高位毫无作为，会带来hash冲突的风险。</p>
<p><strong>而hashcode本身是一个32位整形值，向右移位16位之后再进行异或运行计算出来的整形将具有高位和低位的性质，就可以得到一个非常随机的hash值，在通过除留余数法，得到的index就更低概率的减少了冲突。</strong></p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 1. 如果数组未初始化,则初始化数组</span></span><br><span class="line"> <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 2. 如果当前节点未被插入数据(未碰撞),则直接new一个节点进行插入</span></span><br><span class="line"> <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 碰撞了,已存在相同的key,则进行覆盖</span></span><br><span class="line">   <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">       ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">       e = p;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        <span class="comment">// 4. 碰撞后发现为树结构，则挂载在树上</span></span><br><span class="line">       e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">            <span class="comment">// 5. 进行尾插入,如果链表节点数达到上线则转换为红黑树</span></span><br><span class="line">           <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">               p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                   treeifyBin(tab, hash);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 6. 链表中碰撞了</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">               ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           p = e;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 7. 用新value替换旧的value</span></span><br><span class="line">     <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">       V oldValue = e.value;</span><br><span class="line">       <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">           e.value = value;</span><br><span class="line">       afterNodeAccess(e);</span><br><span class="line">       <span class="keyword">return</span> oldValue;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ++modCount;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 8. 操作阈值则进行扩容</span></span><br><span class="line"> <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">     resize();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 给LinkedHashMap实现</span></span><br><span class="line"> afterNodeInsertion(evict);</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简述下put的逻辑，它主要分为以下几个步骤:</p>
<ol>
<li>首先判断是否初始化，如果未初始化则初始化数组,初始容量为16</li>
<li>通过hash&amp;(n-1)获取数组下标，如果该位置为空，表示未碰撞，直接插入数据</li>
<li>发生碰撞且存在相同的key，则在后面处理中直接进行覆盖</li>
<li>碰撞后发现为树结构，则直接挂载到红黑树上</li>
<li>碰撞后发现为链表结构，则进行尾插入，当链表容量大于等于8的时候转换为树节点</li>
<li>发现在链表中进行碰撞了，则在后面处理直接覆盖</li>
<li>发现之前存在相同的key,只直接用新值替换旧值</li>
<li>map的容量(存储元素的数量)大于阈值则进行扩容，扩容为之前容量的2倍</li>
</ol>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>resize()方法中，如果发现当前数组未初始化，则会初始化数组。如果已经初始化，则会将数组容量扩容为之前的两倍，同时进行rehash(将旧数组的数据移动到新的数组).JDK8的rehash过程很有趣，相比JDK7做了不少优化，我们来看下这里的rehash过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 数组扩容为之前2倍大小的代码省略，这里主要分析rehash过程。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="comment">// 遍历旧数组</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">   Node&lt;K,V&gt; e;</span><br><span class="line">   <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">     oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 1. 如果旧数组中不存在碰撞,则直接移动到新数组的位置</span></span><br><span class="line">     <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        <span class="comment">// 2. 如果存在碰撞，且节点类型是树节点，则进行树节点拆分(挂载到扩容后的数组中或者转为链表)</span></span><br><span class="line">        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">     <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 处理冲突是链表的情况,会保留原有节点的顺序</span></span><br><span class="line"></span><br><span class="line">       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">         next = e.next;</span><br><span class="line">         <span class="comment">// 4. 判断扩容后元素是否在原有的位置(这里非常巧妙,下面会分析)</span></span><br><span class="line">         <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">               loHead = e;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               loTail.next = e;</span><br><span class="line">           loTail = e;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 5. 元素不是在原有位置</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">               hiHead = e;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               hiTail.next = e;</span><br><span class="line">           hiTail = e;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 6. 将扩容后未改变index的元素复制到新数组</span></span><br><span class="line">       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">         loTail.next = <span class="keyword">null</span>;</span><br><span class="line">         newTab[j] = loHead;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 7. 将扩容后改变了index位置的元素复制到新数组</span></span><br><span class="line">       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">         hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">// 8. index改变后,新的下标是j+oldCap,这里也很巧妙，下面会分析</span></span><br><span class="line">         newTab[j + oldCap] = hiHead;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中展现了整个rehash的过程，先遍历旧数组中的元素，接着做下面的事情</p>
<ol>
<li>如果旧数组中不存在数据碰撞(未挂载链表或者红黑树),那么直接将元素赋值到新数组中，其中<code>index=e.hash &amp; (newCap - 1)</code>。</li>
<li>如果存在碰撞，且节点类型是树节点，则进行树节点拆分(挂载到扩容后的数组中或者转为链表)</li>
<li>如果存在碰撞，且节点是链表，则处理链表的情况,<strong>rehash过程会保留节点原始顺序(JDK7中不会保留，这也是导致jdk7中多线程出现死循环的原因)</strong></li>
<li>判断元素在扩容后是否还处于原有的位置，这里通过<code>(e.hash &amp; oldCap) == 0</code>判断,oldCap表示扩容前数组的大小。</li>
<li>发现元素不是在原有位置，更新hiTail和hiHead的指向关系</li>
<li>将扩容后未改变index的元素复制到新数组</li>
<li>将扩容后改变了index位置的元素复制到新数组，新数组的下标是 <code>j + oldCap</code>。</li>
</ol>
<p>其中第4点和第5点中将链表的元素分为两部分(do..while部分)，一部分是rehash后index未改变的元素，一部分是index被改变的元素。分别用两个指针来指向头尾节点。</p>
<blockquote>
<p>比如当oldCap=8时,1–&gt;9–&gt;17都挂载在tab[1]上,而扩容后，1–&gt;17挂载在tab[1]上,9挂载在tab[9]上。</p>
</blockquote>
<p>那么是如何确定rehash后index是否被改变呢？改变之后的index又变成了多少呢？</p>
<p>这里的设计很是巧妙，还记得HashMap中数组大小是2的n次幂吗?当我们计算索引位置的时候，使用的是 e.hash &amp; (tab.length -1)。</p>
<p>这里我们讨论数组大小从8扩容到16的过程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tab.length -1 &#x3D; 7   0 0 1 1 1</span><br><span class="line">e.hashCode &#x3D; x      0 x x x x</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">                    0 0 y y y  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以发现在扩容前index的位置由hashCode的低三位来决定。那么扩容后呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tab.length -1 &#x3D; 15   0 1 1 1 1</span><br><span class="line">e.hashCode &#x3D; x       x x x x x</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">                     0 z y y y</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>扩容后，index的位置由低四位来决定,而低三位和扩容前一致。也就是说扩容后index的位置是否改变是由高字节来决定的,也就是说我们只需要将hashCode和高位进行运算即可得到index是否改变。</p>
<p>而刚好扩容之后的高位和oldCap的高位一样。如上面的15二进制是1111,而8的二进制是1000,他们的高位都是一样的。所以我们通过e.hash &amp; oldCap运算的结果即可判断index是否改变。</p>
<p>同理，如果扩容后index该变了。新的index和旧的index的值也是高位不同，其新值刚好是 oldIndex + oldCap的值。所以当index改变后,新的index是 j + oldCap。</p>
<p>至此,resize方法结束,元素被插入到了该有的位置。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>get()的方法就相对来说要简单一些了，它最重要的就是找到key是存放在哪个位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 首先(n-1) &amp; hash确定元素位置</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 判断第一个元素是否是我们需要找的元素</span></span><br><span class="line">      <span class="keyword">if</span> (first.hash == hash &amp;&amp;</span><br><span class="line">          ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">return</span> first;</span><br><span class="line">      <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. 节点如果是树节点,则在红黑树中寻找元素</span></span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="number">4.</span> 在链表中寻找对应的节点</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>remove方法寻找节点的过程和get()方法寻找节点的过程是一样的，这里我们主要分析寻找到节点后是如何处理的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">    <span class="comment">// 1. 删除树节点,删除时如果不平衡会重新移动节点位置</span></span><br><span class="line">    <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">    <span class="comment">// 删除的节点是链表第一个节点,则直接将第二个节点赋值为第一个节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">        tab[index] = node.next;</span><br><span class="line">    <span class="comment">// 删除的节点是链表的中间节点，这里的p为node的prev节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p.next = node.next;</span><br><span class="line">    ++modCount;</span><br><span class="line">    --size;</span><br><span class="line">    afterNodeRemoval(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>remove方法中，最为复杂的部分应该是removeTreeNode部分，因为删除红黑树节点后，可能需要退化为链表节点，还可能由于不满足红黑树特点，需要移动节点位置。<br>代码也比较多，这里就不贴上来了。但也因此佐证了为什么不全部使用红黑树来代替链表。</p>
<h3 id="JDK7扩容时导致的死循环问题"><a href="#JDK7扩容时导致的死循环问题" class="headerlink" title="JDK7扩容时导致的死循环问题"></a>JDK7扩容时导致的死循环问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line"> Entry[] src = table;</span><br><span class="line"> <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">   Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">   <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">       src[j] = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           <span class="comment">// B线程执行到这里之后就暂停了</span></span><br><span class="line">           Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">           <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">           e.next = newTable[i];</span><br><span class="line">           newTable[i] = e;</span><br><span class="line">           e = next;</span><br><span class="line">       &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>扩容时上面的代码容易导致死循环,是怎样导致的呢？假设有两个线程A和B都在执行这一段代码，数组大小由2扩容到4,在扩容前tab[1]=1–&gt;5–&gt;9。<br><img data-src="/images/java/hashmap-unresize.png" alt="扩容前"></p>
<p>当B线程执行到 next = e.next时让出时间片,A线程执行完整段代码但是还没有将内部的table设置为新的newTable时，线程B继续执行。</p>
<p>此时A线程执行完成之后，挂载在tab[1]的元素是9–&gt;5–&gt;1,注意这里的<strong>顺序被颠倒了</strong>。此时e = 1, next = 5;</p>
<blockquote>
<p>tab[i]的按照循环次数变更顺序, 1. tab[i]=1, 2. tab[i]=5–&gt;1, 3. tab[i]=9–&gt;5–&gt;1</p>
</blockquote>
<p><img data-src="/images/java/hashmap-resize-threadA.png" alt="线程A执行完成后"></p>
<p>同样B线程我们也按照循环次数来分析</p>
<ol>
<li>第一次循环执行完成后,newTable[i]=1, e = 5</li>
<li>第二次循环完成后: newTable[i]=5–&gt;1, e = 1。 </li>
<li>第三次循环,e没有next,所以next指向null。当执行e.next = newTable[i](1–&gt;5)的时候,就形成了 1–&gt;5–&gt;1的环,再执行newTable[i]=e,此时newTable[i] = 1–&gt;5–&gt;1。</li>
</ol>
<p>当在数组该位置get寻找对应的key的时候，就发生了死循环,引起CPU 100%问题。</p>
<p><img data-src="/images/java/hashmap-resize.png" alt="线程B执行扩容过程"></p>
<p>而JDK8就不会出现这个问题,它在这里就有一个优化，它使用了两个指针来分别指向头节点和尾节点，而且还保证了元素原本的顺序。<br>当然HashMap仍然是不安全的,所以在多线程并发条件下推荐使用ConcurrentHashMap。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>我花了一周读了Kafka Producer的源码</title>
    <url>/2019/03/07/kafka-producer-source-code-analysis/</url>
    <content><![CDATA[<p>talk is easy,show me the code,先来看一段创建producer的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducerDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    KafkaProducer&lt;String,String&gt; producer = createProducer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定topic,key,value</span></span><br><span class="line">    ProducerRecord&lt;String,String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;test1&quot;</span>,<span class="string">&quot;newkey1&quot;</span>,<span class="string">&quot;newvalue1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异步发送</span></span><br><span class="line">    producer.send(record);</span><br><span class="line">    producer.close();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;发送完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KafkaProducer&lt;String,String&gt; <span class="title">createProducer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bootstrap.servers 必须设置</span></span><br><span class="line">    props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.239.131:9092&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key.serializer   必须设置</span></span><br><span class="line">    props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// value.serializer  必须设置</span></span><br><span class="line">    props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//client.id</span></span><br><span class="line">    props.put(ProducerConfig.CLIENT_ID_CONFIG, <span class="string">&quot;client-0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//retries</span></span><br><span class="line">    props.put(ProducerConfig.RETRIES_CONFIG, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//acks</span></span><br><span class="line">    props.put(ProducerConfig.ACKS_CONFIG, <span class="string">&quot;all&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//max.in.flight.requests.per.connection</span></span><br><span class="line">    props.put(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//linger.ms</span></span><br><span class="line">    props.put(ProducerConfig.LINGER_MS_CONFIG, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//batch.size</span></span><br><span class="line">    props.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class="number">10240</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//buffer.memory</span></span><br><span class="line">    props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, <span class="number">10240</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>生产者的API使用还是比较简单,创建一个ProducerRecord对象(<strong>这个对象包含目标主题和要发送的内容,当然还可以指定键以及分区</strong>),然后调用send方法就把消息发送出去了。在发送ProducerRecord对象时，生产者要先把键和值对象序列化成字节数组，这样才能在网络上进行传输。<br>在深入源码之前，我先给出一张源码分析图给大家(其实应该在结尾的时候给出来),这样看着图再看源码跟容易些<br><img data-src="/images/introduction-kafka/kafka_producer_process.png" alt="流程图"></p>
<p>简要说明:</p>
<ol>
<li><p><code>new KafkaProducer()</code>后创建一个后台线程KafkaThread(实际运行线程是Sender,KafkaThread是对Sender的封装)扫描RecordAccumulator中是否有消息</p>
</li>
<li><p>调用<code>KafkaProducer.send()</code>发送消息，实际是将消息保存到RecordAccumulator中,实际上就是保存到一个Map中(<code>ConcurrentMap&lt;TopicPartition, Deque&lt;ProducerBatch&gt;&gt;</code>),这条消息会被记录到同一个记录批次(相同主题相同分区算同一个批次)里面,这个批次的所有消息会被发送到相同的主题和分区上</p>
</li>
<li><p>后台的独立线程扫描到<code>RecordAccumulator</code>中有消息后，会将消息发送到kafka集群中(不是一有消息就发送，而是要看消息是否ready)</p>
</li>
<li><p>如果发送成功(消息成功写入kafka),就返回一个<code>RecordMetaData</code>对象，它包换了主题和分区信息，以及记录在分区里的偏移量。</p>
</li>
<li><p>如果写入失败，就会返回一个错误，生产者在收到错误之后会尝试重新发送消息(<strong>如果允许的话,此时会将消息在保存到RecordAccumulator中</strong>),几次之后如果还是失败就返回错误消息</p>
</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="后台线程的创建"><a href="#后台线程的创建" class="headerlink" title="后台线程的创建"></a>后台线程的创建</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KafkaClient client &#x3D; new NetworkClient(...);</span><br><span class="line">this.sender &#x3D; new Sender(.,client,...);</span><br><span class="line">String ioThreadName &#x3D; &quot;kafka-producer-network-thread&quot; + &quot; | &quot; + clientId;</span><br><span class="line">this.ioThread &#x3D; new KafkaThread(ioThreadName, this.sender, true);</span><br><span class="line">this.ioThread.start();</span><br></pre></td></tr></table></figure>
<p>上面的代码就是构造<code>KafkaProducer</code>时核心逻辑,它会构造一个<code>KafkaClient</code>负责和broker通信,同时构造一个<code>Sender</code>并启动一个异步线程，这个线程会被命名为：<strong>kafka-producer-network-thread|${clientId}</strong>,如果你在创建producer的时候指定<code>client.id</code>的值为myclient,那么线程名称就是<strong>kafka-producer-network-thread|myclient</strong></p>
<h4 id="发送消息-缓存消息"><a href="#发送消息-缓存消息" class="headerlink" title="发送消息(缓存消息)"></a>发送消息(缓存消息)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">KafkaProducer&lt;String,String&gt; producer = createProducer();</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定topic,key,value</span></span><br><span class="line">ProducerRecord&lt;String,String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(<span class="string">&quot;test1&quot;</span>,<span class="string">&quot;newkey1&quot;</span>,<span class="string">&quot;newvalue1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步发送,可以设置回调函数</span></span><br><span class="line">producer.send(record);</span><br><span class="line"><span class="comment">//同步发送</span></span><br><span class="line"><span class="comment">//producer.send(record).get();</span></span><br></pre></td></tr></table></figure>

<p>发送消息有同步发送以及异步发送两种方式，我们一般不使用同步发送，毕竟太过于耗时，使用异步发送的时候可以指定回调函数，当消息发送完成的时候(成功或者失败)会通过回调通知生产者。</p>
<p>发送消息实际上是将消息缓存起来，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, </span><br><span class="line">  serializedKey,serializedValue, headers, interceptCallback, remainingWaitMs);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>RecordAccumulator</code>的核心数据结构是<code>ConcurrentMap&lt;TopicPartition, Deque&lt;ProducerBatch&gt;&gt;</code>,会将相同主题相同Partition的数据放到一个Deque(双向队列)中,这也是我们之前提到的同一个记录批次里面的消息会发送到同一个主题和分区的意思。append()方法的核心源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从batchs(ConcurrentMap&lt;TopicPartition, Deque&lt;ProducerBatch&gt;&gt;)中</span></span><br><span class="line"><span class="comment">//根据主题分区获取对应的队列，如果没有则new ArrayDeque&lt;&gt;返回</span></span><br><span class="line">Deque&lt;ProducerBatch&gt; dq = getOrCreateDeque(tp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算同一个记录批次占用空间大小，batchSize根据batch.size参数决定</span></span><br><span class="line"><span class="keyword">int</span> size = Math.max(<span class="keyword">this</span>.batchSize, AbstractRecords.estimateSizeInBytesUpperBound(</span><br><span class="line">    maxUsableMagic, compression, key, value, headers));</span><br><span class="line"></span><br><span class="line"><span class="comment">//为同一个topic,partition分配buffer，如果同一个记录批次的内存不足，</span></span><br><span class="line"><span class="comment">//那么会阻塞maxTimeToBlock(max.block.ms参数)这么长时间</span></span><br><span class="line">ByteBuffer buffer = free.allocate(size, maxTimeToBlock);</span><br><span class="line"><span class="keyword">synchronized</span> (dq) &#123;</span><br><span class="line">  <span class="comment">//创建MemoryRecordBuilder,通过buffer初始化appendStream(DataOutputStream)属性</span></span><br><span class="line">  MemoryRecordsBuilder recordsBuilder = recordsBuilder(buffer, maxUsableMagic);</span><br><span class="line">  ProducerBatch batch = <span class="keyword">new</span> ProducerBatch(tp, recordsBuilder, time.milliseconds());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将key,value写入到MemoryRecordsBuilder中的appendStream(DataOutputStream)中</span></span><br><span class="line">  batch.tryAppend(timestamp, key, value, headers, callback, time.milliseconds());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将需要发送的消息放入到队列中</span></span><br><span class="line">  dq.addLast(batch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="发送消息到Kafka"><a href="#发送消息到Kafka" class="headerlink" title="发送消息到Kafka"></a>发送消息到Kafka</h4><p>上面已经将消息存储<code>RecordAccumulator</code>中去了,现在看看怎么发送消息。上面我们提到了创建KafkaProducer的时候会启动一个异步线程去从RecordAccumulator中取得消息然后发送到Kafka,发送消息的核心代码是<code>Sender.java</code>,它实现了Runnable接口并在后台一直运行处理发送请求并将消息发送到合适的节点，直到KafkaProducer被关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The background thread that handles the sending of produce requests to the Kafka cluster. This thread makes metadata</span></span><br><span class="line"><span class="comment">* requests to renew its view of the cluster and then sends produce requests to the appropriate nodes.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一直运行直到kafkaProducer.close()方法被调用</span></span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">       run(time.milliseconds());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从日志上看是开始处理KafkaProducer被关闭后的逻辑</span></span><br><span class="line">    log.debug(<span class="string">&quot;Beginning shutdown of Kafka producer I/O thread, sending remaining records.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当非强制关闭的时候，可能还仍然有请求并且accumulator中还仍然存在数据，此时我们需要将请求处理完成</span></span><br><span class="line">    <span class="keyword">while</span> (!forceClose &amp;&amp; (<span class="keyword">this</span>.accumulator.hasUndrained() || <span class="keyword">this</span>.client.inFlightRequestCount() &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">       run(time.milliseconds());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (forceClose) &#123;</span><br><span class="line">        <span class="comment">//如果是强制关闭,且还有未发送完毕的消息，则取消发送并抛出一个异常new KafkaException(&quot;Producer is closed forcefully.&quot;)</span></span><br><span class="line">        <span class="keyword">this</span>.accumulator.abortIncompleteBatches();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>KafkaProducer的关闭方法有2个,<code>close()</code>以及<code>close(long timeout,TimeUnit timUnit)</code>,其中timeout参数的意思是等待生产者完成任何待处理请求的最长时间，第一种方式的timeout为Long.MAX_VALUE毫秒,如果采用第二种方式关闭，当timeout=0的时候则表示强制关闭,直接关闭Sender(设置running=false)。</p>
<p>run(long)方法中我们先跳过对transactionManager的处理，查看发送消息的主要流程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将记录批次转移到每个节点的生产请求列表中</span></span><br><span class="line"><span class="keyword">long</span> pollTimeout = sendProducerData(now);</span><br><span class="line"></span><br><span class="line"><span class="comment">//轮询进行消息发送</span></span><br><span class="line">client.poll(pollTimeout, now);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先查看sendProducerData()方法，它的核心逻辑在<code>sendProduceRequest()</code>方法(处于Sender.java)中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (ProducerBatch batch : batches) &#123;</span><br><span class="line">    TopicPartition tp = batch.topicPartition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将ProducerBatch中MemoryRecordsBuilder转换为MemoryRecords(发送的数据就在这里面)</span></span><br><span class="line">    MemoryRecords records = batch.records();</span><br><span class="line">    produceRecordsByPartition.put(tp, records);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProduceRequest.Builder requestBuilder = ProduceRequest.Builder.forMagic(minUsedMagic, acks, timeout,</span><br><span class="line">        produceRecordsByPartition, transactionalId);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息发送完成时的回调</span></span><br><span class="line">RequestCompletionHandler callback = <span class="keyword">new</span> RequestCompletionHandler() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(ClientResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理响应消息</span></span><br><span class="line">        handleProduceResponse(response, recordsByPartition, time.milliseconds());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据参数构造ClientRequest,此时需要发送的消息在requestBuilder中</span></span><br><span class="line">ClientRequest clientRequest = client.newClientRequest(nodeId, requestBuilder, now, acks != <span class="number">0</span>,</span><br><span class="line">        requestTimeoutMs, callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将clientRequest转换成Send对象(Send.java,包含了需要发送数据的buffer)，</span></span><br><span class="line"><span class="comment">//给KafkaChannel设置该对象，记住这里还没有发送数据</span></span><br><span class="line">client.send(clientRequest, now);</span><br></pre></td></tr></table></figure>

<p>上面的client.send()方法最终会定位到NetworkClient.doSend()方法，所有的请求(无论是producer发送消息的请求还是获取metadata的请求)都是通过该方法设置对应的Send对象。所支持的请求在ApiKeys.java中都有定义，这里面可以看到每个请求的request以及response对应的数据结构。</p>
<p>上面只是设置了发送消息所需要准备的内容，现在进入到发送消息的主流程，发送消息的核心代码在Selector.java的pollSelectionKeys()方法中，代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* if channel is ready write to any sockets that have space in their buffer and for which we have data */</span></span><br><span class="line"><span class="keyword">if</span> (channel.ready() &amp;&amp; key.isWritable()) &#123;</span><br><span class="line">  <span class="comment">//底层实际调用的是java8 GatheringByteChannel的write方法</span></span><br><span class="line">  channel.write();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就这样，我们的消息就发送到了broker中了,发送流程分析完毕，这个是完美的情况，但是总会有发送失败的时候(消息过大或者没有可用的leader)，那么发送失败后重发又是在哪里完成的呢?还记得上面的回调函数吗？没错，就是在回调函数这里设置的，先来看下回调函数源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleProduceResponse</span><span class="params">(ClientResponse response, Map&lt;TopicPartition, ProducerBatch&gt; batches, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">  RequestHeader requestHeader = response.requestHeader();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (response.wasDisconnected()) &#123;</span><br><span class="line">    <span class="comment">//如果是网络断开则构造Errors.NETWORK_EXCEPTION的响应</span></span><br><span class="line">    <span class="keyword">for</span> (ProducerBatch batch : batches.values())</span><br><span class="line">        completeBatch(batch, <span class="keyword">new</span> ProduceResponse.PartitionResponse(Errors.NETWORK_EXCEPTION), correlationId, now, <span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.versionMismatch() != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果是版本不匹配，则构造Errors.UNSUPPORTED_VERSION的响应</span></span><br><span class="line">    <span class="keyword">for</span> (ProducerBatch batch : batches.values())</span><br><span class="line">        completeBatch(batch, <span class="keyword">new</span> ProduceResponse.PartitionResponse(Errors.UNSUPPORTED_VERSION), correlationId, now, <span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (response.hasResponse()) &#123;</span><br><span class="line">        <span class="comment">//如果存在response就返回正常的response</span></span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果acks=0，那么则构造Errors.NONE的响应，因为这种情况只需要发送不需要响应结果</span></span><br><span class="line">        <span class="keyword">for</span> (ProducerBatch batch : batches.values()) &#123;</span><br><span class="line">            completeBatch(batch, <span class="keyword">new</span> ProduceResponse.PartitionResponse(Errors.NONE), correlationId, now, <span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在completeBatch方法中我们主要关注失败的逻辑处理，核心源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">completeBatch</span><span class="params">(ProducerBatch batch, ProduceResponse.PartitionResponse response, <span class="keyword">long</span> correlationId,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> now, <span class="keyword">long</span> throttleUntilTimeMs)</span> </span>&#123;</span><br><span class="line">  Errors error = response.error;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果发送的消息太大，需要重新进行分割发送</span></span><br><span class="line">  <span class="keyword">if</span> (error == Errors.MESSAGE_TOO_LARGE &amp;&amp; batch.recordCount &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">        (batch.magic() &gt;= RecordBatch.MAGIC_VALUE_V2 || batch.isCompressed())) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.accumulator.splitAndReenqueue(batch);</span><br><span class="line">    <span class="keyword">this</span>.accumulator.deallocate(batch);</span><br><span class="line">    <span class="keyword">this</span>.sensors.recordBatchSplit();</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error != Errors.NONE) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发生了错误，如果此时可以retry(retry次数未达到限制以及产生异常是RetriableException)</span></span><br><span class="line">    <span class="keyword">if</span> (canRetry(batch, response)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (transactionManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//把需要重试的消息放入队列中，等待重试，实际就是调用deque.addFirst(batch)</span></span><br><span class="line">            reenqueueBatch(batch, now);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Producer发送消息的流程已经分析完毕，现在回过头去看流程图会更加清晰。</p>
<p>更多关于Kafka协议的涉及可以参考这个<a href="https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol">链接</a></p>
<h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line"><span class="keyword">if</span> (keyBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果key为null,则使用Round Robin算法</span></span><br><span class="line">    <span class="keyword">int</span> nextValue = nextValue(topic);</span><br><span class="line">    List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">    <span class="keyword">if</span> (availablePartitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> part = Utils.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">        <span class="keyword">return</span> availablePartitions.get(part).partition();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// no partitions are available, give a non-available partition</span></span><br><span class="line">        <span class="keyword">return</span> Utils.toPositive(nextValue) % numPartitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 根据key进行散列</span></span><br><span class="line">    <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kafka中对于分区的算法有两种情况</p>
<ol>
<li>如果键值为null,并且使用了默认的分区器，那么记录键随机地发送到主题内各个可用的分区上。分区器使用轮询(Round Robin)算法键消息均衡地分布到各个分区上。</li>
<li>如果键不为空，并且使用了默认的分区器，那么Kafka会对键进行散列(使用Kafka自己的散列算法，即使升级Java版本，散列值也不会发生变化)，然后根据散列值把消息映射到特定的分区上。同一个键总是被映射到同一个分区上(如果分区数量发生了变化则不能保证)，映射的时候会使用主题所有的分区，而不仅仅是可用分区，所以如果写入数据分区是不可用的，那么就会发生错误，当然这种情况很少发生。</li>
</ol>
<p>如果你想要实现自定义分区，那么只需要实现Partitioner接口即可。</p>
<h3 id="生产者的配置参数"><a href="#生产者的配置参数" class="headerlink" title="生产者的配置参数"></a>生产者的配置参数</h3><p>分析了KafkaProducer的源码之后，我们会发现很多参数是贯穿在整个消息发送流程，下面列出了一些KafkaProducer中用到的配置参数。</p>
<ol>
<li><p>acks<br>acks参数指定了必须要有多少个分区副本收到该消息，producer才会认为消息写入是成功的。有以下三个选项</p>
<ul>
<li><p>acks=0,生产者不需要等待服务器的响应，也就是说如果其中出现了问题，导致服务器没有收到消息，生产者就无从得知，消息也就丢失了，当时由于不需要等待响应，所以可以以网络能够支持的最大速度发送消息，从而达到很高的吞吐量。</p>
</li>
<li><p>acks=1, 只需要集群的leader收到消息，生产者就会收到一个来自服务器的成功响应。如果消息无法到达leader，生产者会收到一个错误响应，此时producer会重发消息。不过如果一个没有收到消息的节点称为leader，消息还是会丢失。</p>
</li>
<li><p>acks=all,当所有参与复制的节点全部收到消息的时候，生产者才会收到一个来自服务器的成功响应，最安全不过延迟比较高。</p>
</li>
</ul>
</li>
<li><p>buffer.memory</p>
<p>设置生产者内存缓冲区的大小，如果应用程序发送消息的速度超过生产者发送到服务器的速度，那么就会导致生产者空间不足，此时send()方法要么被阻塞，要么抛出异常。取决于如何设置max.block.ms，表示在抛出异常之前可以阻塞一段时间。</p>
</li>
<li><p>retries</p>
<p>发送消息到服务器收到的错误可能是可以临时的错误(比如找不到leader),这种情况下根据该参数决定生产者重发消息的次数。注意：此时要根据重试次数以及是否是RetriableException来决定是否重试。</p>
</li>
<li><p>batch.size</p>
<p>当有多个消息需要被发送到同一个分区的时候，生产者会把他们放到同一个批次里面(Deque),该参数指定了一个批次可以使用的内存大小，按照字节数计算，当批次被填满，批次里的所有消息会被发送出去。不过生产者并不一定会等到批次被填满才发送，半满甚至只包含一个消息的批次也有可能被发送。</p>
</li>
<li><p>linger.ms</p>
<p>指定了生产者在发送批次之前等待更多消息加入批次的时间。KafkaProducer会在批次填满或linger.ms达到上限时把批次发送出去。把linger.ms设置成比0大的数，让生产者在发送批次之前等待一会儿，使更多的消息加入到这个批次，虽然这样会增加延迟，当时也会提升吞吐量。</p>
</li>
<li><p>max.block.ms</p>
<p>指定了在调用send()方法或者partitionsFor()方法获取元数据时生产者的阻塞时间。当生产者的发送缓冲区已满，或者没有可用的元数据时，这些方法就会阻塞。在阻塞时间达到max.block.ms时,就会抛出new TimeoutException(“Failed to allocate memory within the configured max blocking time “ + maxTimeToBlockMs + “ ms.”);</p>
</li>
<li><p>client.id</p>
<p>任意字符串，用来标识消息来源，我们的后台线程就会根据它来起名儿，线程名称是kafka-producer-network-thread|{client.id}</p>
</li>
<li><p>max.in.flight.requests.per.connection</p>
<p>该参数指定了生产者在收到服务器响应之前可以发送多少个消息。它的值越高，就会占用越多的内存，不过也会提升吞吐量。把它设为1可以保证消息是按照发送的顺序写入服务器的，即便发生了重试。</p>
</li>
<li><p>timeout.ms、request.timeout.ms和metadata.fetch.timeout.ms</p>
<p>request.timeout.ms指定了生产者在发送数据时等待服务器返回响应的时间，metadata.fetch.timeout.ms指定了生产者在获取元数据(比如目标分区的leader)时等待服务器返回响应的时间。如果等待响应超时，那么生产者要么重试发送数据，要么返回一个错误。timeout.ms指定了broker等待同步副本返回消息确认的时间，与asks的配置相匹配——如果在指定时间内没有收到同步副本的确认，那么broker就会返回一个错误。</p>
</li>
<li><p>max.request.size</p>
<p>该参数用于控制生产者发送的请求大小。broker对可接收的消息最大值也有自己的限制(message.max.bytes),所以两边的配置最好可以匹配，避免生产者发送的消息被broker拒绝。</p>
</li>
<li><p>receive.buffer.bytes和send.buffer.bytes</p>
<p>这两个参数分别制定了TCP socket接收和发送数据包的缓冲区大小(和broker通信还是通过socket)。如果他们被设置为-1，就使用操作系统的默认值。如果生产者或消费者与broker处于不同的数据中心，那么可以适当增大这些值，因为跨数据中心的网络一般都有比较高的延迟和比较低的带宽。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>java中锁的优化</title>
    <url>/2018/07/19/lock-optimization-about-java/</url>
    <content><![CDATA[<h3 id="一切都始于线程-Thread"><a href="#一切都始于线程-Thread" class="headerlink" title="一切都始于线程(Thread)"></a>一切都始于线程(Thread)</h3><p>线程是比进程更加轻量级的调度执行单位,线程的引入可以把一个进程的资源分配和执行调服分开,各个线程之间共享进程资源又可以独立调度,主流的操作系统都提供了线程实现,Java提供了在不同硬件和不同操作系统平台上对线程操作的统一处理。</p>
<p>一般操作系统实现线程主要有3种方式：</p>
<ol>
<li>使用内核线程(直接由操作系统内核支持)实现,但是一般都是去使用内核线程的一种高级接口——轻量级进程</li>
<li>使用用户线程(除了内核线程)实现</li>
<li>使用用户线程加轻量级进程混合实现。</li>
</ol>
<p>而java中的线程就是映射到一条轻量级进程中的,所以如果要阻塞或者唤醒一个线程都需要需要操作系统的支持,因为要从用户态转换到核心态中需要耗费很多的处理器时间,所以才有说法说synchronized是java中的一个重量级的操作。</p>
<h3 id="synchronized你对我的代码做了什么"><a href="#synchronized你对我的代码做了什么" class="headerlink" title="synchronized你对我的代码做了什么?"></a>synchronized你对我的代码做了什么?</h3><p>我们都知道Synchronized 在修饰同步代码块时,是由 monitorenter 和 monitorexit 指令来实现同步的。进入 monitorenter 指令后,线程将持有 Monitor 对象,退出 monitorenter 指令后,线程将释放该 Monitor 对象。</p>
<blockquote>
<p>使用javap -v xxx.class 可以看到字节文件中的monitorenter和monitorexit指令</p>
</blockquote>
<p>而我们一般可以在代码块中指明需要加锁的对象或者在根据修饰的是实例方法还是类方法(static方法)来获取对应的对应实例或者Class对象来进行加锁。</p>
<blockquote>
<p>当 Synchronized 修饰同步方法时,并不会出现 monitorenter 和 monitorexit 指令,而是出现了一个 ACC_SYNCHRONIZED 标志。这是因为 JVM 使用了 ACC_SYNCHRONIZED 访问标志来区分一个方法是否是同步方法。当方法调用时,调用指令将会检查该方法是否被设置 ACC_SYNCHRONIZED 访问标志。如果设置了该标志,执行线程将先持有 Monitor 对象,然后再执行方法。在该方法运行期间,其它线程将无法获取到该 Mointor 对象,当方法执行完成后,再释放该 Monitor 对象。</p>
</blockquote>
<p>java的线程是映射到操作系统的原生线程上的,所以要阻塞或者唤醒一个线程,都需要操作系统的帮助,这就需要从用户态转换到核心态中,因此要耗费很多的处理器时间。所以才说是一个重量级操作。</p>
<p>JVM中的synchronized是基于管程实现的,你可以认为管程就是信号量,synchronized实现加锁其操作系统底层实现方式是Pthread(基于信号量)。信号量我在之前操作系统的文章有提到过,不太清楚的可以再去看看。</p>
<p>信号量实际上是一个整形变量,比如 lock 初始值为0,加锁就将lock的值加1,释放锁就将lock的值减去1,加锁以及释放锁的过程由操作系统保证原子性。</p>
<p>synchronized也不外如是,它会在加锁之前先去获取锁,如果获取到了就把目标锁对象的计数器加1,释放锁就减去1,当计数器的值为0的时候就释放锁,monitorexit这个指令会在同步代码执行完毕的时候将计数器减去1。如果没有获取到锁,那么就要阻塞等待,直到对象锁被其他线程释放,在重新去竞争。</p>
<p>Java中每个对象实例都会有一个Monitor,其对应C++的ObjectMonitor.hpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">  _header       = <span class="literal">NULL</span>;</span><br><span class="line">  _count        = <span class="number">0</span>;</span><br><span class="line">  _waiters      = <span class="number">0</span>,</span><br><span class="line">  <span class="comment">// 递归数量,和可重入锁有关</span></span><br><span class="line">  _recursions   = <span class="number">0</span>;</span><br><span class="line">  _object       = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// 标识拥有该monitor的线程</span></span><br><span class="line">  _owner        = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// 处于wait状态的线程,会被加入到_WaitSet</span></span><br><span class="line">  _WaitSet      = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// 自旋锁</span></span><br><span class="line">  _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">  _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">  _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">  <span class="comment">// contention queue(保存竞争线程的队列)</span></span><br><span class="line">  _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">  FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">  <span class="comment">// 处于等待锁block状态的线程,会被加入到该列表</span></span><br><span class="line">  _EntryList    = <span class="literal">NULL</span> ;</span><br><span class="line">  <span class="comment">// 自旋次数</span></span><br><span class="line">  _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">  _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">  OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/java/synchronized-process.png"></p>
<p>当多个线程同时访问一段同步代码时,多个竞争线程会先被存放到contention queue(cxq)中,cxq上的线程最终会被放置到EntryList,处于blocking状态的线程都会被加入到EntryList列表。<br>接下来当线程获取到对象的monitor时,monitor 是依靠底层操作系统的 Mutex Lock 来实现互斥的(实际就是信号量),线程阻塞操作由操作系统完成(在Linxu下通 过pthread_mutex_lock函数。当线程申请到Mutex成功,则持有该Mutex,其他线程将无法获取到Mutex,竞争失败的线程会再次进入contention queue被挂起。</p>
<p>如果线程调用了wait()方法,就会释放当前持有的Mutex,此时线程就会被放置到_WaitSet集合中,等待下一次被唤醒。如果当前线程顺利执行完方法,也会释放Mutex。<br>而处于_WaitSet集中的线程被唤醒后都会加入到_EntryList集合中。</p>
<blockquote>
<p>关于contention queue说明可以在objectMonitor.cpp看到,mutex实现可以查看 mutex.cpp</p>
</blockquote>
<h3 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h3><p>为了提升性能,JDK1.6 引入了偏向锁、轻量级锁、重量级锁概念,来减少锁竞争带来的上下文切换,而正是新增的 Java 对象头实现了锁升级功能。</p>
<p>当 Java 对象被 Synchronized 关键字修饰成为同步锁后,围绕这个锁的一系列升级操作都将和 Java 对象头有关。</p>
<h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><p>对象头分为两部分,第一部分存储hash码(hashcode),GC分代年龄等,这部分数据的长度在32位系统和64位系统分别为32位和64位,官方称其为“Mark Word”,它们是实现偏向锁和轻量级锁的关键。另一部分用于存储指向方法区对象类型数据的指针,如果是数组对象的话,还会有一个额外的部分用于存储数组长度。</p>
<p>对象头信息与对象自定义的数据无关的额外存储成本,考虑虚拟机的空间效率,Mark Word被设计成一个非固定的的数据结构以便在极小的空间存储更多的信息,它会根据对象的状态复用自己的存储空间。</p>
<p>那么从哪里可以看到这些信息呢？有问题当然看源码,从github上jdk的源码<a href="https://github.com/openjdk/jdk/blob/jdk8-b120/hotspot/src/share/vm/oops/markOop.hpp#L38">源码</a></p>
<p>整理下,这里在内存中的布局如下：</p>
<p><img data-src="/images/mark_word.png" alt="32位系统mark word"><br>上图表明了MarkWord在不同状态下的存储内容,当然上面这是32位系统的,如果是64位基本上是大同小异,</p>
<p>锁升级功能主要依赖于 Mark Word 中的锁标志位和释放偏向锁标志位,Synchronized 同步锁就是从偏向锁开始的,随着竞争越来越激烈,偏向锁升级到轻量级锁,最终升级到重量级锁。</p>
<p>monitorenter执行入口在InterpreterRuntime.cpp的InterpreterRuntime::monitorenter函数。</p>
<h4 id="自旋锁以及自适应自旋"><a href="#自旋锁以及自适应自旋" class="headerlink" title="自旋锁以及自适应自旋"></a>自旋锁以及自适应自旋</h4><p>在讲这两个锁之前我先讲一个小故事。</p>
<p>小明中午趁着休息时间去银行办事情,但是小明去的时候小明前面有人在办理业务,总不能看到有人办理就回去吧,这样不仅难得跑还浪费了中午的时间,小明决定多等一会儿,看看别人能不能办理完,但是也不能一直等呀,等久了下午上班就会迟到,会被领导批评的。于是小明决定给自己设定一个时间,暂且就为十分钟吧,后面十分钟到了前面还有人在办理,小明决定不等了先回去上班,明天再来。<br>第二天,小明又来了,但是前面还是有很多人,小明突然有点绝望,小明问了问旁边的哥们等了多久,他说他等了五分钟了,但是今天办理业务的速度比较快,都办了10个人了,刚说着就轮到他了。小明看了下顿时调整了自己的等待时间,觉得自己在多等下肯定能够办理业务了,然后小明就等呀等,想不到前面那个哥们不到一分钟就完事儿了,就轮到小明办理业务了,今天总算没有白跑一趟。</p>
<p>线程阻塞的时候是需要操作系统支持,从用户态切换到核心态的,这个操作给操作系统的并发性能带来了很大的压力(小明跑路很累)。而且很多时候共享数据的锁定状态只会持续很短的一段时间,为了这段时间去挂起和回复线程并不值得,所以我们就让请求锁的那个线程等一下不要放弃处理器的时间,也就是执行一个忙等待(自旋,相当于小明在业务大厅百无聊赖的玩手机,盯着业务办理情况),但是不能等久了呀,等久了也是很耗费处理器资源的,所以就给自己设定了一个自旋的次数10次(默认),如果操作了这个次数就挂起了。</p>
<p>后来JDK6中引入了自适应的自旋锁,它会由前一次在同一个锁上的自旋时间以及锁的拥有者状态来决定,如果同一个锁上自旋刚获得,那么就认为这次也有很大几率获取到,就多自旋几次,如果对于某个锁说,自旋很少获取到,就认为没戏,就不自旋了,直接去挂起了。</p>
<h4 id="锁的消除"><a href="#锁的消除" class="headerlink" title="锁的消除"></a>锁的消除</h4><p>锁消除是指虚拟机即时编译器在运行时,对一些代码要求同步,但是被检测到不可能存在数据共享竞争的情况的锁进行消除,锁消除的主要判断依据来源于逃逸分析的支持,如果判断在一段代码中,堆上的数据不会逃逸出去从而被其他线程访问到,那么就把他们当成栈数据对待,认为他们是私有的,自然就不用加锁了。比如下面这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">appendString</span><span class="params">(String a,String b,String c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(a);</span><br><span class="line">    sb.append(b);</span><br><span class="line">    sb.append(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们都知道StringBuffer是线程安全的,在于它在方法上加了synchronized关键字,此时就持有sb这个对象上的锁了。这段代码就相当于被加了锁,但是我们发现sb作用域被限制在了appendString方法内部,sb的所有引用不会被外部线程访问到,因此这里虽然有锁,但是编译之后就会忽略所有的同步而执行了。</p>
<h4 id="锁的粗化"><a href="#锁的粗化" class="headerlink" title="锁的粗化"></a>锁的粗化</h4><p>一般我们使用synchronized,总是推荐将关键字的作用范围限制得越来越小,只有数据竞争的实际范围才进行同步,这样是为了使得需要同步的操作数量尽可能小,其他线程也能尽快拿到锁。但是如果一段代码中反复的对同一个对象加锁,即使没有线程竞争,频繁的进行互斥操作也会导致资源的消耗。</p>
<p>因为如果虚拟机检测到了一段代码频繁的对一个对象加锁,就会将这个锁就行粗化,提升到最外围,比如下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(stringBuffer) &#123;</span><br><span class="line">    stringBuffer.append(aStr);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(stringBuffer) &#123;</span><br><span class="line">    stringBuffer.append(bStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(stringBuffer) &#123;</span><br><span class="line">    stringBuffer.append(cStr);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么此时jvm会将代码优化成下面这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(stringBuffer) &#123;</span><br><span class="line">    stringBuffer.append(aStr);</span><br><span class="line">    stringBuffer.append(bStr);</span><br><span class="line">    stringBuffer.append(cStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是一种很乐观的情况,针对只有一个线程的情况,比如在一个循环里面,一个线程经常申请锁,释放锁。</p>
<p>在线程进行加锁时,如果该锁对象支持偏向锁,那么 Java 虚拟机会通过 CAS 操作,将当前线程的地址记录在锁对象的标记字段之中,并且将标记字段的最后三位设置为 101(锁标志位还是 01,“是否偏向锁”标志位设置为 1)。</p>
<p>在接下来的运行过程中,每当有线程请求这把锁,Java 虚拟机只需判断锁对象标记字段中：最后三位是否为 101,是否包含当前线程的地址,以及 epoch 值是否和锁对象的类的 epoch 值相同。如果都满足,那么当前线程持有该偏向锁,可以直接返回</p>
<p>一旦出现其它线程竞争锁资源时,偏向锁就会被撤销。偏向锁的撤销需要等待全局安全点,暂停持有该锁的线程,同时检查该线程是否还在执行该方法,如果是,则升级锁,反之则被其它线程抢占。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::fast_enter</span><span class="params">(Handle obj, BasicLock* lock, <span class="keyword">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">         <span class="comment">// 是否到达线程安全点</span></span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::is_at_safepoint()) &#123;</span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      assert(!attempt_rebias, <span class="string">&quot;can not rebias toward VM thread&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 撤销偏向锁,需要等到全局安全点</span></span><br><span class="line">      BiasedLocking::revoke_at_safepoint(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!obj-&gt;mark()-&gt;has_bias_pattern(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> slow_enter (obj, lock, THREAD) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于biasedLocking.cpp中方法太长了,我就不引入了。</p>
<p>MarkOop中还有一个epoch值,这个值表示第几代锁,这是什么意思呢？</p>
<p>当从撤销偏向锁说起。当请求加锁的线程和锁对象标记字段保持的线程地址不匹配时(同时也需要判断epoch是否相等,不等,那么当前该线程可以将锁重新偏向自己),Java 虚拟机需要撤销该偏向锁。这个撤销过程非常麻烦,它要求持有偏向锁的线程到达安全点,再将偏向锁替换成轻量级锁。</p>
<p>具体的做法便是在每个类中维护一个 epoch 值,你可以理解为第几代偏向锁。</p>
<p>当设置偏向锁时,Java 虚拟机需要将该 epoch 值复制到锁对象的标记字段中。在宣布某个类的偏向锁失效时,Java 虚拟机实则将该类的 epoch 值加 1,表示之前那一代的偏向锁已经失效。</p>
<p>而新设置的偏向锁则需要复制新的 epoch 值。为了保证当前持有偏向锁并且已加锁的线程不至于因此丢锁,Java 虚拟机需要遍历所有线程的 Java 栈,找出该类已加锁的实例,并且将它们标记字段中的 epoch 值加 1。该操作需要所有线程处于安全点状态。如果总撤销数超过另一个阈值（对应 Java 虚拟机参数 -XX:BiasedLockingBulkRevokeThreshold,默认值为 40）,那么 Java 虚拟机会认为这个类已经不再适合偏向锁。此时,Java虚拟机会撤销该类实例的偏向锁,并且在之后的加锁过程中直接为该类实例设置轻量级锁。</p>
<blockquote>
<p>如果你理解不了第几代的意思,你可以把它当成一个版本号或者时间戳都是可以的<br>由于偏向锁是默认打开的,如果存在大量线程竞争资源的情况,可以关闭偏向锁: -XX:-UseBiasedLocking</p>
</blockquote>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>如果此时又有另外一个线程B需要进入临界区执行代码,但是此时锁对象的Mark Word中是偏向线程A的,这个时候线程B是不能进入临界区。<br>此时会将锁对象修改为无锁状态,然后在各自的栈分配一个空间,叫做Lock Record(锁记录),把锁对象的Mark Word在A,B两个线程各自复制一份,叫做Displaced Mard Word.<br>然后将Lock Record的地址使用CAS放到了Mark Word中,并且将锁标志位修改为00,哪个线程修改成功,就代表获取到了锁,可以进入临界区。没有获得锁的线程自旋几次等待其他线程释放锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::slow_enter</span><span class="params">(Handle obj, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  markOop mark = obj-&gt;mark();</span><br><span class="line">  assert(!mark-&gt;has_bias_pattern(), <span class="string">&quot;should not see bias pattern here&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是无锁状态</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;is_neutral()) &#123;</span><br><span class="line">    lock-&gt;set_displaced_header(mark);</span><br><span class="line">    <span class="keyword">if</span> (mark == (markOop) Atomic::cmpxchg_ptr(lock, obj()-&gt;mark_addr(), mark)) &#123;</span><br><span class="line">      TEVENT (slow_enter: <span class="built_in">release</span> stacklock) ;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;has_locker() &amp;&amp; THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) &#123;</span><br><span class="line">    assert(lock != mark-&gt;locker(), <span class="string">&quot;must not re-lock the same lock&quot;</span>);</span><br><span class="line">    assert(lock != (BasicLock*)obj-&gt;mark(), <span class="string">&quot;don&#x27;t relock with same BasicLock&quot;</span>);</span><br><span class="line">    lock-&gt;set_displaced_header(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lock-&gt;set_displaced_header(markOopDesc::unused_mark());</span><br><span class="line">  ObjectSynchronizer::inflate(THREAD, obj())-&gt;enter(THREAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>A,B线程执行,相安无事,即便哪一个获取到了锁也很快就会让出来,另外一个不会等待太久,但是有一天,某个线程自旋了很多次还是没有获取到锁,这个时候就需要操作系统的帮助,这个将轻量级锁升级为重量级锁,同时将标志位修改为10,阻塞其他未获取到锁的线程。</p>
<p>在这个状态下,未抢到锁的线程都会进入 Monitor,之后会被阻塞在 _WaitSet 队列中。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>java对于锁的优化是自动的,不需要我们做什么,编译器在编译的时候会分析代码对代码进行优化。</p>
<p>JVM中关于锁的优化大抵如是了,其实synchronized并不比lock慢多少,甚至在某些方面可能还比lock快,而且JDK8中ConcurrentHashMap也将之前的分段锁改为了Synchronized实现。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>索引优化-世人皆知Mysql,谁人懂我MongoDB</title>
    <url>/2020/04/16/mongodb-index-anslysis/</url>
    <content><![CDATA[<h3 id="查看执行计划"><a href="#查看执行计划" class="headerlink" title="查看执行计划"></a>查看执行计划</h3><p>索引优化是一个永远都绕不过的话题,作为NoSQL的MongoDB也不例外。Mysql中通过explain命令来查看对应的索引信息,MongoDB亦如此。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. db.collection.explain().&lt;method(...)&gt;</span><br><span class="line">    db.products.explain().remove( &#123; category: &quot;apparel&quot; &#125;, &#123; justOne: true &#125;)</span><br><span class="line"></span><br><span class="line">2. db.collection.&lt;method(...)&gt;.explain(&#123;&#125;)</span><br><span class="line">    db.products.remove( &#123; category: &quot;apparel&quot; &#125;, &#123; justOne: true &#125;).explain()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>如果你是在mongoshell 中第一种和第二种没什么区别，如果你是在robot 3T这样的客户端工具中使用你必须在后面显示调用finish()或者next()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.collection.explain().find(&#123;&#125;).finish()</span><br></pre></td></tr></table></figure>

<p>explain有三种模式,分别是:</p>
<ol>
<li>queryPlanner(默认) ：queryPlanner模式下并不会去真正进行query语句查询，而是针对query语句进行执行计划分析并选出winning plan</li>
<li>executionStats ：MongoDB运行查询优化器以选择获胜计划(winning plan)，执行获胜计划直至完成，并返回描述获胜计划执行情况的统计信息。</li>
<li>allPlansExecution: queryPlanner和executionStats都返回。相当于 <code>explain(&quot;allPlansExecution&quot;) = explain(&#123;&#125;)</code></li>
</ol>
<h3 id="queryPlanner-查询计划"><a href="#queryPlanner-查询计划" class="headerlink" title="queryPlanner(查询计划)"></a>queryPlanner(查询计划)</h3><p>日志表中存储了用户的操作日志,我们经常查询某一篇文章的操作日志,数据如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_id&quot; : NumberLong(7277744),</span><br><span class="line">  &quot;operatorName&quot; : &quot;autotest_cp&quot;,</span><br><span class="line">  &quot;operateTimeUnix&quot; : NumberLong(1586511800890),</span><br><span class="line">  &quot;module&quot; : &quot;ARTICLE&quot;,</span><br><span class="line">  &quot;opType&quot; : &quot;CREATE&quot;,</span><br><span class="line">  &quot;level&quot; : &quot;GENERAL&quot;,</span><br><span class="line">  &quot;recordData&quot; : &#123;</span><br><span class="line">      &quot;articleId&quot; : &quot;6153324&quot;,</span><br><span class="line">      &quot;categories&quot; : &quot;100006&quot;,</span><br><span class="line">      &quot;title&quot; : &quot;testCase-2 this article is created for cp edior to search&quot;,</span><br><span class="line">      &quot;status&quot; : &quot;DRAFT&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;responseCode&quot; : 10002</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>集合中大概有700万数据,对于这样的查询语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.getCollection(&#39;operateLog&#39;).find(&#123;&quot;module&quot;: &quot;ARTICLE&quot;, &quot;recordData.articleId&quot;: &quot;6153324&quot;&#125;).sort(&#123;_id:-1&#125;)</span><br></pre></td></tr></table></figure>

<p>首先看下queryPlanner返回的内容：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;queryPlanner&quot; : &#123;</span><br><span class="line">  &quot;plannerVersion&quot; : 1,</span><br><span class="line">  &quot;namespace&quot; : &quot;smcp.operateLog&quot;,</span><br><span class="line">  &quot;indexFilterSet&quot; : false,</span><br><span class="line">  &quot;parsedQuery&quot; : &#123;</span><br><span class="line">    &quot;$and&quot; : [ </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;module&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;$eq&quot;</span> : <span class="string">&quot;ARTICLE&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;recordData.articleId&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;$eq&quot;</span> : <span class="string">&quot;6153324&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;winningPlan&quot; : &#123;</span><br><span class="line">    &quot;stage&quot; : &quot;FETCH&quot;,</span><br><span class="line">    &quot;filter&quot; : &#123;</span><br><span class="line">      &quot;$and&quot; : [ </span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;module&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;$eq&quot;</span> : <span class="string">&quot;ARTICLE&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;recordData.articleId&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;$eq&quot;</span> : <span class="string">&quot;6153324&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;inputStage&quot; : &#123;</span><br><span class="line">      &quot;stage&quot; : &quot;IXSCAN&quot;,</span><br><span class="line">      &quot;keyPattern&quot; : &#123;</span><br><span class="line">          &quot;_id&quot; : 1</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;indexName&quot; : &quot;_id_&quot;,</span><br><span class="line">      &quot;isMultiKey&quot; : false,</span><br><span class="line">      &quot;multiKeyPaths&quot; : &#123;</span><br><span class="line">          &quot;_id&quot; : []</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;isUnique&quot; : true,</span><br><span class="line">      &quot;isSparse&quot; : false,</span><br><span class="line">      &quot;isPartial&quot; : false,</span><br><span class="line">      &quot;indexVersion&quot; : 2,</span><br><span class="line">      &quot;direction&quot; : &quot;backward&quot;,</span><br><span class="line">      &quot;indexBounds&quot; : &#123;</span><br><span class="line">          &quot;_id&quot; : [ </span><br><span class="line">              <span class="string">&quot;[MaxKey, MinKey]&quot;</span></span><br><span class="line">          ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;rejectedPlans&quot; : [ </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;stage&quot;</span> : <span class="string">&quot;SORT&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;sortPattern&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;_id&quot;</span> : <span class="number">-1.0</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;inputStage&quot;</span> : &#123;</span><br><span class="line">        <span class="attr">&quot;stage&quot;</span> : <span class="string">&quot;SORT_KEY_GENERATOR&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;inputStage&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;stage&quot;</span> : <span class="string">&quot;FETCH&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;filter&quot;</span> : &#123;</span><br><span class="line">              <span class="attr">&quot;recordData.articleId&quot;</span> : &#123;</span><br><span class="line">                  <span class="attr">&quot;$eq&quot;</span> : <span class="string">&quot;6153324&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;inputStage&quot;</span> : &#123;</span><br><span class="line">            <span class="attr">&quot;stage&quot;</span> : <span class="string">&quot;IXSCAN&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;keyPattern&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;module&quot;</span> : <span class="number">1.0</span>,</span><br><span class="line">                <span class="attr">&quot;opType&quot;</span> : <span class="number">1.0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;indexName&quot;</span> : <span class="string">&quot;module_1_opType_1&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;isMultiKey&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;multiKeyPaths&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;module&quot;</span> : [],</span><br><span class="line">                <span class="attr">&quot;opType&quot;</span> : []</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;isUnique&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;isSparse&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;isPartial&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;indexVersion&quot;</span> : <span class="number">2</span>,</span><br><span class="line">            <span class="attr">&quot;direction&quot;</span> : <span class="string">&quot;forward&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;indexBounds&quot;</span> : &#123;</span><br><span class="line">                <span class="attr">&quot;module&quot;</span> : [ </span><br><span class="line">                    <span class="string">&quot;[\&quot;ARTICLE\&quot;, \&quot;ARTICLE\&quot;]&quot;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">&quot;opType&quot;</span> : [ </span><br><span class="line">                    <span class="string">&quot;[MinKey, MaxKey]&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字段含义"><a href="#字段含义" class="headerlink" title="字段含义"></a>字段含义</h4><p>一些重要字段的含义</p>
<ul>
<li><p>queryPlanner.namespace<br>查询的哪个表</p>
</li>
<li><p>queryPlanner.winningPlan<br>查询优化器针对该query所返回的最优执行计划的详细内容。</p>
</li>
<li><p>queryPlanner.winningPlan.stage<br>最优计划执行的阶段,每个阶段都包含特定于该阶段的信息。例如，IXSCAN阶段将包括索引范围以及特定于索​​引扫描的其他数据。如果一个阶段具有一个子阶段或多个子阶段，那么该阶段将具有inputStage或inputStages。</p>
</li>
<li><p>queryPlanner.winningPlan.inputStage<br>描述子阶段的文档，该子阶段向其父级提供文档或索引键。如果父阶段只有一个孩子，则该字段存在。</p>
</li>
<li><p>queryPlanner.winningPlan.inputStage.indexName<br>winning plan所选用的index,这里是根据_id来进行排序的，所以使用了_id的索引</p>
</li>
<li><p>queryPlanner.winningPlan.inputStage.isMultiKey<br>是否是Multikey，此处返回是false，如果索引建立在array上，此处将是true</p>
</li>
<li><p>queryPlanner.winningPlan.inputStage.isUnique<br>使用的索引是否是唯一索引，这里的_id是唯一索引</p>
</li>
<li><p>queryPlanner.winningPlan.inputStage.isSparse<br>是否是稀疏索引</p>
</li>
<li><p>queryPlanner.winningPlan.inputStage.isPartial<br>是否是部分索引</p>
</li>
<li><p>queryPlanner.winningPlan.inputStage.direction<br>此query的查询顺序，默认是forward，由于使用了sort({_id:-1})显示backward</p>
</li>
<li><p>queryPlanner.winningPlan.inputStage.indexBounds<br>winningplan所扫描的索引范围,由于这里使用的是sort({_id:-1}),对_id倒序排序,所以范围是[MaxKey,MinKey]。如果是正序,则是[MinKey,MaxKey]</p>
</li>
<li><p>queryPlanner.rejectedPlans<br>拒绝的计划详细内容,各字段含义同winningPlan</p>
</li>
</ul>
<h3 id="executionStats-执行结果"><a href="#executionStats-执行结果" class="headerlink" title="executionStats(执行结果)"></a>executionStats(执行结果)</h3><p>再来看下executionStats的返回结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;executionStats&quot; : &#123;</span><br><span class="line">  &quot;executionSuccess&quot; : true,</span><br><span class="line">  &quot;nReturned&quot; : 1,</span><br><span class="line">  &quot;executionTimeMillis&quot; : 24387,</span><br><span class="line">  &quot;totalKeysExamined&quot; : 6998084,</span><br><span class="line">  &quot;totalDocsExamined&quot; : 6998084,</span><br><span class="line">  &quot;executionStages&quot; : &#123;</span><br><span class="line">    &quot;stage&quot; : &quot;FETCH&quot;,</span><br><span class="line">    &quot;filter&quot; : &#123;</span><br><span class="line">      &quot;$and&quot; : [ </span><br><span class="line">        &#123;</span><br><span class="line">          &quot;module&quot; : &#123;</span><br><span class="line">              &quot;$eq&quot; : &quot;ARTICLE&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">          &quot;recordData.articleId&quot; : &#123;</span><br><span class="line">              &quot;$eq&quot; : &quot;6153324&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;nReturned&quot; : 1,</span><br><span class="line">    &quot;executionTimeMillisEstimate&quot; : 1684,</span><br><span class="line">    &quot;works&quot; : 6998085,</span><br><span class="line">    &quot;advanced&quot; : 1,</span><br><span class="line">    &quot;needTime&quot; : 6998083,</span><br><span class="line">    &quot;needYield&quot; : 0,</span><br><span class="line">    &quot;saveState&quot; : 71074,</span><br><span class="line">    &quot;restoreState&quot; : 71074,</span><br><span class="line">    &quot;isEOF&quot; : 1,</span><br><span class="line">    &quot;invalidates&quot; : 0,</span><br><span class="line">    &quot;docsExamined&quot; : 6998084,</span><br><span class="line">    &quot;alreadyHasObj&quot; : 0,</span><br><span class="line">    &quot;inputStage&quot; : &#123;</span><br><span class="line">      &quot;stage&quot; : &quot;IXSCAN&quot;,</span><br><span class="line">      &quot;nReturned&quot; : 6998084,</span><br><span class="line">      &quot;executionTimeMillisEstimate&quot; : 290,</span><br><span class="line">      &quot;works&quot; : 6998085,</span><br><span class="line">      &quot;advanced&quot; : 6998084,</span><br><span class="line">      &quot;needTime&quot; : 0,</span><br><span class="line">      &quot;needYield&quot; : 0,</span><br><span class="line">      &quot;saveState&quot; : 71074,</span><br><span class="line">      &quot;restoreState&quot; : 71074,</span><br><span class="line">      &quot;isEOF&quot; : 1,</span><br><span class="line">      &quot;invalidates&quot; : 0,</span><br><span class="line">      &quot;keyPattern&quot; : &#123;</span><br><span class="line">          &quot;_id&quot; : 1</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;indexName&quot; : &quot;_id_&quot;,</span><br><span class="line">      &quot;isMultiKey&quot; : false,</span><br><span class="line">      &quot;multiKeyPaths&quot; : &#123;</span><br><span class="line">          &quot;_id&quot; : []</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;isUnique&quot; : true,</span><br><span class="line">      &quot;isSparse&quot; : false,</span><br><span class="line">      &quot;isPartial&quot; : false,</span><br><span class="line">      &quot;indexVersion&quot; : 2,</span><br><span class="line">      &quot;direction&quot; : &quot;backward&quot;,</span><br><span class="line">      &quot;indexBounds&quot; : &#123;</span><br><span class="line">          &quot;_id&quot; : [ </span><br><span class="line">              &quot;[MaxKey, MinKey]&quot;</span><br><span class="line">          ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;keysExamined&quot; : 6998084,</span><br><span class="line">      &quot;seeks&quot; : 1,</span><br><span class="line">      &quot;dupsTested&quot; : 0,</span><br><span class="line">      &quot;dupsDropped&quot; : 0,</span><br><span class="line">      &quot;seenInvalidated&quot; : 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &quot;allPlansExecution&quot; : [</span><br><span class="line">    &#123;...&#125;,</span><br><span class="line">    &#123;...&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><ul>
<li><p>executionStats.executionSuccess<br>是否执行成功</p>
</li>
<li><p>executionStats.nReturned<br>查询的返回条数</p>
</li>
<li><p>executionStats.executionTimeMillis<br>选择查询计划和执行查询所需的总时间（以毫秒为单位）</p>
</li>
<li><p>executionStats.totalKeysExamined<br>索引扫描次数</p>
</li>
<li><p>executionStats.totalDocsExamined<br>document扫描次数</p>
</li>
<li><p>executionStats.executionStages<br>以阶段树的形式详细说明获胜计划的完成执行情况；即一个阶段可以具有一个inputStage或多个inputStages。如上说明。</p>
</li>
<li><p>executionStats.executionStages.inputStage.keysExamined<br>扫描了多少次索引</p>
</li>
<li><p>executionStats.executionStages.inputStage.docsExamined<br>扫描了多少次文档，一般当stage是 COLLSCAN的时候会有这个值。</p>
</li>
<li><p>exlexecutionStats.allPlansExecution<br>这里展示了所有查询计划的详细。(winningPlan + rejectPlans),字段含义和winningPlan中一致，不做赘述</p>
</li>
</ul>
<h3 id="15种stage"><a href="#15种stage" class="headerlink" title="15种stage"></a>15种stage</h3><p>从上面可以看出stage是很重要的，一个查询到底走的是索引还是全表扫描主要看的就是stage的值, 而stage有如下值</p>
<ol>
<li>COLLSCAN : 扫描整个集合</li>
<li>IXSCAN : 索引扫描(index scan)</li>
<li>FETCH : 根据索引返回的结果去检索文档(如上我们的例子)</li>
<li>SHARD_MERGE : 将各个分片返回数据进行merge</li>
<li>SORT : 调用了sort方法,当出现这个阶段的时候你可以看到memUsage以及memLimit这两个字段</li>
<li>SORT_KEY_GENERATOR : 在内存中进行了排序</li>
<li>LIMIT ： 使用limit限制返回数</li>
<li>SKIP ： 使用skip进行跳过</li>
<li>IDHACK ： 针对_id进行查询</li>
<li>SHARDING_FILTER ：通过mongos对分片数据进行查询</li>
<li>COUNT: 利用db.coll.explain().count()之类进行count运算, 只要调用了count方法，那么 executionStats.executionStages.stage = COUNT</li>
<li>COUNT_SCAN : count使用Index进行count时的stage返回</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  country: &quot;ID&quot;,</span><br><span class="line">  name: &quot;jjj&quot;,</span><br><span class="line">  status: 0</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  country: &quot;ZH&quot;,</span><br><span class="line">  name: &quot;lisi&quot;,</span><br><span class="line">  status: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们对country字段建立了索引，同时执行下面的语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.getCollection(&#39;testData&#39;).explain(true).count(&#123;country: &quot;ID&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>那么查看执行结果可以看到 executionStats.executionStages.inputStage.stage = COUNT_SCAN, COUNT_SCAN是COUNT的一个子阶段。</p>
<ol start="12">
<li>COUNTSCAN : count不使用Index进行count时的stage返回。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.getCollection(&#39;testData&#39;).explain(true).count(&#123;status: 0&#125;)</span><br></pre></td></tr></table></figure>

<p>此时 executionStats.executionStages.inputStage.stage = COUNTSCAN , COUNTSCAN是COUNT的一个子阶段</p>
<ol start="13">
<li><p>SUBPLAN : 未使用到索引的$or查询的stage返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.getCollection(&#39;testData&#39;).find(&#123;$or : [&#123;name : &quot;lisi&quot;&#125;, &#123;status: 0&#125;]&#125;).explain(true);</span><br></pre></td></tr></table></figure>
<p>此时 executionStats.executionStages.stage = SUBPLAN</p>
</li>
<li><p>TEXT : 使用全文索引进行查询时候的stage返回</p>
</li>
<li><p>PROJECTION : 限定返回字段时候stage的返回</p>
</li>
</ol>
<p>查看executionStats.executionStages.stage以及其下各个inputStage(子阶段)的值是什么,可以判定存在哪些优化点。</p>
<p><strong>一个查询它扫描的文档数要尽可能的少,才能更快，明显我们我们不希望看到COLLSCAN, SORT_KEY_GENERATOR, COUNTSCAN, SUBPLAN 以及不合理的 SKIP 这些stage,当你看到这些stage的时候就要注意了。</strong></p>
<h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p>当你看winningPlan或者rejectPlan的时候，你就可以知道执行顺序是怎样的，比如我们rejectPlan中，先是通过 “module_1_opType_1”检索 “module = ARTICLE”的数据，然后FETCH阶段再通过 “recordData.articleId=6153324”进行过滤，最后在内存中排序后返回数据。 明显这样的计划被拒绝了，至少它没有winningPlan执行快。</p>
<p>再来看看executionStats返回的数据<br>**<br>nReturned 为 1，即符合条件的只有1条<br>executionTimeMillis 值为24387,执行时间为24秒<br>totalKeysExamined 值为 6998084,虽然用到了索引，但是几乎是扫描了所有的key<br>totalDocsExamined的值为6998084,也是扫描了所有文档<br>**</p>
<p>从上面的输出结果可以看出来，虽然我们使用了索引，但是速度依然很慢。很明显现在的索引，并不适合我们，为了排除干扰，我们先将module_1_opType_1这个索引删除。由于我们这里使用了两个字段进行查询，而 recordData.articleId这个字段并不是每个document(集合中还存储了其他类型的数据)都存在，所以建立索引的时候recordData.articleId需要建立部分索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.getCollection(&#39;operateLog&#39;).createIndex(</span><br><span class="line">&#123;&#39;module&#39;: 1, &#39;recordData.articleId&#39;: 1 &#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;partialFilterExpression&quot;: &#123;</span><br><span class="line">    &quot;recordData.articleId&quot;: &#123;</span><br><span class="line">      &quot;$exists&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &quot;background&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我先吃个苹果，等它把索引建立好，大家有啥吃啥。在索引建立完成之后，我们来看看 executionStats 的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;executionStats&quot; : &#123;</span><br><span class="line">  &quot;executionSuccess&quot; : true,</span><br><span class="line">  &quot;nReturned&quot; : 1,</span><br><span class="line">  &quot;executionTimeMillis&quot; : 3,</span><br><span class="line">  &quot;totalKeysExamined&quot; : 1,</span><br><span class="line">  &quot;totalDocsExamined&quot; : 1,</span><br><span class="line">  &quot;executionStages&quot; : &#123;</span><br><span class="line">    &quot;stage&quot; : &quot;SORT&quot;,</span><br><span class="line">    &quot;sortPattern&quot; : &#123;</span><br><span class="line">        &quot;_id&quot; : -1.0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;memUsage&quot; : 491,</span><br><span class="line">    &quot;memLimit&quot; : 33554432,</span><br><span class="line">    &quot;inputStage&quot; : &#123;</span><br><span class="line">      &quot;stage&quot; : &quot;SORT_KEY_GENERATOR&quot;,</span><br><span class="line">      &quot;inputStage&quot; : &#123;</span><br><span class="line">          &quot;stage&quot; : &quot;FETCH&quot;,</span><br><span class="line">          &quot;nReturned&quot; : 1,</span><br><span class="line">          &quot;inputStage&quot; : &#123;</span><br><span class="line">            &quot;stage&quot; : &quot;IXSCAN&quot;,</span><br><span class="line">            &quot;keyPattern&quot; : &#123;</span><br><span class="line">                &quot;module&quot; : 1.0,</span><br><span class="line">                &quot;recordData.articleId&quot; : 1.0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;indexName&quot; : &quot;module_1_recordData.articleId_1&quot;,</span><br><span class="line">            &quot;isMultiKey&quot; : false,</span><br><span class="line">            &quot;multiKeyPaths&quot; : &#123;</span><br><span class="line">              &quot;module&quot; : [],</span><br><span class="line">              &quot;recordData.articleId&quot; : []</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;isPartial&quot; : true,</span><br><span class="line">            &quot;indexVersion&quot; : 2,</span><br><span class="line">            &quot;direction&quot; : &quot;forward&quot;,</span><br><span class="line">            &quot;indexBounds&quot; : &#123;</span><br><span class="line">              &quot;module&quot; : [ </span><br><span class="line">                &quot;[\&quot;ARTICLE\&quot;, \&quot;ARTICLE\&quot;]&quot;</span><br><span class="line">              ],</span><br><span class="line">              &quot;recordData.articleId&quot; : [ </span><br><span class="line">                &quot;[\&quot;6153324\&quot;, \&quot;6153324\&quot;]&quot;</span><br><span class="line">              ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我忽略了一些不重要的字段,可以看到，<strong>现在执行时间是3毫秒(executionTimeMillis=3),扫描了1个index(totalKeysExamined=1),扫描了1个document(totalDocsExamined=1)。相比于之前的24387毫秒，我可以说我的执行速度提升了8000倍，我就问还有谁。</strong>如果此事让UC 震惊部小编知道了，肯定又可以起一个震惊的标题了</p>
<p><strong>但是这个执行计划仍然有问题，有问题，有问题，重要的事情说三遍。 executionStages.stage = sort,证明它在内存中排序了,在数据量大的时候，是很消耗性能的，所以千万不能忽视它，我们要改进这个点。</strong></p>
<p>我们要在 nReturned = totalDocsExamined的基础上，让排序也走索引。所以我们先将之前的索引删除，然后重新创建索引，这里我们将_id字段也加入到索引中，三个字段形成组合索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.getCollection(&#39;operateLog&#39;).createIndex(</span><br><span class="line">&#123;&#39;module&#39;: 1, &#39;recordData.articleId&#39;: 1, &#39;_id&#39;: -1&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  &quot;partialFilterExpression&quot;: &#123;</span><br><span class="line">    &quot;recordData.articleId&quot;: &#123;</span><br><span class="line">      &quot;$exists&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &quot;background&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样的再来看看我们的执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;executionStats&quot; : &#123;</span><br><span class="line">  &quot;executionSuccess&quot; : true,</span><br><span class="line">  &quot;nReturned&quot; : 1,</span><br><span class="line">  &quot;executionTimeMillis&quot; : 0,</span><br><span class="line">  &quot;totalKeysExamined&quot; : 1,</span><br><span class="line">  &quot;totalDocsExamined&quot; : 1,</span><br><span class="line">  &quot;executionStages&quot; : &#123;</span><br><span class="line">    &quot;stage&quot; : &quot;FETCH&quot;,</span><br><span class="line">    &quot;nReturned&quot; : 1,</span><br><span class="line">    &quot;executionTimeMillisEstimate&quot; : 0,</span><br><span class="line">    &quot;docsExamined&quot; : 1,</span><br><span class="line">    &quot;inputStage&quot; : &#123;</span><br><span class="line">      &quot;stage&quot; : &quot;IXSCAN&quot;,</span><br><span class="line">      &quot;nReturned&quot; : 1,</span><br><span class="line">      &quot;keyPattern&quot; : &#123;</span><br><span class="line">          &quot;module&quot; : 1.0,</span><br><span class="line">          &quot;recordData.articleId&quot; : 1.0,</span><br><span class="line">          &quot;_id&quot; : -1.0</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;indexName&quot; : &quot;module_1_recordData.articleId_1__id_-1&quot;,</span><br><span class="line">      &quot;multiKeyPaths&quot; : &#123;</span><br><span class="line">          &quot;module&quot; : [],</span><br><span class="line">          &quot;recordData.articleId&quot; : [],</span><br><span class="line">          &quot;_id&quot; : []</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;isPartial&quot; : true,</span><br><span class="line">      &quot;direction&quot; : &quot;forward&quot;,</span><br><span class="line">      &quot;indexBounds&quot; : &#123;</span><br><span class="line">          &quot;module&quot; : [ </span><br><span class="line">              &quot;[\&quot;ARTICLE\&quot;, \&quot;ARTICLE\&quot;]&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;recordData.articleId&quot; : [ </span><br><span class="line">              &quot;[\&quot;6153324\&quot;, \&quot;6153324\&quot;]&quot;</span><br><span class="line">          ],</span><br><span class="line">          &quot;_id&quot; : [ </span><br><span class="line">              &quot;[MaxKey, MinKey]&quot;</span><br><span class="line">          ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们这次的stage是FETCH+IXSCAN,同时 nReturned = totalKeysExamined = totalDocsExamined = 1，并且利用了index排序，而非在内存中排序。从executionTimeMillis=0也可以看出来，性能相比于之前的3毫秒也有所提升，至此这个索引就是我们需要的了。</p>
<p>最开头的结果和优化的过程告诉我们,使用了索引你的查询仍然可能很慢,我们要将更多的目光集中到扫描的文档或者行数中。</p>
<h3 id="索引优化准则"><a href="#索引优化准则" class="headerlink" title="索引优化准则"></a>索引优化准则</h3><ol>
<li><p>根据ESR原则创建索引<br>精确(Equal)匹配的字段放最前面,排序(Sort)条件放中间,范围(Range)匹配的字段放最后面,同样适用于ES,ER。</p>
</li>
<li><p>每一个查询都必须要有对应的索引</p>
</li>
<li><p>尽量使用覆盖索引 Covered Indexes(可以避免读数据文件)<br>需要查询的条件以及返回值均在索引中</p>
</li>
<li><p>使用 projection 来减少返回到客户端的的文档的内容</p>
</li>
<li><p>尽可能不要计算总数,特别是数据量大和查询不能命中索引的时候</p>
</li>
<li><p>避免使用skip/limit形式的分页，特别是数据量大的时候</p>
<p>替代方案:使用查询条件+唯一排序条件<br>第一页：<code>db.posts.find(&#123;&#125;).sort(&#123;_id: 1&#125;).limit(20);</code><br>第二页：<code>db.posts.find(&#123;_id: &#123;$gt: &lt;第一页最后一个_id&gt;&#125;&#125;).sort(&#123;_id: 1&#125;).limit(20);</code><br>第三页：<code>db.posts.find(&#123;_id: &#123;$gt: &lt;第二页最后一个_id&gt;&#125;&#125;).sort(&#123;_id: 1&#125;).limit(20);</code></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>老生常谈：mysql的体系结构</title>
    <url>/2022/04/06/mysql-architecture/</url>
    <content><![CDATA[<p>现在要进厂，每个面试官都要问你熟不熟悉mysql,作为开发者咋们也应该清楚mysql的基础体系架构</p>
<p><img data-src="/images/mysql/mysql-architecture.png" alt="mysql架构"></p>
<p>从Mysql官网提供的体系结构图中可以看出来出来，整个mysql分为以下几部分</p>
<ol>
<li>连接池</li>
<li>SQL接口组件</li>
<li>查询分析器组件</li>
<li>优化器组件</li>
<li>缓存组件</li>
<li>存储引擎(插件)</li>
<li>物理文件</li>
</ol>
<p>mysql比较有特色的一点就是，它的存储引擎是以插件方式提供的， 而每个存储引擎决定了我们的数据是如何存放的。</p>
<p>虽然存储引擎有很多种，但是我们常用的不太多。 比如我就只使用过 InnoDB,MyISAM,Memory,InfoBright这4种。</p>
<h3 id="MyISAM-VS-InnoDB"><a href="#MyISAM-VS-InnoDB" class="headerlink" title="MyISAM VS InnoDB"></a>MyISAM VS InnoDB</h3><ol>
<li>MyISAM不支持事务(不支持ACID),InnoDB支持事务(支持ACID)</li>
<li>使用DML语句时，MyISAM锁级别是表锁，同一时间只支持一个session修改表,而InnoDB是行锁,粒度更细，并发更高</li>
<li>MyISAM不支持外键,InnoDB支持</li>
<li>MyISAM写入速度慢,查询速度快，InnoDB写入快，查询慢(相对)</li>
<li>InnoDB因为支持事务，所以更可靠，MyISAM无法保证数据完整性</li>
<li>MyISAM只存储索引，不缓存数据，支持全文索引,InnoDB缓存索引以及数据,不支持全文索引(5.6之前)。</li>
</ol>
<p>所以在选择哪个引擎的时候要根据实际业务选择，比如某个业务只会插入一次数据，后面的都只有查询,那么我就建议使用MyISAM，如果需要支持事务那就用InnoDB。</p>
<h3 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h3><p>由于我们平时使用最多的还是InnoDB引擎，所以这里主要剖析下InnoDB的存储结构(MyISAM和InnoDB在存储结构上是类似的)</p>
<p><img data-src="/images/mysql/innodb-architecture.png" alt="InnoDB索引引擎(5.7)"></p>
<blockquote>
<p>5.7和8.0有些许不一致，主要是系统表空间的一些内容会移动到单独的表空间中去</p>
</blockquote>
<p>为了保证数据不丢失,我们的数据必须要落盘,但是如果每次增删改查都去操作磁盘，那效率太低了，所以mysql会在内存中抽象出一份数据结构和磁盘一一对应，这样我们每次的增删改查就会优先操作内存中的数据。</p>
<p>咱们插入的数据是存储在磁盘的,而平时我们通过Navicate或者shell查询出来的数据，展现形式为表格，并不代表我们的数据也是这样直接这样存储在磁盘上的，磁盘上的数据有自己的格式。</p>
<p>比如我们将数据存在在文件是这样存储的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user.id&#x3D;1</span><br><span class="line">user.name&#x3D;think123</span><br><span class="line">user.age&#x3D;18</span><br></pre></td></tr></table></figure>

<p>在我们代码中，我们会将其映射为一个java对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出显示的时候又是这样 </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;think123&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>将内存中数据刷新到磁盘并不是一条数据一条数据从内存刷新到磁盘的，为了效率，InnoDB将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的⼤⼩⼀般为 16KB,和磁盘上默认的页大小一致。也就是在⼀般情况下，⼀次最少从磁盘中读取16KB的内容到内存中，⼀次最少把内存中的16KB内容刷新到磁盘中。</p>
<p>而内存数据结构主要分为 Buffer Pool(缓冲池) 和 Log Buffer(日志缓冲)，它们管理的都是页，而页中存储的是数据。</p>
<h4 id="Buffer-Pool-缓冲池"><a href="#Buffer-Pool-缓冲池" class="headerlink" title="Buffer Pool(缓冲池)"></a>Buffer Pool(缓冲池)</h4><p>Buffer Pool中存储的是页，页中会存储很多条数据。当我们修改数据的时候会先修改内存中的数据，修改后的页面并不立即同步到磁盘，而是作为脏页继续呆在内存中，然后会有后台线程将内存中的数据刷盘到文件，保证数据一致。</p>
<p><img data-src="/images/mysql/innodb-1.png" alt="简化的结构"></p>
<p>我们可以通过下面的命令查看缓冲池大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show VARIABLES like &#39;innodb_buffer_pool_size&#39;</span><br></pre></td></tr></table></figure>

<p>如果要修改，则通过修改配置完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size &#x3D; 268435456</span><br></pre></td></tr></table></figure>


<p>缓冲池中缓存的数据页类型有:索引页、数据页、undo页、修改缓冲(change buffer)、自适应哈希索引(adaptive hash index)、InnoDB中锁信息、数据字典信息等。除了这些，InnoDB引擎中内存的结构除了缓冲池还有其他结构，如图所示</p>
<p><img data-src="/images/mysql/innodb-memory-data-structure.png" alt="InnoDB内存数据对象"></p>
<blockquote>
<p>图中插入缓冲的部分现在叫做修改缓冲(change buffer),也就是说以前只对插入有用，现在对insert update delete都起作用，后面会分析下什么是修改缓冲</p>
</blockquote>
<p>多线程环境下，访问缓冲池(buffer pool)中的各种page是需要加锁的，不然会有并发问题，而且在Buffer Pool特别⼤⽽且多线程并发访问特别 ⾼的情况下，单⼀的Buffer Pool可能会影响请求的处理速度。所以在Buffer Pool特别⼤的时候，我们可以把它们拆分成多个⼩的Buffer Pool，每个Buffer Pool都称为⼀个实例，它们都是独⽴的，独 ⽴的去申请内存空间，这样可以增加数据库的并发处理，减少资源竞争，我们可以通过修改配置的方式来配置缓冲池个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances &#x3D; 2</span><br></pre></td></tr></table></figure>

<p>每个buffer pool占用内存空间就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">innodb_buffer_pool_size&#x2F;innodb_buffer_pool_instances</span><br></pre></td></tr></table></figure>


<h4 id="自适应Hash索引"><a href="#自适应Hash索引" class="headerlink" title="自适应Hash索引"></a>自适应Hash索引</h4><p>Mysql中B+树的索引高度一般为3-4层，因此需要3-4次的查询，InnoDB会监控表上各索引页的查询，如果建立hash索引可以带来性能提升，则会建立hash索引，称之为自适应哈希索引(Adaptive Hash Index, AHI),AHI通过缓冲池的B+树页构造而来，而且并不需要对整张表建立hash索引，只是对热点页建立hash索引。</p>
<p>AHI要求对某个页的连续访问模式一样，比如对于（a,b)这样的联合索引页，存在下面两种情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">where a = xxx;</span><br><span class="line">where a = xxx and b=xxx</span><br></pre></td></tr></table></figure>
<p>如果每次都查询条件一样，但是交替出现上面两种查询，那么InnoDB不会建立Hash索引，如果只出现一个查询，然后再满足下面的要求，InnoDB就会建立自适应Hash索引</p>
<ol>
<li>以该模式(同样的等值查询条件)访问了100次</li>
<li>页通过该模式访问了N次，N = 页记录/16</li>
</ol>
<p>这种索引属于数据库的自优化，无需DBA进行认为调整。我们可以通过下面的命令查看当前自适应hash索引的使用情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show engine innodb status;</span><br></pre></td></tr></table></figure>

<p>其本质是将频繁访问数据页的索引键值以“Key”放在缓存中，“Value”为该索引键值匹配完整记录所在页面（Page）的位置，通过缩短寻路路径（Search Path）从而提升MySQL查询性能的一种方式</p>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>数据最终会落盘到磁盘的文件中，而实际mysql管理的数据以及额外信息等等都会写入到文件中。</p>
<h4 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h4><p>InnoDB采用将存储的数据按照表空间(tablespace)进行存放设计，默认配置下会有一个初始大小为10M，名为 ibdata1的文件，这个文件就是系统表空间文件，我们可以通过参数在配置文件中进行设置，比如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">innodb_data_file_path &#x3D; ibdata1:10M:autoextend</span><br></pre></td></tr></table></figure>
<p>表示文件初始大小为10MB,用完了这10M,该文件可以自动增长（autoextend)。</p>
<p>设置 innodb_data_file_path 参数后，所有基于InnoDB存储引擎的表的数都会记录到该共享表空间中。</p>
<p>系统表空间中除了双写缓冲区(doublewrite buffer)、change buffer、undo logs之外,还会记录一些有关整个系统的信息。</p>
<blockquote>
<p>再次提一下，从mysql 8.0开始doublewrite buffer会有单独的文件, undo log也会放到自己单独的表空间中<br><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-architecture.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-architecture.html</a></p>
</blockquote>
<p>当我们插入数据到表里面的时候，我们需要知道很多信息，比如</p>
<ol>
<li>某个表属于哪个表空间，表里面有多少列</li>
<li>表对应的每一个列类型是什么</li>
<li>该表有多少索引，每个索引对应哪些字段，该索引对应的根页面在哪个表空间的哪个页面</li>
<li>该表又哪些外键，外键对应哪个表的哪些列</li>
<li>某个表空间对应文件系统上文件路径是什么</li>
</ol>
<p>等等。</p>
<p>上面提到的这些数据实际和我们插入数据无关，但是为了更好管理我们的用户数据而不得不引入的额外数据被称为元数据。InnoDB特意定义了一系列的内部系统表用来记录这些数据，不过咱们是不能直接访问InnoDB的这些内部系统表的，除⾮直接去解析系统表空间对应⽂件系统上的⽂件。</p>
<p>好在我们可以在infomation_schema数据库中看到这些表数据</p>
<ol>
<li>INNODB_SYS_COLUMNS: 整个InnoDB存储引擎中所有的列的信息</li>
<li>INNODB_SYS_DATAFILES: 整个InnoDB存储引擎中所有的表空间对应⽂件系统的⽂件路径信息</li>
<li>INNODB_SYS_FIELDS: 整个InnoDB存储引擎中所有的索引对应的列的信息</li>
<li>INNODB_SYS_FOREIGN: 整个InnoDB存储引擎中所有的外键的信息</li>
<li>INNODB_SYS_FOREIGN_COLS: 整个InnoDB存储引擎中所有的外键对应列的信息</li>
<li>INNODB_SYS_INDEXES: 整个InnoDB存储引擎中所有的索引的信息</li>
<li>INNODB_SYS_TABLES: 整个InnoDB存储引擎中所有的表的信息</li>
<li>INNODB_SYS_TABLESPACES: 整个InnoDB存储引擎中所有的表空间信息</li>
<li>INNODB_SYS_TABLESTATS: 整个InnoDB存储引擎中所有表统计信息</li>
<li>INNODB_SYS_VIRTUAL: 整个InnoDB存储引擎中所有的虚拟⽣成列的信息</li>
</ol>
<p>information_schema数据库中的这些以INNODB_SYS开头的表并不是真正的内部系统表，⽽是在存储引擎启动时读取真正的系统表，然后 填充到这些以INNODB_SYS开头的表中。</p>
<h4 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h4><p>当我们在数据库新建一个表test的时候(如果未做特殊说明，表引擎都是InnoDB),会产生两个文件，一个是 test.frm文件，一个是test.ibd文件。</p>
<p>frm文件中存储的是表结构(任何存储引擎都会产生这个文件)，ibd文件存储的是索引以及数据。</p>
<p>如果设置了 innodb_file_per_table ，则每个基于InnodDB存储引擎产生的表都会产生一个独立表空间，其命名规则为 表名.ibd。 </p>
<blockquote>
<p>表空间是⼀个抽象的概念，对于系统表空间来说，对应着⽂件系统中⼀个或多个实际⽂件；对于每个独⽴表空间来说，对应着⽂件系统中⼀个名为 表名.ibd 的实际⽂件</p>
</blockquote>
<p>innodb_file_per_table 也是推荐的方式(我使用的5.7默认是开启的)，可以通过以下命令查看设置情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show VARIABLES like &#39;innodb_file_per_table&#39;</span><br></pre></td></tr></table></figure>

<p>需要注意的是单独的.ibd独立表空间文件仅仅存储该表的数据、索引和插入缓冲等信息，其余信息还是存放在默认的系统表空间中的。</p>
<h3 id="通用表空间-general-tablesapce"><a href="#通用表空间-general-tablesapce" class="headerlink" title="通用表空间(general tablesapce)"></a>通用表空间(general tablesapce)</h3><p>通用表空间是使用 CREATE TABLESPACE 语法创建的共享 InnoDB 表空间，我们除了像上面那样说的让每个表都有自己的独立表空间之外，还可以让多个表在同一个表空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 创建表空间,文件默认是在data目录下</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLESPACE</span> <span class="string">`ts1`</span> <span class="keyword">ADD</span> <span class="keyword">DATAFILE</span> <span class="string">&#x27;ts1.ibd&#x27;</span> <span class="keyword">Engine</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line">// 可以放到data目录外</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLESPACE</span> <span class="string">`ts1`</span> <span class="keyword">ADD</span> <span class="keyword">DATAFILE</span> <span class="string">&#x27;/my/tablespace/directory/ts1.ibd&#x27;</span> <span class="keyword">Engine</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line">// 指定表在某个表空间</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>) <span class="keyword">TABLESPACE</span> ts1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个让多个表在同一个表空间有啥用呢？ 按照官方文档的说法，其主要特殊点在于两个地方</p>
<ol>
<li>相比独立的表空间，通用表空间因为是多个表放到同一个表空间中，所以其元数据占用内存更少</li>
<li>通过表空间可以将数据文件放在MySQL数据目录之外，因此我们可以为这些特定的表设置RAID或DRBD，或将表绑定到特定的磁盘上</li>
</ol>
<h3 id="临时表空间-temporary-tablespace"><a href="#临时表空间-temporary-tablespace" class="headerlink" title="临时表空间(temporary tablespace)"></a>临时表空间(temporary tablespace)</h3><p>临时表空间分为会话(session)临时表空间和一个全局(global)临时表空间。</p>
<p>全局临时表空间在正常关机或初始化中止时被移除，并在每次服务器启动时重新创建。全局临时表空间在创建时收到一个动态生成的空间ID。如果全局临时表空间不能被创建，则拒绝启动。如果服务器意外停止，全局临时表空间不会被删除。在这种情况下，数据库管理员可以手动删除全局临时表空间或重新启动MySQL服务器。重启MySQL服务器会自动删除并重新创建全局临时表空间。</p>
<p>会话临时表空间在第一次请求创建磁盘临时表时从临时表空间池中分配给会话。 一个会话最多分配两个表空间，一个用于用户创建的临时表，另一个用于优化器创建的内部临时表。 分配给会话的临时表空间用于会话创建的所有磁盘临时表。 当会话断开连接时，其临时表空间将被截断并释放回池中。</p>
<p>当我们创建临时表的时候数据会被放到临时表空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>session的临时表数据会存储在ibt文件中，而global session的临时表数据会存储在ibtmp1文件中</p>
<p>临时表可以使用各种引擎类型，如果使用的是InnoDB或者MyISAM引擎的临时表，写数据的时候是写到磁盘上的，当然临时表也可以使用Memory引擎。</p>
<p>临时表只针对当前会话有用，当会话(session)被关闭的时候，这个临时表也会被删除。临时表具有以下特性</p>
<ol>
<li>临时表只能被创建它的session访问，对其他线程不可见。</li>
<li>临时表可以于普通表同名</li>
<li>session A中有同名的临时表和普通标表的时候，show create 语句，以及增删改查语句访问的是临时表</li>
<li>show tables不显示临时表</li>
</ol>
<h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>我们之前说过修改数据也是先修改buffer pool中页的数据，如果事务提交后发生了故障，导致内存中的数据都丢失了(此时还未刷盘),那提交了的事务对数据库所做的更改也跟着丢失了，这是不能忍受的。</p>
<p>为了保证事务持久性(对于一个已经提交的事务，在事务提交后，即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失)，我们必须要有一个机制来记录事务到底修改了什么内容。</p>
<p>如果每次修改了buffer pool中数据就刷盘到磁盘的话，是不可取的，原因有2个。</p>
<ol>
<li>刷新一个完整的数据也太浪费了: 可能只更新了一个页的几个字节，但是确要刷整个页</li>
<li>随机IO比较慢: 一个事务可能更新多个页，如果这些页不连续，就会产生很多随机IO,随机IO比顺序IO要慢。</li>
</ol>
<p>因此我们使用redo log记录更新了什么内容，当事务提交时，我们只需要把redo log内容刷到磁盘中，即使系统崩溃了，我们也能根据文件内容恢复。使用redo log有以下优势</p>
<ol>
<li>redo日志占用空间非常小</li>
<li>redo日志是顺序写入磁盘的: 每次执行一条语句就可能产生多条redo日志，这些日志是按照产生顺序写入的</li>
</ol>
<p>默认情况下，InnoDB存储引擎的数据目录下会有两个名为 ib_logfile0 和 ib_logfile1 的文件，这个文件是redo log file,它们记录了InnoDB存储引擎的redo日志。</p>
<p>当mysql发生问题时，比如断电了，InnoDB引擎会使用redo log恢复到掉电前时刻，以此来保证数据完整性。</p>
<p>写入redo log并不是直接写，而是先写入redo log buffer中，然后再写入到日志文件中，写入方式是循环写入，InnoDB先写重写ib_logfile0,当文件1达到文件最后时，会切换至ib_logfile1,当文件2也被写满时，会在切换到文件1，如此循环往复。</p>
<p>同样的这里有两个参数可以控制redo log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看相关配置</span><br><span class="line">show VARIABLES like &#39;innodb%log%&#39;</span><br><span class="line"></span><br><span class="line">#指定日志文件大小</span><br><span class="line">innodb_log_file_size&#x3D;5M</span><br><span class="line"></span><br><span class="line">#指定文件组个数(默认值是2,所以是ib_logfile0,ib_logfile1两个文件)</span><br><span class="line">innodb_log_files_in_group&#x3D;2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看到这里是不是会疑惑，先写入redo log buffer,在刷盘，如果在刷盘的时候系统也崩溃了，不是也没办法回复数据吗？那再加一层来解决？ 这不就是俄罗斯套娃了么</p>
<p>还好mysql没有这么干，它让我们可以选择修改⼀个称为 innodb_flush_log_at_trx_commit 的系统变量的值，该变量有3个可选的值</p>
<ul>
<li>0：当该系统变量值为0时，表⽰在事务提交时不⽴即向磁盘中同步redo⽇志，这个任务是交给后台线程做的。 这样很明显会加快请求处理速度，但是如果事务提交后服务器挂了，后台线程没有及时将redo⽇志刷新到磁盘，那么该事务对页⾯的修改会丢失。 </li>
<li>1：当该系统变量值为1时，表⽰在事务提交时需要将redo⽇志同步到磁盘，可以保证事务的持久性。1也是innodb_flush_log_at_trx_commit的默认值。 </li>
<li>2：当该系统变量值为2时，表⽰在事务提交时需要将redo⽇志写到操作系统的缓冲区中，但并不需要保证将⽇志真正的刷新到磁盘。 这种情况下如果数据库挂了，操作系统没挂的话，事务的持久性还是可以保证的，但是操作系统也挂了的话，那就不能保证持久性了。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>Mysql官方文档</li>
<li>&lt;&lt;MySQL是怎样运行的:从根儿上理解MySQL&gt;&gt;</li>
<li>&lt;&lt;MySQL技术内幕：InnoDB存储引擎&gt;&gt;</li>
</ol>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>老生常谈：如何在MySQL中查找数据</title>
    <url>/2022/04/06/mysql-page-in-memory/</url>
    <content><![CDATA[<h3 id="页的组成部分"><a href="#页的组成部分" class="headerlink" title="页的组成部分"></a>页的组成部分</h3><p>数据库中表的数据被划分为若各个页(page),每个页中又存储了很多行记录，而我们往MySQL中插入的每行记录就放到页当中的行记录中,InnoDB的页分为以下几个部分</p>
<p><img data-src="/images/mysql/innodb-page.png" alt="InnoDB页"></p>
<p>InnoDB的页被划分为了7个部分，有的部分大小是确定的，有的部分不确定，各个部分说明如下</p>
<ol>
<li>File Header，表⽰页的⼀些通⽤信息，占固定的38字节。 </li>
<li>Page Header，表⽰数据页专有的⼀些信息，占固定的56个字节。 </li>
<li>Infimum + Supremum，两个虚拟的伪记录，分别表⽰页中的最⼩和最⼤记录，占固定的26个字节。 </li>
<li>User Records：真实存储我们插⼊的记录的部分，⼤⼩不固定。 </li>
<li>Free Space：页中尚未使⽤的部分，⼤⼩不确定。 </li>
<li>Page Directory：页中的某些记录相对位置，也就是各个槽在页⾯中的地址偏移量，⼤⼩不固定，插⼊的记录越多，这个部分占⽤的空间越多。 </li>
<li>File Trailer：⽤于检验页是否完整的部分，占⽤固定的8个字节。</li>
</ol>
<a id="more"></a>

<p>在页的7个组成部分中，我们⾃⼰存储的记录会按照我们指定的⾏格式存储到User Records部分。但是在⼀开始⽣成页的时候，其实并没有User Records这个部分，每当我们插⼊⼀条记录，都会从Free Space部分，也就是尚未使⽤的存储空间中申请⼀个记录⼤⼩的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使⽤完了，如果还有新的 记录插⼊的话，就需要去申请新的页了。</p>
<p>我们往User Records部分插入记录的时候，是直接在现有行的末尾(在顶部可用空间部分)或者删除行留下空间的任何地方插入，而并不是按照主键顺序插入新行(设计到大量数据的移动)。</p>
<blockquote>
<p>删除一条数据的时候mysql并不会马上将其中的数据回收，而是将这条记录置为已删除，下次插入新数据的时候就会重用这部分空间<br>但是为了更好的管理页中的记录,MySQL保证了页中的记录在逻辑上是有序的，这是如何做到的呢？</p>
</blockquote>
<p>行记录格式中有一个next_record字段,它表⽰从当前记录的真实数据到下⼀条记录的真实数据的地址偏移量。⽐⽅说第⼀条记录的next_record值为32，意味着从第⼀条记录的真实数据的地址处向后找32个字节便是 下⼀条记录的真实数据。</p>
<blockquote>
<p>关于行格式可以参见我的上一篇文章</p>
</blockquote>
<p>如果你熟悉数据结构的话，就⽴即明⽩了，这其实是个链表，可以通过⼀条记录找到它的下⼀条记录。但是需要注意注意再注意的⼀点是，下⼀条记录指得并不是按照我们插⼊顺序的下⼀条记录，⽽是按照主键值由⼩到⼤的顺序的下⼀条记录。</p>
<p>⽽且规定 Infimum记录（也就是最⼩记录） 的下⼀条记录就是本页中主键值最⼩的⽤户记录，⽽本页中主键值最⼤的⽤户记 录的下⼀条记录就是 Supremum记录（也就是最⼤记录） ，为了更形象的表⽰⼀下这个next_record起到的作⽤，我们⽤箭头来替代⼀下next_record中的地址偏移量</p>
<p><img data-src="/images/mysql/next-record.png" alt="next-record"></p>
<p>同时无论增删改任何一个操作，mysql都会保证这个链表的数据是自增的。</p>
<h4 id="页目录"><a href="#页目录" class="headerlink" title="页目录"></a>页目录</h4><p>当我们在一个页中查询数据的时候只用从最小记录开始往后遍历就能找到我们需要的记录了，但是如果一个页中记录数少还好，如果数据比较多，这样查找下来就比较耗费性能了，mysql当然不会这么干。</p>
<p>我们平常想从⼀本书中查找某个内容的时候，⼀般会先看⽬录，找到需要查找的内容对应的书的页码，然后到对应的页码查看内容。InnoDB为我们的记录也制作了⼀个类似的⽬录，他们的制作过程是这样的</p>
<ol>
<li>将所有正常的记录（包括最⼤和最⼩记录，不包括标记为已删除的记录）划分为⼏个组</li>
<li>每个组的最后⼀条记录（也就是组内最⼤的那条记录）的头信息中的n_owned属性表⽰该记录拥有多少条记录，也就是该组内共有⼏条记录。</li>
<li>将每个组的最后⼀条记录的地址偏移量单独提取出来按顺序存储到靠近⻚的尾部的地⽅</li>
</ol>
<p>这个地⽅就是所谓的Page Directory，也就是⻚⽬录（此时应该返回头看看页⾯各个部分的图）。页⾯⽬录中 的这些地址偏移量被称为槽（英⽂名：Slot）或者目录槽，所以这个页⾯⽬录就是由槽组成的。</p>
<p><img data-src="/images/mysql/page-directory-slot.png" alt="页目录"></p>
<p>从这个图中我们需要注意这么⼏点： </p>
<ol>
<li>现在⻚⽬录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最⼤记录的地址偏移量（就是从页⾯的0字节开始数，数112个字节；槽0中的值是99，代表最⼩记录的地址偏移量。 </li>
<li>注意最⼩和最⼤记录的头信息中的n_owned属性 最⼩记录的n_owned值为1，这就代表着以最⼩记录结尾的这个分组中只有1条记录，也就是最⼩记录本⾝。 最⼤记录的n_owned值为5，这就代表着以最⼤记录结尾的这个分组中只有5条记录，包括最⼤记录本⾝还有我们⾃⼰插⼊的4条记录。 </li>
</ol>
<p>现在我们就可以二分法查找页中的记录了。</p>
<p>比如我想查id=4的数据,怎么查呢？ 现在有2个slot,分别是0和1,所以 设 low = 0, high = 1。</p>
<ol>
<li>mid = (low + high) /2, 此时mid=0,查看 slot0对应记录的主键值是最小值，所以 high不变，low = 1</li>
<li>按照第一步公式重新计算mid=1,此时查看slot1对应主键值为supremum,大于我们要查找的主键4,因此数据肯定在slot1这个分组中</li>
<li>现在我们只需要从slot1中最小的记录开始遍历链表即可找到我们要的那条数据了。由于slot都是挨着的，所以slot0的下一条数据就是slot1中最小的那条数据，我们就从这条数据开始遍历就行了。</li>
</ol>
<p>为了效率，每个slot组中的记录数并不会太多，关于分组，innodb有这样的规则</p>
<ol>
<li>对于最⼩记录所在的分组只能有 1 条记录，最⼤记录所在的分组拥有的记录条数只能在1到8条之间，剩下的分组中记录的条数范围只能在4到8条之间。</li>
</ol>
<p>所以分组是按照下边的步骤进⾏的： 初始情况下⼀个数据页⾥只有最⼩记录和最⼤记录两条记录，它们分属于两个分组。 之后每插⼊⼀条记录，都会从⻚⽬录中找到主键值⽐本记录的主键值⼤并且差值最⼩的槽，然后把该槽对应的记录的n_owned值加1，表⽰本组内又添加了⼀条记录，直到该组中的记录数等于8个。</p>
<p>在⼀个组中的记录数等于8个后再插⼊⼀条记录时，会将组中的记录拆分成两个组，⼀个组中4条记录，另⼀个5条记录。这个过程会在⻚⽬录中新增⼀个槽来记录这个新增分组中最⼤的那条记录的偏移量。</p>
<h4 id="Page-Header-页面头部"><a href="#Page-Header-页面头部" class="headerlink" title="Page Header(页面头部)"></a>Page Header(页面头部)</h4><p>为了能得到⼀个数据页中存储的记录的状态信息，⽐如本页中已经存储了多少条记录，第⼀条记录的地址是什么，页⽬录中存储了多少个槽等等，特意在页中定义了⼀个叫Page Header的部分，它是⻚结构的第⼆部分，这个部分占⽤固定的56个字节，专门存储各种状态信息，包括但不限于以下内容</p>
<ol>
<li>页目录中槽数量</li>
<li>还未使⽤的空间最⼩地址，也就是说从该地址之后就是Free Space</li>
<li>本页中的记录的数量（包括最⼩和最⼤记录以及标记为删除的记录）</li>
<li>第⼀个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成⼀个单链表，这个单链表中的记录可以被重新利⽤）</li>
<li>已删除记录占⽤的字节数</li>
<li>最后插⼊记录的位置</li>
<li>该页中记录的数量（不包括最⼩和最⼤记录以及被标记为删除的记录）</li>
<li>当前页在B+树中所处的层级</li>
<li>索引ID，表⽰当前页属于哪个索引</li>
</ol>
<p>从这些记录的内容可以看出来，页中的状态值以及属性值还是蛮多的，它们占用固定的大小，可见为了充分利用内存，大佬们费了多少心。</p>
<h4 id="File-Header-文件头部"><a href="#File-Header-文件头部" class="headerlink" title="File Header(文件头部)"></a>File Header(文件头部)</h4><p>File Header针对各种类型的页都通⽤，也就是说不同类型的页都会 以File Header作为第⼀个组成部分，它描述了⼀些针对各种页都通⽤的⼀些信息，⽐⽅说这个页的编号是多少，它的上⼀个页、下⼀个页是谁等等。</p>
<ol>
<li>页的校验和</li>
<li>当前页页号(InnoDB通过页号来可以唯⼀定位⼀个⻚)</li>
<li>上一个页页号</li>
<li>下一个页页号</li>
<li>页面被最后修改时对应的日志序列位置(Log Sequence Number)</li>
<li>页类型</li>
<li>属于哪个表空间</li>
</ol>
<p>页类型分很多种，比如undo日志页，系统页，索引页，blob页等，我们存放记录的数据页的类型就是所谓的索引⻚。</p>
<p>而通过上一页，下一页,存储数据的页就形成了一个双向链表了。</p>
<p><img data-src="/images/mysql/innodb-page-next.png" alt="双向链表数据页"></p>
<p>需要注意的是当一个页已经满了之后，新插入的记录就需要插入到新的页中，由于必须满足下⼀个数据页中⽤户记录的主键值必须⼤于上⼀个页中⽤户记录的主键值的要求，所以插入的过程就会伴随着数据的移动。</p>
<p>假设页A只能插入3条数据(注意实际上能插入很多),分别是1,3,5。现在要插入一条数据4，由于页A已经满了，所以需要将数据插入页B中，由于下一个数据页的主键值必须大于上一页的主键值，所以要现在5这条数据移动到页B中，然后再把4这条数据插入到页A中。</p>
<h4 id="File-Trailer-文件尾部"><a href="#File-Trailer-文件尾部" class="headerlink" title="File Trailer(文件尾部)"></a>File Trailer(文件尾部)</h4><p>InnoDB存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以⻚为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘 中。但是在同步了⼀半的时候中断电了咋办，这不是莫名尴尬么？</p>
<p>为了检测⼀个页是否完整（也就是在同步的时候有没有发⽣只同步⼀半的尴尬情况），File Trailer应运而生，这个部分由8个字节组成，可以分成2个⼩部分： </p>
<p>前4个字节代表页的校验和 这个部分是和File Header中的校验和相对应的。每当⼀个页⾯在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页⾯的前边，所以校验和会被⾸先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的⾸部和尾部的校验和应该是⼀致的。<br>如果写了⼀半⼉断电了，那么在File Header中的校验和就代表着已经修改过的页，⽽在File Trialer中的校验和代表着原先的页，⼆者不同则意味着同步中间出了错。 </p>
<p>后4个字节代表页⾯被最后修改时对应的⽇志序列位置（LSN） 这个部分也是为了校验页的完整性的，只不过我们⽬前还没说LSN是个什么意思，所以⼤家可以先不⽤管这个属性。<br>这个File Trailer与File Header类似，都是所有类型的页通⽤的。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>现在我们知道了如何在一个页中快速查找某一条数据,但是如果我们的数据量很大，分散在很多页中，那应该如何查找呢？ 只能一页一页进行遍历吗？</p>
<p>当然不是，我们同样可以借鉴书本目录的做法，给数据页建立一个索引目录结构。</p>
<p><img data-src="/images/mysql/innodb-index-page.png" alt="索引页"></p>
<p>从图中可以看出来，我们新分配了⼀个编号为30的页来专门存储⽬录项记录。这⾥再次强调⼀遍⽬录项记录和普通的⽤户记录的不同点：</p>
<ol>
<li>⽬录项记录的record_type值是1，⽽普通⽤户记录的record_type值是0。</li>
<li>⽬录项记录只有主键值和页的编号两个列，⽽普通的⽤户记录的列是⽤户⾃⼰定义的，可能包含很多列，另外还有InnoDB⾃⼰添加的隐藏列。</li>
</ol>
<p>上面的图中为了简单，隐藏了最大最小记录，没有画出来并不代表没有哈。</p>
<p>虽然说⽬录项记录中只存储主键值和对应的页号，⽐⽤户记录需要的存储空间⼩多了，但是不论怎么说⼀个页只有16KB⼤⼩，能存放的⽬录项记录也是有限的，那如果表中的数据太多，以⾄于⼀个数据页不<br>⾜以存放所有的⽬录项记录，该咋办呢？当然是再多整⼀个存储⽬录项记录的页</p>
<p><img data-src="/images/mysql/innodb-index-page-2.png" alt="索引页"></p>
<p>当我们存储的记录越多，那么目录项记录也就越多，存储目录项的页也就越多，好像这就又回到了最初的问题，那又怎么解决呢？ 还是同样的解法，给这些目录项的页生成一个更高层的目录就行了，就如下图</p>
<p><img data-src="/images/mysql/innodb-index-multi-page.png" alt="多级目录"></p>
<p>这样当我们要查询某个值的时候，直接从最顶层开始过滤，然后沿着这个目录结构过滤就行了。</p>
<p>你看看这个结构是不是很熟悉，就是一颗咱们熟悉的树嘛，这个数据结构叫B+树。<br><img data-src="/images/mysql/innodb-b-tree.png" alt="B+树"></p>
<p>不论是存放⽤户记录的数据页，还是存放⽬录项记录的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为节点。从图中可以看出来，我们的实际⽤户记录其实都存放在<br>B+树的最底层的节点上，这些节点也被称为叶⼦节点或叶节点，其余⽤来存放⽬录项的节点称为⾮叶⼦节点或者内节点，其中B+树最上边的那个节点也称为根节点。</p>
<p>上面建立的索引有两个特点</p>
<ol>
<li>所有数据(包括隐藏列)都存储在叶子节点中(最底层节点)</li>
<li>无论是页内的记录还是页都是按照主键进行排序的</li>
</ol>
<p>我们把具有这两种特性的B+树称为聚簇索引，所有完整的⽤户记录都存放在这个聚簇索引的叶⼦节点处。InnoDB存储引擎会⾃动的为我们创建聚簇索引。</p>
<h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>上面的聚簇索引，只有搜索条件是主键的时候才能发挥作用，因为B+树中数据是按照主键进行排序的。如果我有下面的表,给a建立了一个索引，应该如何处理？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> idx_a(a),</span><br><span class="line">  <span class="keyword">KEY</span> idx_a_b(a,b)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在InnoDB中，会为每个索引都创建一个B+树，排序规则则是按照索引列进行排序的，比如我们根据a建立了一个索引，那么这颗B+树就长这样</p>
<p><img data-src="/images/mysql/innodb-second-page-index.png" alt="二级索引"></p>
<p>这个B+树和上面聚簇索引有几点不同。</p>
<ol>
<li>页内的记录是按照列a的⼤⼩顺序排成⼀个单向链表。</li>
<li>各个存放⽤户记录的页也是根据页中记录的列a⼤⼩顺序排成⼀个双向链表。</li>
<li>存放⽬录项记录的页分为不同的层次，在同⼀层次中的页也是根据页中⽬录项记录的列a⼤⼩顺序排成⼀个双向链表。</li>
<li>B+树的叶⼦节点存储的并不是完整的⽤户记录，⽽只是列a+主键这两个列的值</li>
<li>⽬录项记录中不再是主键+⻚号的搭配，⽽变成了列a+主键id+⻚号的搭配</li>
</ol>
<p>目录项记录为什么是列a+主键id+页号，而不是列a+页号呢？ </p>
<p>假设我们目录项记录是 列a+页号，当我们在插入一条数据 （13,4,8)的时候，这条数据应该放入到页36还是页37呢？ 这两个页中都有a=4的数据呢，innodb也不知道，所以为了为了让新插⼊记录能找到⾃⼰在那个页⾥，我们需要保证在B+树的同⼀层节点的⽬录项记录除⻚号这个字段以外是唯⼀的。因此目录项记录是 列a+id+页号。</p>
<p>我们再插⼊记录(13, 4, 8)时，由于⻚35中存储的⽬录项记录是由列a + 主键 + ⻚号的值构成的，可以先把新记录的列a的值和⻚35中各⽬录项记录的列a的值作⽐较，如果列a的值相同的话，可以<br>接着⽐较主键值，因为B+树同⼀层中不同⽬录项记录的列a + 主键的值肯定是不⼀样的，所以最后肯定能定位唯⼀的⼀条⽬录项记录，在本例中最后确定新记录应该被插⼊到⻚37中。</p>
<p>现在B+树有了，那么我们应该怎么搜索呢？</p>
<p>以查找列a的值为4的记录为例，查找过程如下：</p>
<ol>
<li>确定⽬录项记录页,根据根⻚⾯，也就是⻚35，可以快速定位到⽬录项记录所在的页为⻚37。</li>
<li>通过⽬录项记录页确定⽤户记录真实所在的页。<br>在⻚37中可以快速定位到实际存储⽤户记录的页，但是由于列a并没有唯⼀性约束，所以列a值为4的记录可能分布在多个数据页中，又因为2 &lt; 4 ≤ 4，所以确定实际存储⽤户记录的页在⻚36和⻚<br>37中。</li>
<li>在真实存储⽤户记录的页中定位到具体的记录。到⻚36和⻚37中定位到具体的记录。</li>
<li>但是这个B+树的叶⼦节点中的记录只存储了a和id（也就是主键）两个列，所以我们必须再根据主键值去聚簇索引中再查找⼀遍完整的⽤户记录。</li>
</ol>
<p>根据这个以列a⼤⼩排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据列a的值查找到完整的⽤户记录的话，仍然需要到聚簇索引中再查⼀遍，这个过程也被称为回表。<br>也就是根据列a的值查询⼀条完整的⽤户记录需要使⽤到2棵B+树！！！</p>
<p>为什么我们还需要⼀次回表操作呢？直接把完整的⽤户记录放到叶⼦节点不就好了么？你说的对，如果把完整的⽤户记录放到叶⼦节点是可以不⽤回表，但是太占地⽅了呀～相当于每建⽴⼀棵B+树都需要把<br>所有的⽤户记录再都拷贝⼀遍，这就有点太浪费存储空间了。因为这种按照⾮主键列建⽴的B+树需要⼀次回表操作才可以定位到完整的⽤户记录，所以这种B+树也被称为⼆级索引（英⽂名secondary<br>index），或者辅助索引。</p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>当然也可以同时以多个列的⼤⼩作为排序规则，也就是同时为多个列建⽴索引，⽐⽅说我们想让B+树按照a和b列的⼤⼩进⾏排序，这个包含两层含义：</p>
<ol>
<li>先把各个记录和页按照a列进⾏排序。</li>
<li>在记录的a列相同的情况下，采⽤b列进⾏排序<br>为a和b列建⽴的索引的⽰意图如下：<br><img data-src="/images/mysql/innodb-union-index-page.png" alt="InnoDB联合索引"></li>
</ol>
<p>联合索引本质也是个二级索引</p>
<h4 id="B-树根页面"><a href="#B-树根页面" class="headerlink" title="B+树根页面"></a>B+树根页面</h4><ul>
<li>每当为某个表创建⼀个B+树索引（聚簇索引不是⼈为创建的，默认就有）的时候，都会为这个索引创建⼀个根节点页⾯。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有⽤户记录，<br>也没有⽬录项记录。</li>
<li>随后向表中插⼊⽤户记录时，先把⽤户记录存储到这个根节点中。</li>
<li>当根节点中的可⽤空间⽤完时继续插⼊记录，此时会将根节点中的所有记录复制到⼀个新分配的页，⽐如⻚a中，然后对这个新页进⾏⻚分裂的操作，得到另⼀个新页，⽐如⻚b。这时新插⼊的记录根据<br>键值（也就是聚簇索引中的主键值，⼆级索引中对应的索引列的值）的⼤⼩就会被分配到⻚a或者⻚b中，⽽根节点便升级为存储⽬录项记录的页。</li>
</ul>
<p>这个过程需要⼤家特别注意的是：⼀个B+树索引的根节点⾃诞⽣之⽇起，便不会再移动。这样只要我们对某个表建⽴⼀个索引，那么它的根节点的页号便会被记录到某个地⽅，然后凡是InnoDB存储引擎需<br>要⽤到这个索引的时候，都会从那个固定的地⽅取出根节点的页号，从⽽来访问这个索引。</p>
<blockquote>
<p>这个固定的地方就是我们之前提到过的数据字典信息</p>
</blockquote>
<p>我们平时是以记录为单位来向表中插⼊数据的，这些记录在磁盘上的存放⽅式也被称为⾏格式或者记录格式。InnoDB有4种不同类型的⾏格式，分别 是Compact、Redundant、Dynamic和Compressed⾏格式，随着时间的推移，他们可能会设计出更多的⾏格式，但是不管怎么变，在原理上⼤体都是相同的。</p>
<h3 id="MyIsam"><a href="#MyIsam" class="headerlink" title="MyIsam"></a>MyIsam</h3><p>InnoDB中聚簇索引叶子节点会包含所有数据，MyISAM索引方案虽然也是使用的树形结果，但是其数据和索引是分开的。</p>
<p>MyISAM将表中的记录按照记录的插⼊顺序单独存储在⼀个⽂件中，称之为数据⽂件。这个⽂件并不划分为若⼲个数据页，有多少记录就往这个⽂件中塞多少记录就成了。我们可以通过⾏号⽽快速访问到⼀<br>条记录.<br><img data-src="/images/mysql/myisam-data.png" alt="myisam数据"></p>
<blockquote>
<p>myisam行记录格式是static(定长)时，可以通过行号找到数据，如果是变长记录格式时，那么MyISAM会直接在索引叶⼦节点处存储该条记录在数据⽂件中的地址偏移量，可以直接通过这个偏移量找到文件中的数据</p>
</blockquote>
<p>由于在插⼊数据的时候并没有刻意按照主键⼤⼩排序，所以我们并不能在这些数据上使⽤⼆分法进⾏查找。<br>使⽤MyISAM存储引擎的表会把索引信息另外存储到⼀个称为索引⽂件的另⼀个⽂件中。MyISAM会单独为表的主键创建⼀个索引，只不过在索引的叶⼦节点中存储的不是完整的⽤户记录，⽽是主键值 + ⾏号的组合。也就是先通过索引找到对应的⾏号，再通过⾏号去找对应的记录！</p>
<p>这⼀点和InnoDB是完全不相同的，在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进⾏⼀次查找就能找到对应的记录，⽽在MyISAM中却需要进⾏⼀次回表操作，意味着MyISAM中建⽴的索引相<br>当于全部都是⼆级索引！</p>
<p>如果有需要的话，我们也可以对其它的列分别建⽴索引或者建⽴联合索引，原理和InnoDB中的索引差不多，不过在叶⼦节点处存储的是相应的列 + ⾏号。这些索引也全部都是⼆级索引。</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql索引原理以及慢查询优化</title>
    <url>/2016/01/06/mysql-slow-query-optimize/</url>
    <content><![CDATA[<p>工作中有遇到mysql优化的问题,当时查找了很多资料，直到看到了这篇文章对mysql的慢查询以及优化有了更加深入的认识。  </p>
<p>以下的文章内容均为转载,可以到<a href="http://tech.meituan.com/mysql-index.html">http://tech.meituan.com/mysql-index.html</a>查看原文。</p>
<p>MySQL凭借着出色的性能、低廉的成本、丰富的资源，已经成为绝大多数互联网公司的首选关系型数据库。虽然性能出色，但所谓“好马配好鞍”，如何能够更好的使用它，已经成为开发工程师的必修课，我们经常会从职位描述上看到诸如“精通MySQL”、“SQL语句优化”、“了解数据库原理”等要求。我们知道一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，所以查询语句的优化显然是重中之重。<br>本人从13年7月份起，一直在美团核心业务系统部做慢查询的优化工作，共计十余个系统，累计解决和积累了上百个慢查询案例。随着业务的复杂性提升，遇到的问题千奇百怪，五花八门，匪夷所思。本文旨在以开发工程师的角度来解释数据库索引的原理和如何优化慢查询。</p>
<h3 id="一个慢查询引发的思考"><a href="#一个慢查询引发的思考" class="headerlink" title="一个慢查询引发的思考"></a>一个慢查询引发的思考</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   <span class="keyword">count</span>(*) </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   task </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   <span class="keyword">status</span>=<span class="number">2</span> </span><br><span class="line">   <span class="keyword">and</span> operator_id=<span class="number">20839</span> </span><br><span class="line">   <span class="keyword">and</span> operate_time&gt;<span class="number">1371169729</span> </span><br><span class="line">   <span class="keyword">and</span> operate_time&lt;<span class="number">1371174603</span> </span><br><span class="line">   <span class="keyword">and</span> <span class="keyword">type</span>=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>系统使用者反应有一个功能越来越慢，于是工程师找到了上面的SQL。<br>并且兴致冲冲的找到了我.<br>“这个SQL需要优化，给我把每个字段都加上索引”<br>我很惊讶，问道“为什么需要每个字段都加上索引？”<br>“把查询的字段都加上索引会更快”工程师信心满满<br>“这种情况完全可以建一个联合索引，因为是最左前缀匹配，所以operate_time需要放到最后，而且还需要把其他相关的查询都拿来，需要做一个综合评估。”<br>“联合索引？最左前缀匹配？综合评估？”工程师不禁陷入了沉思。<br>多数情况下，我们知道索引能够提高查询效率，但应该如何建立索引？索引的顺序如何？许多人却只知道大概。其实理解这些概念并不难，而且索引的原理远没有想象的那么复杂。</p>
<h3 id="MySQL索引原理"><a href="#MySQL索引原理" class="headerlink" title="MySQL索引原理"></a>MySQL索引原理</h3><p><strong>索引目的</strong></p>
<p>索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p>
<p><strong>索引原理</strong></p>
<p>除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。<br>数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢?<br>最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。<br>但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。</p>
<p><strong>磁盘IO与预读</strong></p>
<p>前面提到了访问磁盘，那么这里先简单介绍一下磁盘IO和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = 4.17ms。<br>传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。下图是计算机硬件延迟的对比图，供大家参考：<br><img data-src="http://tech.meituan.com/img/mysql_index/various-system-software-hardware-latencies.png" alt="系统硬件对比图"></p>
<p>考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p>
<p><strong>索引的数据结构</strong></p>
<p>前面讲了生活中索引的例子，索引的基本原理，数据库的复杂性，又讲了操作系统的相关知识，目的就是让大家了解，任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。</p>
<p><strong>详解b+树</strong></p>
<p><img data-src="http://tech.meituan.com/img/mysql_index/btree.jpg" alt="B+树"><br>如上图，是一颗b+树，关于b+树的定义可以参见B+树，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。</p>
<p><strong>b+树的查找过程</strong></p>
<p>如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p>
<p><strong>b+树性质</strong></p>
<ol>
<li><p>通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</p>
</li>
<li><p>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p>
</li>
</ol>
<h3 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h3><p>关于MySQL索引原理是比较枯燥的东西，大家只需要有一个感性的认识，并不需要理解得非常透彻和深入。我们回头来看看一开始我们说的慢查询，了解完索引原理之后，大家是不是有什么想法呢？先总结一下索引的几大基本原则</p>
<h3 id="建索引的几大原则"><a href="#建索引的几大原则" class="headerlink" title="建索引的几大原则"></a>建索引的几大原则</h3><ol>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
<li>尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录</li>
<li>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);</li>
<li>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可</li>
</ol>
<h3 id="回到开始的慢查询"><a href="#回到开始的慢查询" class="headerlink" title="回到开始的慢查询"></a>回到开始的慢查询</h3><p>根据最左匹配原则，最开始的sql语句的索引应该是status、operator_id、type、operate_time的联合索引；其中status、operator_id、type的顺序可以颠倒，所以我才会说，把这个表的所有相关查询都找到，会综合分析；<br>比如还有如下查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> task <span class="keyword">where</span> <span class="keyword">status</span> = <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">type</span> = <span class="number">12</span> <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> task <span class="keyword">where</span> <span class="keyword">status</span> = <span class="number">0</span> ;</span><br></pre></td></tr></table></figure>

<p>那么索引建立成(status,type,operator_id,operate_time)就是非常正确的，因为可以覆盖到所有情况。这个就是利用了索引的最左匹配的原则</p>
<h3 id="查询优化神器-explain命令"><a href="#查询优化神器-explain命令" class="headerlink" title="查询优化神器 - explain命令"></a>查询优化神器 - explain命令</h3><p>关于explain命令相信大家并不陌生，具体用法和字段含义可以参考官网explain-output<a href="http://dev.mysql.com/doc/refman/5.5/en/explain-output.html">官方参考文档</a>，这里需要强调rows是核心指标，绝大部分rows小的语句执行一定很快（有例外，下面会讲到）。所以优化语句基本上都是在优化rows。</p>
<h3 id="慢查询优化基本步骤"><a href="#慢查询优化基本步骤" class="headerlink" title="慢查询优化基本步骤"></a>慢查询优化基本步骤</h3><ol>
<li>先运行看看是否真的很慢，注意设置SQL_NO_CACHE</li>
<li>where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</li>
<li>explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</li>
<li>order by limit 形式的sql语句让排序的表优先查</li>
<li>了解业务方使用场景</li>
<li>加索引时参照建索引的几大原则</li>
<li>观察结果，不符合预期继续从1分析</li>
</ol>
<h3 id="几个慢查询案例"><a href="#几个慢查询案例" class="headerlink" title="几个慢查询案例"></a>几个慢查询案例</h3><p>下面几个例子详细解释了如何分析和优化慢查询</p>
<h3 id="复杂语句写法"><a href="#复杂语句写法" class="headerlink" title="复杂语句写法"></a>复杂语句写法</h3><p>很多情况下，我们写SQL只是为了实现功能，这只是第一步，不同的语句书写方式对于效率往往有本质的差别，这要求我们对mysql的执行计划和索引原则有非常清楚的认识，请看下面的语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   <span class="keyword">distinct</span> cert.emp_id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   (</span><br><span class="line">      <span class="keyword">select</span></span><br><span class="line">         emp.id <span class="keyword">as</span> emp_id,</span><br><span class="line">         emp_cert.id <span class="keyword">as</span> cert_id </span><br><span class="line">      <span class="keyword">from</span></span><br><span class="line">         employee emp </span><br><span class="line">      <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">         emp_certificate emp_cert </span><br><span class="line">            <span class="keyword">on</span> emp.id = emp_cert.emp_id </span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">         emp.is_deleted=<span class="number">0</span></span><br><span class="line">   ) cert </span><br><span class="line">      <span class="keyword">on</span> (</span><br><span class="line">         cl.ref_table=<span class="string">&#x27;Employee&#x27;</span> </span><br><span class="line">         <span class="keyword">and</span> cl.ref_oid= cert.emp_id</span><br><span class="line">      ) </span><br><span class="line">      <span class="keyword">or</span> (</span><br><span class="line">         cl.ref_table=<span class="string">&#x27;EmpCertificate&#x27;</span> </span><br><span class="line">         <span class="keyword">and</span> cl.ref_oid= cert.cert_id</span><br><span class="line">      ) </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date &gt;=<span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date&lt;=<span class="string">&#x27;2013-11-08 16:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>先运行一下，53条记录 1.87秒，又没有用聚合语句，比较慢</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">53 rows in set (1.87 sec)</span><br></pre></td></tr></table></figure>
<ol>
<li>explain</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+</span><br><span class="line">| id | select_type | table      | type  | possible_keys                   | key                   | key_len | ref               | rows  | Extra                          |</span><br><span class="line">+----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+--------------------------------+</span><br><span class="line">|  1 | PRIMARY     | cl         | range | cm_log_cls_id,idx_last_upd_date | idx_last_upd_date     | 8       | NULL              |   379 | Using where; Using temporary   |</span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; | ALL   | NULL                            | NULL                  | NULL    | NULL              | 63727 | Using where; Using join buffer |</span><br><span class="line">|  2 | DERIVED     | emp        | ALL   | NULL                            | NULL                  | NULL    | NULL              | 13317 | Using where                    |</span><br><span class="line">|  2 | DERIVED     | emp_cert   | ref   | emp_certificate_empid           | emp_certificate_empid | 4       | meituanorg.emp.id |     1 | Using index                    |</span><br><span class="line">+----+-------------+------------+-------+---------------------------------+-----------------------+---------+-------------------+-------+---------</span><br><span class="line">-----------------------+</span><br></pre></td></tr></table></figure>


<p>简述一下执行计划，首先mysql根据idx_last_upd_date索引扫描cm_log表获得379条记录；然后查表扫描了63727条记录，分为两部分，derived表示构造表，也就是不存在的表，可以简单理解成是一个语句形成的结果集，后面的数字表示语句的ID。  </p>
<p>derived2表示的是ID = 2的查询构造了虚拟表，并且返回了63727条记录。  </p>
<p>我们再来看看ID = 2的语句究竟做了写什么返回了这么大量的数据，首先全表扫描employee表13317条记录，然后根据索引emp_certificate_empid关联emp_certificate表，rows = 1表示，每个关联都只锁定了一条记录，效率比较高。获得后，再和cm_log的379条记录根据规则关联。从执行过程上可以看出返回了太多的数据，返回的数据绝大部分cm_log都用不到，因为cm_log只锁定了379条记录。  </p>
<p>如何优化呢？可以看到我们在运行完后还是要和cm_log做join,那么我们能不能之前和cm_log做join呢？仔细分析语句不难发现，其基本思想是如果cm_log的ref_table是EmpCertificate就关联emp_certificate表，如果ref_table是Employee就关联employee表，我们完全可以拆成两部分，并用union连接起来，注意这里用union，而不用union all是因为原语句有“distinct”来得到唯一的记录，而union恰好具备了这种功能。<br>如果原语句中没有distinct不需要去重，我们就可以直接使用union all了，因为使用union需要去重的动作，会影响SQL性能。</p>
<p><strong>优化过的语句如下</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">   emp.id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   employee emp </span><br><span class="line">      <span class="keyword">on</span> cl.ref_table = <span class="string">&#x27;Employee&#x27;</span> </span><br><span class="line">      <span class="keyword">and</span> cl.ref_oid = emp.id  </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date &gt;=<span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date&lt;=<span class="string">&#x27;2013-11-08 16:00:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> emp.is_deleted = <span class="number">0</span>  </span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">   emp.id </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   cm_log cl </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   emp_certificate ec </span><br><span class="line">      <span class="keyword">on</span> cl.ref_table = <span class="string">&#x27;EmpCertificate&#x27;</span> </span><br><span class="line">      <span class="keyword">and</span> cl.ref_oid = ec.id  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   employee emp </span><br><span class="line">      <span class="keyword">on</span> emp.id = ec.emp_id  </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   cl.last_upd_date &gt;=<span class="string">&#x27;2013-11-07 15:03:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> cl.last_upd_date&lt;=<span class="string">&#x27;2013-11-08 16:00:00&#x27;</span> </span><br><span class="line">   <span class="keyword">and</span> emp.is_deleted = <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>不需要了解业务场景，只需要改造的语句和改造之前的语句保持结果一致</p>
</li>
<li><p>现有索引可以满足，不需要建索引</p>
</li>
<li><p>用改造后的语句实验一下，只需要10ms 降低了近200倍！</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span><br><span class="line">| id | select_type  | table      | type   | possible_keys                   | key               | key_len | ref                   | rows | Extra       |</span><br><span class="line">+----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span><br><span class="line">|  1 | PRIMARY      | cl         | range  | cm_log_cls_id,idx_last_upd_date | idx_last_upd_date | 8       | NULL                  |  379 | Using where |</span><br><span class="line">|  1 | PRIMARY      | emp        | eq_ref | PRIMARY                         | PRIMARY           | 4       | meituanorg.cl.ref_oid |    1 | Using where |</span><br><span class="line">|  2 | UNION        | cl         | range  | cm_log_cls_id,idx_last_upd_date | idx_last_upd_date | 8       | NULL                  |  379 | Using where |</span><br><span class="line">|  2 | UNION        | ec         | eq_ref | PRIMARY,emp_certificate_empid   | PRIMARY           | 4       | meituanorg.cl.ref_oid |    1 |             |</span><br><span class="line">|  2 | UNION        | emp        | eq_ref | PRIMARY                         | PRIMARY           | 4       | meituanorg.ec.emp_id  |    1 | Using where |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | ALL    | NULL                            | NULL              | NULL    | NULL                  | NULL |             |</span><br><span class="line">+----+--------------+------------+--------+---------------------------------+-------------------+---------+-----------------------+------+-------------+</span><br><span class="line">53 rows in set (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="明确应用场景"><a href="#明确应用场景" class="headerlink" title="明确应用场景"></a>明确应用场景</h3><p>举这个例子的目的在于颠覆我们对列的区分度的认知，一般上我们认为区分度越高的列，越容易锁定更少的记录，但在一些特殊的情况下，这种理论是有局限性的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   * </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   stage_poi sp </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   sp.accurate_result=<span class="number">1</span> </span><br><span class="line">   <span class="keyword">and</span> (</span><br><span class="line">      sp.sync_status=<span class="number">0</span> </span><br><span class="line">      <span class="keyword">or</span> sp.sync_status=<span class="number">2</span> </span><br><span class="line">      <span class="keyword">or</span> sp.sync_status=<span class="number">4</span></span><br><span class="line">   );</span><br></pre></td></tr></table></figure>
<ol>
<li>先看看运行多长时间,951条数据6.22秒，真的很慢</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">951 rows in set (6.22 sec)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>先explain，rows达到了361万，type = ALL表明是全表扫描</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows    | Extra       |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span><br><span class="line">|  1 | SIMPLE      | sp    | ALL  | NULL          | NULL | NULL    | NULL | 3613155 | Using where |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+---------+-------------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有字段都应用查询返回记录数，因为是单表查询 0已经做过了951条</p>
</li>
<li><p>让explain的rows 尽量逼近951</p>
</li>
</ol>
<p>看一下accurate_result = 1的记录数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*),accurate_result <span class="keyword">from</span> stage_poi  <span class="keyword">group</span> <span class="keyword">by</span> accurate_result;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+----------+-----------------+</span><br><span class="line">| count(\*) | accurate_result |</span><br><span class="line">+----------+-----------------+</span><br><span class="line">|     1023 |              -1 |</span><br><span class="line">|  2114655 |               0 |</span><br><span class="line">|   972815 |               1 |</span><br><span class="line">+----------+-----------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们看到accurate_result这个字段的区分度非常低，整个表只有-1,0,1三个值，加上索引也无法锁定特别少量的数据</p>
<p><strong>再看一下sync_status字段的情况</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*),sync_status <span class="keyword">from</span> stage_poi  <span class="keyword">group</span> <span class="keyword">by</span> sync_status;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+----------+-------------+</span><br><span class="line">| count(\*) | sync_status |</span><br><span class="line">+----------+-------------+</span><br><span class="line">|     3080 |           0 |</span><br><span class="line">|  3085413 |           3 |</span><br><span class="line">+----------+-------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样的区分度也很低，根据理论，也不适合建立索引</p>
<p>问题分析到这，好像得出了这个表无法优化的结论，两个列的区分度都很低，即便加上索引也只能适应这种情况，很难做普遍性的优化，比如当sync_status 0、3分布的很平均，那么锁定记录也是百万级别的</p>
<ol start="5">
<li><p>找业务方去沟通，看看使用场景。业务方是这么来使用这个SQL语句的，每隔五分钟会扫描符合条件的数据，处理完成后把sync_status这个字段变成1,五分钟符合条件的记录数并不会太多，1000个左右。了解了业务方的使用场景后，优化这个SQL就变得简单了，因为业务方保证了数据的不平衡，如果加上索引可以过滤掉绝大部分不需要的数据</p>
</li>
<li><p>根据建立索引规则，使用如下语句建立索引</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> stage_poi <span class="keyword">add</span> <span class="keyword">index</span> idx_acc_status(accurate_result,sync_status);</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>观察预期结果,发现只需要200ms，快了30多倍。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">952 rows in set (0.20 sec)</span><br></pre></td></tr></table></figure>

<p>我们再来回顾一下分析问题的过程，单表查询相对来说比较好优化，大部分时候只需要把where条件里面的字段依照规则加上索引就好，如果只是这种“无脑”优化的话，显然一些区分度非常低的列，不应该加索引的列也会被加上索引，这样会对插入、更新性能造成严重的影响，同时也有可能影响其它的查询语句。所以我们第4步调差SQL的使用场景非常关键，我们只有知道这个业务场景，才能更好地辅助我们更好的分析和优化查询语句。</p>
<h3 id="无法优化的语句"><a href="#无法优化的语句" class="headerlink" title="无法优化的语句"></a>无法优化的语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   c.id,</span><br><span class="line">   c.name,</span><br><span class="line">   c.position,</span><br><span class="line">   c.sex,</span><br><span class="line">   c.phone,</span><br><span class="line">   c.office_phone,</span><br><span class="line">   c.feature_info,</span><br><span class="line">   c.birthday,</span><br><span class="line">   c.creator_id,</span><br><span class="line">   c.is_keyperson,</span><br><span class="line">   c.giveup_reason,</span><br><span class="line">   c.status,</span><br><span class="line">   c.data_source,</span><br><span class="line">   from_unixtime(c.created_time) <span class="keyword">as</span> created_time,</span><br><span class="line">   from_unixtime(c.last_modified) <span class="keyword">as</span> last_modified,</span><br><span class="line">   c.last_modified_user_id  </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   contact c  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   contact_branch cb </span><br><span class="line">      <span class="keyword">on</span>  c.id = cb.contact_id  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   branch_user bu </span><br><span class="line">      <span class="keyword">on</span>  cb.branch_id = bu.branch_id </span><br><span class="line">      <span class="keyword">and</span> bu.status <span class="keyword">in</span> (</span><br><span class="line">         <span class="number">1</span>,</span><br><span class="line">      <span class="number">2</span>)  </span><br><span class="line">   <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">      org_emp_info oei </span><br><span class="line">         <span class="keyword">on</span>  oei.data_id = bu.user_id </span><br><span class="line">         <span class="keyword">and</span> oei.node_left &gt;= <span class="number">2875</span> </span><br><span class="line">         <span class="keyword">and</span> oei.node_right &lt;= <span class="number">10802</span> </span><br><span class="line">         <span class="keyword">and</span> oei.org_category = - <span class="number">1</span>  </span><br><span class="line">   <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">      c.created_time <span class="keyword">desc</span>  <span class="keyword">limit</span> <span class="number">0</span> ,</span><br><span class="line">      <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><strong>还是几个步骤</strong></p>
<ol>
<li><p>先看语句运行多长时间，10条记录用了13秒，已经不可忍受</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 rows in set (13.06 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>explain</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------------+-------+--------+-------------------------------------+-------------------------+---------+--------------------------+------+----------------------------------------------+</span><br><span class="line">| id | select_type | table | type   | possible_keys                       | key                     | key_len | ref                      | rows | Extra                                        |</span><br><span class="line">+----+-------------+-------+--------+-------------------------------------+-------------------------+---------+--------------------------+------+----------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | oei   | ref    | idx_category_left_right,idx_data_id | idx_category_left_right | 5       | const                    | 8849 | Using where; Using temporary; Using filesort |</span><br><span class="line">|  1 | SIMPLE      | bu    | ref    | PRIMARY,idx_userid_status           | idx_userid_status       | 4       | meituancrm.oei.data_id   |   76 | Using where; Using index                     |</span><br><span class="line">|  1 | SIMPLE      | cb    | ref    | idx_branch_id,idx_contact_branch_id | idx_branch_id           | 4       | meituancrm.bu.branch_id  |    1 |                                              |</span><br><span class="line">|  1 | SIMPLE      | c     | eq_ref | PRIMARY                             | PRIMARY                 | 108     | meituancrm.cb.contact_id |    1 |                                              |</span><br><span class="line">+----+-------------+-------+--------+-------------------------------------+-------------------------+---------+--------------------------+------+----------------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从执行计划上看，mysql先查org_emp_info表扫描8849记录，再用索引idx_userid_status关联branch_user表，再用索引idx_branch_id关联contact_branch表，最后主键关联contact表。<br>rows返回的都非常少，看不到有什么异常情况。我们在看一下语句，发现后面有order by + limit组合，会不会是排序量太大搞的？于是我们简化SQL，去掉后面的order by 和 limit，看看到底用了多少记录来排序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   contact c  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   contact_branch cb </span><br><span class="line">      <span class="keyword">on</span>  c.id = cb.contact_id  </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">   branch_user bu </span><br><span class="line">      <span class="keyword">on</span>  cb.branch_id = bu.branch_id </span><br><span class="line">      <span class="keyword">and</span> bu.status <span class="keyword">in</span> (</span><br><span class="line">         <span class="number">1</span>,</span><br><span class="line">      <span class="number">2</span>)  </span><br><span class="line">   <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">      org_emp_info oei </span><br><span class="line">         <span class="keyword">on</span>  oei.data_id = bu.user_id </span><br><span class="line">         <span class="keyword">and</span> oei.node_left &gt;= <span class="number">2875</span> </span><br><span class="line">         <span class="keyword">and</span> oei.node_right &lt;= <span class="number">10802</span> </span><br><span class="line">         <span class="keyword">and</span> oei.org_category = - <span class="number">1</span>  </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------+</span><br><span class="line">| count(\*) |</span><br><span class="line">+----------+</span><br><span class="line">|   778878 |</span><br><span class="line">+----------+    </span><br><span class="line"></span><br><span class="line">1 row in set (5.19 sec)</span><br></pre></td></tr></table></figure>
<p>发现排序之前居然锁定了778878条记录，如果针对70万的结果集排序，将是灾难性的，怪不得这么慢，那我们能不能换个思路，先根据contact的created_time排序，再来join会不会比较快呢？<br>于是改造成下面的语句，也可以用straight_join来优化</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    c.id,</span><br><span class="line">    c.name,</span><br><span class="line">    c.position,</span><br><span class="line">    c.sex,</span><br><span class="line">    c.phone,</span><br><span class="line">    c.office_phone,</span><br><span class="line">    c.feature_info,</span><br><span class="line">    c.birthday,</span><br><span class="line">    c.creator_id,</span><br><span class="line">    c.is_keyperson,</span><br><span class="line">    c.giveup_reason,</span><br><span class="line">    c.status,</span><br><span class="line">    c.data_source,</span><br><span class="line">    from_unixtime(c.created_time) <span class="keyword">as</span> created_time,</span><br><span class="line">    from_unixtime(c.last_modified) <span class="keyword">as</span> last_modified,</span><br><span class="line">    c.last_modified_user_id</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    contact c</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">        <span class="number">1</span></span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">        contact_branch cb</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">        branch_user bu</span><br><span class="line">    <span class="keyword">on</span> cb.branch_id = bu.branch_id</span><br><span class="line">    <span class="keyword">and</span> bu.status <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">        org_emp_info oei</span><br><span class="line">    <span class="keyword">on</span> oei.data_id = bu.user_id</span><br><span class="line">    <span class="keyword">and</span> oei.node_left &gt;= <span class="number">2875</span></span><br><span class="line">    <span class="keyword">and</span> oei.node_right &lt;= <span class="number">10802</span></span><br><span class="line">    <span class="keyword">and</span> oei.org_category = - <span class="number">1</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        c.id = cb.contact_id</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">    c.created_time <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">0</span> ,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>验证一下效果 预计在1ms内，提升了13000多倍！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>本以为至此大工告成，但我们在前面的分析中漏了一个细节，先排序再join和先join再排序理论上开销是一样的，为何提升这么多是因为有一个limit！大致执行过程是：mysql先按索引排序得到前10条记录，然后再去join过滤，当发现不够10条的时候，再次去10条，再次join，这显然在内层join过滤的数据非常多的时候，将是灾难的，极端情况，内层一条数据都找不到，mysql还傻乎乎的每次取10条，几乎遍历了这个数据表！<br>用不同参数的SQL试验下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">   sql_no_cache   c.id,</span><br><span class="line">   c.name,</span><br><span class="line">   c.position,</span><br><span class="line">   c.sex,</span><br><span class="line">   c.phone,</span><br><span class="line">   c.office_phone,</span><br><span class="line">   c.feature_info,</span><br><span class="line">   c.birthday,</span><br><span class="line">   c.creator_id,</span><br><span class="line">   c.is_keyperson,</span><br><span class="line">   c.giveup_reason,</span><br><span class="line">   c.status,</span><br><span class="line">   c.data_source,</span><br><span class="line">   from_unixtime(c.created_time) <span class="keyword">as</span> created_time,</span><br><span class="line">   from_unixtime(c.last_modified) <span class="keyword">as</span> last_modified,</span><br><span class="line">   c.last_modified_user_id    </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   contact c   </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">   <span class="keyword">exists</span> (</span><br><span class="line">      <span class="keyword">select</span></span><br><span class="line">         <span class="number">1</span>        </span><br><span class="line">      <span class="keyword">from</span></span><br><span class="line">         contact_branch cb         </span><br><span class="line">      <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">         branch_user bu                     </span><br><span class="line">            <span class="keyword">on</span>  cb.branch_id = bu.branch_id                     </span><br><span class="line">            <span class="keyword">and</span> bu.status <span class="keyword">in</span> (</span><br><span class="line">               <span class="number">1</span>,</span><br><span class="line">            <span class="number">2</span>)                </span><br><span class="line">         <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">            org_emp_info oei                           </span><br><span class="line">               <span class="keyword">on</span>  oei.data_id = bu.user_id                           </span><br><span class="line">               <span class="keyword">and</span> oei.node_left &gt;= <span class="number">2875</span>                           </span><br><span class="line">               <span class="keyword">and</span> oei.node_right &lt;= <span class="number">2875</span>                           </span><br><span class="line">               <span class="keyword">and</span> oei.org_category = - <span class="number">1</span>                </span><br><span class="line">         <span class="keyword">where</span></span><br><span class="line">            c.id = cb.contact_id           </span><br><span class="line">      )        </span><br><span class="line">   <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">      c.created_time <span class="keyword">desc</span>  <span class="keyword">limit</span> <span class="number">0</span> ,</span><br><span class="line">      <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Empty set (2 min 18.99 sec)</span><br></pre></td></tr></table></figure>
<p>2 min 18.99 sec！比之前的情况还糟糕很多。由于mysql的nested loop机制，遇到这种情况，基本是无法优化的。这条语句最终也只能交给应用系统去优化自己的逻辑了。<br>通过这个例子我们可以看到，并不是所有语句都能优化，而往往我们优化时，由于SQL用例回归时落掉一些极端情况，会造成比原来还严重的后果。所以，第一：不要指望所有语句都能通过SQL优化，第二：不要过于自信，只针对具体case来优化，而忽略了更复杂的情况。</p>
<p>慢查询的案例就分析到这儿，以上只是一些比较典型的案例。我们在优化过程中遇到过超过1000行，涉及到16个表join的“垃圾SQL”，也遇到过线上线下数据库差异导致应用直接被慢查询拖死，也遇到过varchar等值比较没有写单引号，还遇到过笛卡尔积查询直接把从库搞死。再多的案例其实也只是一些经验的积累，如果我们熟悉查询优化器、索引的内部原理，那么分析这些案例就变得特别简单了。</p>
<h3 id="写在后面的话"><a href="#写在后面的话" class="headerlink" title="写在后面的话"></a>写在后面的话</h3><p>本文以一个慢查询案例引入了MySQL索引原理、优化慢查询的一些方法论;并针对遇到的典型案例做了详细的分析。其实做了这么长时间的语句优化后才发现，任何数据库层面的优化都抵不上应用系统的优化，同样是MySQL，可以用来支撑Google/FaceBook/Taobao应用，但可能连你的个人网站都撑不住。套用最近比较流行的话：“查询容易，优化不易，且写且珍惜！”</p>
<p>仅仅凭借这么一个例子就能写出漂亮的sql语句是不够的,平时自己还需要多多练习，在此推荐两本书籍:</p>
<ol>
<li>&lt;&lt;必知必会Mysql&gt;&gt;</li>
<li>&lt;&lt;高性能Mysql&gt;&gt;</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS源码分析</title>
    <url>/2020/11/20/sourcecode-of-AQS/</url>
    <content><![CDATA[<h3 id="如何看待AQS"><a href="#如何看待AQS" class="headerlink" title="如何看待AQS?"></a>如何看待AQS?</h3><p>看了Synchronized的实现方式之后，再来看JDK的AQS,感觉就比较简单了，它的行为有点像银行排队，银行有很多窗口处理很多业务，不同的窗口处理不同的业务，比如有个人业务，也有金融业务，也有公司业务等，每个窗口都有很多人排队。一般来讲当你在窗口处理业务的时候是不会有人来打扰你的，不一般的时候是什么时候呢？那就是资料分发窗口，谁来了都给你一张资料，一边看去吧。</p>
<p>而且当你去处理业务的时候，你可能有些资料忘记带了，然后你又要重新去取资料，取完之后回来继续排队。</p>
<p>所以说，代码源于生活，古人诚不欺我。</p>
<a id="more"></a>

<h3 id="带着问题看源码"><a href="#带着问题看源码" class="headerlink" title="带着问题看源码"></a>带着问题看源码</h3><ol>
<li>AQS中是如何实现线程阻塞的？</li>
<li>AQS为什么支持多个Condition？</li>
<li>线程唤醒的时候顺序是怎样的？</li>
</ol>
<p>带着问题去看源码比一猛子扎进源码的海洋好，所以我建议你带着这几个问题去看AQS源码。</p>
<h3 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h3><p>AQS是一个抽象类，很多类都是基于它来实现自己的特有的功能的，比如Lock,Semaphore,CountDownLatch等，我们都知道对于一个共享变量，为了线程安全，同一时刻肯定只能有一个线程线程可以写这个变量，也就是只有一个线程能拿到锁。那么那些没有拿到锁的线程是怎么被阻塞的呢？</p>
<p>AQS中维护了一个基于链表实现的FIFO队列(官方叫它CLH锁),那些没有获取到锁的线程会被封装后放入都在这个队列里面,我们来看下这个队列的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 共享模式</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 排它模式，默认</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前线程的一个等待状态,默认值为0</span></span><br><span class="line">   <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前一个节点</span></span><br><span class="line">  <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 后一个节点</span></span><br><span class="line">  <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队到这个节点的线程</span></span><br><span class="line">  <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下一个等待condition的节点或者是特殊的节点值: SHARED</span></span><br><span class="line">  Node nextWaiter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里共享模式和排它模式是什么意思呢？排它模式是表示同时只能有一个线程获取到锁执行，而共享模式表示可以同时有多个线程执行，比如Semaphore/CountDownLatch。</p>
<p>waitStatus除了默认值外还有三个值，分别代表不同的含义</p>
<ol>
<li>CANCELLED = 1 : 表示当前节点已经不能在获取锁了，当前节点由于超时或者中断而进入该状态，进入该状态的节点状态不会再发生变化，同时后续还会从队列中移除。</li>
<li>SIGNAL = -1 : 表示当前节点需要去唤醒后继节点。 后继节点入队时，会将当前节点的状态更新为SIGNAL</li>
<li>CONDITION = -2 : 当前节点处于条件队列中，当其他线程调用了condition.signal()后，节点会从条件队列转义到同步队列中</li>
<li>PROPAGATE = -3 ： 当共享锁释放的时候，这个状态会被传递到其他后继节点</li>
</ol>
<p><strong>其实原本的CLH队列是没有prev这个指针的，它存在的意义是那些取消锁获取的线程需要被移除掉。</strong></p>
<p>Synchronized的wait只能有一个条件队列(WaitSet)，而AQS则是支持多个条件队列,其中条件队列的关键数据结构如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// condition queue中的头节点</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// condition queue中的尾节点</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建一个新的condition</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 类似于Object的notify</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 类似于Object的wait</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>AQS支持多个Condition的原因就是每个ConditionObject都对应一个队列,所以它可以支持多个Condition。</p>
<p>如果多个线程请求同一把锁，有的线程阻塞在请求锁上面，有的锁阻塞到等待某个条件成立。 那么当持有锁的线程让出锁的时候，哪个线程应该获取到锁呢？</p>
<p>当获取了锁的线程调用了signal()时，它又会不会从条件队列(condition queue)中出队一个node,加入到同步队列中呢？答案是会的。</p>
<p>如果我说AQS分析完毕，你们会不会打我？</p>
<p>哈哈哈，各位放下键盘，扶我起来，我还能在水一会儿。</p>
<p>AQS中除了这两个类之外，还有AQS本身还有几个重要的属性，它们共同构成了AQS这个框架类的基础结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// wait queue(或者叫做同步队列)的头节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait queue(或者叫同步队列)的尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看到了head和tail，是不是一个双向链表的含义跃然纸上了。</p>
<p>AQS 中的state变量，对不同的子类有不同的含义，该变量对 ReentrantLock 来说表示加锁状态，对Semaphore来说则是信号量的数量。总之它们都是基于AQS中的state来实现各自独有功能的。</p>
<p>这里的state我觉得更应该叫做资源，就类似于去银行排队时取的票。对于ReentrantLock来说，这个资源只有1个，对于Semaphore或者CountDownLatch来说资源可以有很多个。</p>
<h3 id="Unsafe讲解"><a href="#Unsafe讲解" class="headerlink" title="Unsafe讲解"></a>Unsafe讲解</h3><p>unsafe是一个非常强大的类，通过它提供的API，我们可以操作内存，修改对象属性值，甚至内存屏障，加锁解锁都能通过它完成</p>
<p><img data-src="/images/java/meituan_safe.png" alt="unsafe"></p>
<blockquote>
<p>图片来自于: <a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html</a></p>
</blockquote>
<p>AQS中就使用了unsafe来实现线程的阻塞以及修改属性的值，这里把AQS中涉及到unsafe的方法列出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 阻塞当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁指定的线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字段的偏移地址</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Field f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAS更新对象的值为x,当现在的值是expected</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     Object expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     Object x)</span></span>;</span><br><span class="line"><span class="comment">// CAS更新</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> expected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>park和unpark的底层实现其实还是之前我们讲解过的pthread,这里不再讲解，感兴趣的可以去看看之前关于synchronized的文章。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">UNSAFE_ENTRY(<span class="keyword">void</span>, Unsafe_Park(JNIEnv *env, jobject unsafe, jboolean isAbsolute, jlong time))</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"> thread-&gt;parker()-&gt;park(isAbsolute != <span class="number">0</span>, time);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<p>修改对象的属性值，我们用一段代码来演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnSafeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span><br><span class="line">    theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Unsafe unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setAge(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> ageOffset = unsafe.objectFieldOffset(Student.class.getDeclaredField(&quot;age&quot;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cas修改student的age为20</span></span><br><span class="line">    unsafe.compareAndSwapInt(student, ageOffset, <span class="number">18</span>, <span class="number">20</span>);</span><br><span class="line">    System.out.println(student.getAge());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码的输出结果为 <code>20</code>,我们通过首先通过objectFieldOffset获取到age属性的内存偏移地址，然后通过compareAndSwapInt将age属性的值修改为20。</p>
<blockquote>
<p>比如对于一维数组a[10],基地址是0x000000,那么a[1]的内存地址就是0x000001 = 0x000000(基地址) + 1(偏移量)</p>
</blockquote>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>其他类如果要想将AQS作为基类以实现自己的功能，只需要根据需求实现以下方法就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试获取共享锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试释放共享锁</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锁是否被独占</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>AQS中获取锁的方法是在<code>acquire()</code>中，释放锁的方法是<code>release()</code>，如果我们想要实现自定义的锁的时候，只需要根据自己的需求实现对应的tryXXX方法就行了，为了简化分析，我们只分析独占锁的源码。</p>
<h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们假设tryAcquire返回false(不关心子类实现),也就是现在锁已经被其他线程占有了。现在又有线程来获取锁肯定是会获取失败的，所以失败的线程会被封装成Node插入到队列中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将nextWaiter设置为EXCLUSIVE，表示节点正以独占模式等待</span></span><br><span class="line">  Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">  Node pred = tail;</span><br><span class="line">  <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">      node.prev = pred;</span><br><span class="line">      <span class="comment">// CAS将tail节点更新为node</span></span><br><span class="line">      <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">          pred.next = node;</span><br><span class="line">          <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果执行到这里就存在两种情况</span></span><br><span class="line">  <span class="comment">// 1. pred == null,表示是第一次插入，当前同步队列中没有其他线程</span></span><br><span class="line">  <span class="comment">// 2. 表明有其他线程修改了tail的值,导致CAS修改tail失败</span></span><br><span class="line">  enq(node);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// CAS更新tail节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      Node t = tail;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 处理第一次插入的情况，这里head = new Node()</span></span><br><span class="line">      <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">              tail = head;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 处理竞争激烈的情况或者第一次插入后未建立链路关系的情况</span></span><br><span class="line">          node.prev = t;</span><br><span class="line">          <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">              t.next = node;</span><br><span class="line">              <span class="keyword">return</span> t;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面逻辑很简单，就是构造一个排它锁模式的node，插入队列中(尾插入)。</p>
<p>但是你尤其需要注意到enq中，当节点第一次插入的时候，head的值是new Node(),它是一个虚拟节点，这个节点本身没有可运行的线程。</p>
<blockquote>
<p>在链表中，使用这种虚拟节点很正常，有时候更加有利于操作。</p>
</blockquote>
<p>enq执行完成后就形成了这样的链路关系: </p>
<p><img data-src="/images/java/aqs-enq.png" alt="enq"></p>
<p>acquireQueued的源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1. 如果前一个节点是头节点，则尝试再次获取锁(机会更大)</span></span><br><span class="line">      <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">          setHead(node);</span><br><span class="line">          p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">          failed = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">return</span> interrupted;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 获取锁失败，需要检查并更新节点状态</span></span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">          interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 3. 如果线程被中断，需要将节点从队列中移除</span></span><br><span class="line">      <span class="keyword">if</span> (failed)</span><br><span class="line">          cancelAcquire(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑也比较简单明了，在线程被阻塞之前，如果前一个节点是头节点(head),那么在尝试去获取一次锁，如果成功了就直接返回。</p>
<p>如果还是失败的话，就更新下节点状态，然后将线程阻塞</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前置节点已经是SIGNAL了，可以放心的park了</span></span><br><span class="line">  <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果前置节点状态是CANCELLED,需要将节点移除</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">          node.prev = pred = pred.prev;</span><br><span class="line">      &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">      pred.next = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这就是我们之前说的在入队的时候，会通过CAS将前置节点的状态设置为SIGNAL</span></span><br><span class="line">      compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程阻塞的代码更简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用了unsafe的park阻塞当前线程</span></span><br><span class="line">  LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此，获取锁的源码就解析完成了。</p>
<p>从上面的代码，我们可以知道 <code>head --&gt; next --&gt; next --&gt; tail</code> 这样的数据结构组成了同步队列，等待获取锁的线程会被封装成node插入到队列中去。</p>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p>release()中主要调用了unparkSuccessor()方法来唤醒后继节点，源码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 传入的node是head节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 获取结点状态</span></span><br><span class="line">  <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 使用CAS更新waitStatus为默认值0</span></span><br><span class="line">  <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">      compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 通过循环找到后继节点中状态不为CANCELLED的节点</span></span><br><span class="line">  Node s = node.next;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      s = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">          <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">              s = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4. 调用unsafe解锁线程</span></span><br><span class="line">  <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">      LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之前提到过head节点是虚拟节点，所以会调用<code>unsafe.park</code>去解锁head.next节点</p>
<h4 id="条件变量-Condition"><a href="#条件变量-Condition" class="headerlink" title="条件变量(Condition)"></a>条件变量(Condition)</h4><p>Java 语言内置的管程(synchronized)里只有一个条件变量，而我们的AQS是支持多个条件变量的，Java中定义了一个接口，叫做Condition,AQS的内部类ConditionObject实现了这个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使得当前线程被阻塞，直到收到信号(signal)或者线程被中断</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 唤醒一个等待线程</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 唤醒所有的等待线程</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 省略其他方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Condition中线程等待和通知需要调用<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>，它们的语义和 <code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 是相同的。但是不一样的是，Condition里只能使用前面的 <code>await()</code>、<code>signal()</code>、<code>signalAll()</code>，而后面的 <code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 只有在 synchronized 实现的管程里才能使用。</p>
<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前线程构造成一个waiter节点，waitStatue的值为-2(CONDITION),将它插入到条件队列中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放持有的锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不在同步队列中，则阻塞当前线程</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在同步队列中，有可能被唤醒了，需要去重新获取锁。并处理中断逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node t = lastWaiter;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果lastWaiter不是出于condition状态，则需要移除掉</span></span><br><span class="line">  <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">      unlinkCancelledWaiters();</span><br><span class="line">      t = lastWaiter;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将当前线程构建为一个condition node</span></span><br><span class="line">  Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">  <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">      firstWaiter = node;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      t.nextWaiter = node;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改lastWaiter的指向</span></span><br><span class="line">  lastWaiter = node;</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>await()方法的逻辑也比较简单，其执行的主要流程如下</p>
<ol>
<li>如果当前线程已经被中断则抛出异常，未中断则执行步骤2</li>
<li>将当前线程构造为condition node，并插入到条件队列中</li>
<li>如果condition node不在同步队列中(有可能被唤醒后，移出条件队列了)，则调用unsafe.park阻塞当前线程</li>
</ol>
<p>通过以上代码分析，await之后条件队列会形成下面这样的数据结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstWaiter --&gt; nextWaiter --&gt; nextWaiter --&gt; lastWaiter</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的firsetWaiter并不是虚拟节点，当只有一个线程在条件队列中时，firstWaiter == node == lastWaiter</p>
</blockquote>
<h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取第一个等待节点，进行唤醒</span></span><br><span class="line">  Node first = firstWaiter;</span><br><span class="line">  <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">      doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 将节点从条件队列中移除</span></span><br><span class="line">      <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">          lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">      first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">           (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点从条件队列移动到同步队列</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// CAS修改waitStatus失败，就证明node处于CANCELLED状态</span></span><br><span class="line">  <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enq的源码上面上面获取锁有提到过，就是将节点插入同步队列并返回前置节点</span></span><br><span class="line">  Node p = enq(node);</span><br><span class="line">  <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">  <span class="comment">// 如果前置节点状态是CANCELLED或者修改waitStatus状态为SIGNAL失败，那么需要唤醒刚插入的节点</span></span><br><span class="line">  <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">      LockSupport.unpark(node.thread);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实signal的逻辑也是很简单的，不知道为什么写到signal的时候，我就想起了我当时写synchronized的时候，一样的索然无味，无欲无求。我想可能是没人给我点赞。</p>
<p>说回signal，它的主要逻辑如下</p>
<ol>
<li>将第一个等待节点从等待队列中移除</li>
<li>修改第一个等待节点的waitStatus为0</li>
<li>将节点入队到同步队列,并返回前一个节点</li>
<li>判断前一个节点是否处于CANCELLED或者waitStatus能否正常修改，如果不能则解锁刚入队的节点</li>
</ol>
<p>你需要注意的是，signal并没有释放自己获得的锁。释放锁的操作仍然是通过release的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过源码的分析，我相信你一定可以回答上之前的三个问题。也让我们知道了AQS和Synchronized其实内在实现方式是很类似的。</p>
<p>AQS中有同步队列和条件队列，signal的时候是将节点从条件队列转移到同步队列。<br>Synchronized中有EntryList和WaitSet。notify的时候将线程从WaitSet移动到EntryList中。</p>
<p>同样的，看源码我个人更喜欢沿着一条线去看，而不是大而全的看，这样更容易把控整个脉络。</p>
]]></content>
      <tags>
        <tag>多线程</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC源码分析</title>
    <url>/2018/08/13/springmvc-sourcecode-analysis/</url>
    <content><![CDATA[<h3 id="强大的DispatcherServlet"><a href="#强大的DispatcherServlet" class="headerlink" title="强大的DispatcherServlet"></a>强大的DispatcherServlet</h3><p>还记得在web.xml中配置的DispatcherServlet吗?其实那个就是SpringMVC框架的入口，这也是struts2和springmvc不同点之一，struts2是通过filter的，而springmvc是通过servlet的。看下servlet的结构图<br><img data-src="/images/dispatcherServlet_in_Spring.png" alt="结构图"><br><img data-src="/images/dispatcherServetl_diagram_in_spring.png" alt="类图"></p>
<p>从上面这张图很明显可以看出DispatcherServlet和Servlet以及Spring的关系。而我们今天的重点就从DispatchServlet说起。</p>
<p>在分析之前我用SpringBoot搭建了一个很简单的后台项目，用于分析。代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> generalthink</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/&#123;id&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(HttpServletRequest request,<span class="meta">@PathVariable</span> Integer id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个user,不走数据库只是为了分析springmvc源码</span></span><br><span class="line">User user = User.builder()</span><br><span class="line">.id(id)</span><br><span class="line">.age(ThreadLocalRandom.current().nextInt(<span class="number">30</span>))</span><br><span class="line">.name(<span class="string">&quot;zzz&quot;</span> + id)</span><br><span class="line">.address(<span class="string">&quot;成都市&quot;</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/condition&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getByNameOrAge</span><span class="params">(<span class="meta">@RequestParam</span> String name,<span class="meta">@RequestParam</span> Integer age)</span> </span>&#123;</span><br><span class="line">User user = User.builder().name(name).age(age).address(<span class="string">&quot;成都市&quot;</span>).id(<span class="number">2</span>).build();</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Integer id = user.getName().hashCode() - user.getAge().hashCode();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> id &gt; <span class="number">0</span> ? id : -id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里为了方便调试把关注点更多集中在SpringMVC源码中,所以这里的数据都是伪造的。而且这里的关注点也集中到使用注解的Controller(org.springframework.stereotype.Controller)，而不是Controller接口(org.springframework.web.servlet.mvc.Controller),这两者的区别主要在意一个只用标注注解，一个需要实现接口，但是它们都能完成处理请求的基本功能。我们都知道访问servlet的时候默认是访问service方法的，所以我们将断点打在HttpServlet的service方法中，此时查看整个调用栈如下<br><img data-src="/images/dispatcherServlet_invoke_stack.png" alt="调用栈"></p>
<p>从这里我们也知道了请求时如何从servlet到了DispatcherServlet的，我们先来看一下DispatcherServlet的doDiapatch的方法逻辑，这里把核心逻辑列出来了，把其他的一些非核心逻辑移除了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpServletRequest processedRequest = request;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意这里放回的是HandlerExecutionChain对象</span></span><br><span class="line">        HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">            ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">            Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//检查是否存在文件上传</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据当前request获取handler,handler中包含了请求url,以及最终定位到的controller以及controller中的方法</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过handler获取对应的适配器,主要完成参数解析</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用Controller中的方法</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        </span><br><span class="line">            processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到核心逻辑其实非常简单，首先检查是不是multipart request，如果是则对当前的request进行一定的封装(提取文件等），然后获取对应的handler(保存了请求url对应的controller以及method以及一系列的Interceptor),然后在通过handler获取到对应的handlerAdapter(参数组装)，通过它来进行最终方法的调用</p>
<h3 id="解析multipart"><a href="#解析multipart" class="headerlink" title="解析multipart"></a>解析multipart</h3><p>那么是如何解析当前请求是文件上传请求呢？这里直接进入到checkMultipart方法看看是如何解析的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我精简了下代码，只提取了核心逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HttpServletRequest <span class="title">checkMultipart</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> MultipartException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.multipartResolver != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.multipartResolver.isMultipart(request)) &#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.multipartResolver.resolveMultipart(request);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里可以看出通过multipartResolver判断当前请求是否是文件上传请求,如果是则返回MultipartHttpServletRequest(继承自HttpServletRequest).不是则返回原本request对象。<br>那么问题来了multipartResolver是什么时候初始化的呢？</p>
<p>我们在idea中可以直接将断点定位到multipartResolver属性上，进行请求访问这个时候会发现断点直接进入到了initMultipartResolver方法中，接着跟踪整个调用栈，可以发现调用关系如下：<br><img data-src="/images/init_mulitpartResovler_in_SpringMVC.png" alt="初始化multipartResovler"></p>
<p>图上表明了是在初始化servlet的时候对multipartResolver进行了初始化的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initMultipartResolver</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从Spring中获取id为multipartResolver的类</span></span><br><span class="line">    <span class="keyword">this</span>.multipartResolver = context.getBean(<span class="string">&quot;multipartResolver&quot;</span>, MultipartResolver.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MultipartResolver接口有CommonsMultipartResolver以及StandardServletMultipartResolver2种实现，CommonsMultipartResolver接口是依赖于commons-upload组件实现的，而 StandardServletMultipartResolver是依赖于Servlet的part(servlet3才存在)实现的.两者判断是否是文件上传请求的方法isMultipart均是通过判定请求方法是否为post以及content-type头是否包含multipart/来进行判定的。</p>
<h3 id="DispatchServlet初始化了哪些内容"><a href="#DispatchServlet初始化了哪些内容" class="headerlink" title="DispatchServlet初始化了哪些内容"></a>DispatchServlet初始化了哪些内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">   initMultipartResolver(context);  <span class="comment">//初始化multipartResolver</span></span><br><span class="line">   initLocaleResolver(context);<span class="comment">//初始化localeResolver</span></span><br><span class="line">   initThemeResolver(context);<span class="comment">//初始化themResolver</span></span><br><span class="line">   initHandlerMappings(context);<span class="comment">//初始化handerMappings</span></span><br><span class="line">   initHandlerAdapters(context);<span class="comment">//初始化handlerAdapters</span></span><br><span class="line">   initHandlerExceptionResolvers(context);</span><br><span class="line">   initRequestToViewNameTranslator(context);</span><br><span class="line">   initViewResolvers(context);<span class="comment">//初始化试图解析器</span></span><br><span class="line">   initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些初始化的内容都会在后面被逐一使用，这里先有一个印象。</p>
<h3 id="根据请求获取mapperHandler"><a href="#根据请求获取mapperHandler" class="headerlink" title="根据请求获取mapperHandler"></a>根据请求获取mapperHandler</h3><p>还是进入到getHander方法中看看到底做了什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">        HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据HandlerMapping来查看对应的handler,那么进入到initHandlerMappings方法中查看如何初始化handlerMappings</p>
<p><img data-src="/images/init_handlerMapping_in_springmvc.png" alt="初始化handlerMappings"></p>
<p>其中获取默认的handlerMappings是去spring-webmvc的org.springframework.web.servlet中的DispatcherServlet.properties中查找，文件内容是这样的</p>
<p><img data-src="/images/DispatcherServlet.properties.png" alt="DispatcherServlet.properties"><br>因为detechAllhanderMappings默认为true，所以会获取到所有HanderMapping的实现类，来看看它的类图结构是怎样的<br><img data-src="/images/handlerMapping_interface_structure_in_springmvc.png" alt="HandlerMapping类图"></p>
<p><img data-src="/images/this.handlerMappings_in_springmvc.png" alt="this.handlerMappings的值"></p>
<p>这几个HandlerMapping的作用如下：<br>SimpleUrlHandlerMapping : 允许明确指定URL模式和Handler的映射关系，内部维护了一个urlMap来确定url和handler的关系<br>BeanNameUrlHandlerMapping:  指定URL和bean名称的映射关系，不常用，我们的关注点也主要集中在RequestMappingHandlerMapping中</p>
<p>这里也基本明确了HandlerMapping的作用:帮助DispatcherServlet进行Web请求的URL到具体类的匹配,之所以称为HandlerMapping是因为在SpringMVC中并不局限于<br>必须使用注解的Controller我们也可以继承Controller接口，也同样可以使用第三方接口，比如Struts2中的Action<br><img data-src="/images/RequestMappingHandlerMapping.png" alt="RequestMappingHandlerMapping"></p>
<p>接着看下getHandler的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">         HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line">         <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handler;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回的handler是HandlerExecutionChain,这其中包含了真实的handler以及拦击器，可以在执行前,执行后，执行完成这三个阶段处理业务逻辑。<br>RequestMappingHandlerMapping的getHandler的调用逻辑如下：<br><img data-src="/images/handlerMapping_invoke_logic_in_springmvc.png" alt="调用逻辑"></p>
<p>会遍历所有Controller的url查看是否有符合条件的match(head,url,produce,consume，method都要满足要求),采用antMatcher的方式来进行url匹配，如果匹配上了则返回对应的handler，否则返回null,如果映射发现有重复的映射（url映射相同，请求方法相同，参数相同，请求头相同，consume相同，produce相同，自定义参数相同），则会抛出异常。</p>
<p>而SimpleUrlHandlerMapping的调用逻辑如下：<br><img data-src="/images/simple_url_handlerMapping_invoke_logic.png" alt="SimpleUrlHandlerMapping调用逻辑"></p>
<p>其中维护了url到handler的映射，先通过url到urlMap中找对应的handler，如果没有找到则尝试pattenMatch，成功则返回对应的handler,未匹配则返回null。</p>
<p>会发现处理HandlerMapping这里运用了模板方法，在抽象类中定义好了业务逻辑，具体实现只需要实现自己的业务逻辑即可。同时也符合开闭原则，完全是面向接口编程，不得不让人叹服这里的涉及逻辑。</p>
<p>分析到这里的时候我们会发现我们之前定义的Controller明显是符合RequestMappingHandlerMapping的策略的，所以返回的HandlerExecutionChain已经包含了需要访问的方法的全路径了。</p>
<h3 id="关于HandlerAdapter"><a href="#关于HandlerAdapter" class="headerlink" title="关于HandlerAdapter"></a>关于HandlerAdapter</h3><p>HandlerMapping会通过HandlerExecutionChain返回一个Object类型的Handler对象，用于Web请求处理，这里的Handler并没有限制具体是什么类型，一般来说任何类型的Handler都可以在<br>SpringMVC中使用，只要它是用于处理Web请求的处理对象就行。</p>
<p>不过对于DispatcherServlet来说就存在问题了，它无法判断到底使用的是什么类型的Handler，也无法知道是调用Handler的哪个方法来处理请求，为了以同意的方式来调用各种类型的Handler,<br>DispatcherServlet将不同Handler的调用职责转交给了一个成为HandlerAdapter的角色。</p>
<p>先看一下HandlerAdpter接口的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>主要关注supports和handle方法。先看下DispatcherServlet中handlerAdapters的初始化过程，和handlerMappings的初始化过程是类似的<br><img data-src="/images/init_handlerAdapters_in_springmvc.png" alt="初始化HandlerAdapters"></p>
<p>接着在看一下HandlerAdapter的类关系<br><img data-src="/images/handlerAdpater_class_diagram.png" alt="HandlerAdapter类图"></p>
<p>同样的，仍然通过合适的策略寻找对应的Adapter，我们主要关注的是RequestMappingHandlerAdapter(其他的用得很少)，所以这里就主要讲解它。查看它support的实现代码：<br><img data-src="/images/handler_adapter_supports_method.png" alt="supports方法"></p>
<p>在上面关于handler的说明中说了其实Object handler实际上是HandlerMethod，所以这里对应的HandlerAdapter就是RequestMappingHandlerAdapter。</p>
<p>找到对应的适配器之后，这个时候就可以调用真正的逻辑了。在这之前使用者可以通过拦截器做一些事儿，比如记录日志，打印执行时间等，所以如果想要在执行的方法之前添加一条语句，我们只需要配置自己的拦击器即可。<br><img data-src="/images/handlerInterceptors_invoke.png" alt="执行拦截器方法"></p>
<p>接下来我们重点分析handle方法，看看它到底会做什么？，先看一下handle方法的执行流程，同样的adapter同样使用了模板方法，先在父类里面定义流程，子类只需要实现逻辑即可，所以这里首先会调用AbstracthandlerMethodAdapter的invokeHadlerMethod方法，其中对HandlerMethod进行了封装。<br><img data-src="/images/invoke_handle_method.png" alt="invokeHandle"><br><img data-src="/images/invoke_and_handle.png" alt="invokeAndHandle"></p>
<p>我们进入到第一步，看看invokeForRequest方法中主要做了什么<br><img data-src="/images/invoke_for_request.png" alt="invokeForRequest"></p>
<p>发现这个方法的调用逻辑实际上很简单，就是解析参数，然后调用方法。我们来看一下如何进行参数解析的呢？<br><img data-src="/images/arguementResolver_resolve.png" alt="参数解析"></p>
<p>可以看到几乎所有的核心逻辑都集中到了argumentResovlers中去，那么支持的arguementResolver有哪些？又是在哪里初始化的呢？</p>
<p>首先需要定位到这个属性是从哪里过来的，RequestMappingHandlerAdapter实现了InitializingBean，所以在初始化的时候会执行afterPropertiesSet方法，在这其中对arguementResolvers以及returnValueHandlers进行了初始化。<br>不同的resovler支持的参数解析不一样，比如说有支持HttpServletRequest注入的，有支持HttpServletREsponse注入的还有支持body体注入的等等。<br><img data-src="/images/getDefaultArgumentResolver.png" alt="arguementResovler初始化"></p>
<p><img data-src="/images/init_return_value_handlers.png" alt="returnValueHandlers初始化"></p>
<p>经过参数解析之后就得到了反射需要的数据了,class,method以及参数，最后通过java的反射api调用即可。<br><img data-src="/images/invoke_true_method.png" alt="反射调用"></p>
<p>至此，springmvc的整个调用流程基本就清晰了。</p>
<p>但是到了这里问题仍然没有结束，因为我们还不知道参数具体是如何解析的。比如get方式提交的数据？post方式提交的数据？如何转换成对象的？这写问题都还存在，那我们继续研究。<br>这里我使用postman工具来发起请求，首先访问 Get <a href="http://localhost:8080/user/condition?name=zhangsan&amp;age=25,%E5%AE%9A%E4%BD%8D%E5%88%B0resolveArgument%E6%96%B9%E6%B3%95">http://localhost:8080/user/condition?name=zhangsan&amp;age=25,定位到resolveArgument方法</a><br><img data-src="/images/arguementResovler_resolve.png" alt="如何获取具体的arguementResolver"></p>
<p>接着又执行revolver.resolveArgument方法，同样的这里还是使用的模板方法，在抽象类AbstractNamedValueMethodArgumentResolver中定义流程，各个子类只需要实现自己的逻辑即可。RequestParamMethodArgumentResolver的参数就是通过request.getParameter来获取到的。获取到了参数之后就执行反射调用，这个时候就执行了我们写的UserController的对应方法，获取到了User对象，接下来就是处理返回值了，通过returnValueHandlers进行处理<br><img data-src="/images/handler_return_value.png" alt="处理返回值"></p>
<p>handler会根据返回的类型对数据进行处理，比如说这里就通过response向请求方输出数据，输出数据也是通过messageConverter来实现的<br><img data-src="/images/deal_result.png" alt="处理数据输出"></p>
<p>最后获取ModalAndView对象，但是这里由于没有modalAndView所以返回的null.最后在DispatcherServlet的processDispatchResult方法的调用逻辑如下<br><img data-src="/images/process_dispatcher_result.png" alt="最后的处理"></p>
<p>那么对于这样的请求又时如何解析的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">saveUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Integer id = user.getName().hashCode() - user.getAge().hashCode();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> id &gt; <span class="number">0</span> ? id : -id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同样我们聚焦在解析参数的时候，在上一个get请求的示例中我说了会先访问AbstractNamedValueMethodArgumentResolver，但是在处理@RequestBody的参数中它使用的是RequestResponseBodyMethodProcessor,它复写了resolveArgument方法。所以不会去执行父类的逻辑。<br><img data-src="/images/resolve_arguement_with_post_method.png" alt="参数解析"></p>
<p>这里最后会定位到jakson的objectMapper中， 在spring boot中，默认使用Jackson来实现java对象到json格式的序列化与反序列化。当然是可以配置messageConvert的，只需要实现Spring的HttpMessageConverter即可。</p>
<p>源码分析到这里就结束了，当然其中还存在一些没有讲的地方，比如View的渲染呀，一般视图是多种多样的，又html,xml,jsp等等，所以springmvc也提供了接口供用户选择自己需要的模板，只需要实现ViewResolver接口即可。还有关于Theme,MessageResource，Exception的处理等等，如果铺开来讲篇幅实在是太长了，我更相信掌握了核心流程看其他的处理就会很简单了，所以这里也就不对其他枝节内容做分析了。</p>
<h3 id="一图胜千言"><a href="#一图胜千言" class="headerlink" title="一图胜千言"></a>一图胜千言</h3><p><img data-src="/images/springmvc_process.png" alt="SpringMVC流程图"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Synchronized锁优化源码解析</title>
    <url>/2020/10/22/synchronized-source-code-analysis/</url>
    <content><![CDATA[<h3 id="模板解释器"><a href="#模板解释器" class="headerlink" title="模板解释器"></a>模板解释器</h3><p>我们都知道Java之所以可以一次编译到处运行，完全是因为字节码的原因，字节码就相当于中间层屏蔽了底层细节。但是想要在机器执行，最终还是要翻译成机器指令。</p>
<p>而JVM是通过C/C++来编写的,Java程序编译后，会产生很多字节码指令，每一个字节码指令在JVM底层执行的时候又会编程一堆C代码，这一堆C代码在编译之后又会编程很多的机器指令，这样我们的java代码到最终执行的机器指令那一层，所产生的机器指令时指数级的，这也就导致了Java执行效率低下。</p>
<p>早期的JVM是因为解释执行慢而被人诟病，那么有没有办法优化这个问题呢？我们发现之所以慢是因为java和机器指令之间隔了一层C/C++,而GCC之类的编译器又不能做到绝对的智能编译，所产生的机器码效率就不是很高。因此我们只要跳过C/C++这个层次，直接将Java字节码和本地机器码进行一个对应就可以了。</p>
<p>因此HotSpot的工程师们废弃了早期的解释执行器，而采用了模板执行器。所谓的模板就是将一个 java 字节码通过人工手动的方式编写为固定模式的机器指令，这部分不在需要 GCC 的帮助，这样就可以大大减少最终需要执行的机器指令，所以才能提高效率。</p>
<a id="more"></a>

<p>在OpenJdk12源码中，JVM所有的解释器都在<code>src/hotspot/share/interpreter </code>目录下，<code>templateInterpreter.cpp</code>就是模板解释器的代码位置。分析这里的initialize方法，我们可以在<code>templateTable.cpp</code>中找到和synchronized相关的两个指令(<code>monitorenter</code>,<code>monitorexit</code>)的实现方式，当然这里面还有其他我们熟悉的指令，比如<code>invokedynamic</code>,<code>newarray</code>等指令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">def(Bytecodes::_monitorenter, ____|disp|clvm|____, atos, vtos, monitorenter, _);</span><br><span class="line">def(Bytecodes::_monitorexit, ____|____|clvm|____, atos, vtos, monitorexit, _ );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="monitorenter执行逻辑"><a href="#monitorenter执行逻辑" class="headerlink" title="monitorenter执行逻辑"></a>monitorenter执行逻辑</h3><p>这里倒数第二个参数的<code>monitorenter</code>函数和<code>monitorexit</code>函数是对应字节码的机器码模板的位置，这里我们看下<code>monitorenter</code>的实现，因为机器码的实现和CPU相关的,这里我们看下x86的实现(<code>templateTable_x86.cpp</code>),当然也可以在<code>src/hotspot/cpu</code>下看到其他的实现，比如<code>ppc,arm,s390</code>等</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TemplateTable::monitorenter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// 将要锁的对象指针放到BasicObjectLock的obj变量中</span></span><br><span class="line">    <span class="function">__ <span class="title">movptr</span><span class="params">(Address(rmon, BasicObjectLock::obj_offset_in_bytes()), rax)</span></span>;</span><br><span class="line">    <span class="comment">// 跳转执行 lock_object 函数</span></span><br><span class="line">    <span class="function">__ <span class="title">lock_object</span><span class="params">(rmon)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InterpreterMacroAssembler::lock_object</span><span class="params">(Register lock_reg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果使用重量级锁，则直接进入monitorenter()执行</span></span><br><span class="line">  <span class="keyword">if</span> (UseHeavyMonitors) &#123;</span><br><span class="line">    call_VM(noreg,</span><br><span class="line">            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),</span><br><span class="line">            lock_reg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load object pointer into obj_reg</span></span><br><span class="line">    movptr(obj_reg, Address(lock_reg, obj_offset));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关于偏向锁的处理</span></span><br><span class="line">    <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">      <span class="comment">// lock_reg : 存储指向BasicObjectLock的指针</span></span><br><span class="line">      <span class="comment">// obj_reg : 存储锁对象的指针</span></span><br><span class="line">      <span class="comment">// slow_case : 标记，类似于goto,这里指的是InterpreterRuntime::monitorenter()</span></span><br><span class="line">      <span class="comment">// done: 标记，标志着获取锁成功。</span></span><br><span class="line">      <span class="comment">// slow_case 和 done 也被传入，这样在biased_locking_enter()中，就可以根据情况跳到这两处了。</span></span><br><span class="line">      biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp_reg, <span class="literal">false</span>, done, &amp;slow_case);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">   <span class="comment">// slow_case逻辑,需要进入InterpreterRuntime::monitorenter()中获取锁。</span></span><br><span class="line">    bind(slow_case);</span><br><span class="line">    <span class="comment">// Call the runtime routine for slow case</span></span><br><span class="line">    call_VM(noreg,</span><br><span class="line">            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),</span><br><span class="line">            lock_reg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的done和上面传入到偏向锁的done是一样的。直接跳到这表明获取锁成功，接下来就会返回进行字节码的执行了。</span></span><br><span class="line">    bind(done);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从代码可以看出如果启用了重量级锁，那么就直接走重量级锁的逻辑(monitorenter)，不然会先处理偏向锁的逻辑，然后不满足会再回到monitorenter中</p>
<blockquote>
<p>偏向锁: -XX:+UseBiasedLocking , JDK1.6之后默认启用<br>重量级锁: -XX:+UseHeavyMonitors</p>
</blockquote>
<h3 id="偏向锁-轻量级锁以及重量级锁"><a href="#偏向锁-轻量级锁以及重量级锁" class="headerlink" title="偏向锁,轻量级锁以及重量级锁"></a>偏向锁,轻量级锁以及重量级锁</h3><p>我们提到了重量级锁和偏向锁，这两个是什么意思呢？</p>
<p>我们都知道Java的线程是映射到操作系统的原生线程之上的，无论是是阻塞还是唤醒一个线程，都需要操作系统的帮助，这就需要从用户态转换到核心态中。而很多人说synchronized慢也正是由于这个原因。之前的文章也说过synchronized实际上是通过操作系统的互斥量来实现的，而这也被称为重量级锁。</p>
<p>相对于重量级锁，还有一个叫做轻量级锁。它的加锁不是通过操作系统来实现的，而是通过CAS配合Mark Word一起实现的，后面我会通过源码来展示它的实现方式。</p>
<p>而偏向锁相对于轻量级锁更加轻量，这里的偏向指的是偏向某一个线程。如果只有一个线程来获取锁，那么锁对象就会偏向这个线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<p>接下来我们沿着源码从 偏向锁–&gt;轻量级锁–&gt;重量级锁这样来分析下JVM是如何进行优化的。</p>
<h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>在分析锁实现之前,你可能要先去看看上一篇文章,看看对象在内存中的布局，这里我贴一张图让你在重温下</p>
<p><img data-src="/images/macos-jvm/mark-word-32-system.png" alt="未开启指针压缩"></p>
<h3 id="锁状态转化及对象Mark-Word的关系"><a href="#锁状态转化及对象Mark-Word的关系" class="headerlink" title="锁状态转化及对象Mark Word的关系"></a>锁状态转化及对象Mark Word的关系</h3><p>实际上锁的优化逻辑,在JDK中的wiki中已经有一个提纲挈领的图了，这里我先贴出来。后面的代码分析也会跟着这张图走。</p>
<p><img data-src="/images/macos-jvm/Synchronization.gif" alt="锁优化"></p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><h4 id="偏向锁的启动"><a href="#偏向锁的启动" class="headerlink" title="偏向锁的启动"></a>偏向锁的启动</h4><p>偏向锁会在虚拟机启动后的4秒之后才会生效，我们可以从<code>hotspot/share/runtime/biasedLocking.cpp</code>看到这样的设定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BiasedLocking::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="keyword">if</span> (BiasedLockingStartupDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      EnableBiasedLockingTask* task = <span class="keyword">new</span> EnableBiasedLockingTask(BiasedLockingStartupDelay);</span><br><span class="line">      task-&gt;enroll();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      VM_EnableBiasedLocking op(<span class="literal">false</span>);</span><br><span class="line">      VMThread::execute(&amp;op);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的task最终会调用这个方法，将锁对象的类的mark word的后三位设置为101</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enable_biased_locking</span><span class="params">(InstanceKlass* k)</span> </span>&#123;</span><br><span class="line">  k-&gt;set_prototype_header(markOopDesc::biased_locking_prototype());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>BiasedLockingStartupDelay</code>默认时间是4000毫秒，所以会在启动4s之后启动一个定时任务来设置开启偏向锁的设定。</p>
<p>我们可以通过<code>-XX:BiasedLockingStartupDelay=0</code>来设置马上启动偏向锁。这里也填了上一篇的一个坑。</p>
<blockquote>
<p>java -XX:+PrintFlagsFinal | grep BiasedLockingStartupDelay</p>
</blockquote>
<p>定时任务会调用<code>enable_biased_locking</code>方法,将锁对象的类的Mark Word的后三个字节设置为101,<strong>锁对象类的Mark Word被称为prototype_header</strong>,记住这个下面分析偏向锁的时候会用到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">MyObject obj = <span class="keyword">new</span> MyObject();</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">  </span><br><span class="line">  doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面Java代码中锁对象是obj,其所属类型是MyObject(obj是MyObject的一个实例)。而<code>prototype header</code>实际上就是MyObject的Mark Word。</p>
<h4 id="偏向锁申请"><a href="#偏向锁申请" class="headerlink" title="偏向锁申请"></a>偏向锁申请</h4><p><code>biased_locking_enter()</code>方法比较长，所以我们一段一段来分析。以下代码片段均来自于<code>hotspot/cpu/x86/macroAssembler_x86.cpp::biased_locking_enter</code>中。</p>
<ol>
<li>首先判断Mark Word中的后三位(是否偏向锁+锁标志位)的值是否为5,即是否为偏向锁状态，如果是则执行后面fast_enter的逻辑,如果不是则执行第2步</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Address <span class="title">mark_addr</span> <span class="params">(obj_reg, oopDesc::mark_offset_in_bytes())</span></span>;</span><br><span class="line"></span><br><span class="line">... 省略部分代码 ...</span><br><span class="line"></span><br><span class="line">Label cas_label;</span><br><span class="line"><span class="keyword">int</span> null_check_offset = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果swap_reg中没存mark_addr，那么就先将mark_addr存入swap_reg中。</span></span><br><span class="line"><span class="keyword">if</span> (!swap_reg_contains_mark) &#123;</span><br><span class="line">  null_check_offset = offset();</span><br><span class="line">  movptr(swap_reg, mark_addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将对象的mark_addr，即markOop指针移入tmp_reg中</span></span><br><span class="line">movptr(tmp_reg, swap_reg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将tmp_reg和biased_lock_mask_in_place(111)进行与操作,取出markOop中后三位，即(是否偏向锁+锁标志位)</span></span><br><span class="line">andptr(tmp_reg, markOopDesc::biased_lock_mask_in_place);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看Mark Word后三位是否为5(biased_lock_pattern为5,即101），如果不相等，则表明不为偏向锁状态,跳往cas_label。否则即为偏向锁状态。</span></span><br><span class="line">cmpptr(tmp_reg, markOopDesc::biased_lock_pattern);</span><br><span class="line">jcc(Assembler::notEqual, cas_label);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>判断锁对象Mark Word中是否包含当前线程地址,最后三位标志位是否相同，且epoch值和类的epoch值是否相等。如果都相同，那么当前线程持有该偏向锁，可以直接返回。不然执行第3步</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将类的prototype_header(Mark Word)加载到tmp_reg中</span></span><br><span class="line">load_prototype_header(tmp_reg, obj_reg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前线程地址和类的的prototype_header相或，这样得到的结果为(当前线程id + prototype_header中的(epoch + 分代年龄 + 偏向锁标志 + 锁标志位))</span></span><br><span class="line">orptr(tmp_reg, r15_thread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将上面计算得到的结果与锁对象的markOop进行异或,得到一个结果diff(相等的位被置为0)</span></span><br><span class="line">xorptr(tmp_reg, swap_reg);</span><br><span class="line">Register header_reg = tmp_reg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将header_reg中除了分代年龄之外的其他位取了出来，即将上面异或得到的结果中分代年龄给忽略掉。</span></span><br><span class="line">andptr(header_reg, ~((<span class="keyword">int</span>) markOopDesc::age_mask_in_place));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果除了分代年龄，对象的markOop和(当前线程地址+其他位)相等，那么上面与操作的结果应该为0，表明对象之前已经偏向当前线程,那么跳到done处，执行同步代码块中的代码</span></span><br><span class="line"><span class="comment">// 否则表明当前线程还不是偏向锁的持有者，会接着往下走。</span></span><br><span class="line">jcc(Assembler::equal, done);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是这里会得到一个异或结果header_reg，会在后面的步骤中使用到。</p>
<ol start="3">
<li>判断类对象是否支持偏向锁，如果不支持，则跳转到第6步执行移除偏向锁的逻辑。 如果支持则跳转到第4步执行</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">testptr(header_reg, markOopDesc::biased_lock_mask_in_place);</span><br><span class="line">jccb(Assembler::notZero, try_revoke_bias);</span><br></pre></td></tr></table></figure>

<p>header_reg中存储的是(当前线程id + prototype_header中的(epoch + 分代年龄 + 偏向锁标志 + 锁标志位)) 和 锁对象 Mark Word异或的结果，我们要查看后三位(biased_lock_mask_in_place的值是111)的结果是否为0，如果不为0，表示之前异或时锁对象的Mark Word后三位和对象所属类的后三位不一致,所以对象所属类不再支持偏向锁，此时需要跳转到try_revoke_bias进行移除偏向锁操作。</p>
<blockquote>
<p>这个testptr的实现实际上是获取第一个参数多少位的值。多少位是根据第二个参数的二进制长度来决定的。</p>
</blockquote>
<ol start="4">
<li>执行到这里表示锁对象以及类对象都支持偏向锁,但是并不是偏向的当前线程。所以接下来会判断异或结果中的epoch是否为0，如果为0，则跳转到第5步执行。如果不为0，则证明锁过期了,跳转到第7步执行重新偏向逻辑</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试锁对象的epoch值和锁对象类的epoch是否相等，如果不相等，则证明锁过期了，需要重新偏向</span></span><br><span class="line">testptr(header_reg, markOopDesc::epoch_mask_in_place);</span><br><span class="line">jccb(Assembler::notZero, try_rebias);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>表明锁对象还未偏向任何线程，则可以尝试去获取锁，使得对象偏向当前线程</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取出对象Mark Word中除线程地址之外的其他位</span></span><br><span class="line">andptr(swap_reg,</span><br><span class="line">       markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place | markOopDesc::epoch_mask_in_place);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将其他位移动至 tmp_reg</span></span><br><span class="line">movptr(tmp_reg, swap_reg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将其他位和当前线程进行或，构造成一个新的完整的Mark Word,存入tmp_reg中。新的Mark Word因为保存了当前线程地址，所以会偏向当前线程。</span></span><br><span class="line">orptr(tmp_reg, r15_thread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试利用CAS操作将新构成的Mark Word存入锁对象的mark_addr(Mark Word)，如果设置成功，则获取偏向锁成功。</span></span><br><span class="line"><span class="comment">// cmpxchgptr操作会强制将rax寄存器（swap_reg）中内容作为老数据，与第二个参数，在这里即mark_addr处的内容进行比较，如果相等，则将第一个参数的内容，即tmp_reg中的新数据，存入mark_addr。</span></span><br><span class="line">cmpxchgptr(tmp_reg, mark_addr); <span class="comment">// compare tmp_reg and swap_reg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面CAS操作失败的情况下，表明对象头中的markOop数据已经被篡改，即有其他线程已经获取到偏向锁，因为偏向锁不容许多个线程访问同一个锁对象，所以需要跳到slow_case(InterpreterRuntime::monitorenter)处，去撤销该对象的偏向锁，并进行锁升级。</span></span><br><span class="line"><span class="keyword">if</span> (slow_case != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  jcc(Assembler::notZero, *slow_case);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面CAS成功的情况下，直接就跳往done处，回去执行方法的字节码了。</span></span><br><span class="line">jmp(done);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>try_revoke_bias使用CAS操作，重置mark word。撤销偏向锁后后续所有操作都走轻量级锁的加锁过程</p>
<p>try_revoke_bias和try_rebias的代码定义也在biased_locking_enter中</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bind(try_revoke_bias);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的prototype_header中已经支持偏向锁的位了，即这个类的所有对象都不再支持偏向锁了，但是当前对象仍为偏向锁状态，所以我们需要重置下当前对象的markOop为无锁态。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将锁对象所属类的prototype_header送入tmp_reg。</span></span><br><span class="line">load_prototype_header(tmp_reg, obj_reg);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试用CAS操作，使对象的markOop重置为无锁态。这里是否失败无所谓，即使失败了，也表明其他线程已经移除了对象的偏向锁标志。</span></span><br><span class="line">cmpxchgptr(tmp_reg, mark_addr); </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>try_rebias就是将使得锁对象重新偏向当前线程，如果失败则走slow_case(InterpreterRuntime::monitorenter)进行偏向锁撤销逻辑</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bind(try_rebias);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将锁对象所属类的prototype_header送入tmp_reg。</span></span><br><span class="line">load_prototype_header(tmp_reg, obj_reg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前线程地址和类的的prototype header(Mark Word)相或，这样得到的结果为(当前线程id + prototype_header中的(epoch + 分代年龄 + 偏向锁标志 + 锁标志位))</span></span><br><span class="line">orptr(tmp_reg, r15_thread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试用CAS操作，成功表示重偏向加锁成功</span></span><br><span class="line">cmpxchgptr(tmp_reg, mark_addr); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果CAS失败，则表明Mark Word已经被其他线程更改，需要跳往slow_case进行撤销偏向锁，否则跳往done处，执行字节码。</span></span><br><span class="line"><span class="keyword">if</span> (slow_case != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  jcc(Assembler::notZero, *slow_case);</span><br><span class="line">&#125;</span><br><span class="line">jmp(done);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p><code>slow_case</code>(偏向锁的撤销)的逻辑是在<code>InterpreterRuntime::monitorente</code>r中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">IRT_END</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::fast_enter</span><span class="params">(Handle obj, BasicLock* lock,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::is_at_safepoint()) &#123;</span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      assert(!attempt_rebias, <span class="string">&quot;can not rebias toward VM thread&quot;</span>);</span><br><span class="line">      <span class="comment">// 移除偏向锁</span></span><br><span class="line">      BiasedLocking::revoke_at_safepoint(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!obj-&gt;mark()-&gt;has_bias_pattern(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  slow_enter(obj, lock, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BiasedLocking::revoke_and_rebias</code>也会再重试下看能否使用偏向锁，逻辑基本和上面分析的一致，你要是看了这里面的代码你还会发现如果你调用了<code>System.identityHashCode()</code>是会移除偏向锁的。</p>
<p>由于偏向锁的移除需要在全局安全点的时候执行,所以如果当有大量线程竞争同一个锁资源时，我们可以通过关闭偏向锁来调优系统性能。</p>
<p>接下来我们来看<code>revoke_at_safepoint</code>会做哪些事情</p>
<ol>
<li><code>update_heuristics()</code>方法会将类对象上revoke次数加1</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 增加revoke次数</span></span><br><span class="line"><span class="keyword">if</span> (revocation_count &lt;= BiasedLockingBulkRevokeThreshold) &#123;</span><br><span class="line">  revocation_count = k-&gt;atomic_incr_biased_lock_revocation_count();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果revoke次数等于BiasedLockingBulkRevokeThreshold(默认40)</span></span><br><span class="line"><span class="keyword">if</span> (revocation_count == BiasedLockingBulkRevokeThreshold) &#123;</span><br><span class="line">  <span class="keyword">return</span> HR_BULK_REVOKE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果revoke次数等于BiasedLockingBulkRebiasThreshold(默认20)</span></span><br><span class="line"><span class="keyword">if</span> (revocation_count == BiasedLockingBulkRebiasThreshold) &#123;</span><br><span class="line">  <span class="keyword">return</span> HR_BULK_REBIAS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> HR_SINGLE_REVOKE;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果撤销次数等于<code>BiasedLockingBulkRebiasThreshold</code>(默认20)，则认为类对象还可以重偏向，因此要做以下操作(bulk rebias)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (klass-&gt;prototype_header()-&gt;has_bias_pattern()) &#123;</span><br><span class="line">  <span class="keyword">int</span> prev_epoch = klass-&gt;prototype_header()-&gt;bias_epoch();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将类对象的prototype_header中的epoch值加1</span></span><br><span class="line">  klass-&gt;set_prototype_header(klass-&gt;prototype_header()-&gt;incr_bias_epoch());</span><br><span class="line">  <span class="keyword">int</span> cur_epoch = klass-&gt;prototype_header()-&gt;bias_epoch();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 遍历所有线程的栈，找到所有类对象的实例，将它们Mark Word中的epoch值加1</span></span><br><span class="line">  <span class="keyword">for</span> (; JavaThread *thr = jtiwh.next(); ) &#123;</span><br><span class="line">    GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(thr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cached_monitor_info-&gt;length(); i++) &#123;</span><br><span class="line">      MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);</span><br><span class="line">      oop owner = mon_info-&gt;owner();</span><br><span class="line">      markOop mark = owner-&gt;mark();</span><br><span class="line">      <span class="keyword">if</span> ((owner-&gt;klass() == k_o) &amp;&amp; mark-&gt;has_bias_pattern()) &#123;</span><br><span class="line">        assert(mark-&gt;bias_epoch() == prev_epoch || mark-&gt;bias_epoch() == cur_epoch, <span class="string">&quot;error in bias epoch adjustment&quot;</span>);</span><br><span class="line">        owner-&gt;set_mark(mark-&gt;set_bias_epoch(cur_epoch));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// At this point we&#x27;re done. All we have to do is potentially</span></span><br><span class="line"><span class="comment">// adjust the header of the given object to revoke its bias</span></span><br><span class="line">revoke_bias(o, attempt_rebias_of_object &amp;&amp; klass-&gt;prototype_header()-&gt;has_bias_pattern(), <span class="literal">true</span>, requesting_thread, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>在bulk rebias过程中，首先会将类对象的epoch值加1，然后遍历所有线程的栈，找到所有该类对象的实例，将它们的epoch值加1,最后会移除掉锁对象的偏向信息。</p>
<p>如果你想查看<code>bulk revoke bias</code>的过程以及结果，你可以使用 这个回答(<a href="https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock)%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81">https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock)中的代码</a></p>
<ol start="3">
<li>如果类对象的撤销次数等于<code>BiasedLockingBulkRevokeThreshold</code>，则认为类对象不合适使用偏向锁，因此要做bulk revoke</li>
</ol>
<p>代码和上面的类似，我就不贴出来了，主要做下面两件事情</p>
<ul>
<li>将类对象的prototype header设置为不可偏向状态</li>
<li>遍历所有线程的栈,找到所有类的实例，修改mark word的状态位为001以及对应的lock record,并将偏向锁修改为轻量级锁</li>
</ul>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的代码实现是在<code>slow_enter</code>方法里面</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectSynchronizer::slow_enter</span><span class="params">(Handle obj, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略其他代码。。。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否是无锁状态</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;is_neutral()) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接把mark保存到BasicLock对象的_displaced_header字段</span></span><br><span class="line">    lock-&gt;set_displaced_header(mark);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过CAS将mark word更新为指向BasicLock对象的指针，更新成功表示获得了轻量级锁</span></span><br><span class="line">    <span class="keyword">if</span> (mark == obj()-&gt;cas_set_mark((markOop) lock, mark)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicLock</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> markOop _displaced_header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断Mark Word是否是中立的，即Mark Word的最后三个字节的值是否为1(001),如果是中立的，则表示此时处于未锁定，且不可偏向。</p>
<p>因此首先会将锁对象的mark word放入到lock对象(这就是我们常说的Lock Record)的<code>displaced_header</code>属性中，然后使用CAS将对象的Mark Word更新为指向Lock Record的指针，如果更新成功，表示这个线程就拥有了该对象的锁。并且Mark Word的锁标志位(Mark Word的最后2bit)将转变为00,即表示此对象处于轻量级锁定状态。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>如果CAS更新失败，就会膨胀称为重量级锁了，锁标志的状态值也变成10，Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程也要进入阻塞状态。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ObjectSynchronizer::inflate(THREAD,</span><br><span class="line">                          obj(),</span><br><span class="line">                          inflate_cause_monitor_enter)-&gt;enter(THREAD);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>inflate主要是一些状态的判断，看注释还是比较容易理解的，我们重点看下enter函数中的执行逻辑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectMonitor::EnterI</span><span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 已经是锁的持有者直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (Self-&gt;is_lock_owned ((address)cur)) &#123;</span><br><span class="line">    assert(_recursions == <span class="number">0</span>, <span class="string">&quot;internal state error&quot;</span>);</span><br><span class="line">    _recursions = <span class="number">1</span>;</span><br><span class="line">    _owner = Self;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了避免昂贵的线程阻塞、唤醒等操作，会在进入阻塞状态前先自适应自旋</span></span><br><span class="line">  <span class="keyword">if</span> (TrySpin(Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    assert(_owner == Self, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">    assert(_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">    assert(((oop)(object()))-&gt;mark() == markOopDesc::encode(<span class="keyword">this</span>), <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">    Self-&gt;_Stalled = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在重量级锁的判定中，不会马上去申请锁，而是会先自适应自旋几次看能否获取到锁，如果不能再去申请锁。</p>
<blockquote>
<p>自适应的自旋锁,它会由前一次在同一个锁上的自旋时间以及锁的拥有者状态来决定,如果同一个锁上自旋刚获得,那么就认为这次也有很大几率获取到,就多自旋几次,如果对于某个锁说,自旋很少获取到,就认为没戏,就不自旋了,直接去挂起了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (TryLock(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">2</span>) &amp;&amp; _Responsible == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      Atomic::replace_if_null(Self, &amp;_Responsible);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// park self</span></span><br><span class="line">    <span class="keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">      TEVENT(Inflated enter - park TIMED);</span><br><span class="line">      Self-&gt;_ParkEvent-&gt;park((jlong) recheckInterval);</span><br><span class="line">     </span><br><span class="line">      recheckInterval *= <span class="number">8</span>;</span><br><span class="line">      <span class="keyword">if</span> (recheckInterval &gt; MAX_RECHECK_INTERVAL) &#123;</span><br><span class="line">        recheckInterval = MAX_RECHECK_INTERVAL;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TEVENT(Inflated enter - park UNTIMED);</span><br><span class="line">      Self-&gt;_ParkEvent-&gt;park();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TryLock(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后再去申请锁之前还要自旋(贼心不死)，最后没成功才会park当前线程，而park的实现就是我们之前文章提到过的pthread的实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void os::PlatformEvent::park() &#123;</span><br><span class="line">  ...</span><br><span class="line">  int status &#x3D; pthread_mutex_lock(_mutex);</span><br><span class="line">  ...</span><br><span class="line">  status &#x3D; pthread_cond_wait(_cond, _mutex);</span><br><span class="line">  ...</span><br><span class="line">  status &#x3D; pthread_mutex_unlock(_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自旋状态还带来另外一个副作用，那便是不公平的锁机制。处于阻塞状态的线程，并没有办法立刻竞争被释放的锁。然而，处于自旋状态的线程，则很有可能优先获得这把锁。</p>
<p>当线程获取到重量级锁之后就可以执行方法了，但是即使锁被释放之后也不会被恢复到最初的那种无锁状态了</p>
<h3 id="好消息和坏消息"><a href="#好消息和坏消息" class="headerlink" title="好消息和坏消息"></a>好消息和坏消息</h3><p>我们可以看到偏向锁非常之负责，为了支持偏向锁整个代码复杂度大幅度提升，而许多受益于偏向锁的应用程序都是早期Java集合api，比如HashTable,Vector等。</p>
<p>所以好消息是在JDK15就把偏向锁禁用了，并在以后删除它。</p>
<p>坏消息是现在大部分应用使用的都是JDK8,并且还会使用很多年。</p>
<h3 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h3><p>1.《深入理解JVM虚拟机》<br>2.《深入拆解Java虚拟机》<br>3. <a href="https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock">https://stackoverflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock</a><br>4. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.94.8487&amp;rep=rep1&amp;type=pdf">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.94.8487&amp;rep=rep1&amp;type=pdf</a><br>5. <a href="https://createchance.github.io/post/java-%E5%B9%B6%E5%8F%91%E4%B9%8B%E5%9F%BA%E7%9F%B3%E7%AF%87">https://createchance.github.io/post/java-并发之基石篇</a><br>6. <a href="https://zhuanlan.zhihu.com/p/34662715">https://zhuanlan.zhihu.com/p/34662715</a><br>7. <a href="https://www.zhihu.com/question/55075763">https://www.zhihu.com/question/55075763</a></p>
]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
