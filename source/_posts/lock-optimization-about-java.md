title: java中锁的优化
date: 2018-07-19 21:22:46
tags: 多线程
categories: [java,jvm]
description: 多线程编码中,我们常用到synchronized关键字,都知道它是加锁关键字，也或多或少听说过轻量级锁，重量级锁，偏向锁这些关键字，可是我们知道这些具体指的是什么吗？为了我们更优的使用，JVM团队在背后做了多少努力?
keywords: synchronized,jvm,偏向锁,轻量级锁,重量级锁
---

### 一切都始于线程(Thread)

线程是比进程更加轻量级的调度执行单位,线程的引入可以把一个进程的资源分配和执行调服分开，各个线程之间共享进程资源又可以独立调度，主流的操作系统都提供了线程实现，Java这提供了在不同硬件和不同操作系统平台上对线程操作的统一处理。

一般操作系统实现线程主要有3种方式：
1. 使用内核线程(直接由操作系统内核支持)实现,但是一般都是去使用内核线程的一种高级接口——轻量级进程
2. 使用用户线程(除了内核线程)实现
3. 使用用户线程加轻量级进程混合实现。

而java中的线程就是映射到一条轻量级进程中的,所以如果要阻塞或者唤醒一个线程都需要需要操作系统的支持,因为要从用户态转换到核心态中需要耗费很多的处理器时间，所以才有说法说synchronized是java中的一个重量级的操作。但是一来我们很少使用(保证线程安全处理synchronized关键字还有JUC包下提供的其他支持)，二来虚拟机本身也做了一些优化，而我们今天谈的就是锁的优化。

### synchronized你对我的代码做了什么?

我们都知道synchronized关键字经过编译之后会线程monitorenter和monitorexit这两个字节码指令,这个两个字节码都需要一个reference类型的参数来指明需要锁定和解锁的对象，而我们一般可以在代码块中指明需要加锁的对象或者在根据修饰的是实例方法还是类方法(static方法)来获取对应的对应实例或者Class对象来进行加锁。

既然是加锁，那么在加锁之前肯定要去获取锁，如果获取到了就把锁的计数器加1,释放锁就减去1，当计数器的值为0的时候就释放锁,monitorexit这个指令会在同步代码执行完毕的时候将计数器减去1。如果没有获取到锁，那么就要阻塞等待，知道对象锁被其他线程释放，在重新去竞争。

### 锁的优化

#### 自旋锁以及自适应自旋


在讲这两个锁之前我先讲一个小故事。

小明中午趁着休息时间去银行办事情，但是小明去的时候小明前面有人在办理业务，总不能看到有人办理就回去吧，这样不仅难得跑还浪费了中午的时间，小明决定多等一会儿，看看别人能不能办理完,但是也不能一直等呀，等久了下午上班就会迟到，会被领导批评的，于是小明决定给自己设定一个时间，暂且就为十分钟吧，后面十分钟到了前面还有人在办理，小明决定不等了先回去上班，明天再来。
第二天，小明又来了，但是前面还是有很多人，小明突然有点绝望，小明问了问旁边的哥们等了多久，他说他等了五分钟了，但是今天办理业务的速度比较快，都办了10个人了，刚说着就轮到他了。小明看了下顿时调整了自己的等待时间，觉得自己在多等下肯定能够办理业务了，然后小明就等呀等，想不到前面那个哥们不到一分钟就完事儿了，就轮到小明办理业务了，今天总算没有白跑一趟。

线程阻塞的时候是需要操作系统支持，从用户态切换到核心态的，这个操作给操作系统的并发性能带来了很大的压力(小明跑路很累)。而且很多时候共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和回复线程并不值得，所以我们就让请求锁的那个线程等一下不要放弃处理器的时间，也就是执行一个忙循环(自旋,相当于小明在业务大厅百无聊赖的玩手机,盯着业务办理情况)，但是不能等久了呀，等久了也是很耗费处理器资源的，所以就给自己设定了一个自旋的次数10次(默认)，如果操作了这个次数就挂起了。

后来JDK6中引入了自适应的自旋锁，它会由前一次在同一个锁上的自旋时间以及锁的拥有者状态来决定，如果同一个锁上自旋刚获得，那么就认为这次也有很大几率获取到，就多自旋几次，如果对于某个锁说，自旋很少获取到，就认为没戏，就不自旋了，直接去挂起了。

#### 锁的消除

锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是被检测到不可能存在数据共享竞争的情况的锁进行消除,锁消除的主要判断依据来源于逃逸分析的支持,如果判断在一段代码中，堆上的数据不会逃逸出去从而被其他线程访问到，那么就把他们当成栈数据对待，认为他们是私有的，自然就不用加锁了。比如下面这段代码

```java

public String appendString(String a,String b,String c) {

	StringBuffer sb = new StringBuffer();
	sb.append(a);
	sb.append(b);
	sb.append(c);

	return sb.toString();
}

```

我们都知道StringBuffer是线程安全的,在于它在方法上加了synchronized关键字，此时就持有sb这个对象上的锁了。这段代码就相当于被加了锁，但是我们发现sb作用域被限制在了appendString方法内部，sb的所有引用不会被外部线程访问到，因此这里虽然有锁，但是编译之后就会忽略所有的同步而执行了。

#### 锁的粗化

一般我们使用synchronized，总是推荐将关键字的作用范围限制得越来越小，只有数据竞争的实际范围才进行同步，这样是为了使得需要同步的操作数量尽可能小，其他线程也能尽快拿到锁。但是如果一段代码中反复的对同一个对象加锁，即使没有线程竞争，频繁的进行互斥操作也会导致资源的消耗。

因为如果虚拟机检测到了一段代码频繁的对一个对象加锁，就会将这个锁就行粗化，提升到最外围，比如下面这段代码：

```java
synchronized(stringBuffer) {
	stringBuffer.append(aStr);
	
}

synchronized(stringBuffer) {
	stringBuffer.append(bStr);
}

synchronized(stringBuffer) {
	stringBuffer.append(cStr);
	
}

```

那么此时jvm会将代码优化成下面这样


```java
synchronized(stringBuffer) {
	stringBuffer.append(aStr);
	stringBuffer.append(bStr);
	stringBuffer.append(cStr);
}

```

在讲下面这三个锁之前，需得从jvm的对象头说起，对象头分为两部分，第一部分存储hash码(hashcode),GC分代年龄等,这部分数据的长度在32位系统和64位系统分别为32位和64位,官方称其为“Mark Word",它们是实现偏向锁和轻量级锁的关键。另一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度。

对象头信息与对象自定义的数据无关的额外存储成本，考虑虚拟机的空间效率，Mark Word被设计成一个非固定的的数据结构以便在极小的空间存储更多的信息，它会根据对象的状态复用自己的存储空间。

那么从哪里可以看到这些信息呢？有问题当然看源码，从github上jdk的源码[源码](https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/oops/markOop.hpp#L38)

整理下，这里在内存中的布局如下：

![32位系统mark word](/images/mark_word.png)
上图表明了MarkWord在不同状态下的存储内容，当然上面这是32位系统的，如果是64位基本上是大同小异，

#### 偏向锁

当线程A进入临界区准备执行代码的时候，jvm发现此时只有一个线程在执行临界区代码所以此时会将是否偏向锁的标志位修改为1，
然后记录下当前线程的地址(注意这里不是线程id，很多书上都写错了)，表示当前的锁是偏向这个线程的

#### 轻量级锁

如果此时又有另外一个线程B需要进入临界区执行代码，但是此时锁对象的Mark Word中是偏向线程A的，这个时候线程B是不能进入临界区。
此时会将锁对象修改为无锁状态，然后在各自的栈分配一个空间，叫做Lock Record,把锁对象的Mark Word在A,B两个线程各自复制一份，叫做Displaced Mard Word.
然后将Lock Record的地址使用CAS放到了Mark Word中，并且将锁标志位修改为00，哪个线程修改成功，就代表获取到了锁，可以进入临界区。没有获得锁的线程自旋几次等待其他线程释放锁。


#### 重量级锁
A,B线程执行，相安无事，即便哪一个获取到了锁也很快就会让出来，另外一个不会等待太久，但是有一天，某个线程自旋了很多次还是没有获取到锁，这个时候就需要操作系统的帮助，这个将轻量级锁升级为重量级锁，同时将标志位修改为10，阻塞其他未获取到锁的线程。

### 总结

java对于锁的优化是自动的，不需要我们做什么，编译器在编译的时候会分析代码对代码进行优化。

JVM中关于锁的优化大抵如是了，其实synchronized并不比lock慢多少，甚至在某些方面可能还比lock快，而且JDK8中ConcurrentHashMap也将之前的分段锁改为了Synchronized实现。




