<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhu.Yang</title>
  <icon>http://yoursite.com/icon.png</icon>
  <subtitle>朱阳的个人博客(公众号:think123)</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2024-11-13T02:21:33.042Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zhu.Yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql-index-optimize-method</title>
    <link href="http://yoursite.com/2024/09/23/mysql-index-optimize-method/"/>
    <id>http://yoursite.com/2024/09/23/mysql-index-optimize-method/</id>
    <published>2024-09-23T02:03:44.000Z</published>
    <updated>2024-11-13T02:21:33.042Z</updated>
    
    <content type="html"><![CDATA[<p>·</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;·&lt;/p&gt;
</summary>
        
      
    
    
    
    
    <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
    <category term="索引优化" scheme="http://yoursite.com/tags/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/"/>
    
    <category term="join" scheme="http://yoursite.com/tags/join/"/>
    
    <category term="explain" scheme="http://yoursite.com/tags/explain/"/>
    
  </entry>
  
  <entry>
    <title>工作8年,你就是这样记日志的？</title>
    <link href="http://yoursite.com/2024/09/19/how-to-record-log/"/>
    <id>http://yoursite.com/2024/09/19/how-to-record-log/</id>
    <published>2024-09-19T09:05:40.000Z</published>
    <updated>2024-11-13T02:21:33.038Z</updated>
    
    <content type="html"><![CDATA[<p>平常在写代码的过程中,我们经常需要记录日志,具体的日志实现我们可以使用logback, log4j, log4j2等。 但是一般我们会通过日志门面来记录日志，比如通过SLF4J或者apache commons logging。 无论使用哪种方式记录日志都不在我们这篇文章的讨论范围内。</p><p>如果你对它们如何找到真正的日志实现感兴趣，可以看看我<a href="https://juejin.cn/post/6844903936780926989">之前的文章</a>。</p><h3 id="日志怎么记录"><a href="#日志怎么记录" class="headerlink" title="日志怎么记录"></a>日志怎么记录</h3><p>日志分为6种，每种级别实际上有不同的应对场景，但是说实话我在项目中看到最多的永远是INFO, ERROR级别。</p><p>几乎没有怎么见到业务系统中有其他级别。 DEBUG的日志在集成的各个框架中是比较多见的。</p><p>日志应该是帮助我们定位问题的，所以日志怎么记录其实很关键。</p><a id="more"></a><h3 id="DEBUG日志"><a href="#DEBUG日志" class="headerlink" title="DEBUG日志"></a>DEBUG日志</h3><h4 id="开源框架如何使用"><a href="#开源框架如何使用" class="headerlink" title="开源框架如何使用"></a>开源框架如何使用</h4><p>哪里应该记录debug日志呢？ 我们先看看开源框架中哪里地方会打印DEBUG日志，我们学习下。</p><p>项目中使用了Nacos,在加载nacos配置的变量的时候，会把加载到的Nacos的数据打印出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.cloud.nacos.client.NacosPropertySourceBuilder#loadNacosData#92</span></span><br><span class="line"><span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(String.format(</span><br><span class="line">            <span class="string">&quot;Loading nacos data, dataId: &#x27;%s&#x27;, group: &#x27;%s&#x27;, data: %s&quot;</span>, dataId,</span><br><span class="line">            group, data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到这里使用的是debug日志。  一般而言我们的配置基本上都是配置到nacos中的，比如数据库连接信息，openfeign配置信息，还有其他一些变量，所以这里的数据打印出来应该是比较多的。 像这种日志打印出来也更多只是为了验证下我们的配置是否正确或者帮助我们调试。</p><p>所以这里我们使用debug级别日志来打印信息。</p><p>再来看看Spring中哪些地方用到了debug日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition#1014</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Overriding bean definition for bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                    <span class="string">&quot;&#x27; with a different definition: replacing [&quot;</span> + existingDefinition +</span><br><span class="line">                    <span class="string">&quot;] with [&quot;</span> + beanDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当我们注册BeanDefinition的时候，如果有相同的,这时候会把旧的替换掉，所以这里会打上一个debug日志。 当想要排查之前的Bean是怎样被替换的，这时候只需要开启日志级别是DEBUG，我们就能清晰的知道Bean是被那个Defeinition替换掉的了。</p><p>这里为什么不记录INFO日志呢？ 我个人理解是因为注册BeanDefinition这个行为如果产生了replace行为,那么一定是使用者控制的，框架不会产生重复的BeanDefinition, 那么既然是使用者自己行为,所以这里替换掉原有的就很合理，但是又为了让用户知道框架的具体行为(是替换还是忽略),所以这里加了一个debug日志。</p><h4 id="业务系统如何记录"><a href="#业务系统如何记录" class="headerlink" title="业务系统如何记录"></a>业务系统如何记录</h4><p>在业务开发中我们主要是和参数打各种交道,比如我们接收到前端一个大参数的时候,我们需要对这个参数进行各种转换和计算之后保存到数据库。这个时候我建议记录下DEBUG日志。 </p><p>有时候业务逻辑依赖这个参数进行运算，但是有时候得到的结果又和我们需要的不一致，所以这时候就需要排查下前端是否处理的不准确，或者计算逻辑是否不正确。 这个时候把参数打印出来我们就可以复现这个问题。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.debug(<span class="string">&quot;save param is &#123;&#125;&quot;</span>, JSON.toJSONString(param));</span><br></pre></td></tr></table></figure><p>这里打印的时候我建议打印出json字符串,因为我们拿到这个字符串后可以在本地进行调试。当然由于这个字符串很大,这也是我们设置成debug级别的原因之一,至少不要让日志成为制约系统响应速度的罪魁祸首。</p><h3 id="INFO日志"><a href="#INFO日志" class="headerlink" title="INFO日志"></a>INFO日志</h3><h4 id="开源框架如何使用-1"><a href="#开源框架如何使用-1" class="headerlink" title="开源框架如何使用"></a>开源框架如何使用</h4><p>同样是nacos,在进行服务注册的时候如果注册成功，会输出一条注册完成的日志。从这个日志我们可以知道哪个服务注册成功了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.cloud.nacos.registry.NacosServiceRegistry:register#75</span></span><br><span class="line">log.info(<span class="string">&quot;nacos registry, &#123;&#125; &#123;&#125; &#123;&#125;:&#123;&#125; register finished&quot;</span>, group, serviceId,</span><br><span class="line">                    instance.getIp(), instance.getPort());</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从这里可以看到使用INFO日志,是记录一个比较重要的时刻,我们打印出必要的消息，证明已经跑过了一个重要的节点。</p><p>同样的在Spring初始化ServletContext的时候也打印了INFO日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#prepareWebApplicationContext#288</span></span><br><span class="line">setServletContext(servletContext);</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - getStartupDate();</span><br><span class="line">                logger.info(<span class="string">&quot;Root WebApplicationContext: initialization completed in &quot;</span> + elapsedTime + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从这里我们可以看出来测试Spring框架运行到了一个重要的节点,又打印出了一些必要的信息：初始化的时间。</p><h4 id="业务系统如何记录-1"><a href="#业务系统如何记录-1" class="headerlink" title="业务系统如何记录"></a>业务系统如何记录</h4><p>我们一般会在一些重要的节点进行日志记录,比如在邮件模板系统中,当我们找到需要处理的模板的时候,我记录了这样的一条日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;find templates by rule,templateNames=&#123;&#125;, serviceLineId=&#123;&#125;, companyId=&#123;&#125;, triggerEventId=&#123;&#125;&quot;</span>,</span><br><span class="line">                emailTemplateList.stream().map(EmailTemplate::getTemplateName).collect(Collectors.joining(<span class="string">&quot;;&quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>)),</span><br><span class="line">                dto.getServiceLineId(), dto.getCompanyId(), dto.getTriggerEventId()</span><br><span class="line">        );</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这条日志记录了我根据参数找到了哪些需要被处理的模板。后面当我看日志的时候我就知道根据下游系统的参数定位到了哪些模板来处理</p><h3 id="WARN日志"><a href="#WARN日志" class="headerlink" title="WARN日志"></a>WARN日志</h3><h4 id="开源框架如何使用-2"><a href="#开源框架如何使用-2" class="headerlink" title="开源框架如何使用"></a>开源框架如何使用</h4><p>同样的，在Nacos中如果未加载到nacos的配置信息的时候，这里使用了warn日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.cloud.nacos.client.NacosPropertySourceBuilder#loadNacosData#86</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(data)) &#123;</span><br><span class="line">    log.warn(</span><br><span class="line">            <span class="string">&quot;Ignore the empty nacos configuration and get it based on dataId[&#123;&#125;] &amp; group[&#123;&#125;]&quot;</span>,</span><br><span class="line">            dataId, group);</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为什么不使用ERROR其他类型的日志呢？ 其实是因为加载不到配置信息不影响系统的运行,但是你用了nacos又加载不到，就很奇怪。</p><p>所以这里使用了warn级别日志，而不是ERROR或者其他级别日志。 </p><h4 id="业务系统如何记录-2"><a href="#业务系统如何记录-2" class="headerlink" title="业务系统如何记录"></a>业务系统如何记录</h4><p>warn是一个警告，证明了这个信息不影响业务继续运行,但是会对业务使用有一定影响。比如我们列表查询需要展示业务单独的操作人,根据单据存储的userId获取userName进行展示, 需要去用户服务中取,但是由于下游系统挂了或者这个用户被删除了， 我们取不到这个用户了。</p><p>那整个列表就不展示了吗？ 当然不行,顶多是某行数据的user name不展示就行了。 这种情况下,我们需要记录下warn日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略业务代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;user not exists, userId=&#123;&#125;&quot;</span>, id);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ERROR日志"><a href="#ERROR日志" class="headerlink" title="ERROR日志"></a>ERROR日志</h3><h4 id="开源框架如何使用-3"><a href="#开源框架如何使用-3" class="headerlink" title="开源框架如何使用"></a>开源框架如何使用</h4><p>同样还是nacos加载数据失败的场景，这里就打印了通过哪个dataId加载数据的时候失败，并打印了异常。<br>但是因为nacos加载数据失败并不会影响程序的继续运行，所以这里这是打印了日志，并没有抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;PropertySource&lt;?&gt;&gt; loadNacosData(String dataId, String group,</span><br><span class="line">        String fileExtension) &#123;</span><br><span class="line">    <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;get data from Nacos error,dataId:&#123;&#125; &quot;</span>, dataId, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;parse data from Nacos error,dataId:&#123;&#125;,data:&#123;&#125;&quot;</span>, dataId, data, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而在Spring初始化ServletContext的时候如果失败了是会打印error日志，并抛出异常的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">        setServletContext(servletContext);</span><br><span class="line">        <span class="comment">// 省略其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Context initialization failed&quot;</span>, ex);</span><br><span class="line">        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里不仅仅记录了错误日志，而且还抛出了异常，而这个异常会直接让我们的应用程序崩溃，这很合理，因为servlet初始化失败，就代表我们的容器启动失败，所以这里就需要住址程序继续往下运行。</p><h4 id="业务系统如何记录-3"><a href="#业务系统如何记录-3" class="headerlink" title="业务系统如何记录"></a>业务系统如何记录</h4><p>业务系统中如果我们捕获了某些异常，然后需要记录错误日志，比如我们发送测试邮件失败。但是又因为发送邮件不是一个必须行为，所以我们并不抛出异常，而是可以继续执行后续逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       remoteNotiService.sendContent(email);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       log.error(LogUtil.format(<span class="string">&quot;send email failure, toList=&#123;&#125;, subject=&#123;&#125;&quot;</span>, toList, subject), e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然如果你在系统中捕获的非业务异常,那么一般都是记录日志，然后抛出异常的。</p><h3 id="添加traceId"><a href="#添加traceId" class="headerlink" title="添加traceId"></a>添加traceId</h3><p>最后无论现在你们是否有完整的日志体系，我都建议你把traceId加入到你的日志中,因为你可以通过traceId拉到某一次请求所有的日志，能很好的帮助你过滤掉无关日志。 关于traceId的添加可以参考我<a href="https://juejin.cn/post/6949073119852101663">之前的文章</a></p><p>虽然有了traceId,但是我还是建议你记录日志的文本要是唯一的,这样你根据日志搜索的时候可以直接定位到是哪一段代码。</p><p>当然我这里还推荐给你了另外一种方式,如果你使用了spring cloud, 那你可以使用sleuth来添加traceId。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时你只需要在你spring cloud的gateway中添加一个filter即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceIdFilter</span>  <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">        HttpHeaders httpHeaders = response.getHeaders();</span><br><span class="line">        httpHeaders.add(<span class="string">&quot;X-Trace-Id&quot;</span>, MDC.get(<span class="string">&quot;traceId&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange.mutate().response(response).build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里是从MDC(slf4j)中获取的，因为sleuth会将这个值放到MDC中，我们直接从里面获取就行了。</p><p>当然你可以直接注入<code>org.springframework.cloud.sleuth.Tracer</code>,然后这样获取traceId也可以使用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracer.currentSpan().context().traceId();</span><br></pre></td></tr></table></figure><p>然后在logback的配置文件的log pattern中加上traceId,这里我给出我的log pattern</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;log.pattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%d&#123;HH:mm:ss.SSS&#125;-[%thread]-[traceId=%X&#123;traceId&#125;,spanId=%X&#123;spanId&#125;]-%-5level-%logger&#123;20&#125;-[%method,%line]-%msg%n&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这样子打印出来的日志就会有traceId了，然后返回给前端的header里面也带有traceId了。而且因为引入了sleuth,所以它只天然支持openfeign的，你就不用再去写Inteceptor了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我上面特意忽略了trace和fatal这两个级别，这两个实在不常用,不过你可以根据你的实际情况来使用，这里我也把各个级别的使用场景总结了下。</p><h4 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h4><ul><li>用于记录程序执行的细节信息,提供最详细的日志信息。</li><li>通常用于调试和问题分析,在正常运行时可以被禁用以减少日志输出。</li></ul><h4 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h4><ul><li>用于记录程序执行的详细信息,有助于开发和调试。</li><li>通常在开发和测试环境中使用,在生产环境中可以被禁用以减少日志输出。</li></ul><h4 id="INFO"><a href="#INFO" class="headerlink" title="INFO"></a>INFO</h4><ul><li>用于记录程序执行的重要信息,如关键事件、状态变更等。</li><li>通常在生产环境中使用,提供程序运行的概况信息。</li></ul><h4 id="WARN"><a href="#WARN" class="headerlink" title="WARN"></a>WARN</h4><ul><li>用于记录程序执行中出现的潜在问题,但不会导致程序崩溃。</li><li>通常用于记录一些可能会影响程序正常运行的情况,如资源耗尽、配置错误等。</li></ul><h4 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h4><ul><li>用于记录程序执行中出现的错误信息,可能会导致程序崩溃或无法正常运行。</li><li>通常用于记录严重的问题,如异常、错误代码、系统故障等。</li></ul><h4 id="FATAL"><a href="#FATAL" class="headerlink" title="FATAL"></a>FATAL</h4><ul><li>用于记录程序执行中出现的严重错误,导致程序无法继续运行。</li><li>通常用于记录程序无法恢复的致命错误,如系统崩溃、资源耗尽等。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;平常在写代码的过程中,我们经常需要记录日志,具体的日志实现我们可以使用logback, log4j, log4j2等。 但是一般我们会通过日志门面来记录日志，比如通过SLF4J或者apache commons logging。 无论使用哪种方式记录日志都不在我们这篇文章的讨论范围内。&lt;/p&gt;
&lt;p&gt;如果你对它们如何找到真正的日志实现感兴趣，可以看看我&lt;a href=&quot;https://juejin.cn/post/6844903936780926989&quot;&gt;之前的文章&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;日志怎么记录&quot;&gt;&lt;a href=&quot;#日志怎么记录&quot; class=&quot;headerlink&quot; title=&quot;日志怎么记录&quot;&gt;&lt;/a&gt;日志怎么记录&lt;/h3&gt;&lt;p&gt;日志分为6种，每种级别实际上有不同的应对场景，但是说实话我在项目中看到最多的永远是INFO, ERROR级别。&lt;/p&gt;
&lt;p&gt;几乎没有怎么见到业务系统中有其他级别。 DEBUG的日志在集成的各个框架中是比较多见的。&lt;/p&gt;
&lt;p&gt;日志应该是帮助我们定位问题的，所以日志怎么记录其实很关键。&lt;/p&gt;</summary>
    
    
    
    
    <category term="log" scheme="http://yoursite.com/tags/log/"/>
    
    <category term="traceId" scheme="http://yoursite.com/tags/traceId/"/>
    
    <category term="logback" scheme="http://yoursite.com/tags/logback/"/>
    
    <category term="slf4j" scheme="http://yoursite.com/tags/slf4j/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot中使用profile的几种方式</title>
    <link href="http://yoursite.com/2024/06/05/multi-profile-in-springboot/"/>
    <id>http://yoursite.com/2024/06/05/multi-profile-in-springboot/</id>
    <published>2024-06-05T01:58:23.000Z</published>
    <updated>2024-11-13T02:21:33.042Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目中进行仓库拆分了之后,因为引入了公共包,所以就存在可能有snapshot版本以及release版本问题,比如我想要在dev环境的时候import snapshot版本,prod环境的时候又使用release版本，为了不频繁修改pom.xml文件，因此决定使用POM的profile来解决这个问题。 </p><p>当然由于maven默认是不下载snapshot包的，因此我们要配置让它下载，这里分为全局配置和项目级别配置</p><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>在pom文件中添加如下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--修改成自己私服地址--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:18081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--主要是这里--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>在maven的settings.xml中新增配置,如果不配置profile，只配置mirror,是下载不了snapshot包的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>bv-profile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:18081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回到正题，如何使用maven的profile呢？</p><h3 id="maven-profile"><a href="#maven-profile" class="headerlink" title="maven profile"></a>maven profile</h3><p>同样的首先在pom.xml中新增配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">spring.profiles.active</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">spring.profiles.active</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bvpro.api.version</span>&gt;</span>2.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">bvpro.api.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">spring.profiles.active</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">spring.profiles.active</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bvpro.api.version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">bvpro.api.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定配置文件所在的resource目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>db/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>static/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>mapper/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 选择要打包的配置文件和日志，当然也可以不加打包所有配置文件，然后由具体服务器来选择使用哪个 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>bootstrap.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>bootstrap-$&#123;spring.profiles.active&#125;.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>logback.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><p>比如这里我就设定了两个profile(dev, prod), 然后他们引用某个包的版本不一样，然后应用包的时候这样使用就行了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bvpro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bvpro-common-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;bvpro.api.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后项目中的bootstrap.yml文件中修改如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Spring</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="comment"># 环境配置</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">@spring.profiles.active@</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后当我们打包的时候 <code>mvn clean package -P dev</code> 就可以打包dev环境的配置，同时 @spring.profiles.active@ 会被替换成dev</p><p>当然如果你使用idea的时候就更加简单了，只需要勾选profile=dev就行了。</p><h3 id="docker中使用"><a href="#docker中使用" class="headerlink" title="docker中使用"></a>docker中使用</h3><p>我们知道在使用dockerfile的时候也可以指定环境变量,然后启动的时候就可以根据环境变量来启动了,比如这样子</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jre-alpine</span><br><span class="line">ENV env_java_debug_enabled=<span class="literal">false</span></span><br><span class="line">EXPOSE 8080</span><br><span class="line">WORKDIR /app</span><br><span class="line">ADD target/smcp-web.jar /app/target/smcp-web.jar</span><br><span class="line">ADD run.sh /app</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-Dspring.profiles.active=test&quot;</span>, <span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;target/smcp-web.jar&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后run.sh这样写:</p><p>可以看到我们在dockerfile中使用了ENV来指定我们要启动什么环境，但是这种方式太僵硬了, 因为相当于把启动什么环境给写死了，后面想要切换到其他环境的时候还要去修改dockerfile,这种方式看上去不太行呀</p><h3 id="SPRING-PROFILES-ACTIVE"><a href="#SPRING-PROFILES-ACTIVE" class="headerlink" title="SPRING_PROFILES_ACTIVE"></a>SPRING_PROFILES_ACTIVE</h3><p>好在springboot项目启动的时候会去读这样的一个特殊环境变量 SPRING_PROFILES_ACTIVE， 如果环境变量中配置了这个值，那么会根据这个值找到对应的profile, 然后启动对应的环境，所以我么可以在启动的时候指定这个环境变量就行了， 所以可以这样子</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jre-alpine</span><br><span class="line">ENV spring_profiles_active=dev</span><br><span class="line">ENV env_java_debug_enabled=<span class="literal">false</span></span><br><span class="line">EXPOSE 8080</span><br><span class="line">WORKDIR /app</span><br><span class="line">ADD target/smcp-web.jar /app/target/smcp-web.jar</span><br><span class="line">ADD run.sh /app</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;target/smcp-web.jar&quot;</span>]</span><br></pre></td></tr></table></figure><p>这里预设了spring_profiles_active的值是dev,当启动的时候你可以更改这个值。</p><p>如果你使用docker-compose来启动,那么也可以在docker-compose文件中配置environment,比如</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">SPRING_PROFILES_ACTIVE=prod</span></span><br></pre></td></tr></table></figure><p>这就是指定profile的各种方式了，使用这种方式我们可以更加精确的控制我们需要启动的环境，并且还是最少的修改。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近项目中进行仓库拆分了之后,因为引入了公共包,所以就存在可能有snapshot版本以及release版本问题,比如我想要在dev环境的时候import snapshot版本,prod环境的时候又使用release版本，为了不频繁修改pom.xml文件，因此决定使用POM的profile来解决这个问题。 &lt;/p&gt;
&lt;p&gt;当然由于maven默认是不下载snapshot包的，因此我们要配置让它下载，这里分为全局配置和项目级别配置&lt;/p&gt;
&lt;h3 id=&quot;项目配置&quot;&gt;&lt;a href=&quot;#项目配置&quot; class=&quot;headerlink&quot; title=&quot;项目配置&quot;&gt;&lt;/a&gt;项目配置&lt;/h3&gt;&lt;p&gt;在pom文件中添加如下内容&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;repositories&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;repository&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;nexus&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--修改成自己私服地址--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;http://localhost:18081/repository/maven-public/&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;releases&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;enabled&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;enabled&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;updatePolicy&lt;/span&gt;&amp;gt;&lt;/span&gt;always&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;updatePolicy&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;releases&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;snapshots&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--主要是这里--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;enabled&lt;/span&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;enabled&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;updatePolicy&lt;/span&gt;&amp;gt;&lt;/span&gt;always&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;updatePolicy&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;snapshots&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;repository&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;repositories&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
    <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
    <category term="profile" scheme="http://yoursite.com/tags/profile/"/>
    
  </entry>
  
  <entry>
    <title>Git中仓库拆分的两种方式</title>
    <link href="http://yoursite.com/2024/05/30/migrate-service-in-git/"/>
    <id>http://yoursite.com/2024/05/30/migrate-service-in-git/</id>
    <published>2024-05-30T07:46:33.000Z</published>
    <updated>2024-11-13T02:21:33.038Z</updated>
    
    <content type="html"><![CDATA[<p>最近要把项目中的子模块单独拆分为一个项目,并且移动到新的仓库地址，同时需要保留所有提交记录以及所有分支(包括未上线-未合并到master分支)的代码,我这里总结了2种方式以供大家参考。</p><h3 id="项目现状"><a href="#项目现状" class="headerlink" title="项目现状"></a>项目现状</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bv_sc_server</span><br><span class="line">|───bvpro-modules</span><br><span class="line">    │  ├─bvpro-job</span><br><span class="line">    │  │  ├─src</span><br><span class="line">    │  │  │  └─main</span><br><span class="line">    │  │  │      ├─java</span><br><span class="line">    │  │  │      │  └─com</span><br><span class="line">    │  │  │      │      └─bvpro</span><br><span class="line">    │  │  │      │          └─job</span><br><span class="line">    |  ├─bvpro-file</span><br><span class="line">    │  │  ├─src</span><br><span class="line">    │  │  │  └─main</span><br><span class="line">    │  │  │      ├─java</span><br><span class="line">    │  │  │      │  └─com</span><br><span class="line">    │  │  │      │      └─bvpro</span><br><span class="line">    │  │  │      │          └─file    </span><br></pre></td></tr></table></figure><p>&lt;!-more–&gt;</p><p>项目中有很多子模块，我需要将他们单独独立出来放到放到一个新的仓库,同时只保留各自仓库的代码。 </p><p>比如我有一个分支feature/migrate-data,它同时修改了bvpro-file以及bvpro-job的代码，那么迁移过去的效果希望是<br>新的bvpro-file和bvpro-job仓库都有这个分支，同时也只包含当前仓库的代码，而不再想之前一样混杂着多个模块的代码。</p><p>因此调研了下发现有两种方案可以达到这样的目的，一种是git subtree, 一种是git filter-repo。 </p><h3 id="git-subtree"><a href="#git-subtree" class="headerlink" title="git subtree"></a>git subtree</h3><p>需要拆分的仓库叫做 bv_sc_server, 现在需要拆分的模块是 bv_sc_server/bvpro-modules/bvpro-job, 拆分后的新仓库叫做bvpro-job</p><ol><li><p>先在代码服务器(比如gitlab)上新建一个空的仓库， 比如bvpro-job</p></li><li><p>在本地文件夹clone刚创建的新仓库, 和bv_sc_server在同一个目录下</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone http:&#x2F;&#x2F;localhost:8090&#x2F;sc_group&#x2F;bvpro-job.git</span><br></pre></td></tr></table></figure><ol start="3"><li>进入bv_sc_server这个仓库的目录下进行拆分,当前处于master分支(这个分支是需要迁移的分支)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git subtree split -P bvpro-modules&#x2F;bvpro-job -b feature&#x2F;split-bvpro-job</span><br></pre></td></tr></table></figure><ol start="4"><li>进入到bvpro-job这个新仓库,执行以下命令: <ul><li>cd ../bvpro-job</li><li>git pull ..\bv_sc_server feature/split-bvpro-job</li><li>git remote remove origin</li><li>git remote add origin <a href="http://localhost:8090/sc_group/bvpro-job.git">http://localhost:8090/sc_group/bvpro-job.git</a></li><li>git push –set-upstream origin –all</li></ul></li></ol><p>到这里我们就把bv_sc_server中bvpro-job模块的master分支代码迁移到了新的仓库，但是其他分支还没有迁移过去,所以这里我们重复执行下操作</p><p>这里为了不相互影响，我们将本地bvpro-job目录删除，然后重新新建一个空白bvpro-job目录。然后在重复执行上面的命令,这里为了演示方便我就将命令写到一起。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cd bvpro-job</span><br><span class="line">git clone http:&#x2F;&#x2F;localhost:8090&#x2F;sc_group&#x2F;bvpro-job.git</span><br><span class="line">cd ..&#x2F;bv_sc_server</span><br><span class="line">#切换到需要迁移的分支</span><br><span class="line">git checkout feature&#x2F;SCA-5034_AutoApprovalForTcAndSc</span><br><span class="line">git subtree split -P bvpro-modules&#x2F;bvpro-job -b  split&#x2F;SCA-5034_AutoApprovalForTcAndSc</span><br><span class="line">cd ..&#x2F;bvpro-job</span><br><span class="line">git pull ..\bv_sc_server split&#x2F;SCA-5034_AutoApprovalForTcAndSc</span><br><span class="line">git remote remove origin</span><br><span class="line">git remote add origin http:&#x2F;&#x2F;localhost:8090&#x2F;sc_group&#x2F;bvpro-job.git</span><br><span class="line"># 新clone的仓库默认是master分支(也可能是main), 然后推送到远端的feature分支</span><br><span class="line">git push --set-upstream origin master:feature&#x2F;SCA-5034_AutoApprovalForTcAndSc</span><br></pre></td></tr></table></figure><p>这样就完成了feature/SCA-5034_AutoApprovalForTcAndSc分支的迁移了,这样迁移也只保留了bvpro-job有关的代码，如果这个分支在以前的其他模块也有代码,那么也要按照这样的方式进行迁移，同时有多少个分支需要迁移就需要执行多次上面的命令。</p><p>可以发现这样迁移的效率是很低的，要是分支或者提交记录很多一天的时间都耗在这上面了。当然如果你只想要迁移master分支代码，这种方式也是很不错的，关键是这个命令是git自带的。</p><h3 id="git-filter-repo"><a href="#git-filter-repo" class="headerlink" title="git filter-repo"></a>git filter-repo</h3><p>这个命令并不是git自带的,但是它也很赫赫有名，毕竟官方都推荐使用它进行迁移。</p><p>使用它是有限制的，首先python版本要在3.5以上,git版本要在2.2以上。因为我使用的是windows,所以下面演示windows上的安装方式</p><ol><li>安装git-filter-repo<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --user git-filter-repo</span><br></pre></td></tr></table></figure></li></ol><p>记录下安装的地址，然后配置环境变量，然后就可以使用git filter-repo这个命令了。</p><ol start="2"><li>git clone bv_sc_server项目,默认master分支,最好是最新的,这样子命令运行错了也不影响你的开发</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone http:&#x2F;&#x2F;localhost:8090&#x2F;sc_group&#x2F;bv_sc_server.git bvpro-job</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>拆分</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd bvpro-job</span><br><span class="line"></span><br><span class="line"># 只保留bvpro-modules&#x2F;bvpro-job这个路径的代码</span><br><span class="line">git filter-repo --path bvpro-modules&#x2F;bvpro-job</span><br><span class="line"></span><br><span class="line"># 将bvpro-modules&#x2F;bvpro-job这个目录提升为根目录</span><br><span class="line">git filter-repo --subdirectory-filter bvpro-modules&#x2F;bvpro-job</span><br><span class="line"></span><br><span class="line"># 上面两句可以合并成下面这句，还可以指定要保留的分支</span><br><span class="line">git filter-repo --path bvpro-modules&#x2F;bvpro-job --subdirectory-filter bvpro-modules&#x2F;bvpro-job --branches &lt;保留的分支名称&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的命令执行完成后,bv_sc_server这个目录下的代码就只有以前bvpro-job的代码了</p><ol start="4"><li>推送</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin http:&#x2F;&#x2F;localhost:8090&#x2F;sc_group&#x2F;bvpro-job.git</span><br><span class="line"></span><br><span class="line">git push --set-upstream origin --all</span><br></pre></td></tr></table></figure><p>这样子就将bvpro-job这个子模块的所有代码，commit以及分支都迁移到了新的仓库，不用再想subtree一样针对特定的分支反复操作了， 所以我是推荐使用这个命令的。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近要把项目中的子模块单独拆分为一个项目,并且移动到新的仓库地址，同时需要保留所有提交记录以及所有分支(包括未上线-未合并到master分支)的代码,我这里总结了2种方式以供大家参考。&lt;/p&gt;
&lt;h3 id=&quot;项目现状&quot;&gt;&lt;a href=&quot;#项目现状&quot;</summary>
        
      
    
    
    
    
    <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
    <category term="filter-repo" scheme="http://yoursite.com/tags/filter-repo/"/>
    
    <category term="subtree" scheme="http://yoursite.com/tags/subtree/"/>
    
  </entry>
  
  <entry>
    <title>好家伙，这些问题还不是手拿把掐</title>
    <link href="http://yoursite.com/2024/02/18/current-issues-in-my-system/"/>
    <id>http://yoursite.com/2024/02/18/current-issues-in-my-system/</id>
    <published>2024-02-18T02:44:01.000Z</published>
    <updated>2024-11-13T02:21:33.034Z</updated>
    
    <content type="html"><![CDATA[<p>总结了下这段时间遇到的问题。</p><h3 id="快速生成字典表数据"><a href="#快速生成字典表数据" class="headerlink" title="快速生成字典表数据"></a>快速生成字典表数据</h3><p>在前期开发的时候，BA总是给我好几张excel,让我生成字典表,写代码又耗时，而且不同的excel字段也不一样，不可能每次都要去改代码吧，总之我不干，好在我能借助excel函数完成这样的需求。</p><p><img data-src="/images/excel.gif" alt="函数"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;CONCATENATE(&quot;insert into test_claims(&#96;id&#96;,&#96;code&#96;,&#96;name&#96;) values(&#39;&quot;, A1, &quot;&#39;,&#39;&quot;,B1, &quot;&#39;,&#39;&quot;,C1,&quot;&#39;);&quot;)</span><br><span class="line"></span><br><span class="line">这个函数的语法是 CONCATENATE(text1, [text2], ...)</span><br><span class="line">1. text1（必需）：要联接的第一个项目。项目可以是文本值、数字或单元格引用；</span><br><span class="line"></span><br><span class="line">2. Text2, ... （可选）：要联接的其他文本项目。最多可以有 255 个项目，总共最多支持 8,192 个字符</span><br></pre></td></tr></table></figure><h3 id="Kubernetes-Pod频繁重启"><a href="#Kubernetes-Pod频繁重启" class="headerlink" title="Kubernetes Pod频繁重启"></a>Kubernetes Pod频繁重启</h3><p>后台看到部署到kubernetes的pod一直在重启，但是看日志没有报错，但是一会儿它就自动重启了，最后通过describe命令看到是因为liveness接口的原因</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubelet  Liveness probe failed: Get &quot;http:&#x2F;&#x2F;10.24.8.84:9202&#x2F;actuator&#x2F;health&quot;</span><br></pre></td></tr></table></figure><p>因为使用了springboot actuator接口,它会检测服务中使用到的其他服务是否能正常使用,从而判定当前服务是否存活，所以必然是因为这个接口返回的信息导致pod重启。</p><p>重启的这个服务主要用到了邮件以及Redis,但是不知道到底是哪个服务健康检查失败了。此时我们也无法进入到pod中访问health接口了。</p><p>所以我们先移除掉pod template的livenessProbe配置，然后重新部署服务</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line">  <span class="attr">httpGet:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/actuator/health</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">9204</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">60</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">timeoutSeconds:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>这个时候使用exec命令进入pod</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">kubectl <span class="built_in">exec</span> -it &lt;pod name&gt; -n &lt;namespace&gt; -- /bin/bash</span><br></pre></td></tr></table></figure><p>访问  <code>curl -i http://localhost:9202/actuator/health</code>  可以看到response status code是503,并且还可以看到具体失败的组件是哪一个。 </p><p>最终确定是redis访问超时了，于是调整了下 livenessProbe的timeoutSeconds,然后在重启就不报错了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@noti-844567c558-2mvj8:&#x2F;home&#x2F;pro# curl -i http:&#x2F;&#x2F;localhost:9202&#x2F;actuator&#x2F;health</span><br><span class="line">HTTP&#x2F;1.1 200 </span><br><span class="line">X-XSS-Protection: 1; mode&#x3D;block</span><br><span class="line">Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;self&#39;; frame-ancestors &#39;self&#39;; object-src &#39;none&#39;</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">X-Frame-Options: SAMEORIGIN</span><br><span class="line">Content-Type: application&#x2F;vnd.spring-boot.actuator.v3+json;charset&#x3D;utf-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Sun, 18 Feb 2024 07:36:22 GMT</span><br><span class="line"></span><br><span class="line">&#123;&quot;status&quot;:&quot;UP&quot;,&quot;components&quot;:&#123;&quot;discoveryComposite&quot;:&#123;&quot;description&quot;:&quot;Discovery Client not initialized&quot;,&quot;status&quot;:&quot;UNKNOWN&quot;,&quot;components&quot;:&#123;&quot;discoveryClient&quot;:&#123;&quot;description&quot;:&quot;Discovery Client not initialized&quot;,&quot;status&quot;:&quot;UNKNOWN&quot;&#125;&#125;&#125;,&quot;diskSpace&quot;:&#123;&quot;status&quot;:&quot;UP&quot;,&quot;details&quot;:&#123;&quot;total&quot;:133003395072,&quot;free&quot;:94000709632,&quot;threshold&quot;:10485760,&quot;exists&quot;:true&#125;&#125;,&quot;livenessState&quot;:&#123;&quot;status&quot;:&quot;UP&quot;&#125;,&quot;mail&quot;:&#123;&quot;status&quot;:&quot;UP&quot;,&quot;details&quot;:&#123;&quot;location&quot;:&quot;xxmail:465&quot;&#125;&#125;,&quot;ping&quot;:&#123;&quot;status&quot;:&quot;UP&quot;&#125;,&quot;readinessState&quot;:&#123;&quot;status&quot;:&quot;UP&quot;&#125;,&quot;redis&quot;:&#123;&quot;status&quot;:&quot;UP&quot;,&quot;details&quot;:&#123;&quot;version&quot;:&quot;6.0.14&quot;&#125;&#125;,&quot;refreshScope&quot;:&#123;&quot;status&quot;:&quot;UP&quot;&#125;&#125;,&quot;groups&quot;:[&quot;liveness&quot;,&quot;readiness&quot;]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="minio数据迁移到Azure-blob"><a href="#minio数据迁移到Azure-blob" class="headerlink" title="minio数据迁移到Azure blob"></a>minio数据迁移到Azure blob</h3><p>项目中需要将minio中保存的文件迁移到azure的blob中,然后minio中保存文件的路径是这样的 <code>2023/11/07/20231107164256A579/Image3.jpg</code>  相当于文件夹中包含了时间戳等信息，虽然blob不支持目录，但是它的虚拟目录可以有相同的效果，这里我们使用azure提供的azcopy命令来进行数据迁移。</p><p>首先进入到minio所在的服务器,然后执行下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1.  sudo mkdir &#x2F;home&#x2F;azcopy </span><br><span class="line"></span><br><span class="line">2. cd &#x2F;home&#x2F;azcopy</span><br><span class="line"> </span><br><span class="line">3. sudo  wget -O azcopy_v10.tar.gz https:&#x2F;&#x2F;aka.ms&#x2F;downloadazcopy-v10-linux &amp;&amp;</span><br><span class="line"></span><br><span class="line">4. sudo tar -xf azcopy_v10.tar.gz --strip-components&#x3D;1</span><br><span class="line"></span><br><span class="line">5. sudo azcopy login  &#x2F;&#x2F; 登录azure</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6. 同步minio数据到blob,将sc-dev bucket的数据迁移到blob的container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里的sc-dev是minio的bucket, saoscdev是azure blob的account name, bvsc是container name</span><br><span class="line">    a. sudo &#x2F;home&#x2F;azcopy&#x2F;azcopy copy &#39;&#x2F;data&#x2F;minio&#x2F;data&#x2F;sc-dev&#x2F;*&#39; &#39;https:&#x2F;&#x2F;saoscdev.blob.core.windows.net&#x2F;bvsc&#39; --recursive</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将增量数据同步到blob中</span><br><span class="line">    b. sudo &#x2F;home&#x2F;azcopy&#x2F;azcopy sync &#39;&#x2F;data&#x2F;minio&#x2F;data&#x2F;sc-dev&#39; &#39;https:&#x2F;&#x2F;saoscdev.blob.core.windows.net&#x2F;bvsc&#39; --recursive</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是我最近遇到的问题，第一个字典表的那个当时第一反应是写代码，但是后来想到写代码的时候太长，成本太高还是需要借助工具，恰好提供给我的又是excel,于是就用excel顺带完成了这个功能，同时后面的其他字典数据如法炮制，也就变简单了。</p><p>第二个问题本来是定位重启的问题，但是看着看着就深入到了actuator的源码当中起了，这一点很不好，不过有失必有得，有顺带看了下actuator的源码,它其中的EntryPoint感觉很棒，后面针对这个写一篇。</p><p>第三个问题的话就是微软没有提供如何迁移的文档，不过好在它本生工具不少，多尝试也就成功了，这里我把迁移的步骤给出来，希望能帮助到同样有需求的人。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;总结了下这段时间遇到的问题。&lt;/p&gt;
&lt;h3 id=&quot;快速生成字典表数据&quot;&gt;&lt;a href=&quot;#快速生成字典表数据&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Minio" scheme="http://yoursite.com/tags/Minio/"/>
    
    <category term="Azure" scheme="http://yoursite.com/tags/Azure/"/>
    
  </entry>
  
  <entry>
    <title>因为一个bug,我还是掀开了openfeign的神秘面纱</title>
    <link href="http://yoursite.com/2023/12/14/spring-cloud-openfeign-analysis/"/>
    <id>http://yoursite.com/2023/12/14/spring-cloud-openfeign-analysis/</id>
    <published>2023-12-14T02:41:39.000Z</published>
    <updated>2024-11-13T02:21:33.042Z</updated>
    
    <content type="html"><![CDATA[<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><p>最近项目中访问一个外部api报错了，报错信息如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</span><br></pre></td></tr></table></figure><p>看着像是证书问题，这个时候我首先想到的是百度下，看看怎么解决。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>百度告诉我说如果你open-feign中使用的是http client,那么可以通过下面的配置来让跳过SSL验证</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">disable-ssl-validation:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>结果还是报同样的错误。 于是我又百度,又重新找了一个解决方法，这次的方案是让我自己重写Client了,具体操作如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Client <span class="title">feignClient</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException, KeyManagementException </span>&#123;</span><br><span class="line">    SSLContext ctx = SSLContext.getInstance(<span class="string">&quot;SSL&quot;</span>);</span><br><span class="line">    X509TrustManager tm = <span class="keyword">new</span> X509TrustManager() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ctx.init(<span class="keyword">null</span>, <span class="keyword">new</span> TrustManager[]&#123;tm&#125;, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">new</span> Client.Default(ctx.getSocketFactory(), (hostName, session) -&gt; <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这把我感觉要起飞了， 一切尽在掌握中,重新deploy,打开postman,测试测试我的接口。</p><p>测试后感觉好了但是看日志又没有完全好。 这个接口倒是不报错了，但是我调用内部服务给我报错了，比如我这里的内部服务名称叫做</p><p>pro-file, 就现在它没法根据我这个pro-file名字找到对应的IP了，从而导致我这个服务使用不了了。</p><p>百度误我！</p><h3 id="求人不如求己"><a href="#求人不如求己" class="headerlink" title="求人不如求己"></a>求人不如求己</h3><p>此刻我自信的打开了IDEA, 输入了类名 <code>FeignAutoConfiguration</code> , Spring Cloud关于某个组件的自动注入类大多是XXXConfiguration, 所以按照这么找准没错。</p><p>然后我有自信的把断点打在了这个部分 <code>FeignAutoConfiguration:246</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ApacheHttpClient.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(CloseableHttpClient.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;feign.httpclient.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="meta">@Conditional(HttpClient5DisabledConditions.class)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientFeignConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(Client.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Client <span class="title">feignClient</span><span class="params">(HttpClient httpClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApacheHttpClient(httpClient);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动项目，好家伙断点没进来呀。 没进来的原因大概率可能是不满足条件,我赶紧看看这里对应的Conditional, 发现了我的代码中没有</p><p>设置<code>feign.httpclient.enabled</code>属性的值, 而且这里也没有设置havingValue, 根据源码可以知道， 如果没有设置havingValue, 那么这个属性的值会被和false进行比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.boot.autoconfigure.condition.OnPropertyCondition.Spec#isMatch</span></span><br><span class="line"><span class="comment">// 这里的requiredValue是havingValue</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String value, String requiredValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(requiredValue)) &#123;</span><br><span class="line">        <span class="keyword">return</span> requiredValue.equalsIgnoreCase(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !<span class="string">&quot;false&quot;</span>.equalsIgnoreCase(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>搞半天这个Configurtion相当于没起作用。 </p><p>好好好，这么玩是吧。</p><p>既然这个配置不生效，那肯定有其他配置生效，我就找找其他配置，最终我在spring-cloud-openfeign-core这个jar包的loadbalancer这个包下面找到了我想要的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(Feign.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(&#123; LoadBalancerClient.class, LoadBalancerClientFactory.class &#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore(FeignAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; BlockingLoadBalancerClientAutoConfiguration.class, LoadBalancerAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(FeignHttpClientProperties.class)</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="comment">// Order is important here, last should be the default, first should be optional</span></span><br><span class="line"><span class="comment">// see</span></span><br><span class="line"><span class="comment">// https://github.com/spring-cloud/spring-cloud-netflix/issues/2086#issuecomment-316281653</span></span><br><span class="line"><span class="meta">@Import(&#123; HttpClientFeignLoadBalancerConfiguration.class, OkHttpFeignLoadBalancerConfiguration.class,</span></span><br><span class="line"><span class="meta">        HttpClient5FeignLoadBalancerConfiguration.class, DefaultFeignLoadBalancerConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignLoadBalancerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为我们项目是采用springcloud alibaba进行开发，所以引入了spring-cloud-loadbalancer这个包,因此这个这个配置类就会生效，由于我们没有配置使用httpclient,同样也未使用okhttp,所以生效的配置类只有一个，那就是 <code>DefaultFeignLoadBalancerConfiguration</code></p><p>这个配置类中retryClient会被加载,因为我们引入了spring-retry.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(name = &quot;org.springframework.retry.support.RetryTemplate&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(LoadBalancedRetryFactory.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &quot;spring.cloud.loadbalancer.retry.enabled&quot;, havingValue = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">        matchIfMissing = true)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Client <span class="title">feignRetryClient</span><span class="params">(LoadBalancerClient loadBalancerClient,</span></span></span><br><span class="line"><span class="function"><span class="params">        LoadBalancedRetryFactory loadBalancedRetryFactory, LoadBalancerClientFactory loadBalancerClientFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RetryableFeignBlockingLoadBalancerClient(<span class="keyword">new</span> Client.Default(<span class="keyword">null</span>, <span class="keyword">null</span>), loadBalancerClient,</span><br><span class="line">            loadBalancedRetryFactory, loadBalancerClientFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这也是为什么上面我们自己配置了自己的Client后，访问其他spring cloud服务会找不到地址，这是因为默认的client不会去通过LoadBalancer去获取服务地址。 </p><h3 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h3><p>期间debug的时候,还发现最终的Client的SeataFeignClient,我一看才发现某个公共包引入了Seata,但是没有使用Seata功能,然后Seata会把我们最终使用的FeignClient在给封装一次，所以后面我就把seata从项目中移除了。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>既然问题找到了,那么就好修改了，修改方式有两种，一种是创建自己的<code>RetryableFeignBlockingLoadBalancerClient</code>, 就把上面的代码拿过来抄一遍，只是自己指定SSLContext，另一种是启用httpclient</p><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Client <span class="title">feignRetryClient</span><span class="params">(LoadBalancerClient loadBalancerClient,</span></span></span><br><span class="line"><span class="function"><span class="params">                               LoadBalancedRetryFactory loadBalancedRetryFactory, LoadBalancerClientFactory loadBalancerClientFactory)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, KeyManagementException </span>&#123;</span><br><span class="line">    SSLContext ctx = SSLContext.getInstance(<span class="string">&quot;SSL&quot;</span>);</span><br><span class="line">    X509TrustManager tm = <span class="keyword">new</span> X509TrustManager() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ctx.init(<span class="keyword">null</span>, <span class="keyword">new</span> TrustManager[]&#123;tm&#125;, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RetryableFeignBlockingLoadBalancerClient(<span class="keyword">new</span> Client.Default(ctx.getSocketFactory(), (hostname, session) -&gt; <span class="keyword">true</span>), loadBalancerClient,</span><br><span class="line">            loadBalancedRetryFactory, loadBalancerClientFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>另一种方案就是启用httpclient,并且禁用ssl验证，配置如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">disable-ssl-validation:</span> <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自此这个问题解决了，当然在使用中更加倾向使用方案二，因为Feign默认的Client采用的是<code>HttpURLConnection</code>,它没有连接池,当然你也可以使用okhttp。</p><h3 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h3><p>这个问题看起来简单，但是排查起来还是颇费心思,很多细节隐藏到了框架之下,所以我想看源码还是有好处的，因为网上的文章别人的情况可能和你不一样，与其遨游在各个文章里面，还不如debug一把。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h3 id=&quot;报错&quot;&gt;&lt;a href=&quot;#报错&quot; class=&quot;headerlink&quot; title=&quot;报错&quot;&gt;&lt;/a&gt;报错&lt;/h3&gt;&lt;p&gt;最近项目中访问一个外部api报错了，报错信息如下&lt;/p&gt;
&lt;figure class=&quot;highlight</summary>
        
      
    
    
    
    
    <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
    <category term="OpenFeign" scheme="http://yoursite.com/tags/OpenFeign/"/>
    
    <category term="Feign" scheme="http://yoursite.com/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>k8s中如何进行DNS解析</title>
    <link href="http://yoursite.com/2023/11/23/dns-analysis-in-k8s/"/>
    <id>http://yoursite.com/2023/11/23/dns-analysis-in-k8s/</id>
    <published>2023-11-23T01:53:16.000Z</published>
    <updated>2024-11-13T02:21:33.034Z</updated>
    
    <content type="html"><![CDATA[<p>之前文章&lt;老大喊我7天从SpringCloud转到K8S&gt;中我提到过我们使用open-feign来访问内部服务,有很多童鞋留言问我访问内部服务的url应该怎么写，但是还是整个系统的整体url吗？</p><p>比如我整个系统的url是  <code>http://www.think123.com</code>, 现在有user服务和manage服务,那我现在想要访问user服务的ip就变成 <code>http://www.think123.com/user</code>吗? 当然不是因为这样的话你的访问就相当于还是访问外网，又要重新走gateway, 这样子不仅增加网络开销，而且我们做鉴权也不方便，因为服务间的访问鉴权往往是通过一个注解或者token来实现的。</p><p>&lt;!-more–&gt;</p><h3 id="服务的ip地址"><a href="#服务的ip地址" class="headerlink" title="服务的ip地址"></a>服务的ip地址</h3><p>我们都知道在k8s中我们一般会部署多个pod, 而我们又是通过K8S的Service来做LoadBalance的,Service会根据一定的策略来选择具体访问的pod, 如下图所示</p><p><img data-src="/images/k8s/website-to-k8s.png" alt="访问"></p><p>因此实际上我们只需要知道service的地址就行了,使用下面的命令查看service的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get  svc -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure><p><img data-src="/images/k8s/svc-ip.png" alt="service"></p><p>我们可以看到service的ip,因为我们服务是部署到同一个集群的，那是不是只需要知道服务的ip就行了，然后在open-feign中声明要访问的服务的ip加上端口就可以了呢？</p><p>原则是上可以的,但是实际上有问题,首先不同集群中ip地址不一样,如果你要部署不同集群，那么每次都要修改，其次就算只有一个集群，这个ip也是可能变动的，所以写ip不太靠谱。</p><h3 id="服务的域名"><a href="#服务的域名" class="headerlink" title="服务的域名"></a>服务的域名</h3><p>好在kubernetes给某个服务都添加了一个域名(这是通过kube-proxy和iptables实现的), 域名的规则是  <code>..svc.cluster.local</code>。 </p><p>比如对于我们的user服务,我们这个地址就是 <code>user.dev.svc.cluster.local(&lt;serviceName&gt;.&lt;namespace&gt;.svc.cluster.local)</code></p><p>当然后面的这么一堆你都可以省略，实际上我们在open-feign的url中只需要声明 <code>http://user:9201/(服务名:端口)</code> 就可以了,kubernetes在进行dns寻址的时候会先在本地dns找user这个域名对应的ip地址</p><h3 id="K8S的DNS解析机制"><a href="#K8S的DNS解析机制" class="headerlink" title="K8S的DNS解析机制"></a>K8S的DNS解析机制</h3><ol><li><p>集群域名和后缀：Kubernetes集群中的每个服务都会被分配一个域名，该域名由服务名称（Service Name）和命名空间（Namespace）组成。例如，一个服务名为my-service，位于命名空间my-namespace的服务的完整域名将是my-service.my-namespace.svc.cluster.local。svc.cluster.local是Kubernetes集群默认的后缀。</p></li><li><p>Kubernetes DNS服务器：Kubernetes集群内部有一个专用的DNS服务器负责处理服务的DNS解析请求。这个DNS服务器通常被命名为kube-dns或coredns。</p></li><li><p>解析流程：在进行DNS解析时，应用程序或服务可以使用服务名作为主机名（hostname），然后发送DNS查询请求到Kubernetes DNS服务器。</p></li><li><p>DNS查询：Kubernetes DNS服务器接收到DNS查询请求后，会根据请求中的域名信息进行解析。它首先进行域名拆分，将服务名、命名空间和集群后缀分离开。</p></li><li><p>域名解析：Kubernetes DNS服务器会依次解析域名的各个部分。它首先解析命名空间，然后根据服务名在该命名空间下查找对应的Service资源。</p></li><li><p>Service资源解析：Kubernetes DNS服务器在Service资源中查找与请求的服务名和命名空间匹配的条目。如果找到匹配项，将返回与之关联的Pod IP地址列表。</p></li><li><p>IP地址返回：Kubernetes DNS服务器将解析到的Pod IP地址返回给发起请求的应用程序或服务。</p></li><li><p>重试机制：如果在初始查询时没有找到匹配的Service资源，Kubernetes DNS服务器可能会进行一些重试机制，以确保服务名得到正确解析。这样做是因为在创建和删除Service资源的过程中，可能会存在一定的延迟。<br>通过这种方式，Kubernetes DNS解析机制使得服务能够通过服务名进行通信，无需关心具体的Pod IP地址。这种抽象层简化了服务之间的通信配置，并支持动态扩展和管理服务。</p></li></ol><h4 id="查看域名"><a href="#查看域名" class="headerlink" title="查看域名"></a>查看域名</h4><p>可以通过下面的命令查看域名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc my-service -n my-namespace -o jsonpath&#x3D;&#39;&#123;.metadata.name&#125;.&#123;.metadata.namespace&#125;.svc.cluster.local&#39;</span><br></pre></td></tr></table></figure><h4 id="查看coredns"><a href="#查看coredns" class="headerlink" title="查看coredns"></a>查看coredns</h4><p>通过下面的命令可以查看coredns pod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kube-system get pods -l k8s-app&#x3D;kube-dns</span><br></pre></td></tr></table></figure><p>当然我们可以通过下面的命令查看coredns的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kube-system get cm -l k8s-app&#x3D;kube-dns</span><br><span class="line">kubectl describe cm coredns -n kube-system</span><br></pre></td></tr></table></figure><p>其核心配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.:53 &#123;</span><br><span class="line">    errors</span><br><span class="line">    ready</span><br><span class="line">    health</span><br><span class="line">    kubernetes cluster.local in-addr.arpa ip6.arpa &#123;</span><br><span class="line">      pods insecure</span><br><span class="line">      fallthrough in-addr.arpa ip6.arpa</span><br><span class="line">    &#125;</span><br><span class="line">    prometheus :9153</span><br><span class="line">    forward . &#x2F;etc&#x2F;resolv.conf</span><br><span class="line">    cache 30</span><br><span class="line">    loop</span><br><span class="line">    reload</span><br><span class="line">    loadbalance</span><br><span class="line">    import custom&#x2F;*.override</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p><code>.:53</code> 表示监听的 DNS 端口号为 53，. 表示根域名（Root Zone）。</p></li><li><p><code>kubernetes cluster.local in-addr.arpa ip6.arpa</code> 定义了多个域和反向解析配置项。</p><ul><li><p><code>kubernetes</code> 是 Kubernetes 插件的名称，用于解析 Kubernetes 集群的服务和 Pod。</p></li><li><p><code>cluster.local</code> 是 Kubernetes 集群内部域名的默认后缀。</p></li><li><p><code>in-addr.arpa</code> 和 <code>ip6.arpa</code> 是用于反向 DNS 解析的 IPv4 和 IPv6 地址后缀。</p></li><li><p><code>pods insecure</code> 允许对 Pod 进行非安全（insecure）的 DNS 解析。</p></li><li><p>fallthrough in-addr.arpa ip6.arpa 表示如果查询未匹配到任何资源记录，则继续向下查询反向 DNS 解析。</p></li></ul></li><li><p><code>forward . /etc/resolv.conf</code> 将未能解析的 DNS 请求转发给 /etc/resolv.conf 文件中配置的其他 DNS 服务器。</p></li></ol><p>大家也可以去看pod中中/etc/host和/etc/resolv.conf然后也能发现一些迹象。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>至此,讲清楚了集群中内部服务之间是如何访问的，且k8s是如何进行寻址导致对应的pod的,希望对大家有所帮助。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;之前文章&amp;lt;老大喊我7天从SpringCloud转到K8S&amp;gt;中我提到过我们使用open-feign来访问内部服务,有很多童鞋留言问我访问内部服务的url应该怎么写，但是还是整个系统的整体url吗？&lt;/p&gt;
&lt;p&gt;比如我整个系统的url是 </summary>
        
      
    
    
    
    
    <category term="Kubernetes" scheme="http://yoursite.com/tags/Kubernetes/"/>
    
    <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>我在项目中这样使用状态机</title>
    <link href="http://yoursite.com/2023/11/16/cola-state-machine-in-project/"/>
    <id>http://yoursite.com/2023/11/16/cola-state-machine-in-project/</id>
    <published>2023-11-16T07:30:15.000Z</published>
    <updated>2024-11-13T02:21:33.034Z</updated>
    
    <content type="html"><![CDATA[<p>最近一个新的项目中的一个业务,状态的流转比较复杂，涉及到二十几个状态的流转,而且吸取了其他业务教训,我们决定使用状态机来解决状态流转的问题。</p><p>要使用状态机除了自己写状态模式下还研究了当下两个开源项目，一个是spring的state machine,一个是cola-state-machine。</p><p>spring的状态机可以做状态持久化,和spring结合比较好，但是太重了。 cola就比较简单,它只是简单做了一个抽象,我们只需要实现具体的行为就行了。 使用cola最重要的就是要记得”因为某个事件，导致了状态A向状态B进行了迁移”,当然这里的状态可以是同一个。</p><p>因为项目中使用的是springboot,所以我这里结合起来做了一定的改造,下面给出我在项目中使用的例子,仅供大家参考</p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cola<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cola-component-statemachine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>因为某个事件，导致了状态A向状态B进行了迁移。所以需要定义状态,事件,流程。</p><p><img data-src="/images/state-machine/state-process.png" alt="状态迁移"></p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>根据我们的流程我定义了以下事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> StatusChangeEventEnum &#123;</span><br><span class="line">    <span class="comment">// save as draft</span></span><br><span class="line">    SAVE_AS_DRAFT_EVENT,</span><br><span class="line">    <span class="comment">// draft submit</span></span><br><span class="line">    DRAFT_SUBMIT_EVENT,</span><br><span class="line">    <span class="comment">// submit</span></span><br><span class="line">    SUBMIT_EVENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> StatusEnum &#123;</span><br><span class="line"></span><br><span class="line">    NONE(<span class="number">0</span>, <span class="string">&quot;None&quot;</span>),</span><br><span class="line">    DRAFT(<span class="number">1</span>, <span class="string">&quot;Draft&quot;</span>),</span><br><span class="line">    SUBMITTED(<span class="number">2</span>, <span class="string">&quot;Submitted&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>定义状态迁移和事件的关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> StatusChangeEnum implements StatusChange &#123;</span><br><span class="line"></span><br><span class="line">    SAVE_AS_DRAFT(NONE, DRAFT, SAVE_AS_DRAFT_EVENT),</span><br><span class="line">    SUBMIT(NONE, SUBMITTED, SUBMIT_EVENT),</span><br><span class="line">    DRAFT_SUBMIT(DRAFT, SUBMITTED, DRAFT_SUBMIT_EVENT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StatusEnum fromStatus;</span><br><span class="line">    <span class="keyword">private</span> StatusEnum toStatus;</span><br><span class="line">    <span class="keyword">private</span> StatusChangeEventEnum event;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StatusEnum <span class="title">from</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fromStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StatusEnum <span class="title">to</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StatusChangeEventEnum <span class="title">event</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> event;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象状态变更的接口，因为可能会存在多个不同的状态变更流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatusChange</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">StatusEnum <span class="title">from</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">StatusEnum <span class="title">to</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">StatusChangeEventEnum <span class="title">event</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用Spring管理状态机"><a href="#使用Spring管理状态机" class="headerlink" title="使用Spring管理状态机"></a>使用Spring管理状态机</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachineConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;StateMachineHandler&gt; handlerList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NEW_REQUEST_STATE_MACHINE = <span class="string">&quot;newRequestStateMachine&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(NEW_REQUEST_STATE_MACHINE)</span></span><br><span class="line">    <span class="keyword">public</span> &lt;C&gt; <span class="function">StateMachine&lt;StatusEnum, StatusChangeEventEnum, C&gt; <span class="title">newRequestStateMachine</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        StateMachineBuilder&lt;StatusEnum, StatusChangeEventEnum, C&gt; builder = StateMachineBuilderFactory.create();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (StatusChangeEnum changeEnum :StatusChangeEnum.values()) &#123;</span><br><span class="line">            build(builder, changeEnum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.build(NEW_REQUEST_STATE_MACHINE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;C&gt; <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(StateMachineBuilder&lt;StatusEnum, StatusChangeEventEnum, C&gt; builder, StatusChange statusChange)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 找到对应的handler来处理</span></span><br><span class="line">        StateMachineHandler&lt;StatusEnum, StatusChangeEventEnum, C&gt; handler = getHandler(statusChange);</span><br><span class="line"></span><br><span class="line">        StatusEnum fromStatus = statusChange.from();</span><br><span class="line">        StatusEnum toStatus = statusChange.to();</span><br><span class="line">        StatusChangeEventEnum changeEvent = statusChange.event();</span><br><span class="line">        <span class="comment">// 只产生了事件,但是状态未发生变化</span></span><br><span class="line">        <span class="keyword">if</span> (fromStatus == toStatus) &#123;</span><br><span class="line">            builder.internalTransition()</span><br><span class="line">                    .within(fromStatus)</span><br><span class="line">                    .on(changeEvent)</span><br><span class="line">                    .when(handler::isSatisfied)</span><br><span class="line">                    .perform((from, to, event, ctx) -&gt; handler.execute(from, to, event, ctx));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            builder.externalTransition()</span><br><span class="line">                    .from(fromStatus)</span><br><span class="line">                    .to(toStatus)</span><br><span class="line">                    .on(changeEvent)</span><br><span class="line">                    .when(handler::isSatisfied)</span><br><span class="line">                    .perform((from, to, event, ctx) -&gt; handler.execute(from, to, event, ctx));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接在handler中抛出更详细异常</span></span><br><span class="line">        <span class="comment">//builder.setFailCallback(new AlertFailCallback&lt;&gt;());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;C&gt; <span class="function">StateMachineHandler&lt;StatusEnum, StatusChangeEventEnum, C&gt; <span class="title">getHandler</span><span class="params">(StatusChange statusChange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handlerList.stream().filter(handler -&gt; handler.canHandle(statusChange))</span><br><span class="line">                .findFirst()</span><br><span class="line">                .orElse(<span class="keyword">new</span> DefaultStateMachineHandler&lt;C&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经过上面的定义后,后续有新的状态变更流程,我们只需要在 <code>StatusChangeEnum</code> 中添加就行了。</p><h3 id="实现对应的handler"><a href="#实现对应的handler" class="headerlink" title="实现对应的handler"></a>实现对应的handler</h3><p>这里我举一个例子,比如说首次提交数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoneToSubmittedStatusHandler</span>  <span class="keyword">implements</span> </span></span><br><span class="line"><span class="class">                        <span class="title">StateMachineHandler</span>&lt;<span class="title">StatusEnum</span>, <span class="title">StatusChangeEventEnum</span>, <span class="title">SubmitDTO</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canHandle</span><span class="params">(StatusChange statusChange)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// handler能处理的变更流程</span></span><br><span class="line">        StatusChangeEnum changeEnum = StatusChangeEnum.SUBMIT;</span><br><span class="line">        <span class="keyword">return</span> statusChange == changeEnum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(StatusEnum from, StatusEnum to, StatusChangeEventEnum event, SubmitDTO context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行具体的业务逻辑,比如插入数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfied</span><span class="params">(SubmitDTO context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否满足条件,比如是否是对应的用户等</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样子我们的每一个handler的功能就比较专一了,只需要处理对应状态的就行了，你可能回想要是有些状态的变成要做的事情类似,这样的代码不可能写两遍吧? 其实我们可以有一个抽象类可以将这些公用的逻辑放到抽象类里面,这样子有相同逻辑的就可以使用了。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>万事具备,现在只差在项目中使用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachine</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> StateMachine&lt;StatusEnum, StatusChangeEventEnum, StatusChangeContext&gt; newRequestStateMachine;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">statusChange</span><span class="params">(StatusChange changeEnum, StatusChangeContext context)</span> </span>&#123;</span><br><span class="line">        newRequestStateMachine.fireEvent(changeEnum.from(), changeEnum.event(), context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatusChangeContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubmitDTO</span> <span class="keyword">extends</span> <span class="title">StatusChangeContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long String;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只要涉及到状态变更的,就都可以调用StateMachie了。 </p><h3 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h3><p>这种方式其实会导致类的数量变多，但是职责更加清晰,每个类的代码行数也并不多，而且以后想要找某个状态变更到某个状态做了什么时候很很好找。</p><p>这就是最近使用状态机的一些心得，希望能对你有所帮助。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;最近一个新的项目中的一个业务,状态的流转比较复杂，涉及到二十几个状态的流转,而且吸取了其他业务教训,我们决定使用状态机来解决状态流转的问题。&lt;/p&gt;
&lt;p&gt;要使用状态机除了自己写状态模式下还研究了当下两个开源项目，一个是spring的state</summary>
        
      
    
    
    
    
    <category term="cola" scheme="http://yoursite.com/tags/cola/"/>
    
    <category term="statemachine" scheme="http://yoursite.com/tags/statemachine/"/>
    
    <category term="状态机" scheme="http://yoursite.com/tags/%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>helm常用命令</title>
    <link href="http://yoursite.com/2023/11/07/helm-use/"/>
    <id>http://yoursite.com/2023/11/07/helm-use/</id>
    <published>2023-11-07T01:57:55.000Z</published>
    <updated>2024-11-13T02:21:33.038Z</updated>
    
    <content type="html"><![CDATA[<h3 id="helm官方文档"><a href="#helm官方文档" class="headerlink" title="helm官方文档"></a>helm官方文档</h3><p>hi, bro, 最好的永远是官方文档: <a href="https://helm.sh/zh/docs/">https://helm.sh/zh/docs/</a></p><p>就是它上面的东西太多了，我知道你看得费力，所以我给你总结了下面的常用命令</p><h3 id="helm添加仓库"><a href="#helm添加仓库" class="headerlink" title="helm添加仓库"></a>helm添加仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">helm repo add  elastic  https:&#x2F;&#x2F;helm.elastic.co       </span><br><span class="line">helm repo add  gitlab   https:&#x2F;&#x2F;charts.gitlab.io       </span><br><span class="line">helm repo add  harbor   https:&#x2F;&#x2F;helm.goharbor.io</span><br><span class="line">helm repo add traefik   https:&#x2F;&#x2F;traefik.github.io&#x2F;charts    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加国内仓库       </span><br><span class="line">helm repo add stable http:&#x2F;&#x2F;mirror.azure.cn&#x2F;kubernetes&#x2F;charts       </span><br><span class="line">helm repo add aliyun https:&#x2F;&#x2F;kubernetes.oss-cn-hangzhou.aliyuncs.com&#x2F;charts       </span><br><span class="line">helm repo update       </span><br><span class="line">helm repo list</span><br><span class="line"></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="搜索chart"><a href="#搜索chart" class="headerlink" title="搜索chart"></a>搜索chart</h3><ol><li><code>helm search repo traefik/traefik</code></li><li><code>helm search repo nginx</code></li></ol><h3 id="安装或者查看出错时"><a href="#安装或者查看出错时" class="headerlink" title="安装或者查看出错时"></a>安装或者查看出错时</h3><p>出现报错 Error: Kubernetes cluster unreachable: Get “<a href="http://localhost:8080/version&quot;">http://localhost:8080/version&quot;</a>: dial tcp 127.0.0.1:8080</p><p>需要指定kubernetes api server地址,可以通过</p><p><code>helm --kube-apiserver address</code></p><h3 id="安装chart"><a href="#安装chart" class="headerlink" title="安装chart"></a>安装chart</h3><ol><li><code>helm repo update</code></li><li><code>helm install bitnami/mysql --generate-name</code><blockquote><p>在 Helm 3 中，必须主动指定release名称，或者增加 –generate-name 的参数使Helm自动生成</p></blockquote></li></ol><h3 id="查看安装的chart"><a href="#查看安装的chart" class="headerlink" title="查看安装的chart"></a>查看安装的chart</h3><ol><li><code>helm list(helm ls)</code></li></ol><h3 id="卸载chart"><a href="#卸载chart" class="headerlink" title="卸载chart"></a>卸载chart</h3><ol><li><code>helm uninstall mysql-xxx</code></li></ol><h3 id="安装traefik"><a href="#安装traefik" class="headerlink" title="安装traefik"></a>安装traefik</h3><ol><li>安装traefik,并指定对应参数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install --set deployment.kind&#x3D;DaemonSet --set namespaceOverride&#x3D;traefik --set service.enabled&#x3D;false traefik traefik&#x2F;traefik</span><br></pre></td></tr></table></figure><ol start="2"><li>端口转发，像访问本地服务一样访问traefik</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl port-forward $(kubectl get pods --selector &quot;app.kubernetes.io&#x2F;name&#x3D;traefik&quot; -n traefik --output&#x3D;name) 9000:9000 -n traefik</span><br></pre></td></tr></table></figure><ol start="3"><li><p>更新服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm upgrade --set deployment.kind&#x3D;DaemonSet --set namespaceOverride&#x3D;traefik --set service.enabled&#x3D;false traefik traefik&#x2F;traefik</span><br></pre></td></tr></table></figure></li><li><p>配合Azure使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install --set deployment.kind&#x3D;DaemonSet --set namespaceOverride&#x3D;traefik --set service.annotations.&quot;service.beta.kubernetes.io&#x2F;azure-load-balancer-internal&quot;&#x3D;true  traefik traefik&#x2F;traefik</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装时报错内存不足"><a href="#安装时报错内存不足" class="headerlink" title="安装时报错内存不足"></a>安装时报错内存不足</h3><p>0/2 nodes are available: 2 Insufficient memory. preemption: 0/2 nodes are available: 2 No preemption victims found for incoming pod</p><p>这是因为我们的chart在安装的时候，k8s集群内存不足。</p><p>可以通过下面的命令查看node的内存状况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node </span><br></pre></td></tr></table></figure><p>可以在安装的时候调整服务所需的内存,CPU等，也可以给集群加机器添加内存。</p><h3 id="查看chart信息"><a href="#查看chart信息" class="headerlink" title="查看chart信息"></a>查看chart信息</h3><p>+. 查看基本信息: <code>helm show chart traefik/traefik</code><br>+. 查看所有信息: <code>helm show all traefik/traefik</code></p><h3 id="查看chart的可配置选项"><a href="#查看chart的可配置选项" class="headerlink" title="查看chart的可配置选项"></a>查看chart的可配置选项</h3><ol><li><code>helm show values traefik/traefik</code></li></ol><p>然后，你可以使用 YAML 格式的文件覆盖上述任意配置项，并在安装过程中使用该文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2. echo &#39;&#123;web.port: 8080&#125;&#39; &gt; values.yml</span><br><span class="line">3. helm install -f values.yml traefik&#x2F;traefik --generate-name</span><br></pre></td></tr></table></figure><p>还可以直接使用 –set web.port=8080 指定,优先级比-f(–values)高</p><h3 id="创建并安装自己的charts"><a href="#创建并安装自己的charts" class="headerlink" title="创建并安装自己的charts"></a>创建并安装自己的charts</h3><ol><li><code>helm create think-manifesto</code></li><li><code>heml package think-manifesto</code></li><li><code>helm install think-manifesto</code> 上一步打包好的tgz包</li></ol><h3 id="debug-chart而不安装"><a href="#debug-chart而不安装" class="headerlink" title="debug chart而不安装"></a>debug chart而不安装</h3><p><code>helm install --debug --dry-run goodly-guppy ./mychart</code></p><p>这样不会安装应用(chart)到你的kubenetes集群中，只会渲染模板内容到控制台</p><p>如果想看渲染出错的内容,可以加上另外参数</p><p><code>helm install --dry-run --disable-openapi-validation moldy-jaguar ./mychart</code></p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><ul><li><code>helm lin</code>t 是验证chart是否遵循最佳实践的首选工具。</li><li><code>helm template --debug</code> 在本地测试渲染chart模板。</li><li><code>helm install --dry-run --debug</code>：我们已经看到过这个技巧了，这是让服务器渲染模板的好方法，然后返回生成的清单文件。</li><li><code>helm get manifest</code>: 这是查看安装在服务器上的模板的好方法。</li></ul><p><code>helm template --dry-run --debug --disable-openapi-validation thinkpro-test .\think-manifesto\</code></p><h3 id="helm内置对象"><a href="#helm内置对象" class="headerlink" title="helm内置对象"></a>helm内置对象</h3><p><a href="https://helm.sh/zh/docs/chart_template_guide/builtin_objects/">https://helm.sh/zh/docs/chart_template_guide/builtin_objects/</a></p><h4 id="Release"><a href="#Release" class="headerlink" title="Release"></a>Release</h4><p>Release对象描述了版本发布本身。包含了以下对象：</p><ol><li>Release.Name： release名称</li><li>Release.Namespace： 版本中包含的命名空间(如果manifest没有覆盖的话)</li></ol><h4 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h4><p>Values对象是从values.yaml文件和用户提供的文件传进模板的。默认为空</p><h4 id="Chart"><a href="#Chart" class="headerlink" title="Chart"></a>Chart</h4><p>Chart.yaml文件内容。 Chart.yaml里的所有数据在这里都可以可访问的。比如 <code>&#123;&#123; .Chart.Name &#125;&#125;-&#123;&#123; .Chart.Version &#125;&#125;</code> 会打印出 mychart-0.1.0</p><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p>模板中频繁使用的一个函数是default： default DEFAULT_VALUE GIVEN_VALUE。 这个函数允许你在模板中指定一个默认值，以防这个值被忽略. 当然还可以使用管道符配合使用,比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drink: &#123;&#123; .Values.favorite.drink | default &quot;tea&quot; | quote &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="删除空白"><a href="#删除空白" class="headerlink" title="删除空白"></a>删除空白</h3><p><code>&#123;&#123;-` (包括添加的横杠和空格)表示向左删除空白， 而 `-&#125;&#125;</code>表示右边的空格应该被去掉。 一定注意空格就是换行</p><p>要确保-和其他命令之间有一个空格。 <code>&#123;&#123;- 3 &#125;&#125;</code> 表示“删除左边空格并打印3”，而<code>&#123;&#123;-3 &#125;&#125;</code>表示“打印-3”。</p><h3 id="模板的使用"><a href="#模板的使用" class="headerlink" title="模板的使用"></a>模板的使用</h3><p>我们一般会在_helpers.tpl中写我们的模板代码</p><h4 id="声明一个模板"><a href="#声明一个模板" class="headerlink" title="声明一个模板"></a>声明一个模板</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- define &quot;mychart.labels&quot; &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    generator: helm</span><br><span class="line">    date: &#123;&#123; now | htmlDate &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h4><p>我们可以使用 template  templateName 来引用我们的模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-configmap</span><br><span class="line">  &#123;&#123;- template &quot;mychart.labels&quot; &#125;&#125;</span><br></pre></td></tr></table></figure><p>如果我们在模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;- define &quot;mychart.labels&quot; &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    generator: helm</span><br><span class="line">    date: &#123;&#123; now | htmlDate &#125;&#125;</span><br><span class="line">    chart: &#123;&#123; .Chart.Name &#125;&#125;</span><br><span class="line">    version: &#123;&#123; .Chart.Version &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中使用 .Chart,会发现渲染出错(–disable-openapi-validation 可以查看渲染的内容),这是因为没有内容传入到模板中(可以认为默认范围是在模板),所以无法使用 . 访问任何内容. 需要传递一个范围给模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- template &quot;mychart.labels&quot; . &#125;&#125;</span><br></pre></td></tr></table></figure><p>注意这个在template调用末尾传入的.，我们可以简单传入.Values或.Values.favorite或其他需要的范围。但一定要是顶层范围。</p><p>由于template是一个行为，不是方法，无法将 template调用的输出传给其他方法，数据只是简单地按行插入。</p><p>为了处理这个问题，Helm提供了一个 include 的可选项，可以将模板内容导入当前管道，然后传递给管道中的其他方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; .Release.Name &#125;&#125;-configmap</span><br><span class="line">  labels:</span><br><span class="line">&#123;&#123; include &quot;mychart.app&quot; . | indent 4 &#125;&#125;</span><br></pre></td></tr></table></figure><p>相较于使用template，在helm中使用include被认为是更好的方式 只是为了更好地处理YAML文档的输出格式</p><h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><h4 id="配置更新后-Pod-自动重启"><a href="#配置更新后-Pod-自动重启" class="headerlink" title="配置更新后 Pod 自动重启"></a>配置更新后 Pod 自动重启</h4><p>利用 k8s 的 Deployment 更改后的自动更新，我们可以用来更新应用配置，简单说就是更新 Secrets 或 ConfigMaps 后，计算它的最新 hash 值，然后将这个 hash 值 patch 到相应的 Deployment 中。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">checksum/config:</span> &#123;&#123; <span class="string">include</span> <span class="string">(print</span> <span class="string">$.Template.BasePath</span> <span class="string">&quot;/configmap.yaml&quot;</span><span class="string">)</span> <span class="string">.</span> <span class="string">|</span> <span class="string">sha256sum</span> &#125;&#125;</span><br></pre></td></tr></table></figure><p>这样，假如这个配置有问题，比如造成应用崩溃了，k8s 也会认为新的 ReplicaSet 失败了，不会将流量导过去，从而不继续滚动更新，避免了了由配置更新导致的应用崩溃问题。</p><h4 id="Image-pull-credentials"><a href="#Image-pull-credentials" class="headerlink" title="Image pull credentials"></a>Image pull credentials</h4><p>有些时候，Docker 镜像可能需要用户名与密码去 registry 拉取，那么，你就需要专门为此创建一个模板了。<br>比如 value 是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">imageCredentials:</span><br><span class="line">  registry: quay.io</span><br><span class="line">  username: someone</span><br><span class="line">  password: sillyness</span><br></pre></td></tr></table></figure><p>而模板就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- define &quot;imagePullSecret&quot; &#125;&#125;</span><br><span class="line">&#123;&#123;- printf &quot;&#123;&quot;auths&quot;: &#123;&quot;%s&quot;: &#123;&quot;auth&quot;: &quot;%s&quot;&#125;&#125;&#125;&quot; .Values.imageCredentials.registry (printf &quot;%s:%s&quot; .Values.imageCredentials.username .Values.imageCredentials.password | b64enc) | b64enc &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure><p>当然，需要注意多个 Deployment 共享一个 Chart 的情况，这时候可能会出现 secrets 冲突的情况，可考虑单为此单独创建一个 Config Chart，然后作为 App Chart 的依赖。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;helm官方文档&quot;&gt;&lt;a href=&quot;#helm官方文档&quot; class=&quot;headerlink&quot; title=&quot;helm官方文档&quot;&gt;&lt;/a&gt;helm官方文档&lt;/h3&gt;&lt;p&gt;hi, bro, 最好的永远是官方文档: &lt;a href=&quot;https://helm.sh/zh/docs/&quot;&gt;https://helm.sh/zh/docs/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;就是它上面的东西太多了，我知道你看得费力，所以我给你总结了下面的常用命令&lt;/p&gt;
&lt;h3 id=&quot;helm添加仓库&quot;&gt;&lt;a href=&quot;#helm添加仓库&quot; class=&quot;headerlink&quot; title=&quot;helm添加仓库&quot;&gt;&lt;/a&gt;helm添加仓库&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;helm repo add  elastic  https:&amp;#x2F;&amp;#x2F;helm.elastic.co       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;helm repo add  gitlab   https:&amp;#x2F;&amp;#x2F;charts.gitlab.io       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;helm repo add  harbor   https:&amp;#x2F;&amp;#x2F;helm.goharbor.io&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;helm repo add traefik   https:&amp;#x2F;&amp;#x2F;traefik.github.io&amp;#x2F;charts    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F;添加国内仓库       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;helm repo add stable http:&amp;#x2F;&amp;#x2F;mirror.azure.cn&amp;#x2F;kubernetes&amp;#x2F;charts       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;helm repo add aliyun https:&amp;#x2F;&amp;#x2F;kubernetes.oss-cn-hangzhou.aliyuncs.com&amp;#x2F;charts       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;helm repo update       &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;helm repo list&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Helm" scheme="http://yoursite.com/tags/Helm/"/>
    
    <category term="K8s" scheme="http://yoursite.com/tags/K8s/"/>
    
  </entry>
  
  <entry>
    <title>from-spring-cloud-to-springboot</title>
    <link href="http://yoursite.com/2023/09/14/from-spring-cloud-to-springboot/"/>
    <id>http://yoursite.com/2023/09/14/from-spring-cloud-to-springboot/</id>
    <published>2023-09-14T02:20:10.000Z</published>
    <updated>2024-11-13T02:21:33.034Z</updated>
    
    <content type="html"><![CDATA[<p>之前项目使用的是springcloud,主要使用到的组件有 spring gateway, nacos, minio, load balancer,open-feign等,然后我们的微服务通过docker部署到虚拟机里面的。</p><p>但是出于安全的考虑,需要将它迁移到azure的aks(kubernetes)中,所以需要将spring cloud改造成spring boot。这样就不用自己维护虚拟机的安全策略，也不需要去关注补丁了。</p><h3 id="梳理项目结构"><a href="#梳理项目结构" class="headerlink" title="梳理项目结构"></a>梳理项目结构</h3><p>项目是一个一个微服务组织起来的，大概业务类的服务有5个,公共服务有4个。 设计到的改造主要集中在gateway, auth中，公共包的一些改造比较少，主要是将open-feign的访问改为通过url进行调用，而不是之前通过服务名来。</p><p>而在kubernetes中，我们使用Traefik2来代替gateway的功能，不知道traefik2的，可以去翻翻之前的文章。</p><p>同时对于授权,需要提供一个授权接口，配合traefik2使用，这样每一个请求都会进行授权的验证。</p><h3 id="开始改造"><a href="#开始改造" class="headerlink" title="开始改造"></a>开始改造</h3><h4 id="确定分支"><a href="#确定分支" class="headerlink" title="确定分支"></a>确定分支</h4><p>最开始肯定是新拉一个分支进行这些改动，即便没改好也不影响其他人，所以我们先把分支名定好就叫做 feature/AKS-migrate。</p><h4 id="改造gateway"><a href="#改造gateway" class="headerlink" title="改造gateway"></a>改造gateway</h4><p>首先把pom文件中的不需要的依赖包注释掉,比如spring cloud gateay, nacos, sentinel等spring cloud相关组件。注释掉之后<br>去看代码中有哪些报错，就针对性的修改。</p><p>我们的项目中使用蛮多gateway的filter以及handler,最开始我看他们都是使用的webflux,我就想我单独引入这个包，代码是不是最小的改动就行了呢？</p><p>这样尝试过之后我发现不行,因为项目中使用最多还是@RestController,如果使用webflux的方式,那么很多filter不生效的。 </p><p>所以这种方式也不行，但是代码改得太多了，我只好回退到注释pom文件依赖的那一步。</p><p>没办法,只能读之前对应的代码逻辑,然后将其转换了。</p><p>读取gateway filter的代码,将其转换成spring filter,直接继承 <code>org.springframework.web.filter.OncePerRequestFilter</code> 即可，然后将之前的逻辑搬过来。 </p><p>需要注意的是如果是全局filter需要放到公共包里面。</p><p>handler也是一样的,将其转换成filter,需要注意执行顺序。</p><p>这样,核心代码改造完毕,可以开启调试了</p><h4 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h4><p>处理上面说的webflux的问题外,将springcloud变成springboot后,我们之前的配置文件名称是bootstrap.yml,bootstrap-dev.yml文件,但是改成了springboot后，配置文件名要改成application.yml,application-env.yml。</p><p>不然你会发现你启动不了,说找不到文件，这个坑也是自己把自己给坑了。</p><p>然后就是要将gateway的filter转换成spring filter的时候要注意一定要保证之前的逻辑完全移植过来了，我就遇到一个在改造前可以重复读取request的流,但是改造后这段代码报错了，就是因为没有将这段逻辑移植过去的问题。</p><h4 id="改造nacos"><a href="#改造nacos" class="headerlink" title="改造nacos"></a>改造nacos</h4><p>前面提到了nacos主要在open-feign的调用中以及变量注入中使用到了。feign那个好改,只需要指定url参数即可,这样就可以去掉nacos的依赖了。 然后变量注入同样的我们可以使用Kubernetes的ConfigMap以及Secret来代替。 </p><p>所以我们需要将以前配置到nacos中的变量放到配置文件中,这样变量可以直接通过Kubernetes进行注入了。</p><p>我们在各个环境中只需要有一份代码(一个镜像),部署的时候只需要注入的配置不一样就可以了，这样就可以保证各个环境代码一致。</p><p>比如之前的配置是这样的</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改造后配置文件的值为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;env_redis_host&#125;</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">$&#123;env_redis_port&#125;</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">$&#123;env_redis_database&#125;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;env_redis_password&#125;</span></span><br></pre></td></tr></table></figure><p>而这里的变量是通过ConfigMap进行配置的,到时候会注入到容器环境变量中，这样spring就可以从环境变量中获取到值了。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>之前使用的jenkins方式部署，jenkins也是自己搭建的，现在全部迁移到了azure github上,所以这里直接使用azure的pipeline进行部署。 而我们管理k8s的资源则使用的是helm。</p><p>比如我项目中使用helm生成后结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">C:.                 </span><br><span class="line">│  .helmignore      </span><br><span class="line">│  Chart.yaml       </span><br><span class="line">│  values-prod.yaml </span><br><span class="line">│  values-qa.yaml   </span><br><span class="line">│  values-test.yaml </span><br><span class="line">│  values.yaml      </span><br><span class="line">│                   </span><br><span class="line">├─charts            </span><br><span class="line">├─config            </span><br><span class="line">│  ├─dev            </span><br><span class="line">│  │      config.yaml</span><br><span class="line">│  │      secret.yaml</span><br><span class="line">│  │                </span><br><span class="line">│  ├─prod           </span><br><span class="line">│  │      config.yaml</span><br><span class="line">│  │      secret.yaml</span><br><span class="line">│  │                </span><br><span class="line">│  ├─qa             </span><br><span class="line">│  │      config.yaml</span><br><span class="line">│  │      secret.yaml</span><br><span class="line">│  │                </span><br><span class="line">│  └─test           </span><br><span class="line">│          config.yaml</span><br><span class="line">│          secret.yaml</span><br><span class="line">│                   </span><br><span class="line">└─templates         </span><br><span class="line">        configmap.yaml</span><br><span class="line">        deployment.yaml</span><br><span class="line">        hpa.yaml    </span><br><span class="line">        secret.yaml </span><br><span class="line">        service.yaml</span><br><span class="line">        _helpers.tpl</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里只需要部署的时候指定不同的value 文件，就可以实现同一个镜像部署到不同的环境了。</p><p>dev目录下config.yaml，secret.yaml文件内容大致如下:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># config.yaml</span></span><br><span class="line"><span class="attr">env_redis_host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">env_redis_port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">env_redis_database:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#secret.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env_redis_password:</span> <span class="number">123456</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在template中configmap.yaml, secret.yaml中主要是如何将文件内容转换成对应的yaml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#values.yaml 指定有哪些文件</span></span><br><span class="line"><span class="attr">configOverrides:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">config/dev/config.yaml</span></span><br><span class="line"><span class="attr">secretOverrides:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">config/dev/secret.yaml</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># configmap.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> &#123;&#123; <span class="string">include</span> <span class="string">&quot;think-manifesto.fullname&quot;</span> <span class="string">.</span> &#125;&#125;<span class="string">-configmap</span></span><br><span class="line">  <span class="attr">namespace:</span> &#123;&#123; <span class="string">.Values.nameSpace</span> &#125;&#125;</span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">$files</span> <span class="string">:=</span> <span class="string">.Files</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">range</span>  <span class="string">.Values.configOverrides</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">range</span> <span class="string">$key</span>, <span class="string">$value</span> <span class="string">:=</span>  <span class="string">($files.Get</span> <span class="string">(printf</span> <span class="string">&quot;%s&quot;</span> <span class="string">.)</span> <span class="string">|</span> <span class="string">fromYaml)</span> &#125;&#125;</span><br><span class="line">&#123;&#123; <span class="string">$key</span> <span class="string">|</span> <span class="string">indent</span> <span class="number">2</span> &#125;&#125;<span class="string">:</span> &#123;&#123; <span class="string">$value</span> <span class="string">|</span> <span class="string">quote</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># secret.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> &#123;&#123; <span class="string">include</span> <span class="string">&quot;think-manifesto.fullname&quot;</span> <span class="string">.</span> &#125;&#125;<span class="string">-secret</span></span><br><span class="line">  <span class="attr">namespace:</span> &#123;&#123; <span class="string">.Values.nameSpace</span> &#125;&#125;</span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">$files</span> <span class="string">:=</span> <span class="string">.Files</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">range</span>  <span class="string">.Values.secretOverrides</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">range</span> <span class="string">$key</span>, <span class="string">$value</span> <span class="string">:=</span>  <span class="string">($files.Get</span> <span class="string">(printf</span> <span class="string">&quot;%s&quot;</span> <span class="string">.)</span> <span class="string">|</span> <span class="string">fromYaml)</span> &#125;&#125;</span><br><span class="line">&#123;&#123; <span class="string">$key</span> <span class="string">|</span> <span class="string">indent</span> <span class="number">2</span> &#125;&#125;<span class="string">:</span> &#123;&#123; <span class="string">$value</span> <span class="string">|</span> <span class="string">b64enc</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">&#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后给我deployment.yaml的例子,大家可以参考下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> &#123;&#123; <span class="string">include</span> <span class="string">&quot;think-manifesto.fullname&quot;</span> <span class="string">.</span> &#125;&#125;</span><br><span class="line">  <span class="attr">namespace:</span> &#123;&#123; <span class="string">.Values.nameSpace</span> &#125;&#125;</span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    &#123;&#123;<span class="bullet">-</span> <span class="string">include</span> <span class="string">&quot;think-manifesto.labels&quot;</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">4</span> &#125;&#125;</span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> &#123;&#123; <span class="string">.Values.replicaCount</span> &#125;&#125;</span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">include</span> <span class="string">&quot;think-manifesto.selectorLabels&quot;</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">6</span> &#125;&#125;</span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">include</span> <span class="string">&quot;think-manifesto.selectorLabels&quot;</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">8</span> &#125;&#125;</span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">if</span> <span class="string">.Values.configOverrides</span>&#125;&#125;</span><br><span class="line">        <span class="attr">checksum/config:</span> &#123;&#123; <span class="string">include</span> <span class="string">(print</span> <span class="string">$.Template.BasePath</span> <span class="string">&quot;/configmap.yaml&quot;</span><span class="string">)</span> <span class="string">.</span> <span class="string">|</span> <span class="string">sha256sum</span> &#125;&#125;</span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">if</span> <span class="string">.Values.secretOverrides</span>&#125;&#125;</span><br><span class="line">        <span class="attr">checksum/secret:</span> &#123;&#123; <span class="string">include</span> <span class="string">(print</span> <span class="string">$.Template.BasePath</span> <span class="string">&quot;/secret.yaml&quot;</span><span class="string">)</span> <span class="string">.</span> <span class="string">|</span> <span class="string">sha256sum</span> &#125;&#125;</span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">with</span> <span class="string">.Values.imagePullSecrets</span> &#125;&#125;</span><br><span class="line">      <span class="attr">imagePullSecrets:</span></span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">8</span> &#125;&#125;</span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> &#123;&#123; <span class="string">.Chart.Name</span> &#125;&#125;</span><br><span class="line">          <span class="attr">image:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; .Values.image.repository &#125;&#125;</span>:<span class="template-variable">&#123;&#123; .Values.image.tag | default .Chart.AppVersion &#125;&#125;</span>&quot;</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> &#123;&#123; <span class="string">.Values.image.pullPolicy</span> &#125;&#125;</span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> &#123;&#123; <span class="string">.Values.service.portName</span> &#125;&#125;</span><br><span class="line">              <span class="attr">containerPort:</span> &#123;&#123; <span class="string">.Values.service.port</span> &#125;&#125;</span><br><span class="line">          <span class="attr">envFrom:</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">if</span> <span class="string">.Values.configOverrides</span> &#125;&#125;</span><br><span class="line">            <span class="bullet">-</span> <span class="attr">configMapRef:</span></span><br><span class="line">                <span class="attr">name:</span> &#123;&#123; <span class="string">include</span> <span class="string">&quot;think-manifesto.fullname&quot;</span> <span class="string">.</span> &#125;&#125;<span class="string">-configmap</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">if</span> <span class="string">.Values.secretOverrides</span> &#125;&#125;</span><br><span class="line">            <span class="bullet">-</span> <span class="attr">secretRef:</span></span><br><span class="line">                <span class="attr">name:</span> &#123;&#123; <span class="string">include</span> <span class="string">&quot;think-manifesto.fullname&quot;</span> <span class="string">.</span> &#125;&#125;<span class="string">-secret</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">          &#123;&#123;<span class="bullet">-</span> <span class="string">with</span> <span class="string">.Values.livenessProbe</span> &#125;&#125;</span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">12</span> &#125;&#125;</span><br><span class="line">          &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">          &#123;&#123;<span class="bullet">-</span> <span class="string">with</span> <span class="string">.Values.readinessProbe</span> &#125;&#125;</span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">12</span> &#125;&#125;</span><br><span class="line">          &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            &#123;&#123;<span class="bullet">-</span> <span class="string">toYaml</span> <span class="string">.Values.resources</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">12</span> &#125;&#125;</span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">with</span> <span class="string">.Values.nodeSelector</span> &#125;&#125;</span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">8</span> &#125;&#125;</span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">with</span> <span class="string">.Values.affinity</span> &#125;&#125;</span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">8</span> &#125;&#125;</span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">with</span> <span class="string">.Values.tolerations</span> &#125;&#125;</span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">        &#123;&#123;<span class="bullet">-</span> <span class="string">toYaml</span> <span class="string">.</span> <span class="string">|</span> <span class="string">nindent</span> <span class="number">8</span> &#125;&#125;</span><br><span class="line">      &#123;&#123;<span class="bullet">-</span> <span class="string">end</span> &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至于values.yaml我就不给出来了，基本上是其他模板需要什么就写在上面就好了。</p><p>和Kustomize相比,helm安装第三方chart很方便，它有自己的仓库，这里附上我安装traefik2的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 添加traefiK仓库</span><br><span class="line">helm repo add traefik   https:&#x2F;&#x2F;traefik.github.io&#x2F;charts    </span><br><span class="line">#添加国内仓库       </span><br><span class="line">helm repo add stable http:&#x2F;&#x2F;mirror.azure.cn&#x2F;kubernetes&#x2F;charts       </span><br><span class="line">helm repo add aliyun https:&#x2F;&#x2F;kubernetes.oss-cn-hangzhou.aliyuncs.com&#x2F;charts       </span><br><span class="line">helm repo update       </span><br><span class="line">helm repo list</span><br><span class="line"></span><br><span class="line">helm install --set deployment.kind&#x3D;DaemonSet --set namespaceOverride&#x3D;traefik --set service.enabled&#x3D;false traefik traefik&#x2F;traefik</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="本地验证"><a href="#本地验证" class="headerlink" title="本地验证"></a>本地验证</h4><p>当你写好了上面的chart之后,如果你本地没有kubernetes环境(因为它可能在服务器才存在),而你又想要在本地进行验证你写得是否有问题，那么可以使用下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将下面的变量替换成你自己的。 chart-name表示chart的名字,chart-dir表示chart地址</span><br><span class="line">helm template --dry-run --debug --disable-openapi-validation $&#123;chart-name&#125; .\$&#123;chart-dir&#125;\</span><br></pre></td></tr></table></figure><p>然后如果你想要在k8s环境中安装的时候,而k8s环境又在远端服务器,那么你可以将chart打包，然后到服务器中进行安装，然后也可以在<br>将chart上传到服务器中，然后进行安装(服务器中要先安装helm)。</p><h3 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h3><p>自此,从springcloud迁移到k8s集群总算是完成了。因为是第一次使用helm(以前都用的kustomize),所以在helm这里耗费了一些功夫，主要是排查错误方面的,不过不得不说helm的文档写得不错，很清晰。</p><p>再然后就是代码改造以及一些配置问题,因为迁移azure,所以上面的关于它pipeline的一些配置不是很清楚，不过好在可以直接练习他们的运维,还是帮我们解决了一些问题的。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;之前项目使用的是springcloud,主要使用到的组件有 spring gateway, nacos, minio, load</summary>
        
      
    
    
    
    
    <category term="springcloud" scheme="http://yoursite.com/tags/springcloud/"/>
    
    <category term="springboot" scheme="http://yoursite.com/tags/springboot/"/>
    
    <category term="k8s" scheme="http://yoursite.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>这次上线我花了12个小时</title>
    <link href="http://yoursite.com/2023/05/11/deployment-spend-a-day/"/>
    <id>http://yoursite.com/2023/05/11/deployment-spend-a-day/</id>
    <published>2023-05-11T01:58:08.000Z</published>
    <updated>2024-11-13T02:21:33.034Z</updated>
    
    <content type="html"><![CDATA[<h3 id="迁移思路"><a href="#迁移思路" class="headerlink" title="迁移思路"></a>迁移思路</h3><p>这次上线比较复杂,线上有两个服务,A和B, A服务部署在生产环境(姑且叫做Prod-1), B服务部署到QA环境,当时客户催得急,被当做生产使用了。现在要做的就是将A,B两个服务迁移到C这个正式的生产环境(称作Prod-2)。</p><p>服务主要依赖两个外部组件,一个是minio,一个是mysql数据库(部署到Azure云平台上), 经过讨论  Prod-2环境要使用的minio仍然沿用Prod-1使用的,mysql数据库则使用新的。</p><p>意味着我们需要将QA环境的minio数据迁移到Prod-2的minio(和Prod-1使用的同一个), 需要将QA环境的mysql数据和Prod-1环境的mysql数据迁移到Prod-2,但是由于QA和Prod-1是不同的两个服务,所用的表均不一样,所以sql没有冲突。</p><a id="more"></a><h3 id="minio迁移"><a href="#minio迁移" class="headerlink" title="minio迁移"></a>minio迁移</h3><p>minio数据是以文件方式存储到服务器上的,所以我们只需要将文件迁移过来,然后保证路径不变就行了(bucket name变动没有问题),因此最开始就调研到了两种方案,一种是使用scp进行文件迁移,一种是使用rclone,但是QA环境minio和prod-1环境所在minio网络不能直接通,让运维给开通,他说有问题(这里我当时没多想下,多想下就不得有这样问题了),所以就只能采用scp方式。 先将QA minio数据拷贝到跳板机,然后从跳板机拷贝到生产环境。 </p><h4 id="SCP-amp-CP"><a href="#SCP-amp-CP" class="headerlink" title="SCP &amp; CP"></a>SCP &amp; CP</h4><p>使用的SCP命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1。 将文件从远程复制到本地</span><br><span class="line">// 将qa环境中的minio数据复制到当前目录(在跳板机运行的命令), sc-qa指的是bucket名字</span><br><span class="line"> sudo scp -r  scadmin@10。2。0。4:/data/minio/data/sc-qa 。</span><br><span class="line"></span><br><span class="line">// 将文件夹复制到prod环境所在目录(在跳板机运行命令),先放到一个目录中</span><br><span class="line">sudo scp -r sc-qa/ scadmin@10。2。0。5:/home/scadmin/sc-qa</span><br><span class="line"></span><br><span class="line">// 下面都在prod执行,先将现在的minio数据备份</span><br><span class="line">sudo cp -r  /data/minio/data/sc-prod /data/minio/data/sc-prod-bak-20230311-zy</span><br><span class="line"></span><br><span class="line">// 将sc-qa的数据递归开呗到sc-prod中,如果存在重复数据,会在文件名后添加一个 ~1~</span><br><span class="line">sudo cp -frap --backup=number /home/scadmin/sc-qa/* /data/minio/data/sc-prod/</span><br><span class="line"></span><br><span class="line">// 找出重复数据</span><br><span class="line">find /data/minio/data/sc-prod -<span class="built_in">type</span> f -regex <span class="string">&quot;。*\。~1~&quot;</span></span><br></pre></td></tr></table></figure><p>找到重复数据后,这个时候我们只能重命名文件名,然后修改对应数据库记录,不过好在,未发现重复记录。</p><p>最开始使用SCP方式文件大小和拷贝前一致,但是在界面就是打不开,说文件已被损坏,后来通过对比发现,虽然文件大小一样,但是不知道为什么拷贝过来的文件中但是有些字节发生了改变,导致文件无法打开了。</p><p>于是考虑使用winscp来移动数据,但是文件比较大,网络又有问题,总是中断,在重试了2个小时后作罢。</p><p>开始怀疑scp有什么问题,后来让运维帮我把目录导过来,还是一样的问题,这个方案只能就此作罢,但是我在dev环境下使用scp是可以的,不知道为什么,如果有知道的老哥麻烦给我讲下。</p><p>此时时间来到了下午。</p><h4 id="rclone"><a href="#rclone" class="headerlink" title="rclone"></a>rclone</h4><p>后面没办法只能采用rclone的方式,之前不是说两个网络不能通吗? 后来想想就让运维将qa环境开了一个外网,这样就可以了。于是开始使用rclone,首先需要安装好rclone, 我的rclone是安装在用户目录下的,所以编辑用户目录下的 <code>~/。config/rclone/rclone。conf</code>文件</p><p>配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[oldminio]</span><br><span class="line">type &#x3D; s3</span><br><span class="line">provider &#x3D; Minio</span><br><span class="line">env_auth &#x3D; false</span><br><span class="line">access_key_id &#x3D; bvfs</span><br><span class="line">secret_access_key &#x3D; BvFs2022</span><br><span class="line">region &#x3D; cn-east-1</span><br><span class="line"># qa环境的minio外网地址</span><br><span class="line">endpoint &#x3D; http:&#x2F;&#x2F;20。xx。xx。xx:9000</span><br><span class="line">location_constraint &#x3D;</span><br><span class="line">server_side_encryption &#x3D;</span><br><span class="line"></span><br><span class="line">[newminio]</span><br><span class="line">type &#x3D; s3</span><br><span class="line">provider &#x3D; Minio</span><br><span class="line">env_auth &#x3D; false</span><br><span class="line">access_key_id &#x3D; minioadmin</span><br><span class="line">secret_access_key &#x3D; minioadmin</span><br><span class="line">region &#x3D; cn-east-1</span><br><span class="line">&#x2F;&#x2F; 生产环境minio地址</span><br><span class="line">endpoint &#x3D; http:&#x2F;&#x2F;10。1。1。5:9000</span><br><span class="line">location_constraint &#x3D;</span><br><span class="line">server_side_encryption &#x3D;</span><br></pre></td></tr></table></figure><p>解释下access_key_id和secret_access_key这两个值是你项目中配置minio的accessKey和secretKey的值。</p><p>上面的配置文件是在prod minio服务器配置的。</p><p>然后使用 rclone copy命令进行文件复制,因为我们不能删除prod目录的文件。在运行这个命令之前,强烈建议使用 –dry-run 来测试下(它不会copy任何东西)</p><p>使用rclone后,minio文件同步成功,且能正确打开。</p><h3 id="Mysql同步"><a href="#Mysql同步" class="headerlink" title="Mysql同步"></a>Mysql同步</h3><p>以为mysql同步总要好点,结果还是很坑。 因为我们的mysql也是不同的环境,而且使用navicate无法连接上,于是我只能使用idea自带的database进行连接,先将qa数据库数据导出,然后在导入。 </p><p>但是导入的时候发现太慢了(一个文件一千多行sql),经常一个文件执行就半个小时,可是好多个文件,就算把idea的事务换成手动提交还是很慢,这里又折腾了许久,发现自己还是不行。</p><p>只能把sql给运维,让他到mysql所在服务器执行去了,通过source命令, 它几分钟就搞定了。</p><p>但是进行验证的时候,发现有些数据序号错乱了,因为数据库有些表字段是自增的,在idea中导出的时候不会导出自增字段,这就导致了在源数据库的自增值和新的不一致,因为源数据库的数据可能会删除掉,然后自增值就不是连续的了,导入到新的库,这个值就变成连续的,就知道两边不一致,这个坑也把我整到了,所以又只能重新导数据。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>下班的时候已经是晚上十点钟了,宵夜都吃过一次了,回首这次上线感觉被坑了许多,复盘这次上线,最重要的是记得要在dev环境充分预演下上线流程,一定要使用相同方案!</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;迁移思路&quot;&gt;&lt;a href=&quot;#迁移思路&quot; class=&quot;headerlink&quot; title=&quot;迁移思路&quot;&gt;&lt;/a&gt;迁移思路&lt;/h3&gt;&lt;p&gt;这次上线比较复杂,线上有两个服务,A和B, A服务部署在生产环境(姑且叫做Prod-1), B服务部署到QA环境,当时客户催得急,被当做生产使用了。现在要做的就是将A,B两个服务迁移到C这个正式的生产环境(称作Prod-2)。&lt;/p&gt;
&lt;p&gt;服务主要依赖两个外部组件,一个是minio,一个是mysql数据库(部署到Azure云平台上), 经过讨论  Prod-2环境要使用的minio仍然沿用Prod-1使用的,mysql数据库则使用新的。&lt;/p&gt;
&lt;p&gt;意味着我们需要将QA环境的minio数据迁移到Prod-2的minio(和Prod-1使用的同一个), 需要将QA环境的mysql数据和Prod-1环境的mysql数据迁移到Prod-2,但是由于QA和Prod-1是不同的两个服务,所用的表均不一样,所以sql没有冲突。&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>面试官问我MySQL的行格式是怎样的</title>
    <link href="http://yoursite.com/2022/05/07/mysql-row-format/"/>
    <id>http://yoursite.com/2022/05/07/mysql-row-format/</id>
    <published>2022-05-07T01:44:26.000Z</published>
    <updated>2024-11-13T02:21:33.042Z</updated>
    
    <content type="html"><![CDATA[<p>行格式(row format)决定了我们插入的一行数据，是如何存储在数据库中的，MySQL有4种行格式，分别是REDUNDANT，COMPACT，DYNAMIC，COMPRESSED。</p><p>不同行格式区别:</p><table><thead><tr><th>行格式</th><th>紧凑存储</th><th>增强可变长度列存储</th><th>大索引键前缀</th><th>压缩支持</th><th>支持的表空间类型</th><th>所需文件格式</th></tr></thead><tbody><tr><td>REDUNDANT</td><td>否</td><td>否</td><td>否</td><td>否</td><td>system, file-per-table, general</td><td>Antelope or Barracuda</td></tr><tr><td>COMPACT</td><td>是</td><td>否</td><td>否</td><td>否</td><td>system, file-per-table, general</td><td>Antelope or Barracuda</td></tr><tr><td>DYNAMIC</td><td>是</td><td>是</td><td>是</td><td>否</td><td>system, file-per-table, general</td><td>Barracuda</td></tr><tr><td>COMPRESSED</td><td>是</td><td>是</td><td>是</td><td>是</td><td>file-per-table, general</td><td>Barracuda</td></tr></tbody></table><a id="more"></a><p>MySQL 5.7默认使用的是Dynamic的行格式。</p><p>我们可以在创建表的时候指定字符集和行格式。</p><blockquote><p>字符集表示我们插入的字符是用几个字节编码的，比如ASCII用一个字节，GB2312用2个字节,utf8使用3个字节,utf8mb4用4个字节(如果存储emoj表情就要用这个字符集)</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`price`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`code`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 ROW_FORMAT=Dynamic;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在讲下面行格式的时候，我们使用这个表进行讲解</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> record_format_demo (</span><br><span class="line"> c1 <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line"> c2 <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"> c3 <span class="built_in">CHAR</span>(<span class="number">10</span>),</span><br><span class="line"> c4 <span class="built_in">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">) <span class="keyword">CHARSET</span>=<span class="keyword">ascii</span> ROW_FORMAT=Redundant;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> record_format_demo(c1, c2, c3, c4) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="string">&#x27;aaaa&#x27;</span>, <span class="string">&#x27;bbb&#x27;</span>, <span class="string">&#x27;cc&#x27;</span>, <span class="string">&#x27;d&#x27;</span>), </span><br><span class="line">  (<span class="string">&#x27;eeee&#x27;</span>, <span class="string">&#x27;fff&#x27;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Redundant行格式"><a href="#Redundant行格式" class="headerlink" title="Redundant行格式"></a>Redundant行格式</h3><p>Redundant行格式是一个比较老的行格式了,现在也就只有MySQL的一些系统表会使用它了，平常咱们一般不用，但是这个行格式我觉得是能搞明白其他行格式的基础。</p><h4 id="行格式结构"><a href="#行格式结构" class="headerlink" title="行格式结构"></a>行格式结构</h4><p><img data-src="/images/mysql/mysql-innodb-record-format.png" alt="Redundant行格式"></p><p>如上图所示，整个行格式分为记录的额外信息和记录的真实数据两部分，其中记录的额外信息又分为字段长度偏移列表和记录头信息两部分。</p><ol><li>字段长度偏移列表</li></ol><p>在Redundant行格式中,会把所有字段的真实数据占⽤的字节长度都存放在记录的开头部位，从⽽形成⼀个字段长度偏移列表，字段长度占⽤的字节数按照列的顺序逆序存放,逆序存放,逆序存放！</p><ol start="2"><li><p>记录头信息<br>Redundant⾏格式的记录头信息占⽤6字节，48个⼆进制位，这些⼆进制位代表的意思如下</p><table><thead><tr><th>名称</th><th>大小(bit)</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>未使用</td></tr><tr><td>预留位2</td><td>1</td><td>未使用</td></tr><tr><td>delete_mask</td><td>1</td><td>该记录是否删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树每层非叶子节点最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>当前记录组拥有记录数</td></tr><tr><td>heap_no</td><td>13</td><td>当前记录在页面堆位置信息</td></tr><tr><td>n_field</td><td>10</td><td>记录中列数量</td></tr><tr><td>1byte_offs_flag</td><td>1</td><td>字段长度偏移列表中每个列对应的偏移量是使⽤1字节还是2字节表⽰的</td></tr><tr><td>next_record</td><td>16</td><td>下一条记录的相对位置</td></tr></tbody></table></li><li><p>真实数据</p></li></ol><p>对于record_format_demo表来说，记录的真实数据除了c1、c2、c3、c4这⼏个我们⾃⼰定义的列的数据以外，MySQL会为每个记录默认的添加⼀些列（也称为隐藏列），具体的列如下</p><ol><li>DB_ROW_ID(row_id) : 当表没有定义主键，则选择unique键作为主键，如果仍没有，则默认添加一个名为DB_ROW_ID的隐藏列作为主键，占用6个字节。也就是说这个列只有当没有主键也没有唯一索引时才存在</li><li>DB_TRX_ID(transaction_id): 事务id,占用6字节</li><li>DB_ROLL_PTR(roll_pointer): 占用7个字节,回滚指针(后面MVCC的时候会用到)</li></ol><p>所以，对我们的数据来讲，其行格式数据如下<br><img data-src="/images/mysql/innodb-redundant-row1.png" alt="数据"></p><h4 id="列长度如何计算"><a href="#列长度如何计算" class="headerlink" title="列长度如何计算"></a>列长度如何计算</h4><p>⽐如第⼀条记录的字段⻓度偏移列表就是：<br>25 24 1A 17 13 0C 06 </p><p>因为它是逆序排放的，所以按照列的顺序排列就是：<br>06 0C 13 17 1A 24 25 </p><p>计算各个列长度则按照以下方法(字符集是ascii,一个字符占用1个字节)：<br>第⼀列(<code>row_id</code>)的⻓度就是 0x06个字节，也就是6个字节。<br>第⼆列(<code>transaction_id</code>)的⻓度就是 (0x0C - 0x06)个字节，也就是6个字节。<br>第三列(<code>roll_pointer</code>)的⻓度就是 (0x13 - 0x0C)个字节，也就是7个字节。<br>第四列(<code>c1</code>)的⻓度就是 (0x17 - 0x13)个字节，也就是4个字节。<br>第五列(<code>c2</code>)的⻓度就是 (0x1A - 0x17)个字节，也就是3个字节。<br>第六列(<code>c3</code>)的⻓度就是 (0x24 - 0x1A)个字节，也就是10个字节。<br>第七列(<code>c4</code>)的⻓度就是 (0x25 - 0x24)个字节，也就是1个字节。</p><p>在记录头信息中的1byte_offs_flag用于表示 字段长度偏移列表中每个列对应的偏移量是使⽤1字节还是2字节表⽰的 ，这个值是如何计算的呢？</p><ol><li>当记录的真实数据占⽤的字节数不⼤于127（⼗六进制0x7F，⼆进制01111111）时，每个列对应的偏移量占⽤1个字节。</li><li>当记录的真实数据占⽤的字节数⼤于127，但不⼤于32767（⼗六进制0x7FFF，⼆进制0111111111111111）时，每个列对应的偏移量占⽤2个字节。</li><li>当记录大于32767的时候，此时的记录已经存放到了溢出页中，在本页中只保留前768个字节和20个字节的溢出页⾯地址（当然这20个字节中还记录了⼀些别的信息）。因为字段⻓度偏移列表处只需要记录每个列在本页⾯中的偏移就好了，所以每个列使⽤2个字节来存储偏移量就够了。</li></ol><p>我们的第一条记录真实数据总长度 = 37(6+6+7+4+3+10+1),小于127，所以采用1字节记录偏移量。为了在解析记录的时候知道列偏移量是采用1字节还是2字节表示，因此使用1byte_offs_flag来决定，当它的值为1时，表明使用1个字节存储，当值为0时，表明使用2字节存储。</p><p>需要注意下记录头信息的next_record,你可以把它理解为指针,通过它我们可以指向下一条记录的位置(多条记录是如何连接的会在下一篇文章讲到哈)，当我们指针在这个位置的时候往后读是真实数据的位置，往前读就是字段的长度列表，所以我们长度列表逆序存放就能和真实数据一一对应。<br><img data-src="/images/mysql/mysql-redundant-read-data.png" alt="读取数据"></p><h4 id="Redundant行格式对NULL值的处理"><a href="#Redundant行格式对NULL值的处理" class="headerlink" title="Redundant行格式对NULL值的处理"></a>Redundant行格式对NULL值的处理</h4><p>列对应偏移量值的第一个比特位作为列值是否为NULL的依据，当解析一条记录某个列时，首先查看这个比特位的值是否为1，如果是1，那么该列的值就是NULL，否则则不是NULL。(现在你知道为什么记录数据长度为什么会有127和32767这两个临界点了吧)</p><blockquote><p>这个bit位也可以称为NULL比特位</p></blockquote><p>对于值为NULL的列，如果是定长类型，NULL值也将占用记录的真实数据部分，数据采用0x00字节填充。如果是变长数据类型，则不在记录的真实数据处占用任何存储空间。</p><p>如上图我们的第二条数据， C3列的值是NULL,类型是CHAR(10),占⽤记录的真实数据部分10字节(，所以我们看到在Redundant⾏格式中使⽤0x00000000000000000000来表⽰NULL值。</p><p>C3列长度偏移量是0xA4，二进制是 10100100，最高位是1，表明该列值是NULL,将高位去掉变成 0100100(十进制的36)， C2列对应偏移量是0x1A(十进制的26),因此其长度是36-26=10</p><p>C4列是Varchar类型，对应偏移量是0xA4,C3列偏移量也是0XA4,表明其长度是0(不占用真实数据存储空间),而其二进制高位是1,表明该列值是NULL。</p><p>为什么定长类型NULL值也要占用固定空间呢？<br>官方文档告诉我对于一个固定长度的列，该列的固定长度被保留在记录的数据部分。为NULL值保留的固定空间允许列从NULL值更新到非NULL值，而不会引起索引页的碎片化。</p><h3 id="Compact行格式"><a href="#Compact行格式" class="headerlink" title="Compact行格式"></a>Compact行格式</h3><p>Compact行格式是Dynamic和Compressed两种行格式的基础，了解了它就了解了其他两种结构</p><h4 id="行格式结构-1"><a href="#行格式结构-1" class="headerlink" title="行格式结构"></a>行格式结构</h4><p><img data-src="/images/mysql/innodb-compact-row-format.png" alt="Compact行格式"></p><p>如上图,Compact行格式中记录额外信息分为变长字段长度列表，NULL值列表，记录头信息。</p><p>变长字段列表中存储的是非空的变长字段的数据长度,变长字段存储的数据是不固定的，所以我们需要将数据占用的字节数也存起来。 同样的，这里占用的长度也是逆序存放，逆序存放，逆序存放的。</p><blockquote><p>varchar(M),VARBINARY(M),各种TEXT以及各种BLOB类型，mysql把拥有这些数据类型的列称为变长字段</p></blockquote><h4 id="对NULL值的处理"><a href="#对NULL值的处理" class="headerlink" title="对NULL值的处理"></a>对NULL值的处理</h4><p>Redundant是将列对应偏移量值的第一个比特位作为列值是否为NULL的依据，但是在Compact中是单独有一个NULL值列表来存储值为NULL的字段。NULL值列表是如何确认的呢？</p><ol><li>首先统计表接口中允许为NULL值的列(主键和unique key是不允许为NULL的)</li><li>如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储NULL的列对应⼀个⼆进制位，⼆进制位按照列的顺序逆序排列,逆序排列,逆序排列<ul><li>⼆进制位的值为1时，代表该列的值为NULL。 </li><li>⼆进制位的值为0时，代表该列的值不为NULL。</li></ul></li><li>MySQL规定NULL值列表必须⽤整数个字节的位表⽰，如果使⽤的⼆进制位个数不是整数个字节，则在字节的⾼位补0。<blockquote><p>如果一个表中有9个允许为NULL的列,那么就需要用2个字节表示</p></blockquote></li></ol><p>对于我们上面的两条数据来说(c1,c3,c4允许为NULL)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&#39;aaaa&#39;, &#39;bbb&#39;, &#39;cc&#39;, &#39;d&#39;), </span><br><span class="line">(&#39;eeee&#39;, &#39;fff&#39;, NULL, NULL);</span><br></pre></td></tr></table></figure><p>第一条数据NULL值列表为 00000000(都不为空)<br>第二条数据NULL值列表为 00000110,c1不为null，所以是0,c3为null,所以是1，c4是null，所以是1，其倒序结果就是00000110</p><h4 id="记录头"><a href="#记录头" class="headerlink" title="记录头"></a>记录头</h4><p>和Redundant不同,Compact的记录头信息使用了5个字节(40bit)来表示记录头信息,其具体信息如下</p><table><thead><tr><th>名称</th><th>大小(bit)</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>未使用</td></tr><tr><td>预留位2</td><td>1</td><td>未使用</td></tr><tr><td>delete_mask</td><td>1</td><td>该记录是否删除</td></tr><tr><td>min_rec_mask</td><td>1</td><td>B+树每层非叶子节点最小记录都会添加该标记</td></tr><tr><td>n_owned</td><td>4</td><td>当前记录组拥有记录数</td></tr><tr><td>heap_no</td><td>13</td><td>当前记录在页面堆位置信息</td></tr><tr><td>record_type</td><td>3</td><td>表⽰当前记录的类型，0表⽰普通记录，1表⽰B+树⾮叶⼦节点记录,2表⽰最⼩记录，3表⽰最⼤记录</td></tr><tr><td>next_record</td><td>16</td><td>下一条记录的相对位置</td></tr></tbody></table><p>可以看到相比Redundant,Compact多了一个record_type的字段，少了n_field和1byte_offs_flag两个字段。 我们之前提到过 1byte_offs_flag 是用来表示 字段长度偏移列表中每个列对应的偏移量是使⽤1字节还是2字节表⽰的， 但是Compact却没有，那变长字段长度列表中字段长度到底是用1个字节表示还是2个字节表示呢？</p><h4 id="列长度如何计算-1"><a href="#列长度如何计算-1" class="headerlink" title="列长度如何计算"></a>列长度如何计算</h4><p>还记得Redundant将列对应偏移量值的第一个比特位作为列值是否为NULL的依据吗？Compact思路也是类似的，它使用字节的第一位来表示.</p><ol><li>假设某个字符集中表⽰⼀个字符最多需要使⽤的字节数为W，也就是使⽤SHOW CHARSET语句的结果中的Maxlen列，⽐⽅说utf8字符集中的W就是3，gbk字符集中的W就是2，ascii字符集中的W就是1。 </li><li>对于变长类型VARCHAR(M)来说，这种类型表⽰能存储最多M个字符（注意是字符不是字节），所以这个类型能表⽰的字符串最多占⽤的字节数就是M×W。</li><li>假设它实际存储的字符串占⽤的字节数是L。 所以确定使⽤1个字节还是2个字节表⽰真正字符串占⽤的字节数的规则就是这样：</li></ol><ul><li>如果M×W &lt;= 255，那么使⽤1个字节来表⽰真正字符串占⽤的字节数。<br>  也就是说InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最⼤字节数不⼤于255时，可以认为只使⽤1个字节来表⽰真正字符串占⽤的字节数。 </li><li>如果M×W &gt; 255，则分为两种情况： <ul><li>如果L &lt;= 127，则⽤1个字节来表⽰真正字符串占⽤的字节数。 </li><li>如果L &gt; 127，则⽤2个字节来表⽰真正字符串占⽤的字节数。<br>InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最⼤字节数⼤于255时，该怎么区分它正在读的某个字节是⼀个单独的字段长度还是半个字段长度 呢？该字节的第⼀个⼆进制位作为标志位：如果该字节的第⼀个位为0，那该字节就是⼀个单独的字段长度（使⽤⼀个字节表⽰不⼤于127(01111111)的⼆进制的第⼀个位都 为0），如果该字节的第⼀个位为1，那该字节就是半个字段长度。 对于⼀些占⽤字节数⾮常多的字段，⽐⽅说某个字段长度⼤于了16KB，那么如果该记录在单个页⾯中⽆法存储 时，InnoDB会把⼀部分数据存放到所谓的溢出页中，在变长字段长度列表处只存储留在本页⾯中的长度，所以使⽤两个字节也可以存放下来。<br>总结⼀下就是说：如果该可变字段允许存储的最⼤字节数（M×W）超过255字节并且真实存储的字节数（L）超过127字节，则使⽤2个字节，否则使⽤1个字节。</li></ul></li></ul><blockquote><p>上面的内容参考了小孩子大佬的&lt;&lt;MySQL是怎样运行的:从根儿上理解MYSQL&gt;&gt;,大家可以在掘金购买它的小册或者对应的实体书。 他是从Compact讲到Redundant的，但是我觉得从Redundant的格式到Compact<br>格式其实更容易理解,过度更容易。这也是我的一个理解，供大家参考。</p></blockquote><h3 id="行溢出"><a href="#行溢出" class="headerlink" title="行溢出"></a>行溢出</h3><p>在Compact和Reduntant⾏格式中，对于占⽤存储空间⾮常⼤的列，在记录的真实数据处只会存储该列的⼀部分数据，把剩余的数据分散存储在⼏个其他的页中，然后记录的真实数据处⽤20个字节存储指向这些页的地址（当然这20个字节中还包括这些分散在其他页⾯中的数据的占⽤的字节数），从⽽可以找到剩余数据所在的页。</p><p>对于Compact和Reduntant⾏格式来说，如果某⼀列中的数据⾮常多的话，在本记录的真实数据处只会存储该列的前768个字节的数据和⼀个指向其他页的地址(如果一个页都放不下,那么就会使用链表将多个页链接起来)，然后把剩下的数据存放 到其他页中，这个过程也叫做⾏溢出，存储超出768字节的那些页⾯也被称为溢出⻚。</p><p>需要注意的是并不仅仅只有变长字段的列才会发生行溢出，blob,text都有可能，甚至大于或等于768字节的固定长度的列也会被编码为可变长度的列，它可以被存储在页面外。例如，如果字符集的最大字节长度大于3，一个CHAR(255)列可以超过768字节，正如utf8mb4那样。</p><h3 id="Dynamic和Compressed⾏格式"><a href="#Dynamic和Compressed⾏格式" class="headerlink" title="Dynamic和Compressed⾏格式"></a>Dynamic和Compressed⾏格式</h3><p>Dynamic和Compressed⾏格式，现在使⽤的MySQL版本是5.7，它的默认⾏格式就是Dynamic，这俩⾏格式和Compact⾏格式挺像，只不过在处理⾏溢出数据时有点⼉分歧，它们不会在记录的真实数据处存储字段真实数据的前768个字节，⽽是把所有的字节都存储到其他页⾯中，只在记录的真实数据处存储其他页⾯的地</p><p><img data-src="/images/mysql/innodb-overflow-page.png" alt="溢出页"></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ol><li>&lt;&lt;MySQL是怎样运行的:从根儿上理解MYSQL&gt;&gt;</li><li>官方文档: <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html</a></li><li>官方文档: <a href="https://dev.mysql.com/doc/internals/en/innodb-field-contents.html">https://dev.mysql.com/doc/internals/en/innodb-field-contents.html</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;行格式(row format)决定了我们插入的一行数据，是如何存储在数据库中的，MySQL有4种行格式，分别是REDUNDANT，COMPACT，DYNAMIC，COMPRESSED。&lt;/p&gt;
&lt;p&gt;不同行格式区别:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;行格式&lt;/th&gt;
&lt;th&gt;紧凑存储&lt;/th&gt;
&lt;th&gt;增强可变长度列存储&lt;/th&gt;
&lt;th&gt;大索引键前缀&lt;/th&gt;
&lt;th&gt;压缩支持&lt;/th&gt;
&lt;th&gt;支持的表空间类型&lt;/th&gt;
&lt;th&gt;所需文件格式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;REDUNDANT&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;system, file-per-table, general&lt;/td&gt;
&lt;td&gt;Antelope or Barracuda&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;COMPACT&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;system, file-per-table, general&lt;/td&gt;
&lt;td&gt;Antelope or Barracuda&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DYNAMIC&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;system, file-per-table, general&lt;/td&gt;
&lt;td&gt;Barracuda&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;COMPRESSED&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;file-per-table, general&lt;/td&gt;
&lt;td&gt;Barracuda&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>老生常谈：如何在MySQL中查找数据</title>
    <link href="http://yoursite.com/2022/04/06/mysql-page-in-memory/"/>
    <id>http://yoursite.com/2022/04/06/mysql-page-in-memory/</id>
    <published>2022-04-06T10:04:19.000Z</published>
    <updated>2024-11-13T02:21:33.042Z</updated>
    
    <content type="html"><![CDATA[<h3 id="页的组成部分"><a href="#页的组成部分" class="headerlink" title="页的组成部分"></a>页的组成部分</h3><p>数据库中表的数据被划分为若各个页(page),每个页中又存储了很多行记录，而我们往MySQL中插入的每行记录就放到页当中的行记录中,InnoDB的页分为以下几个部分</p><p><img data-src="/images/mysql/innodb-page.png" alt="InnoDB页"></p><p>InnoDB的页被划分为了7个部分，有的部分大小是确定的，有的部分不确定，各个部分说明如下</p><ol><li>File Header，表⽰页的⼀些通⽤信息，占固定的38字节。 </li><li>Page Header，表⽰数据页专有的⼀些信息，占固定的56个字节。 </li><li>Infimum + Supremum，两个虚拟的伪记录，分别表⽰页中的最⼩和最⼤记录，占固定的26个字节。 </li><li>User Records：真实存储我们插⼊的记录的部分，⼤⼩不固定。 </li><li>Free Space：页中尚未使⽤的部分，⼤⼩不确定。 </li><li>Page Directory：页中的某些记录相对位置，也就是各个槽在页⾯中的地址偏移量，⼤⼩不固定，插⼊的记录越多，这个部分占⽤的空间越多。 </li><li>File Trailer：⽤于检验页是否完整的部分，占⽤固定的8个字节。</li></ol><a id="more"></a><p>在页的7个组成部分中，我们⾃⼰存储的记录会按照我们指定的⾏格式存储到User Records部分。但是在⼀开始⽣成页的时候，其实并没有User Records这个部分，每当我们插⼊⼀条记录，都会从Free Space部分，也就是尚未使⽤的存储空间中申请⼀个记录⼤⼩的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使⽤完了，如果还有新的 记录插⼊的话，就需要去申请新的页了。</p><p>我们往User Records部分插入记录的时候，是直接在现有行的末尾(在顶部可用空间部分)或者删除行留下空间的任何地方插入，而并不是按照主键顺序插入新行(设计到大量数据的移动)。</p><blockquote><p>删除一条数据的时候mysql并不会马上将其中的数据回收，而是将这条记录置为已删除，下次插入新数据的时候就会重用这部分空间<br>但是为了更好的管理页中的记录,MySQL保证了页中的记录在逻辑上是有序的，这是如何做到的呢？</p></blockquote><p>行记录格式中有一个next_record字段,它表⽰从当前记录的真实数据到下⼀条记录的真实数据的地址偏移量。⽐⽅说第⼀条记录的next_record值为32，意味着从第⼀条记录的真实数据的地址处向后找32个字节便是 下⼀条记录的真实数据。</p><blockquote><p>关于行格式可以参见我的上一篇文章</p></blockquote><p>如果你熟悉数据结构的话，就⽴即明⽩了，这其实是个链表，可以通过⼀条记录找到它的下⼀条记录。但是需要注意注意再注意的⼀点是，下⼀条记录指得并不是按照我们插⼊顺序的下⼀条记录，⽽是按照主键值由⼩到⼤的顺序的下⼀条记录。</p><p>⽽且规定 Infimum记录（也就是最⼩记录） 的下⼀条记录就是本页中主键值最⼩的⽤户记录，⽽本页中主键值最⼤的⽤户记 录的下⼀条记录就是 Supremum记录（也就是最⼤记录） ，为了更形象的表⽰⼀下这个next_record起到的作⽤，我们⽤箭头来替代⼀下next_record中的地址偏移量</p><p><img data-src="/images/mysql/next-record.png" alt="next-record"></p><p>同时无论增删改任何一个操作，mysql都会保证这个链表的数据是自增的。</p><h4 id="页目录"><a href="#页目录" class="headerlink" title="页目录"></a>页目录</h4><p>当我们在一个页中查询数据的时候只用从最小记录开始往后遍历就能找到我们需要的记录了，但是如果一个页中记录数少还好，如果数据比较多，这样查找下来就比较耗费性能了，mysql当然不会这么干。</p><p>我们平常想从⼀本书中查找某个内容的时候，⼀般会先看⽬录，找到需要查找的内容对应的书的页码，然后到对应的页码查看内容。InnoDB为我们的记录也制作了⼀个类似的⽬录，他们的制作过程是这样的</p><ol><li>将所有正常的记录（包括最⼤和最⼩记录，不包括标记为已删除的记录）划分为⼏个组</li><li>每个组的最后⼀条记录（也就是组内最⼤的那条记录）的头信息中的n_owned属性表⽰该记录拥有多少条记录，也就是该组内共有⼏条记录。</li><li>将每个组的最后⼀条记录的地址偏移量单独提取出来按顺序存储到靠近⻚的尾部的地⽅</li></ol><p>这个地⽅就是所谓的Page Directory，也就是⻚⽬录（此时应该返回头看看页⾯各个部分的图）。页⾯⽬录中 的这些地址偏移量被称为槽（英⽂名：Slot）或者目录槽，所以这个页⾯⽬录就是由槽组成的。</p><p><img data-src="/images/mysql/page-directory-slot.png" alt="页目录"></p><p>从这个图中我们需要注意这么⼏点： </p><ol><li>现在⻚⽬录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最⼤记录的地址偏移量（就是从页⾯的0字节开始数，数112个字节；槽0中的值是99，代表最⼩记录的地址偏移量。 </li><li>注意最⼩和最⼤记录的头信息中的n_owned属性 最⼩记录的n_owned值为1，这就代表着以最⼩记录结尾的这个分组中只有1条记录，也就是最⼩记录本⾝。 最⼤记录的n_owned值为5，这就代表着以最⼤记录结尾的这个分组中只有5条记录，包括最⼤记录本⾝还有我们⾃⼰插⼊的4条记录。 </li></ol><p>现在我们就可以二分法查找页中的记录了。</p><p>比如我想查id=4的数据,怎么查呢？ 现在有2个slot,分别是0和1,所以 设 low = 0, high = 1。</p><ol><li>mid = (low + high) /2, 此时mid=0,查看 slot0对应记录的主键值是最小值，所以 high不变，low = 1</li><li>按照第一步公式重新计算mid=1,此时查看slot1对应主键值为supremum,大于我们要查找的主键4,因此数据肯定在slot1这个分组中</li><li>现在我们只需要从slot1中最小的记录开始遍历链表即可找到我们要的那条数据了。由于slot都是挨着的，所以slot0的下一条数据就是slot1中最小的那条数据，我们就从这条数据开始遍历就行了。</li></ol><p>为了效率，每个slot组中的记录数并不会太多，关于分组，innodb有这样的规则</p><ol><li>对于最⼩记录所在的分组只能有 1 条记录，最⼤记录所在的分组拥有的记录条数只能在1到8条之间，剩下的分组中记录的条数范围只能在4到8条之间。</li></ol><p>所以分组是按照下边的步骤进⾏的： 初始情况下⼀个数据页⾥只有最⼩记录和最⼤记录两条记录，它们分属于两个分组。 之后每插⼊⼀条记录，都会从⻚⽬录中找到主键值⽐本记录的主键值⼤并且差值最⼩的槽，然后把该槽对应的记录的n_owned值加1，表⽰本组内又添加了⼀条记录，直到该组中的记录数等于8个。</p><p>在⼀个组中的记录数等于8个后再插⼊⼀条记录时，会将组中的记录拆分成两个组，⼀个组中4条记录，另⼀个5条记录。这个过程会在⻚⽬录中新增⼀个槽来记录这个新增分组中最⼤的那条记录的偏移量。</p><h4 id="Page-Header-页面头部"><a href="#Page-Header-页面头部" class="headerlink" title="Page Header(页面头部)"></a>Page Header(页面头部)</h4><p>为了能得到⼀个数据页中存储的记录的状态信息，⽐如本页中已经存储了多少条记录，第⼀条记录的地址是什么，页⽬录中存储了多少个槽等等，特意在页中定义了⼀个叫Page Header的部分，它是⻚结构的第⼆部分，这个部分占⽤固定的56个字节，专门存储各种状态信息，包括但不限于以下内容</p><ol><li>页目录中槽数量</li><li>还未使⽤的空间最⼩地址，也就是说从该地址之后就是Free Space</li><li>本页中的记录的数量（包括最⼩和最⼤记录以及标记为删除的记录）</li><li>第⼀个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成⼀个单链表，这个单链表中的记录可以被重新利⽤）</li><li>已删除记录占⽤的字节数</li><li>最后插⼊记录的位置</li><li>该页中记录的数量（不包括最⼩和最⼤记录以及被标记为删除的记录）</li><li>当前页在B+树中所处的层级</li><li>索引ID，表⽰当前页属于哪个索引</li></ol><p>从这些记录的内容可以看出来，页中的状态值以及属性值还是蛮多的，它们占用固定的大小，可见为了充分利用内存，大佬们费了多少心。</p><h4 id="File-Header-文件头部"><a href="#File-Header-文件头部" class="headerlink" title="File Header(文件头部)"></a>File Header(文件头部)</h4><p>File Header针对各种类型的页都通⽤，也就是说不同类型的页都会 以File Header作为第⼀个组成部分，它描述了⼀些针对各种页都通⽤的⼀些信息，⽐⽅说这个页的编号是多少，它的上⼀个页、下⼀个页是谁等等。</p><ol><li>页的校验和</li><li>当前页页号(InnoDB通过页号来可以唯⼀定位⼀个⻚)</li><li>上一个页页号</li><li>下一个页页号</li><li>页面被最后修改时对应的日志序列位置(Log Sequence Number)</li><li>页类型</li><li>属于哪个表空间</li></ol><p>页类型分很多种，比如undo日志页，系统页，索引页，blob页等，我们存放记录的数据页的类型就是所谓的索引⻚。</p><p>而通过上一页，下一页,存储数据的页就形成了一个双向链表了。</p><p><img data-src="/images/mysql/innodb-page-next.png" alt="双向链表数据页"></p><p>需要注意的是当一个页已经满了之后，新插入的记录就需要插入到新的页中，由于必须满足下⼀个数据页中⽤户记录的主键值必须⼤于上⼀个页中⽤户记录的主键值的要求，所以插入的过程就会伴随着数据的移动。</p><p>假设页A只能插入3条数据(注意实际上能插入很多),分别是1,3,5。现在要插入一条数据4，由于页A已经满了，所以需要将数据插入页B中，由于下一个数据页的主键值必须大于上一页的主键值，所以要现在5这条数据移动到页B中，然后再把4这条数据插入到页A中。</p><h4 id="File-Trailer-文件尾部"><a href="#File-Trailer-文件尾部" class="headerlink" title="File Trailer(文件尾部)"></a>File Trailer(文件尾部)</h4><p>InnoDB存储引擎会把数据存储到磁盘上，但是磁盘速度太慢，需要以⻚为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘 中。但是在同步了⼀半的时候中断电了咋办，这不是莫名尴尬么？</p><p>为了检测⼀个页是否完整（也就是在同步的时候有没有发⽣只同步⼀半的尴尬情况），File Trailer应运而生，这个部分由8个字节组成，可以分成2个⼩部分： </p><p>前4个字节代表页的校验和 这个部分是和File Header中的校验和相对应的。每当⼀个页⾯在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页⾯的前边，所以校验和会被⾸先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的⾸部和尾部的校验和应该是⼀致的。<br>如果写了⼀半⼉断电了，那么在File Header中的校验和就代表着已经修改过的页，⽽在File Trialer中的校验和代表着原先的页，⼆者不同则意味着同步中间出了错。 </p><p>后4个字节代表页⾯被最后修改时对应的⽇志序列位置（LSN） 这个部分也是为了校验页的完整性的，只不过我们⽬前还没说LSN是个什么意思，所以⼤家可以先不⽤管这个属性。<br>这个File Trailer与File Header类似，都是所有类型的页通⽤的。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>现在我们知道了如何在一个页中快速查找某一条数据,但是如果我们的数据量很大，分散在很多页中，那应该如何查找呢？ 只能一页一页进行遍历吗？</p><p>当然不是，我们同样可以借鉴书本目录的做法，给数据页建立一个索引目录结构。</p><p><img data-src="/images/mysql/innodb-index-page.png" alt="索引页"></p><p>从图中可以看出来，我们新分配了⼀个编号为30的页来专门存储⽬录项记录。这⾥再次强调⼀遍⽬录项记录和普通的⽤户记录的不同点：</p><ol><li>⽬录项记录的record_type值是1，⽽普通⽤户记录的record_type值是0。</li><li>⽬录项记录只有主键值和页的编号两个列，⽽普通的⽤户记录的列是⽤户⾃⼰定义的，可能包含很多列，另外还有InnoDB⾃⼰添加的隐藏列。</li></ol><p>上面的图中为了简单，隐藏了最大最小记录，没有画出来并不代表没有哈。</p><p>虽然说⽬录项记录中只存储主键值和对应的页号，⽐⽤户记录需要的存储空间⼩多了，但是不论怎么说⼀个页只有16KB⼤⼩，能存放的⽬录项记录也是有限的，那如果表中的数据太多，以⾄于⼀个数据页不<br>⾜以存放所有的⽬录项记录，该咋办呢？当然是再多整⼀个存储⽬录项记录的页</p><p><img data-src="/images/mysql/innodb-index-page-2.png" alt="索引页"></p><p>当我们存储的记录越多，那么目录项记录也就越多，存储目录项的页也就越多，好像这就又回到了最初的问题，那又怎么解决呢？ 还是同样的解法，给这些目录项的页生成一个更高层的目录就行了，就如下图</p><p><img data-src="/images/mysql/innodb-index-multi-page.png" alt="多级目录"></p><p>这样当我们要查询某个值的时候，直接从最顶层开始过滤，然后沿着这个目录结构过滤就行了。</p><p>你看看这个结构是不是很熟悉，就是一颗咱们熟悉的树嘛，这个数据结构叫B+树。<br><img data-src="/images/mysql/innodb-b-tree.png" alt="B+树"></p><p>不论是存放⽤户记录的数据页，还是存放⽬录项记录的数据页，我们都把它们存放到B+树这个数据结构中了，所以我们也称这些数据页为节点。从图中可以看出来，我们的实际⽤户记录其实都存放在<br>B+树的最底层的节点上，这些节点也被称为叶⼦节点或叶节点，其余⽤来存放⽬录项的节点称为⾮叶⼦节点或者内节点，其中B+树最上边的那个节点也称为根节点。</p><p>上面建立的索引有两个特点</p><ol><li>所有数据(包括隐藏列)都存储在叶子节点中(最底层节点)</li><li>无论是页内的记录还是页都是按照主键进行排序的</li></ol><p>我们把具有这两种特性的B+树称为聚簇索引，所有完整的⽤户记录都存放在这个聚簇索引的叶⼦节点处。InnoDB存储引擎会⾃动的为我们创建聚簇索引。</p><h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>上面的聚簇索引，只有搜索条件是主键的时候才能发挥作用，因为B+树中数据是按照主键进行排序的。如果我有下面的表,给a建立了一个索引，应该如何处理？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> idx_a(a),</span><br><span class="line">  <span class="keyword">KEY</span> idx_a_b(a,b)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在InnoDB中，会为每个索引都创建一个B+树，排序规则则是按照索引列进行排序的，比如我们根据a建立了一个索引，那么这颗B+树就长这样</p><p><img data-src="/images/mysql/innodb-second-page-index.png" alt="二级索引"></p><p>这个B+树和上面聚簇索引有几点不同。</p><ol><li>页内的记录是按照列a的⼤⼩顺序排成⼀个单向链表。</li><li>各个存放⽤户记录的页也是根据页中记录的列a⼤⼩顺序排成⼀个双向链表。</li><li>存放⽬录项记录的页分为不同的层次，在同⼀层次中的页也是根据页中⽬录项记录的列a⼤⼩顺序排成⼀个双向链表。</li><li>B+树的叶⼦节点存储的并不是完整的⽤户记录，⽽只是列a+主键这两个列的值</li><li>⽬录项记录中不再是主键+⻚号的搭配，⽽变成了列a+主键id+⻚号的搭配</li></ol><p>目录项记录为什么是列a+主键id+页号，而不是列a+页号呢？ </p><p>假设我们目录项记录是 列a+页号，当我们在插入一条数据 （13,4,8)的时候，这条数据应该放入到页36还是页37呢？ 这两个页中都有a=4的数据呢，innodb也不知道，所以为了为了让新插⼊记录能找到⾃⼰在那个页⾥，我们需要保证在B+树的同⼀层节点的⽬录项记录除⻚号这个字段以外是唯⼀的。因此目录项记录是 列a+id+页号。</p><p>我们再插⼊记录(13, 4, 8)时，由于⻚35中存储的⽬录项记录是由列a + 主键 + ⻚号的值构成的，可以先把新记录的列a的值和⻚35中各⽬录项记录的列a的值作⽐较，如果列a的值相同的话，可以<br>接着⽐较主键值，因为B+树同⼀层中不同⽬录项记录的列a + 主键的值肯定是不⼀样的，所以最后肯定能定位唯⼀的⼀条⽬录项记录，在本例中最后确定新记录应该被插⼊到⻚37中。</p><p>现在B+树有了，那么我们应该怎么搜索呢？</p><p>以查找列a的值为4的记录为例，查找过程如下：</p><ol><li>确定⽬录项记录页,根据根⻚⾯，也就是⻚35，可以快速定位到⽬录项记录所在的页为⻚37。</li><li>通过⽬录项记录页确定⽤户记录真实所在的页。<br>在⻚37中可以快速定位到实际存储⽤户记录的页，但是由于列a并没有唯⼀性约束，所以列a值为4的记录可能分布在多个数据页中，又因为2 &lt; 4 ≤ 4，所以确定实际存储⽤户记录的页在⻚36和⻚<br>37中。</li><li>在真实存储⽤户记录的页中定位到具体的记录。到⻚36和⻚37中定位到具体的记录。</li><li>但是这个B+树的叶⼦节点中的记录只存储了a和id（也就是主键）两个列，所以我们必须再根据主键值去聚簇索引中再查找⼀遍完整的⽤户记录。</li></ol><p>根据这个以列a⼤⼩排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据列a的值查找到完整的⽤户记录的话，仍然需要到聚簇索引中再查⼀遍，这个过程也被称为回表。<br>也就是根据列a的值查询⼀条完整的⽤户记录需要使⽤到2棵B+树！！！</p><p>为什么我们还需要⼀次回表操作呢？直接把完整的⽤户记录放到叶⼦节点不就好了么？你说的对，如果把完整的⽤户记录放到叶⼦节点是可以不⽤回表，但是太占地⽅了呀～相当于每建⽴⼀棵B+树都需要把<br>所有的⽤户记录再都拷贝⼀遍，这就有点太浪费存储空间了。因为这种按照⾮主键列建⽴的B+树需要⼀次回表操作才可以定位到完整的⽤户记录，所以这种B+树也被称为⼆级索引（英⽂名secondary<br>index），或者辅助索引。</p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>当然也可以同时以多个列的⼤⼩作为排序规则，也就是同时为多个列建⽴索引，⽐⽅说我们想让B+树按照a和b列的⼤⼩进⾏排序，这个包含两层含义：</p><ol><li>先把各个记录和页按照a列进⾏排序。</li><li>在记录的a列相同的情况下，采⽤b列进⾏排序<br>为a和b列建⽴的索引的⽰意图如下：<br><img data-src="/images/mysql/innodb-union-index-page.png" alt="InnoDB联合索引"></li></ol><p>联合索引本质也是个二级索引</p><h4 id="B-树根页面"><a href="#B-树根页面" class="headerlink" title="B+树根页面"></a>B+树根页面</h4><ul><li>每当为某个表创建⼀个B+树索引（聚簇索引不是⼈为创建的，默认就有）的时候，都会为这个索引创建⼀个根节点页⾯。最开始表中没有数据的时候，每个B+树索引对应的根节点中既没有⽤户记录，<br>也没有⽬录项记录。</li><li>随后向表中插⼊⽤户记录时，先把⽤户记录存储到这个根节点中。</li><li>当根节点中的可⽤空间⽤完时继续插⼊记录，此时会将根节点中的所有记录复制到⼀个新分配的页，⽐如⻚a中，然后对这个新页进⾏⻚分裂的操作，得到另⼀个新页，⽐如⻚b。这时新插⼊的记录根据<br>键值（也就是聚簇索引中的主键值，⼆级索引中对应的索引列的值）的⼤⼩就会被分配到⻚a或者⻚b中，⽽根节点便升级为存储⽬录项记录的页。</li></ul><p>这个过程需要⼤家特别注意的是：⼀个B+树索引的根节点⾃诞⽣之⽇起，便不会再移动。这样只要我们对某个表建⽴⼀个索引，那么它的根节点的页号便会被记录到某个地⽅，然后凡是InnoDB存储引擎需<br>要⽤到这个索引的时候，都会从那个固定的地⽅取出根节点的页号，从⽽来访问这个索引。</p><blockquote><p>这个固定的地方就是我们之前提到过的数据字典信息</p></blockquote><p>我们平时是以记录为单位来向表中插⼊数据的，这些记录在磁盘上的存放⽅式也被称为⾏格式或者记录格式。InnoDB有4种不同类型的⾏格式，分别 是Compact、Redundant、Dynamic和Compressed⾏格式，随着时间的推移，他们可能会设计出更多的⾏格式，但是不管怎么变，在原理上⼤体都是相同的。</p><h3 id="MyIsam"><a href="#MyIsam" class="headerlink" title="MyIsam"></a>MyIsam</h3><p>InnoDB中聚簇索引叶子节点会包含所有数据，MyISAM索引方案虽然也是使用的树形结果，但是其数据和索引是分开的。</p><p>MyISAM将表中的记录按照记录的插⼊顺序单独存储在⼀个⽂件中，称之为数据⽂件。这个⽂件并不划分为若⼲个数据页，有多少记录就往这个⽂件中塞多少记录就成了。我们可以通过⾏号⽽快速访问到⼀<br>条记录.<br><img data-src="/images/mysql/myisam-data.png" alt="myisam数据"></p><blockquote><p>myisam行记录格式是static(定长)时，可以通过行号找到数据，如果是变长记录格式时，那么MyISAM会直接在索引叶⼦节点处存储该条记录在数据⽂件中的地址偏移量，可以直接通过这个偏移量找到文件中的数据</p></blockquote><p>由于在插⼊数据的时候并没有刻意按照主键⼤⼩排序，所以我们并不能在这些数据上使⽤⼆分法进⾏查找。<br>使⽤MyISAM存储引擎的表会把索引信息另外存储到⼀个称为索引⽂件的另⼀个⽂件中。MyISAM会单独为表的主键创建⼀个索引，只不过在索引的叶⼦节点中存储的不是完整的⽤户记录，⽽是主键值 + ⾏号的组合。也就是先通过索引找到对应的⾏号，再通过⾏号去找对应的记录！</p><p>这⼀点和InnoDB是完全不相同的，在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进⾏⼀次查找就能找到对应的记录，⽽在MyISAM中却需要进⾏⼀次回表操作，意味着MyISAM中建⽴的索引相<br>当于全部都是⼆级索引！</p><p>如果有需要的话，我们也可以对其它的列分别建⽴索引或者建⽴联合索引，原理和InnoDB中的索引差不多，不过在叶⼦节点处存储的是相应的列 + ⾏号。这些索引也全部都是⼆级索引。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;页的组成部分&quot;&gt;&lt;a href=&quot;#页的组成部分&quot; class=&quot;headerlink&quot; title=&quot;页的组成部分&quot;&gt;&lt;/a&gt;页的组成部分&lt;/h3&gt;&lt;p&gt;数据库中表的数据被划分为若各个页(page),每个页中又存储了很多行记录，而我们往MySQL中插入的每行记录就放到页当中的行记录中,InnoDB的页分为以下几个部分&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;/images/mysql/innodb-page.png&quot; alt=&quot;InnoDB页&quot;&gt;&lt;/p&gt;
&lt;p&gt;InnoDB的页被划分为了7个部分，有的部分大小是确定的，有的部分不确定，各个部分说明如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;File Header，表⽰页的⼀些通⽤信息，占固定的38字节。 &lt;/li&gt;
&lt;li&gt;Page Header，表⽰数据页专有的⼀些信息，占固定的56个字节。 &lt;/li&gt;
&lt;li&gt;Infimum + Supremum，两个虚拟的伪记录，分别表⽰页中的最⼩和最⼤记录，占固定的26个字节。 &lt;/li&gt;
&lt;li&gt;User Records：真实存储我们插⼊的记录的部分，⼤⼩不固定。 &lt;/li&gt;
&lt;li&gt;Free Space：页中尚未使⽤的部分，⼤⼩不确定。 &lt;/li&gt;
&lt;li&gt;Page Directory：页中的某些记录相对位置，也就是各个槽在页⾯中的地址偏移量，⼤⼩不固定，插⼊的记录越多，这个部分占⽤的空间越多。 &lt;/li&gt;
&lt;li&gt;File Trailer：⽤于检验页是否完整的部分，占⽤固定的8个字节。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>老生常谈：mysql的体系结构</title>
    <link href="http://yoursite.com/2022/04/06/mysql-architecture/"/>
    <id>http://yoursite.com/2022/04/06/mysql-architecture/</id>
    <published>2022-04-06T06:20:27.000Z</published>
    <updated>2024-11-13T02:21:33.042Z</updated>
    
    <content type="html"><![CDATA[<p>现在要进厂，每个面试官都要问你熟不熟悉mysql,作为开发者咋们也应该清楚mysql的基础体系架构</p><p><img data-src="/images/mysql/mysql-architecture.png" alt="mysql架构"></p><p>从Mysql官网提供的体系结构图中可以看出来出来，整个mysql分为以下几部分</p><ol><li>连接池</li><li>SQL接口组件</li><li>查询分析器组件</li><li>优化器组件</li><li>缓存组件</li><li>存储引擎(插件)</li><li>物理文件</li></ol><p>mysql比较有特色的一点就是，它的存储引擎是以插件方式提供的， 而每个存储引擎决定了我们的数据是如何存放的。</p><p>虽然存储引擎有很多种，但是我们常用的不太多。 比如我就只使用过 InnoDB,MyISAM,Memory,InfoBright这4种。</p><h3 id="MyISAM-VS-InnoDB"><a href="#MyISAM-VS-InnoDB" class="headerlink" title="MyISAM VS InnoDB"></a>MyISAM VS InnoDB</h3><ol><li>MyISAM不支持事务(不支持ACID),InnoDB支持事务(支持ACID)</li><li>使用DML语句时，MyISAM锁级别是表锁，同一时间只支持一个session修改表,而InnoDB是行锁,粒度更细，并发更高</li><li>MyISAM不支持外键,InnoDB支持</li><li>MyISAM写入速度慢,查询速度快，InnoDB写入快，查询慢(相对)</li><li>InnoDB因为支持事务，所以更可靠，MyISAM无法保证数据完整性</li><li>MyISAM只存储索引，不缓存数据，支持全文索引,InnoDB缓存索引以及数据,不支持全文索引(5.6之前)。</li></ol><p>所以在选择哪个引擎的时候要根据实际业务选择，比如某个业务只会插入一次数据，后面的都只有查询,那么我就建议使用MyISAM，如果需要支持事务那就用InnoDB。</p><h3 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h3><p>由于我们平时使用最多的还是InnoDB引擎，所以这里主要剖析下InnoDB的存储结构(MyISAM和InnoDB在存储结构上是类似的)</p><p><img data-src="/images/mysql/innodb-architecture.png" alt="InnoDB索引引擎(5.7)"></p><blockquote><p>5.7和8.0有些许不一致，主要是系统表空间的一些内容会移动到单独的表空间中去</p></blockquote><p>为了保证数据不丢失,我们的数据必须要落盘,但是如果每次增删改查都去操作磁盘，那效率太低了，所以mysql会在内存中抽象出一份数据结构和磁盘一一对应，这样我们每次的增删改查就会优先操作内存中的数据。</p><p>咱们插入的数据是存储在磁盘的,而平时我们通过Navicate或者shell查询出来的数据，展现形式为表格，并不代表我们的数据也是这样直接这样存储在磁盘上的，磁盘上的数据有自己的格式。</p><p>比如我们将数据存在在文件是这样存储的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user.id&#x3D;1</span><br><span class="line">user.name&#x3D;think123</span><br><span class="line">user.age&#x3D;18</span><br></pre></td></tr></table></figure><p>在我们代码中，我们会将其映射为一个java对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出显示的时候又是这样 </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;think123&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p>将内存中数据刷新到磁盘并不是一条数据一条数据从内存刷新到磁盘的，为了效率，InnoDB将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的⼤⼩⼀般为 16KB,和磁盘上默认的页大小一致。也就是在⼀般情况下，⼀次最少从磁盘中读取16KB的内容到内存中，⼀次最少把内存中的16KB内容刷新到磁盘中。</p><p>而内存数据结构主要分为 Buffer Pool(缓冲池) 和 Log Buffer(日志缓冲)，它们管理的都是页，而页中存储的是数据。</p><h4 id="Buffer-Pool-缓冲池"><a href="#Buffer-Pool-缓冲池" class="headerlink" title="Buffer Pool(缓冲池)"></a>Buffer Pool(缓冲池)</h4><p>Buffer Pool中存储的是页，页中会存储很多条数据。当我们修改数据的时候会先修改内存中的数据，修改后的页面并不立即同步到磁盘，而是作为脏页继续呆在内存中，然后会有后台线程将内存中的数据刷盘到文件，保证数据一致。</p><p><img data-src="/images/mysql/innodb-1.png" alt="简化的结构"></p><p>我们可以通过下面的命令查看缓冲池大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show VARIABLES like &#39;innodb_buffer_pool_size&#39;</span><br></pre></td></tr></table></figure><p>如果要修改，则通过修改配置完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size &#x3D; 268435456</span><br></pre></td></tr></table></figure><p>缓冲池中缓存的数据页类型有:索引页、数据页、undo页、修改缓冲(change buffer)、自适应哈希索引(adaptive hash index)、InnoDB中锁信息、数据字典信息等。除了这些，InnoDB引擎中内存的结构除了缓冲池还有其他结构，如图所示</p><p><img data-src="/images/mysql/innodb-memory-data-structure.png" alt="InnoDB内存数据对象"></p><blockquote><p>图中插入缓冲的部分现在叫做修改缓冲(change buffer),也就是说以前只对插入有用，现在对insert update delete都起作用，后面会分析下什么是修改缓冲</p></blockquote><p>多线程环境下，访问缓冲池(buffer pool)中的各种page是需要加锁的，不然会有并发问题，而且在Buffer Pool特别⼤⽽且多线程并发访问特别 ⾼的情况下，单⼀的Buffer Pool可能会影响请求的处理速度。所以在Buffer Pool特别⼤的时候，我们可以把它们拆分成多个⼩的Buffer Pool，每个Buffer Pool都称为⼀个实例，它们都是独⽴的，独 ⽴的去申请内存空间，这样可以增加数据库的并发处理，减少资源竞争，我们可以通过修改配置的方式来配置缓冲池个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances &#x3D; 2</span><br></pre></td></tr></table></figure><p>每个buffer pool占用内存空间就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size&#x2F;innodb_buffer_pool_instances</span><br></pre></td></tr></table></figure><h4 id="自适应Hash索引"><a href="#自适应Hash索引" class="headerlink" title="自适应Hash索引"></a>自适应Hash索引</h4><p>Mysql中B+树的索引高度一般为3-4层，因此需要3-4次的查询，InnoDB会监控表上各索引页的查询，如果建立hash索引可以带来性能提升，则会建立hash索引，称之为自适应哈希索引(Adaptive Hash Index, AHI),AHI通过缓冲池的B+树页构造而来，而且并不需要对整张表建立hash索引，只是对热点页建立hash索引。</p><p>AHI要求对某个页的连续访问模式一样，比如对于（a,b)这样的联合索引页，存在下面两种情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">where a = xxx;</span><br><span class="line">where a = xxx and b=xxx</span><br></pre></td></tr></table></figure><p>如果每次都查询条件一样，但是交替出现上面两种查询，那么InnoDB不会建立Hash索引，如果只出现一个查询，然后再满足下面的要求，InnoDB就会建立自适应Hash索引</p><ol><li>以该模式(同样的等值查询条件)访问了100次</li><li>页通过该模式访问了N次，N = 页记录/16</li></ol><p>这种索引属于数据库的自优化，无需DBA进行认为调整。我们可以通过下面的命令查看当前自适应hash索引的使用情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status;</span><br></pre></td></tr></table></figure><p>其本质是将频繁访问数据页的索引键值以“Key”放在缓存中，“Value”为该索引键值匹配完整记录所在页面（Page）的位置，通过缩短寻路路径（Search Path）从而提升MySQL查询性能的一种方式</p><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>数据最终会落盘到磁盘的文件中，而实际mysql管理的数据以及额外信息等等都会写入到文件中。</p><h4 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h4><p>InnoDB采用将存储的数据按照表空间(tablespace)进行存放设计，默认配置下会有一个初始大小为10M，名为 ibdata1的文件，这个文件就是系统表空间文件，我们可以通过参数在配置文件中进行设置，比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_file_path &#x3D; ibdata1:10M:autoextend</span><br></pre></td></tr></table></figure><p>表示文件初始大小为10MB,用完了这10M,该文件可以自动增长（autoextend)。</p><p>设置 innodb_data_file_path 参数后，所有基于InnoDB存储引擎的表的数都会记录到该共享表空间中。</p><p>系统表空间中除了双写缓冲区(doublewrite buffer)、change buffer、undo logs之外,还会记录一些有关整个系统的信息。</p><blockquote><p>再次提一下，从mysql 8.0开始doublewrite buffer会有单独的文件, undo log也会放到自己单独的表空间中<br><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-architecture.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-architecture.html</a></p></blockquote><p>当我们插入数据到表里面的时候，我们需要知道很多信息，比如</p><ol><li>某个表属于哪个表空间，表里面有多少列</li><li>表对应的每一个列类型是什么</li><li>该表有多少索引，每个索引对应哪些字段，该索引对应的根页面在哪个表空间的哪个页面</li><li>该表又哪些外键，外键对应哪个表的哪些列</li><li>某个表空间对应文件系统上文件路径是什么</li></ol><p>等等。</p><p>上面提到的这些数据实际和我们插入数据无关，但是为了更好管理我们的用户数据而不得不引入的额外数据被称为元数据。InnoDB特意定义了一系列的内部系统表用来记录这些数据，不过咱们是不能直接访问InnoDB的这些内部系统表的，除⾮直接去解析系统表空间对应⽂件系统上的⽂件。</p><p>好在我们可以在infomation_schema数据库中看到这些表数据</p><ol><li>INNODB_SYS_COLUMNS: 整个InnoDB存储引擎中所有的列的信息</li><li>INNODB_SYS_DATAFILES: 整个InnoDB存储引擎中所有的表空间对应⽂件系统的⽂件路径信息</li><li>INNODB_SYS_FIELDS: 整个InnoDB存储引擎中所有的索引对应的列的信息</li><li>INNODB_SYS_FOREIGN: 整个InnoDB存储引擎中所有的外键的信息</li><li>INNODB_SYS_FOREIGN_COLS: 整个InnoDB存储引擎中所有的外键对应列的信息</li><li>INNODB_SYS_INDEXES: 整个InnoDB存储引擎中所有的索引的信息</li><li>INNODB_SYS_TABLES: 整个InnoDB存储引擎中所有的表的信息</li><li>INNODB_SYS_TABLESPACES: 整个InnoDB存储引擎中所有的表空间信息</li><li>INNODB_SYS_TABLESTATS: 整个InnoDB存储引擎中所有表统计信息</li><li>INNODB_SYS_VIRTUAL: 整个InnoDB存储引擎中所有的虚拟⽣成列的信息</li></ol><p>information_schema数据库中的这些以INNODB_SYS开头的表并不是真正的内部系统表，⽽是在存储引擎启动时读取真正的系统表，然后 填充到这些以INNODB_SYS开头的表中。</p><h4 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h4><p>当我们在数据库新建一个表test的时候(如果未做特殊说明，表引擎都是InnoDB),会产生两个文件，一个是 test.frm文件，一个是test.ibd文件。</p><p>frm文件中存储的是表结构(任何存储引擎都会产生这个文件)，ibd文件存储的是索引以及数据。</p><p>如果设置了 innodb_file_per_table ，则每个基于InnodDB存储引擎产生的表都会产生一个独立表空间，其命名规则为 表名.ibd。 </p><blockquote><p>表空间是⼀个抽象的概念，对于系统表空间来说，对应着⽂件系统中⼀个或多个实际⽂件；对于每个独⽴表空间来说，对应着⽂件系统中⼀个名为 表名.ibd 的实际⽂件</p></blockquote><p>innodb_file_per_table 也是推荐的方式(我使用的5.7默认是开启的)，可以通过以下命令查看设置情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show VARIABLES like &#39;innodb_file_per_table&#39;</span><br></pre></td></tr></table></figure><p>需要注意的是单独的.ibd独立表空间文件仅仅存储该表的数据、索引和插入缓冲等信息，其余信息还是存放在默认的系统表空间中的。</p><h3 id="通用表空间-general-tablesapce"><a href="#通用表空间-general-tablesapce" class="headerlink" title="通用表空间(general tablesapce)"></a>通用表空间(general tablesapce)</h3><p>通用表空间是使用 CREATE TABLESPACE 语法创建的共享 InnoDB 表空间，我们除了像上面那样说的让每个表都有自己的独立表空间之外，还可以让多个表在同一个表空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建表空间,文件默认是在data目录下</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLESPACE</span> <span class="string">`ts1`</span> <span class="keyword">ADD</span> <span class="keyword">DATAFILE</span> <span class="string">&#x27;ts1.ibd&#x27;</span> <span class="keyword">Engine</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line">// 可以放到data目录外</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLESPACE</span> <span class="string">`ts1`</span> <span class="keyword">ADD</span> <span class="keyword">DATAFILE</span> <span class="string">&#x27;/my/tablespace/directory/ts1.ibd&#x27;</span> <span class="keyword">Engine</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line">// 指定表在某个表空间</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (c1 <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>) <span class="keyword">TABLESPACE</span> ts1;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个让多个表在同一个表空间有啥用呢？ 按照官方文档的说法，其主要特殊点在于两个地方</p><ol><li>相比独立的表空间，通用表空间因为是多个表放到同一个表空间中，所以其元数据占用内存更少</li><li>通过表空间可以将数据文件放在MySQL数据目录之外，因此我们可以为这些特定的表设置RAID或DRBD，或将表绑定到特定的磁盘上</li></ol><h3 id="临时表空间-temporary-tablespace"><a href="#临时表空间-temporary-tablespace" class="headerlink" title="临时表空间(temporary tablespace)"></a>临时表空间(temporary tablespace)</h3><p>临时表空间分为会话(session)临时表空间和一个全局(global)临时表空间。</p><p>全局临时表空间在正常关机或初始化中止时被移除，并在每次服务器启动时重新创建。全局临时表空间在创建时收到一个动态生成的空间ID。如果全局临时表空间不能被创建，则拒绝启动。如果服务器意外停止，全局临时表空间不会被删除。在这种情况下，数据库管理员可以手动删除全局临时表空间或重新启动MySQL服务器。重启MySQL服务器会自动删除并重新创建全局临时表空间。</p><p>会话临时表空间在第一次请求创建磁盘临时表时从临时表空间池中分配给会话。 一个会话最多分配两个表空间，一个用于用户创建的临时表，另一个用于优化器创建的内部临时表。 分配给会话的临时表空间用于会话创建的所有磁盘临时表。 当会话断开连接时，其临时表空间将被截断并释放回池中。</p><p>当我们创建临时表的时候数据会被放到临时表空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>session的临时表数据会存储在ibt文件中，而global session的临时表数据会存储在ibtmp1文件中</p><p>临时表可以使用各种引擎类型，如果使用的是InnoDB或者MyISAM引擎的临时表，写数据的时候是写到磁盘上的，当然临时表也可以使用Memory引擎。</p><p>临时表只针对当前会话有用，当会话(session)被关闭的时候，这个临时表也会被删除。临时表具有以下特性</p><ol><li>临时表只能被创建它的session访问，对其他线程不可见。</li><li>临时表可以于普通表同名</li><li>session A中有同名的临时表和普通标表的时候，show create 语句，以及增删改查语句访问的是临时表</li><li>show tables不显示临时表</li></ol><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>我们之前说过修改数据也是先修改buffer pool中页的数据，如果事务提交后发生了故障，导致内存中的数据都丢失了(此时还未刷盘),那提交了的事务对数据库所做的更改也跟着丢失了，这是不能忍受的。</p><p>为了保证事务持久性(对于一个已经提交的事务，在事务提交后，即使系统发生了崩溃，这个事务对数据库中所做的更改也不能丢失)，我们必须要有一个机制来记录事务到底修改了什么内容。</p><p>如果每次修改了buffer pool中数据就刷盘到磁盘的话，是不可取的，原因有2个。</p><ol><li>刷新一个完整的数据也太浪费了: 可能只更新了一个页的几个字节，但是确要刷整个页</li><li>随机IO比较慢: 一个事务可能更新多个页，如果这些页不连续，就会产生很多随机IO,随机IO比顺序IO要慢。</li></ol><p>因此我们使用redo log记录更新了什么内容，当事务提交时，我们只需要把redo log内容刷到磁盘中，即使系统崩溃了，我们也能根据文件内容恢复。使用redo log有以下优势</p><ol><li>redo日志占用空间非常小</li><li>redo日志是顺序写入磁盘的: 每次执行一条语句就可能产生多条redo日志，这些日志是按照产生顺序写入的</li></ol><p>默认情况下，InnoDB存储引擎的数据目录下会有两个名为 ib_logfile0 和 ib_logfile1 的文件，这个文件是redo log file,它们记录了InnoDB存储引擎的redo日志。</p><p>当mysql发生问题时，比如断电了，InnoDB引擎会使用redo log恢复到掉电前时刻，以此来保证数据完整性。</p><p>写入redo log并不是直接写，而是先写入redo log buffer中，然后再写入到日志文件中，写入方式是循环写入，InnoDB先写重写ib_logfile0,当文件1达到文件最后时，会切换至ib_logfile1,当文件2也被写满时，会在切换到文件1，如此循环往复。</p><p>同样的这里有两个参数可以控制redo log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#查看相关配置</span><br><span class="line">show VARIABLES like &#39;innodb%log%&#39;</span><br><span class="line"></span><br><span class="line">#指定日志文件大小</span><br><span class="line">innodb_log_file_size&#x3D;5M</span><br><span class="line"></span><br><span class="line">#指定文件组个数(默认值是2,所以是ib_logfile0,ib_logfile1两个文件)</span><br><span class="line">innodb_log_files_in_group&#x3D;2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到这里是不是会疑惑，先写入redo log buffer,在刷盘，如果在刷盘的时候系统也崩溃了，不是也没办法回复数据吗？那再加一层来解决？ 这不就是俄罗斯套娃了么</p><p>还好mysql没有这么干，它让我们可以选择修改⼀个称为 innodb_flush_log_at_trx_commit 的系统变量的值，该变量有3个可选的值</p><ul><li>0：当该系统变量值为0时，表⽰在事务提交时不⽴即向磁盘中同步redo⽇志，这个任务是交给后台线程做的。 这样很明显会加快请求处理速度，但是如果事务提交后服务器挂了，后台线程没有及时将redo⽇志刷新到磁盘，那么该事务对页⾯的修改会丢失。 </li><li>1：当该系统变量值为1时，表⽰在事务提交时需要将redo⽇志同步到磁盘，可以保证事务的持久性。1也是innodb_flush_log_at_trx_commit的默认值。 </li><li>2：当该系统变量值为2时，表⽰在事务提交时需要将redo⽇志写到操作系统的缓冲区中，但并不需要保证将⽇志真正的刷新到磁盘。 这种情况下如果数据库挂了，操作系统没挂的话，事务的持久性还是可以保证的，但是操作系统也挂了的话，那就不能保证持久性了。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>Mysql官方文档</li><li>&lt;&lt;MySQL是怎样运行的:从根儿上理解MySQL&gt;&gt;</li><li>&lt;&lt;MySQL技术内幕：InnoDB存储引擎&gt;&gt;</li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;现在要进厂，每个面试官都要问你熟不熟悉mysql,作为开发者咋们也应该清楚mysql的基础体系架构&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;/images/mysql/mysql-architecture.png&quot;</summary>
        
      
    
    
    
    
    <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>写过那么多代码,这些问题还在犯吗？？</title>
    <link href="http://yoursite.com/2021/07/24/technical-debt/"/>
    <id>http://yoursite.com/2021/07/24/technical-debt/</id>
    <published>2021-07-24T09:32:28.000Z</published>
    <updated>2024-11-13T02:21:33.042Z</updated>
    
    <content type="html"><![CDATA[<p>当审视你现在所做的系统，下面这些技术债你遇到了多少？</p><ol><li><p>注释不规范</p><p> 类注释，方法注释，语句注释没有一个统一的规范，大多时候没有注释。</p><p> 建议在关键逻辑上写明注释，不为别人也为自己，几个月后再来看代码，看不懂了就尴尬了。</p></li><li><p>单元注释少</p><p> 建议在核心业务逻辑上添加单元注释</p></li><li><p>大量的sql语句在xml中</p><p> 建议少一些，尽量使用面向对象编程(或者面向领域驱动)</p></li><li><p>mybatis-plus queryWrapper使用不正确</p><p> queryWrapper.eq(“id”, id)类似这种的建议写成 queryWrapper.eq(User::getId, id),避免书写<br>错误的发生或后续数据库改动导致整个程序都要改。</p></li><li><p>一个类或者一个方法逻辑太长</p><p> 建议一个类300行，一个方法核心代码30行，不要超过阿里的80行。</p></li><li><p>避免循环嵌套try-catch</p></li><li><p>分支语句判断不要超过三层，for循环同理</p></li><li><p>对象锁要使用全局锁，比如private final Object lock = new Object()</p></li><li><p>能提前判断程序快速结束的，先快速结束</p></li><li><p>使用StringUtils.equals判断两个字符串是否相等</p></li><li><p>map的迭代使用entrySet方式</p></li><li><p>for循环中建议使用break而不是return</p></li><li><p>不要混淆使用Boolean和boolean</p></li><li><p>log日志输出，使用占位符而不是字符串拼接</p></li><li><p>List,Map初始化建议使用guava Lists,Maps进行初始化</p></li><li><p>不用将Map,List等缺乏领域含义的对象用做参数传递</p></li><li><p>在同一个配置类中进行线程次创建</p></li><li><p>遵循单一职责原则，将相同的业务处理放置到同一个类中</p></li><li><p>不要盲目建立索引，而是有的放矢。 索引也不是越多越好</p></li><li><p>mongodb内嵌文档不要太多，不要太大</p></li><li><p>数据库字段的逻辑删除尽量不要介入业务逻辑</p></li><li><p>不要用两个字段来表示一个状态</p></li><li><p>要在关键业务逻辑加上日志，并打印出有效信息，可以帮助排查问题</p></li><li><p>方法参数不要超过5个，尽量使用对象进行封装</p></li><li><p>apoll配置的值动态更新后，需要确定你使用到它的地方是否能够自动更新上</p></li><li><p>push代码的时候先确保本地build可以通过，同时使用阿里巴巴插件扫描下提交代码是否存在问题</p></li><li><p>对包进行合理分层</p></li><li><p>dubbo服务对外提供的api，应该只存在一些接定义以及一些参数或者常量，保持最小化</p></li><li><p>不要过度设计，保持MVP功能优先</p></li><li><p>该重构就重构，不要等</p></li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;当审视你现在所做的系统，下面这些技术债你遇到了多少？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;注释不规范&lt;/p&gt;
&lt;p&gt; 类注释，方法注释，语句注释没有一个统一的规范，大多时候没有注释。&lt;/p&gt;
&lt;p&gt;</summary>
        
      
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中对象在JVM中如何表示？</title>
    <link href="http://yoursite.com/2021/04/27/view-class-in-jvm-with-HSDB/"/>
    <id>http://yoursite.com/2021/04/27/view-class-in-jvm-with-HSDB/</id>
    <published>2021-04-27T09:20:37.000Z</published>
    <updated>2024-11-13T02:21:33.046Z</updated>
    
    <content type="html"><![CDATA[<p>我们写代码的时候，前端传递参数给后端，后端都会有一个对象来负责参数接收，同样的JVM内部也有一个模型来表示Java对象，而这个就是oop-Klass模型。</p><p>Hotspot虚拟机在内部使用两组类来表示Java的类和对象</p><ol><li>oop(ordinary object pointer)用来描述对象实例信息</li><li>kclass用来描述Java类，是虚拟机内部Java类型结构的对等体</li></ol><p><img data-src="/images/java/class-in-jvm.png" alt="class-in-jvm"></p><a id="more"></a><p>JVM内部基于OOP-Klass模型描述一个Java类，将一个Java类一拆为二，第一个是oop,第二个是klass.</p><p>oop是ordinary object pointer(普通对象指针), 它用来表示对象的实例信息(Java类实例对象中各个属性在运行期的值)。看起来像是一个指针，而实际上对象实例数据都藏在指针所指向的内存首地址后面的一篇内存区域中。</p><p><img data-src="/images/java/oopDesc.png" alt="oopDesc"></p><blockquote><p>以上代码在<a href="https://github.com/openjdk/jdk/blob/jdk8-b29/hotspot/src/share/vm/oops/oop.hpp">https://github.com/openjdk/jdk/blob/jdk8-b29/hotspot/src/share/vm/oops/oop.hpp</a></p></blockquote><p>从注释中我们可以知道oopDesc是对象类的顶级基础类，{name}Desc用来描述Java对象格式，从而可以在C++中访问到它。<br>Java中万物皆为对象，所以C++中将方法，常量，数组等都抽象成为了对象，可以用oop来表示</p><p><img data-src="/images/java/other-oops.png"></p><p>而klass则包含元数据和方法信息，用来描述Java类或者JVM内部自带的C++类型信息。比如Java类的继承信息、成员变量、静态变量、成员方法、构造函数等信息都在klass中保存，JVM根据这个<br>可以在运行期反射出Java类的全部结构信息。JVM根据这个就能在运行期反射出Java类的全部结构信息。</p><p>同样的和oop一样，klass也是成体系的，它也有很多子类，这里我就不列举出来了，我们可以看一个instanceKlass的定义</p><p><img data-src="/images/java/instanceKlass-layout.png" alt="layout"></p><p>由于mirror也是一个instanceKlass，所以它包含了instanceKlass所包含的一切字段</p><p>执行 <code>new A()</code> 的时候，JVM native 层里发生了什么。首先，如果这个类没有被加载过，JVM 就会进行类的加载，并在 JVM 内部创建一个 instanceKlass 对象表示这个类的运行时元数据（相当于 Java 层的 Class 对象）。到初始化的时候（执行 invokespecial A::<init>），JVM 就会创建一个 instanceOopDesc 对象表示这个对象的实例，然后进行 Mark Word 的填充，将元数据指针指向 Klass 对象，并填充实例变量。</p><p>根据对 JVM 的理解，我们可以想到，元数据—— instanceKlass 对象会存在元空间（方法区），而对象实例—— instanceOopDesc 会存在 Java 堆。Java 虚拟机栈中会存有这个对象实例的引用。</p><h3 id="handle体系"><a href="#handle体系" class="headerlink" title="handle体系"></a>handle体系</h3><p>JVM内部访问对象并不是直接通过oop，而是通过handle,handle封装了oop,handle是对普通对象的一种间接引用，那JVM内部为什么要什么这种间接引用呢？</p><p>这完全是为GC考虑。</p><ol><li>通过handle，能够让GC知道其内部代码有哪些地方持有GC管理对象的引用，只需要扫描handle对应的table,这样JVM无须关注其内部哪些地方持有对普通对象的引用。</li><li>GC过程中，如果发生了对象移动(比如从新生代移动到老年代),那么JVM内部引用无须跟着更改为被移动对象的新地址，JVM只需要更改handle table里面对应的指针即可。</li></ol><p>在JVM中为了方便回收oop和klass(oop在堆中,klass处于metaspace),会将这两个对象封装成 oop</p><p><img data-src="/images/java/handle.png"></p><blockquote><p><a href="https://github.com/openjdk/jdk/blob/jdk8-b29/hotspot/src/share/vm/runtime/handles.hpp">https://github.com/openjdk/jdk/blob/jdk8-b29/hotspot/src/share/vm/runtime/handles.hpp</a></p></blockquote><p>在handles.hpp被编译后，会分别出现oop和klass对应的handle,</p><p>比如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 类实例handle</span><br><span class="line">instanceHandle</span><br><span class="line"></span><br><span class="line"># 方法实例handle</span><br><span class="line">methodHandle</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"># 类元结构handle</span><br><span class="line">instanceKlassHandle</span><br><span class="line"></span><br><span class="line"># 方法元结构handle</span><br><span class="line">methodKlassHandle</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>jvm在具体描述一个类型时，会使用oop(其实这里是oopDesc)去存储这个类型的实例数据，使用klass去存储这个类型的元数据和虚方法表。当一个类型完成其生命周期后，需要将这两部分都回收<br>，因此将 oop封装成oop,klass也封装成oop。</p><p>可能有点绕，换个说法。</p><p>比如我们将JVM内部描述类信息模型叫做data-meta模型，将jvm内部的oop体系的类名全部改成Data结尾，比如instanceData, methodData。 klass体系的类改成以Meta结尾，比如 methodMeta, instanceMeta, JVM再进行GC时，即要回收Data类实例，也要回收Meta类实例，为了让GC方便回收，因此对于每一个Meta和Data类，JVM在内部将其封装成了oop模型。</p><p>对于Data类，内存布局前面是oop对象头，后面紧跟实例数据；对于Meta类，其内存布局是前面是oop对象头，后面紧跟实例数据和方发表。 封装成oop之后，再进一步使用handle来封装，于是有利于GC内存回收。</p><h3 id="查看Java对象在内存中的样子"><a href="#查看Java对象在内存中的样子" class="headerlink" title="查看Java对象在内存中的样子"></a>查看Java对象在内存中的样子</h3><p>为了让梦想照进现实，我们使用HSDB来查看JAVA对象在JVM中长什么样子,我们使用下面的代码来进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String name = <span class="string">&quot;think123&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String staticString = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> String desc = <span class="string">&quot;heheda&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">                      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    MyClassTest test = <span class="keyword">new</span> MyClassTest();</span><br><span class="line">    hello(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">hello</span><span class="params">(String otherName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name + <span class="string">&quot; : &quot;</span> + otherName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的java是安装在 C:\Program Files\Java\jdk1.8.0_172\lib，所以在这个目录下执行以下命令启动HSDB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -cp sa-jdi.jar sun.jvm.hotspot.HSDB</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后启动我们的程序(启动时最好关闭指针压缩：-XX:-UseCompressedOops)， 使用<code>jps -l </code>命令查看java进程id, 然后选择 <code>File --&gt; Attach to Hotspot Process</code>,输入java进程id</p><p><img data-src="/images/java/hsdb-attach.gif" alt="attach"><br><img data-src="/images/java/hsdb-threads.png"></p><h4 id="查看OOP"><a href="#查看OOP" class="headerlink" title="查看OOP"></a>查看OOP</h4><p>此时我们可以查看main线程的oop以及线程堆栈，在堆栈中可以看到我们的MyClassTest对象分配到了年轻代，也可以看到对应的内存地址，然后把这个地址复制下来，我们可以通过</p><p>Tools–&gt; Inspector查看对应的oop对象。</p><p><img data-src="/images/java/show-thread-info.gif"></p><p>不过这种方式比较麻烦，我们可以使用<code>Tools --&gt; Object Histogram</code>的方式来查看<br><img data-src="/images/java/hsdb-object.png" alt="查找对象"></p><p>找到对应的对象后，双击打开，然后点击Inspect</p><p><img data-src="/images/java/hsdb-object-type.png"></p><p><img data-src="/images/java/hsdb-oop.png"></p><h4 id="查看Klass"><a href="#查看Klass" class="headerlink" title="查看Klass"></a>查看Klass</h4><p><img data-src="/images/java/hsdb-class-browser.png"></p><p><img data-src="/images/java/hsdb-klass.png"></p><p>而在Method中我们则可以看到方法对应的字节码<br><img data-src="/images/java/hsdb-method-bytecode.png"></p><p>常量池中这是MyClass中的常量(比如引用类全限定名，方法名，常量，LocalNumberTable,LocalVariableTable等)</p><p>通过刚才查看到的地址，我们还可以看看Klass的数据结构是怎样的</p><p><img data-src="/images/java/hsdb-klass-structure.png"></p><blockquote><p>klass中的Method的定义: <a href="https://github.com/openjdk/jdk/blob/61bb6eca3e34b3f8382614edccd167f7ecefba65/src/hotspot/share/oops/method.hpp">https://github.com/openjdk/jdk/blob/61bb6eca3e34b3f8382614edccd167f7ecefba65/src/hotspot/share/oops/method.hpp</a></p></blockquote><p>可以看到，它的结构和我们最开始列出来的instanceKlass layout是一样的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们需要记住的是在JVM内部实例对象和Class是分别使用不同的数据结构来表示的(oop,Klass),我们可以借助HSDB工具来查看它们在JVM中的数据结构。</p><p>而我们常用到的反射，只所以能拿到那些字段，方法，接口等这些参数全是因为借助了Klass来实现的。</p><p>同时我们还可以借助它来查看常量池，比如困扰大家的intern问题，就可以结合HSDB来分析。</p><h3 id="think123"><a href="#think123" class="headerlink" title="think123"></a>think123</h3><p>以前最开始看小说的时候，那会儿异界修仙流比较出名，过程倒是记不住了，但是各个等级还是印象颇深。</p><p>炼气  筑基  金丹  元婴  离合  渡劫  大乘</p><p>如果程序员也有这种级别认定的话，那或许也是一件不错的事儿,每次升级都大吼一声</p><p>“键来!”</p><h3 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h3><p>《揭秘Java虚拟机-JVM设计原理与实现》</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们写代码的时候，前端传递参数给后端，后端都会有一个对象来负责参数接收，同样的JVM内部也有一个模型来表示Java对象，而这个就是oop-Klass模型。&lt;/p&gt;
&lt;p&gt;Hotspot虚拟机在内部使用两组类来表示Java的类和对象&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;oop(ordinary object pointer)用来描述对象实例信息&lt;/li&gt;
&lt;li&gt;kclass用来描述Java类，是虚拟机内部Java类型结构的对等体&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img data-src=&quot;/images/java/class-in-jvm.png&quot; alt=&quot;class-in-jvm&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
    <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>你有没有被ThreadLocal坑过?</title>
    <link href="http://yoursite.com/2021/04/12/thread-local-problems/"/>
    <id>http://yoursite.com/2021/04/12/thread-local-problems/</id>
    <published>2021-04-12T05:29:53.000Z</published>
    <updated>2024-11-13T02:21:33.042Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章发出去后，雄哥给我讲写得很好，但是有一些关于ThreadLocal的坑没有指出来。大佬不愧是大佬，一语中的。</p><p>因此这篇来看看ThreadLocal存在什么问题，又有怎样的解决方案</p><a id="more"></a><h3 id="ThreadLocal的问题"><a href="#ThreadLocal的问题" class="headerlink" title="ThreadLocal的问题"></a>ThreadLocal的问题</h3><p>ThreadLocal是线程变量，每个线程都会有一个ThreadLocal副本。每个Thread都维护着一个ThreadLocalMap,<br>ThreadLocalMap 中存在一个弱引用Entry。如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收。</p><p>这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链<br><code>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</code> 永远无法回收，造成内存泄漏。</p><p>虽然在调用get()、set()、remove()的时候会清除所有key为null的value,但是如果调用者不调用也没办法。关于ThreadLocalMap的分析可以参考我写的这篇<a href="https://juejin.cn/post/6844903904933576711/">开放寻址的ThreadLocalMap分析</a></p><p><img data-src="/images/java/thread-local.png" alt="ThreadLocal"></p><p>使用ThreadLocal,在子线程中我们是获取不到父线程中的ThreadLocal的值的。</p><p><img data-src="/images/java/test-single-thread.png" alt="test-single-thread"></p><p>输出结果如下</p><p><img data-src="/images/java/single-thread-test-result.png" alt="test-result"></p><h3 id="如何获取父线程中ThreadLocal的值？"><a href="#如何获取父线程中ThreadLocal的值？" class="headerlink" title="如何获取父线程中ThreadLocal的值？"></a>如何获取父线程中ThreadLocal的值？</h3><p>使用InheritableThreadLocal。InheritableThreadLocal重写了getMap与createMap方法，ThreadLocal使用的是Thread.threadLocals,而InheritableThreadLocal使用的是Thread.inheritableThreadLocals。</p><p><img data-src="/images/java/inherit-thread-local.png" alt="InheritableThreadLocal"></p><p><strong>问: InheritableThreadLocal是如何实现在子线程中获取父线程中ThreadLocal值？</strong><br>答：将父线程中的所有值Copy到子线程</p><p>InheritableThreadLocal在创建线程的时候做了一些工作</p><p><img data-src="/images/java/inherit-create.png" alt="创建"></p><p>若父线程inheritableThreadLocals不为null，则为当前线程创建inheritableThreadLocals，并且copy父线程inheritableThreadLocals中的内容,createInheritedMap会创建并拷贝。</p><p>总结:</p><ul><li>创建InheritableThreadLocal对象时，赋值给了Thread.inheritableThreadLocals变量</li><li>创建新的子线程会check父线程的inheritableThreadLocals是否为null, 不为null拷贝父线程inheritableThreadLocals中的内容到当前线程</li><li>InheritableThreadLocal重写了getMap, createMap, 使用的都是Thread.inheritableThreadLocals变量</li></ul><h3 id="InheritableThreadLocal的问题"><a href="#InheritableThreadLocal的问题" class="headerlink" title="InheritableThreadLocal的问题"></a>InheritableThreadLocal的问题</h3><p>在使用线程池的时候InheritableThreadLocal并不能解决获取父线程值得问题，因为线程池中的线程是复用的，可能在子线程中对值进行了修改，使子线程获取到的值并不正确。</p><p><img data-src="/images/java/test-inherit-thread.png" alt="test"></p><p>输出结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[main]: aaa</span><br><span class="line"></span><br><span class="line">[pool-1-thread-1]: aaa</span><br><span class="line">[pool-1-thread-1]: bbb</span><br><span class="line"></span><br><span class="line">[pool-1-thread-2]: aaa</span><br><span class="line">[pool-1-thread-1]: bbb</span><br><span class="line">[pool-1-thread-4]: aaa</span><br><span class="line">[pool-1-thread-1]: bbb</span><br><span class="line">[pool-1-thread-2]: aaa</span><br><span class="line">[pool-1-thread-3]: aaa</span><br><span class="line">[pool-1-thread-2]: aaa</span><br><span class="line">[pool-1-thread-1]: bbb</span><br><span class="line">[pool-1-thread-4]: aaa</span><br><span class="line">[pool-1-thread-3]: aaa</span><br><span class="line"></span><br><span class="line">[main]: aaa</span><br></pre></td></tr></table></figure><p>几个典型应用场景</p><ul><li>分布式跟踪系统</li><li>日志收集记录系统上下文</li><li>应用容器或上层框架跨应用代码给下层SDK传递信息</li></ul><p>比如我们的<a href="https://generalthink.github.io/2021/04/08/record-all-links-log/">这样记日志，再也不背锅</a> 其中的MDC就是使用的InheritableThreadLocal。</p><p>解决办法:</p><ol><li>线程使用完成，清空TheadLocalMap</li><li>submit提交新任务时，重新拷贝父线程中的所有Entry。重新为当前线程的inheritableThreadLocals赋值。</li></ol><h3 id="使用alibab-TransmittableThreadLocal"><a href="#使用alibab-TransmittableThreadLocal" class="headerlink" title="使用alibab TransmittableThreadLocal"></a>使用alibab TransmittableThreadLocal</h3><p>TransmittableThreadLocal就采用了备份的方法来解决这个问题</p><p><img data-src="/images/java/ttl-thread-local-test.png" alt="TTL"></p><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[main]: aaa</span><br><span class="line"></span><br><span class="line">[pool-1-thread-1]:aaa</span><br><span class="line">[pool-1-thread-1]:bbb</span><br><span class="line"></span><br><span class="line">[pool-1-thread-2]:aaa</span><br><span class="line">[pool-1-thread-1]:aaa</span><br><span class="line">[pool-1-thread-3]:aaa</span><br><span class="line">[pool-1-thread-4]:aaa</span><br><span class="line">[pool-1-thread-3]:aaa</span><br><span class="line">[pool-1-thread-1]:aaa</span><br><span class="line">[pool-1-thread-3]:aaa</span><br><span class="line">[pool-1-thread-2]:aaa</span><br><span class="line">[pool-1-thread-1]:aaa</span><br><span class="line">[pool-1-thread-4]:aaa</span><br><span class="line"></span><br><span class="line">[main]: aaa</span><br></pre></td></tr></table></figure><p>TransmittableThreadLocal原理很容易理解，就是在业务逻辑之前先将ThreadLocal中的内容备份，业务逻辑完成后在将内容还原。</p><p><img data-src="/images/java/ttl-thread-local.png" alt="TTL"></p><p>具体的可以参考官方这篇文档: <a href="https://github.com/alibaba/transmittable-thread-local/blob/master/docs/developer-guide.md">https://github.com/alibaba/transmittable-thread-local/blob/master/docs/developer-guide.md</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇文章发出去后，雄哥给我讲写得很好，但是有一些关于ThreadLocal的坑没有指出来。大佬不愧是大佬，一语中的。&lt;/p&gt;
&lt;p&gt;因此这篇来看看ThreadLocal存在什么问题，又有怎样的解决方案&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
    <category term="ThreadLocal" scheme="http://yoursite.com/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>这种日志记录方式，你一定用得上!</title>
    <link href="http://yoursite.com/2021/04/08/record-all-links-log/"/>
    <id>http://yoursite.com/2021/04/08/record-all-links-log/</id>
    <published>2021-04-08T15:19:54.000Z</published>
    <updated>2024-11-13T02:21:33.042Z</updated>
    
    <content type="html"><![CDATA[<p>不知道你有没有经历过被日志支配的恐惧？我就经历过，以前在服务器上要找到一个请求经过所有链路的日志，并串联起来发现真的好难，而且有了日志还没用，最好还有有参数，有响应可以串联起来整个业务逻辑，最大程度进行场景复原，那段找日志的时光真是不堪回首，令人难忘，好在后来我离开了再没去服务器上看过日志了。</p><p>针对这种场景，怎么解呢？针对每次请求如果我们生成一个id,每次打印日志的时候都把这个id打印出来，那么当我们搜索每次请求的时候，根据这个id进行搜索就行了,本文也是基于这个思路来实现这个功能的。</p><a id="more"></a><h3 id="请求链路"><a href="#请求链路" class="headerlink" title="请求链路"></a>请求链路</h3><p>client —&gt;  tomcat —&gt; other API</p><p>为了简化我们的请求逻辑,这里假设client访问我们的tomcat,然后tomcat访问外部服务</p><h3 id="记录请求参数以及响应"><a href="#记录请求参数以及响应" class="headerlink" title="记录请求参数以及响应"></a>记录请求参数以及响应</h3><p>为了记录请求参数以及响应结果，我们需要借助Filter来解决这个问题</p><p><img data-src="/images/java/logging-filter.png" alt="LoggingFilter"></p><h3 id="记录Restful请求以及响应"><a href="#记录Restful请求以及响应" class="headerlink" title="记录Restful请求以及响应"></a>记录Restful请求以及响应</h3><p>一般而言，我们的服务会调用其他服务，无论你是使用的dubbo还是http，我们都能通过拦截器来记录请求和响应参数，我们以rest来进行举例</p><p><img data-src="/images/java/rest-interceptor.png" alt="Inteceptor"></p><p>由于我们的response是stream,我们想要消费多次(一次返回给调用者，一次用于记录),所以我们必须对这个response进行封装</p><p><img data-src="/images/java/rest-config.png" alt="Config"></p><h3 id="Log4j2配置"><a href="#Log4j2配置" class="headerlink" title="Log4j2配置"></a>Log4j2配置</h3><p><img data-src="/images/java/log4j2-config1.png" alt="log4j2配置"></p><p>至此,我们的日志记录已经初具雏形了，这个时候当我们访问后端请求时,就可以通过返回的requestId去服务器上查询这次请求的链路日志</p><p><img data-src="/images/java/test-logging.png" alt="requestId"></p><p>后台日志如下</p><p><img data-src="/images/java/log.png" alt="后台日志"></p><p>查询时我们可以使用这样的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat api.log | grep $&#123;requestId&#125;</span><br></pre></td></tr></table></figure><p>这样就足够了吗？不，还不够好。我们可以将我们的日志发送到ElasticSearch,然后通过Kibana进行搜索，这样就不用每次查看日志都还要登录服务器了</p><h3 id="自定义appender"><a href="#自定义appender" class="headerlink" title="自定义appender"></a>自定义appender</h3><p>由于需要将日志发送到ES,所以我们需要自定义appender来发送日志，一个简单的appender的如下</p><p><img data-src="/images/java/esAppender.png" alt="ESAppender"></p><p>然后在Log4j中进行如下配置即可</p><p><img data-src="/images/java/log4j2-config2.png" alt="log4j2配置"></p><p>这里我的es使用的是本地安装的es,所以在运行的时候需要先启动es</p><h3 id="在Kibana中查询"><a href="#在Kibana中查询" class="headerlink" title="在Kibana中查询"></a>在Kibana中查询</h3><p><img data-src="/images/java/kibana-search-log.png" alt="日志"></p><p>至此，我们的日志平台就搭建起来了，以后别人就别想那么容易的推锅给你了。</p><p>所以的代码我都上传到了我的github: (<a href="https://github.com/generalthink/code">https://github.com/generalthink/code</a>)</p><p>以供大家参考</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不知道你有没有经历过被日志支配的恐惧？我就经历过，以前在服务器上要找到一个请求经过所有链路的日志，并串联起来发现真的好难，而且有了日志还没用，最好还有有参数，有响应可以串联起来整个业务逻辑，最大程度进行场景复原，那段找日志的时光真是不堪回首，令人难忘，好在后来我离开了再没去服务器上看过日志了。&lt;/p&gt;
&lt;p&gt;针对这种场景，怎么解呢？针对每次请求如果我们生成一个id,每次打印日志的时候都把这个id打印出来，那么当我们搜索每次请求的时候，根据这个id进行搜索就行了,本文也是基于这个思路来实现这个功能的。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>K8S你知道,K9S你可能也知道，那Lens呢？</title>
    <link href="http://yoursite.com/2021/01/29/k8s-lens/"/>
    <id>http://yoursite.com/2021/01/29/k8s-lens/</id>
    <published>2021-01-29T07:15:49.000Z</published>
    <updated>2024-11-13T02:21:33.038Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes是用于自动部署、扩展和管理“容器化应用程序”的开源系统，而<a href="https://github.com/derailed/k9s">K9S</a>则提供了一个终端让我们能方便的操作K8S集群，它在github上有10.8K的star</p><p>比如查看日志</p><p><img data-src="/images/k8s/k9s_logs.png" alt="查看日志"></p><p>而<a href="https://github.com/lensapp/lens">Lens</a>也是一个终端工具，它也能让我们更好的操控集群，它在github上也有12.6K star</p><p><img data-src="/images/k8s/lens.png" alt="Lens"></p><p>Lens的使用比K9S更加方便也更加直观,无论是查看Deployment, Service, Pod。它还可以直接access work node,更是方便至极。</p><p><img data-src="/images/k8s/lens-info.png" alt="Lens"></p><p>所以，我推荐大家使用Lens。</p>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;p&gt;Kubernetes是用于自动部署、扩展和管理“容器化应用程序”的开源系统，而&lt;a</summary>
        
      
    
    
    
    
    <category term="K8S" scheme="http://yoursite.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>创建线程的几种主流方式</title>
    <link href="http://yoursite.com/2021/01/21/methods-of-create-thread/"/>
    <id>http://yoursite.com/2021/01/21/methods-of-create-thread/</id>
    <published>2021-01-21T11:19:36.000Z</published>
    <updated>2024-11-13T02:21:33.038Z</updated>
    
    <content type="html"><![CDATA[<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>继承Thread类，并重写它的run方法，就可以创建一个线程了，当然线程是如何真正被启动，可以参考我之前的 <a href="https://juejin.cn/post/6858058928467968008">为什么start方法才能启动线程,而run不行？</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThinkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;think123&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> ThinkThread().start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">new</span> Thread(() -&gt; </span><br><span class="line">  System.out.println(<span class="string">&quot;实现了Runnable接口&quot;</span>)</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure><p>构造Thread时传入Runnable类型的参数，也可以创建一个线程</p><h3 id="通过线程池创建线程"><a href="#通过线程池创建线程" class="headerlink" title="通过线程池创建线程"></a>通过线程池创建线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交 Runnable 任务</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 Callable 任务</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 Runnable 任务及结果引用。 future.get()==result</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br></pre></td></tr></table></figure><p>Runnable类型的参数和Callable类型的参数不同之处在于Runnable 接口的 run() 方法是没有返回值的，所以 submit(Runnable task)这个方法返回的 Future 仅可以用来断言任务已经结束了，类似于 Thread.join()。 而Callable是一个接口，它有一个call()方法，这个方法是有返回值的，这个可以通过 future.get() l获取任务执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建议手动创建线程池，这里只是为了举例</span></span><br><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Future future = service.submit(() -&gt; <span class="string">&quot;think123&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(future.get());</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="通过FutureTask创建线程"><a href="#通过FutureTask创建线程" class="headerlink" title="通过FutureTask创建线程"></a>通过FutureTask创建线程</h3><p>FutureTask继承了Runnable和Future接口,所以我们可以将FutureTask对象作为任务提交到线程池执行，也可以直接被Thread执行，而且还可以获取到任务执行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FutureTask task = <span class="keyword">new</span> FutureTask(() -&gt; <span class="string">&quot;666&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(task);</span><br><span class="line">t1.start();;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞main线程，直到t1执行完成</span></span><br><span class="line">System.out.println(task.get());</span><br></pre></td></tr></table></figure><p>FutureTask的源码很简单，当执行run方法时，会将执行的结果保存在内部变量 outcome 中，即便是抛出了异常，此时也会将异常记录到outcome中。</p><p>当调用 get 方法时，如果还未执行完成，则会阻塞调用方。执行完成后会将正常的结果返回，如果call方法中抛出了异常，则将其封装成 ExecutionException 抛出。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面介绍了Java中常用的创建线程执行的方式，可以发现，实际上都是通过 创建Thread来执行的，实际上也是可以算作一种，如果面试官问题，你可以先装一下说之后一种，然后峰回路转，给他说说为什么之后一种。</p><blockquote><p>当然还有其他方式，比如TimerTask, Quartz Job但是实际上都是类似的。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;继承Thread类&quot;&gt;&lt;a href=&quot;#继承Thread类&quot; class=&quot;headerlink&quot; title=&quot;继承Thread类&quot;&gt;&lt;/a&gt;继承Thread类&lt;/h3&gt;&lt;p&gt;继承Thread类，并重写它的run方法，就可以创建一个线程了，当然线程是如何真正被启动，可以参考我之前的 &lt;a href=&quot;https://juejin.cn/post/6858058928467968008&quot;&gt;为什么start方法才能启动线程,而run不行？&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThinkThread&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Thread&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;think123&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThinkThread().start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
    <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
